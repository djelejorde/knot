(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-7a5057ef'], {
  2709 (t, e, i) { 'use strict'; const a = i('66d0'); const n = i.n(a); n.a },
  4604 (t, e, i) {},
  '51e1' (t, e, i) {},
  '66d0' (t, e, i) {},
  '8db2' (t, e) { t.exports = { props: { id: { type: String, required: !0 }, name: { type: String, required: !0 }, value: { type: null, default: null }, type: { type: String, required: !0 }, length: { type: [String, Number], default: null }, readonly: { type: Boolean, default: !1 }, collection: { type: String, default: null }, primaryKey: { type: [Number, String], default: null }, required: { type: Boolean, default: !1 }, options: { type: Object, default: () => ({}) }, newItem: { type: Boolean, default: !1 }, relation: { type: Object, default: null }, fields: { type: Object, default: null }, values: { type: Object, default: null }, width: { type: String, default: null, validator (t) { return ['half', 'half-left', 'half-right', 'full', 'fill'].includes(t) } } } } },
  bab4 (t, e, i) {
    /*!
 * Cropper.js v1.5.6
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2019-10-04T04:33:48.372Z
 */
    (function (e, i) { t.exports = i() })(0, function () { 'use strict'; function t (e) { return t = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t }, t(e) } function e (t, e) { if (!(t instanceof e)) { throw new TypeError('Cannot call a class as a function') } } function i (t, e) { for (let i = 0; i < e.length; i++) { const a = e[i]; a.enumerable = a.enumerable || !1, a.configurable = !0, 'value' in a && (a.writable = !0), Object.defineProperty(t, a.key, a) } } function a (t, e, a) { return e && i(t.prototype, e), a && i(t, a), t } function n (t, e, i) { return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t } function r (t, e) { const i = Object.keys(t); if (Object.getOwnPropertySymbols) { let a = Object.getOwnPropertySymbols(t); e && (a = a.filter(function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable })), i.push.apply(i, a) } return i } function o (t) { for (let e = 1; e < arguments.length; e++) { var i = arguments[e] != null ? arguments[e] : {}; e % 2 ? r(i, !0).forEach(function (e) { n(t, e, i[e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(i).forEach(function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)) }) } return t } function s (t) { return h(t) || c(t) || l() } function h (t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++) { i[e] = t[e] } return i } } function c (t) { if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]') { return Array.from(t) } } function l () { throw new TypeError('Invalid attempt to spread non-iterable instance') } const d = typeof window !== 'undefined' && typeof window.document !== 'undefined'; const p = d ? window : {}; const u = !!d && 'ontouchstart' in p.document.documentElement; const m = !!d && 'PointerEvent' in p; const g = 'cropper'; const f = 'all'; const v = 'crop'; const w = 'move'; const b = 'zoom'; const y = 'e'; const x = 'w'; const M = 's'; const C = 'n'; const D = 'ne'; const k = 'nw'; const O = 'se'; const E = 'sw'; const B = ''.concat(g, '-crop'); const T = ''.concat(g, '-disabled'); const R = ''.concat(g, '-hidden'); const N = ''.concat(g, '-hide'); const W = ''.concat(g, '-invisible'); const H = ''.concat(g, '-modal'); const L = ''.concat(g, '-move'); const j = ''.concat(g, 'Action'); const z = ''.concat(g, 'Preview'); const S = 'crop'; const I = 'move'; const Y = 'none'; const X = 'crop'; const A = 'cropend'; const _ = 'cropmove'; const P = 'cropstart'; const U = 'dblclick'; const q = u ? 'touchstart' : 'mousedown'; const $ = u ? 'touchmove' : 'mousemove'; const F = u ? 'touchend touchcancel' : 'mouseup'; const Q = m ? 'pointerdown' : q; const V = m ? 'pointermove' : $; const K = m ? 'pointerup pointercancel' : F; const Z = 'ready'; const J = 'resize'; const G = 'wheel'; const tt = 'zoom'; const et = 'image/jpeg'; const it = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/; const at = /^data:/; const nt = /^data:image\/jpeg;base64,/; const rt = /^img|canvas$/i; const ot = 200; const st = 100; const ht = { viewMode: 0, dragMode: S, initialAspectRatio: NaN, aspectRatio: NaN, data: null, preview: '', responsive: !0, restore: !0, checkCrossOrigin: !0, checkOrientation: !0, modal: !0, guides: !0, center: !0, highlight: !0, background: !0, autoCrop: !0, autoCropArea: 0.8, movable: !0, rotatable: !0, scalable: !0, zoomable: !0, zoomOnTouch: !0, zoomOnWheel: !0, wheelZoomRatio: 0.1, cropBoxMovable: !0, cropBoxResizable: !0, toggleDragModeOnDblclick: !0, minCanvasWidth: 0, minCanvasHeight: 0, minCropBoxWidth: 0, minCropBoxHeight: 0, minContainerWidth: 200, minContainerHeight: 100, ready: null, cropstart: null, cropmove: null, cropend: null, crop: null, zoom: null }; const ct = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>'; const lt = Number.isNaN || p.isNaN; function dt (t) { return typeof t === 'number' && !lt(t) } const pt = function (t) { return t > 0 && t < 1 / 0 }; function ut (t) { return typeof t === 'undefined' } function mt (e) { return t(e) === 'object' && e !== null } const gt = Object.prototype.hasOwnProperty; function ft (t) { if (!mt(t)) { return !1 } try { const e = t.constructor; const i = e.prototype; return e && i && gt.call(i, 'isPrototypeOf') } catch (a) { return !1 } } function vt (t) { return typeof t === 'function' } const wt = Array.prototype.slice; function bt (t) { return Array.from ? Array.from(t) : wt.call(t) } function yt (t, e) { return t && vt(e) && (Array.isArray(t) || dt(t.length) ? bt(t).forEach(function (i, a) { e.call(t, i, a, t) }) : mt(t) && Object.keys(t).forEach(function (i) { e.call(t, t[i], i, t) })), t } const xt = Object.assign || function (t) { for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), a = 1; a < e; a++) { i[a - 1] = arguments[a] } return mt(t) && i.length > 0 && i.forEach(function (e) { mt(e) && Object.keys(e).forEach(function (i) { t[i] = e[i] }) }), t }; const Mt = /\.\d*(?:0|9){12}\d*$/; function Ct (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e11; return Mt.test(t) ? Math.round(t * e) / e : t } const Dt = /^width|height|left|top|marginLeft|marginTop$/; function kt (t, e) { const i = t.style; yt(e, function (t, e) { Dt.test(e) && dt(t) && (t = ''.concat(t, 'px')), i[e] = t }) } function Ot (t, e) { return t.classList ? t.classList.contains(e) : t.className.includes(e) } function Et (t, e) { if (e) { if (dt(t.length)) { yt(t, function (t) { Et(t, e) }) } else if (t.classList) { t.classList.add(e) } else { const i = t.className.trim(); i ? !i.includes(e) && (t.className = ''.concat(i, ' ').concat(e)) : t.className = e } } } function Bt (t, e) { e && (dt(t.length) ? yt(t, function (t) { Bt(t, e) }) : t.classList ? t.classList.remove(e) : t.className.includes(e) && (t.className = t.className.replace(e, ''))) } function Tt (t, e, i) { e && (dt(t.length) ? yt(t, function (t) { Tt(t, e, i) }) : i ? Et(t, e) : Bt(t, e)) } const Rt = /([a-z\d])([A-Z])/g; function Nt (t) { return t.replace(Rt, '$1-$2').toLowerCase() } function Wt (t, e) { return mt(t[e]) ? t[e] : t.dataset ? t.dataset[e] : t.getAttribute('data-'.concat(Nt(e))) } function Ht (t, e, i) { mt(i) ? t[e] = i : t.dataset ? t.dataset[e] = i : t.setAttribute('data-'.concat(Nt(e)), i) } function Lt (t, e) { if (mt(t[e])) { try { delete t[e] } catch (i) { t[e] = void 0 } } else if (t.dataset) { try { delete t.dataset[e] } catch (i) { t.dataset[e] = void 0 } } else { t.removeAttribute('data-'.concat(Nt(e))) } } const jt = /\s\s*/; const zt = (function () { let t = !1; if (d) { let e = !1; const i = function () {}; const a = Object.defineProperty({}, 'once', { get () { return t = !0, e }, set (t) { e = t } }); p.addEventListener('test', i, a), p.removeEventListener('test', i, a) } return t }()); function St (t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; let n = i; e.trim().split(jt).forEach(function (e) { if (!zt) { const r = t.listeners; r && r[e] && r[e][i] && (n = r[e][i], delete r[e][i], Object.keys(r[e]).length === 0 && delete r[e], Object.keys(r).length === 0 && delete t.listeners) }t.removeEventListener(e, n, a) }) } function It (t, e, i) { const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; let n = i; e.trim().split(jt).forEach(function (e) { if (a.once && !zt) { const r = t.listeners; const o = void 0 === r ? {} : r; n = function () { delete o[e][i], t.removeEventListener(e, n, a); for (var r = arguments.length, s = new Array(r), h = 0; h < r; h++) { s[h] = arguments[h] }i.apply(t, s) }, o[e] || (o[e] = {}), o[e][i] && t.removeEventListener(e, o[e][i], a), o[e][i] = n, t.listeners = o }t.addEventListener(e, n, a) }) } function Yt (t, e, i) { let a; return vt(Event) && vt(CustomEvent) ? a = new CustomEvent(e, { detail: i, bubbles: !0, cancelable: !0 }) : (a = document.createEvent('CustomEvent'), a.initCustomEvent(e, !0, !0, i)), t.dispatchEvent(a) } function Xt (t) { const e = t.getBoundingClientRect(); return { left: e.left + (window.pageXOffset - document.documentElement.clientLeft), top: e.top + (window.pageYOffset - document.documentElement.clientTop) } } const At = p.location; const _t = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i; function Pt (t) { const e = t.match(_t); return e !== null && (e[1] !== At.protocol || e[2] !== At.hostname || e[3] !== At.port) } function Ut (t) { const e = 'timestamp='.concat((new Date()).getTime()); return t + (!t.includes('?') ? '?' : '&') + e } function qt (t) { const e = t.rotate; const i = t.scaleX; const a = t.scaleY; const n = t.translateX; const r = t.translateY; const o = []; dt(n) && n !== 0 && o.push('translateX('.concat(n, 'px)')), dt(r) && r !== 0 && o.push('translateY('.concat(r, 'px)')), dt(e) && e !== 0 && o.push('rotate('.concat(e, 'deg)')), dt(i) && i !== 1 && o.push('scaleX('.concat(i, ')')), dt(a) && a !== 1 && o.push('scaleY('.concat(a, ')')); const s = o.length ? o.join(' ') : 'none'; return { WebkitTransform: s, msTransform: s, transform: s } } function $t (t) { const e = o({}, t); const i = []; return yt(t, function (t, a) { delete e[a], yt(e, function (e) { const a = Math.abs(t.startX - e.startX); const n = Math.abs(t.startY - e.startY); const r = Math.abs(t.endX - e.endX); const o = Math.abs(t.endY - e.endY); const s = Math.sqrt(a * a + n * n); const h = Math.sqrt(r * r + o * o); const c = (h - s) / s; i.push(c) }) }), i.sort(function (t, e) { return Math.abs(t) < Math.abs(e) }), i[0] } function Ft (t, e) { const i = t.pageX; const a = t.pageY; const n = { endX: i, endY: a }; return e ? n : o({ startX: i, startY: a }, n) } function Qt (t) { let e = 0; let i = 0; let a = 0; return yt(t, function (t) { const n = t.startX; const r = t.startY; e += n, i += r, a += 1 }), e /= a, i /= a, { pageX: e, pageY: i } } function Vt (t) { const e = t.aspectRatio; let i = t.height; let a = t.width; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'contain'; const r = pt(a); const o = pt(i); if (r && o) { const s = i * e; n === 'contain' && s > a || n === 'cover' && s < a ? i = a / e : a = i * e } else { r ? i = a / e : o && (a = i * e) } return { width: a, height: i } } function Kt (t) { const e = t.width; const i = t.height; let a = t.degree; if (a = Math.abs(a) % 180, a === 90) { return { width: i, height: e } } const n = a % 90 * Math.PI / 180; const r = Math.sin(n); const o = Math.cos(n); const s = e * o + i * r; const h = e * r + i * o; return a > 90 ? { width: h, height: s } : { width: s, height: h } } function Zt (t, e, i, a) { const n = e.aspectRatio; const r = e.naturalWidth; const o = e.naturalHeight; const h = e.rotate; const c = void 0 === h ? 0 : h; const l = e.scaleX; const d = void 0 === l ? 1 : l; const p = e.scaleY; const u = void 0 === p ? 1 : p; const m = i.aspectRatio; const g = i.naturalWidth; const f = i.naturalHeight; const v = a.fillColor; const w = void 0 === v ? 'transparent' : v; const b = a.imageSmoothingEnabled; const y = void 0 === b || b; const x = a.imageSmoothingQuality; const M = void 0 === x ? 'low' : x; const C = a.maxWidth; const D = void 0 === C ? 1 / 0 : C; const k = a.maxHeight; const O = void 0 === k ? 1 / 0 : k; const E = a.minWidth; const B = void 0 === E ? 0 : E; const T = a.minHeight; const R = void 0 === T ? 0 : T; const N = document.createElement('canvas'); const W = N.getContext('2d'); const H = Vt({ aspectRatio: m, width: D, height: O }); const L = Vt({ aspectRatio: m, width: B, height: R }, 'cover'); const j = Math.min(H.width, Math.max(L.width, g)); const z = Math.min(H.height, Math.max(L.height, f)); const S = Vt({ aspectRatio: n, width: D, height: O }); const I = Vt({ aspectRatio: n, width: B, height: R }, 'cover'); const Y = Math.min(S.width, Math.max(I.width, r)); const X = Math.min(S.height, Math.max(I.height, o)); const A = [-Y / 2, -X / 2, Y, X]; return N.width = Ct(j), N.height = Ct(z), W.fillStyle = w, W.fillRect(0, 0, j, z), W.save(), W.translate(j / 2, z / 2), W.rotate(c * Math.PI / 180), W.scale(d, u), W.imageSmoothingEnabled = y, W.imageSmoothingQuality = M, W.drawImage.apply(W, [t].concat(s(A.map(function (t) { return Math.floor(Ct(t)) })))), W.restore(), N } const Jt = String.fromCharCode; function Gt (t, e, i) { let a = ''; i += e; for (let n = e; n < i; n += 1) { a += Jt(t.getUint8(n)) } return a } const te = /^data:.*,/; function ee (t) { const e = t.replace(te, ''); const i = atob(e); const a = new ArrayBuffer(i.length); const n = new Uint8Array(a); return yt(n, function (t, e) { n[e] = i.charCodeAt(e) }), a } function ie (t, e) { const i = []; const a = 8192; let n = new Uint8Array(t); while (n.length > 0) { i.push(Jt.apply(null, bt(n.subarray(0, a)))), n = n.subarray(a) } return 'data:'.concat(e, ';base64,').concat(btoa(i.join(''))) } function ae (t) { let e; const i = new DataView(t); try { let a, n, r; if (i.getUint8(0) === 255 && i.getUint8(1) === 216) { const o = i.byteLength; let s = 2; while (s + 1 < o) { if (i.getUint8(s) === 255 && i.getUint8(s + 1) === 225) { n = s; break }s += 1 } } if (n) { const h = n + 4; const c = n + 10; if (Gt(i, h, 4) === 'Exif') { const l = i.getUint16(c); if (a = l === 18761, (a || l === 19789) && i.getUint16(c + 2, a) === 42) { const d = i.getUint32(c + 4, a); d >= 8 && (r = c + d) } } } if (r) { let p; let u; const m = i.getUint16(r, a); for (u = 0; u < m; u += 1) { if (p = r + 12 * u + 2, i.getUint16(p, a) === 274) { p += 8, e = i.getUint16(p, a), i.setUint16(p, 1, a); break } } } } catch (g) { e = 1 } return e } function ne (t) { let e = 0; let i = 1; let a = 1; switch (t) { case 2:i = -1; break; case 3:e = -180; break; case 4:a = -1; break; case 5:e = 90, a = -1; break; case 6:e = 90; break; case 7:e = 90, i = -1; break; case 8:e = -90; break; default: } return { rotate: e, scaleX: i, scaleY: a } } const re = { render () { this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox() }, initContainer () { const t = this.element; const e = this.options; const i = this.container; const a = this.cropper; Et(a, R), Bt(t, R); const n = { width: Math.max(i.offsetWidth, Number(e.minContainerWidth) || 200), height: Math.max(i.offsetHeight, Number(e.minContainerHeight) || 100) }; this.containerData = n, kt(a, { width: n.width, height: n.height }), Et(t, R), Bt(a, R) }, initCanvas () { const t = this.containerData; const e = this.imageData; const i = this.options.viewMode; const a = Math.abs(e.rotate) % 180 === 90; const n = a ? e.naturalHeight : e.naturalWidth; const r = a ? e.naturalWidth : e.naturalHeight; const o = n / r; let s = t.width; let h = t.height; t.height * o > t.width ? i === 3 ? s = t.height * o : h = t.width / o : i === 3 ? h = t.width / o : s = t.height * o; const c = { aspectRatio: o, naturalWidth: n, naturalHeight: r, width: s, height: h }; c.left = (t.width - s) / 2, c.top = (t.height - h) / 2, c.oldLeft = c.left, c.oldTop = c.top, this.canvasData = c, this.limited = i === 1 || i === 2, this.limitCanvas(!0, !0), this.initialImageData = xt({}, e), this.initialCanvasData = xt({}, c) }, limitCanvas (t, e) { const i = this.options; const a = this.containerData; const n = this.canvasData; const r = this.cropBoxData; const o = i.viewMode; const s = n.aspectRatio; const h = this.cropped && r; if (t) { let c = Number(i.minCanvasWidth) || 0; let l = Number(i.minCanvasHeight) || 0; o > 1 ? (c = Math.max(c, a.width), l = Math.max(l, a.height), o === 3 && (l * s > c ? c = l * s : l = c / s)) : o > 0 && (c ? c = Math.max(c, h ? r.width : 0) : l ? l = Math.max(l, h ? r.height : 0) : h && (c = r.width, l = r.height, l * s > c ? c = l * s : l = c / s)); const d = Vt({ aspectRatio: s, width: c, height: l }); c = d.width, l = d.height, n.minWidth = c, n.minHeight = l, n.maxWidth = 1 / 0, n.maxHeight = 1 / 0 } if (e) { if (o > (h ? 0 : 1)) { const p = a.width - n.width; const u = a.height - n.height; n.minLeft = Math.min(0, p), n.minTop = Math.min(0, u), n.maxLeft = Math.max(0, p), n.maxTop = Math.max(0, u), h && this.limited && (n.minLeft = Math.min(r.left, r.left + (r.width - n.width)), n.minTop = Math.min(r.top, r.top + (r.height - n.height)), n.maxLeft = r.left, n.maxTop = r.top, o === 2 && (n.width >= a.width && (n.minLeft = Math.min(0, p), n.maxLeft = Math.max(0, p)), n.height >= a.height && (n.minTop = Math.min(0, u), n.maxTop = Math.max(0, u)))) } else { n.minLeft = -n.width, n.minTop = -n.height, n.maxLeft = a.width, n.maxTop = a.height } } }, renderCanvas (t, e) { const i = this.canvasData; const a = this.imageData; if (e) { const n = Kt({ width: a.naturalWidth * Math.abs(a.scaleX || 1), height: a.naturalHeight * Math.abs(a.scaleY || 1), degree: a.rotate || 0 }); const r = n.width; const o = n.height; const s = i.width * (r / i.naturalWidth); const h = i.height * (o / i.naturalHeight); i.left -= (s - i.width) / 2, i.top -= (h - i.height) / 2, i.width = s, i.height = h, i.aspectRatio = r / o, i.naturalWidth = r, i.naturalHeight = o, this.limitCanvas(!0, !1) }(i.width > i.maxWidth || i.width < i.minWidth) && (i.left = i.oldLeft), (i.height > i.maxHeight || i.height < i.minHeight) && (i.top = i.oldTop), i.width = Math.min(Math.max(i.width, i.minWidth), i.maxWidth), i.height = Math.min(Math.max(i.height, i.minHeight), i.maxHeight), this.limitCanvas(!1, !0), i.left = Math.min(Math.max(i.left, i.minLeft), i.maxLeft), i.top = Math.min(Math.max(i.top, i.minTop), i.maxTop), i.oldLeft = i.left, i.oldTop = i.top, kt(this.canvas, xt({ width: i.width, height: i.height }, qt({ translateX: i.left, translateY: i.top }))), this.renderImage(t), this.cropped && this.limited && this.limitCropBox(!0, !0) }, renderImage (t) { const e = this.canvasData; const i = this.imageData; const a = i.naturalWidth * (e.width / e.naturalWidth); const n = i.naturalHeight * (e.height / e.naturalHeight); xt(i, { width: a, height: n, left: (e.width - a) / 2, top: (e.height - n) / 2 }), kt(this.image, xt({ width: i.width, height: i.height }, qt(xt({ translateX: i.left, translateY: i.top }, i)))), t && this.output() }, initCropBox () { const t = this.options; const e = this.canvasData; const i = t.aspectRatio || t.initialAspectRatio; const a = Number(t.autoCropArea) || 0.8; const n = { width: e.width, height: e.height }; i && (e.height * i > e.width ? n.height = n.width / i : n.width = n.height * i), this.cropBoxData = n, this.limitCropBox(!0, !0), n.width = Math.min(Math.max(n.width, n.minWidth), n.maxWidth), n.height = Math.min(Math.max(n.height, n.minHeight), n.maxHeight), n.width = Math.max(n.minWidth, n.width * a), n.height = Math.max(n.minHeight, n.height * a), n.left = e.left + (e.width - n.width) / 2, n.top = e.top + (e.height - n.height) / 2, n.oldLeft = n.left, n.oldTop = n.top, this.initialCropBoxData = xt({}, n) }, limitCropBox (t, e) { const i = this.options; const a = this.containerData; const n = this.canvasData; const r = this.cropBoxData; const o = this.limited; const s = i.aspectRatio; if (t) { let h = Number(i.minCropBoxWidth) || 0; let c = Number(i.minCropBoxHeight) || 0; let l = o ? Math.min(a.width, n.width, n.width + n.left, a.width - n.left) : a.width; let d = o ? Math.min(a.height, n.height, n.height + n.top, a.height - n.top) : a.height; h = Math.min(h, a.width), c = Math.min(c, a.height), s && (h && c ? c * s > h ? c = h / s : h = c * s : h ? c = h / s : c && (h = c * s), d * s > l ? d = l / s : l = d * s), r.minWidth = Math.min(h, l), r.minHeight = Math.min(c, d), r.maxWidth = l, r.maxHeight = d }e && (o ? (r.minLeft = Math.max(0, n.left), r.minTop = Math.max(0, n.top), r.maxLeft = Math.min(a.width, n.left + n.width) - r.width, r.maxTop = Math.min(a.height, n.top + n.height) - r.height) : (r.minLeft = 0, r.minTop = 0, r.maxLeft = a.width - r.width, r.maxTop = a.height - r.height)) }, renderCropBox () { const t = this.options; const e = this.containerData; const i = this.cropBoxData; (i.width > i.maxWidth || i.width < i.minWidth) && (i.left = i.oldLeft), (i.height > i.maxHeight || i.height < i.minHeight) && (i.top = i.oldTop), i.width = Math.min(Math.max(i.width, i.minWidth), i.maxWidth), i.height = Math.min(Math.max(i.height, i.minHeight), i.maxHeight), this.limitCropBox(!1, !0), i.left = Math.min(Math.max(i.left, i.minLeft), i.maxLeft), i.top = Math.min(Math.max(i.top, i.minTop), i.maxTop), i.oldLeft = i.left, i.oldTop = i.top, t.movable && t.cropBoxMovable && Ht(this.face, j, i.width >= e.width && i.height >= e.height ? w : f), kt(this.cropBox, xt({ width: i.width, height: i.height }, qt({ translateX: i.left, translateY: i.top }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output() }, output () { this.preview(), Yt(this.element, X, this.getData()) } }; const oe = { initPreview () { const t = this.element; const e = this.crossOrigin; const i = this.options.preview; const a = e ? this.crossOriginUrl : this.url; const n = t.alt || 'The image to preview'; const r = document.createElement('img'); if (e && (r.crossOrigin = e), r.src = a, r.alt = n, this.viewBox.appendChild(r), this.viewBoxImage = r, i) { let o = i; typeof i === 'string' ? o = t.ownerDocument.querySelectorAll(i) : i.querySelector && (o = [i]), this.previews = o, yt(o, function (t) { const i = document.createElement('img'); Ht(t, z, { width: t.offsetWidth, height: t.offsetHeight, html: t.innerHTML }), e && (i.crossOrigin = e), i.src = a, i.alt = n, i.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', t.innerHTML = '', t.appendChild(i) }) } }, resetPreview () { yt(this.previews, function (t) { const e = Wt(t, z); kt(t, { width: e.width, height: e.height }), t.innerHTML = e.html, Lt(t, z) }) }, preview () { const t = this.imageData; const e = this.canvasData; const i = this.cropBoxData; const a = i.width; const n = i.height; const r = t.width; const o = t.height; const s = i.left - e.left - t.left; const h = i.top - e.top - t.top; this.cropped && !this.disabled && (kt(this.viewBoxImage, xt({ width: r, height: o }, qt(xt({ translateX: -s, translateY: -h }, t)))), yt(this.previews, function (e) { const i = Wt(e, z); const c = i.width; const l = i.height; let d = c; let p = l; let u = 1; a && (u = c / a, p = n * u), n && p > l && (u = l / n, d = a * u, p = l), kt(e, { width: d, height: p }), kt(e.getElementsByTagName('img')[0], xt({ width: r * u, height: o * u }, qt(xt({ translateX: -s * u, translateY: -h * u }, t)))) })) } }; const se = { bind () { const t = this.element; const e = this.options; const i = this.cropper; vt(e.cropstart) && It(t, P, e.cropstart), vt(e.cropmove) && It(t, _, e.cropmove), vt(e.cropend) && It(t, A, e.cropend), vt(e.crop) && It(t, X, e.crop), vt(e.zoom) && It(t, tt, e.zoom), It(i, Q, this.onCropStart = this.cropStart.bind(this)), e.zoomable && e.zoomOnWheel && It(i, G, this.onWheel = this.wheel.bind(this), { passive: !1, capture: !0 }), e.toggleDragModeOnDblclick && It(i, U, this.onDblclick = this.dblclick.bind(this)), It(t.ownerDocument, V, this.onCropMove = this.cropMove.bind(this)), It(t.ownerDocument, K, this.onCropEnd = this.cropEnd.bind(this)), e.responsive && It(window, J, this.onResize = this.resize.bind(this)) }, unbind () { const t = this.element; const e = this.options; const i = this.cropper; vt(e.cropstart) && St(t, P, e.cropstart), vt(e.cropmove) && St(t, _, e.cropmove), vt(e.cropend) && St(t, A, e.cropend), vt(e.crop) && St(t, X, e.crop), vt(e.zoom) && St(t, tt, e.zoom), St(i, Q, this.onCropStart), e.zoomable && e.zoomOnWheel && St(i, G, this.onWheel, { passive: !1, capture: !0 }), e.toggleDragModeOnDblclick && St(i, U, this.onDblclick), St(t.ownerDocument, V, this.onCropMove), St(t.ownerDocument, K, this.onCropEnd), e.responsive && St(window, J, this.onResize) } }; const he = { resize () { const t = this.options; const e = this.container; const i = this.containerData; const a = Number(t.minContainerWidth) || ot; const n = Number(t.minContainerHeight) || st; if (!(this.disabled || i.width <= a || i.height <= n)) { let r; let o; const s = e.offsetWidth / i.width; if (s !== 1 || e.offsetHeight !== i.height) { t.restore && (r = this.getCanvasData(), o = this.getCropBoxData()), this.render(), t.restore && (this.setCanvasData(yt(r, function (t, e) { r[e] = t * s })), this.setCropBoxData(yt(o, function (t, e) { o[e] = t * s }))) } } }, dblclick () { this.disabled || this.options.dragMode === Y || this.setDragMode(Ot(this.dragBox, B) ? I : S) }, wheel (t) { const e = this; const i = Number(this.options.wheelZoomRatio) || 0.1; let a = 1; this.disabled || (t.preventDefault(), this.wheeling || (this.wheeling = !0, setTimeout(function () { e.wheeling = !1 }, 50), t.deltaY ? a = t.deltaY > 0 ? 1 : -1 : t.wheelDelta ? a = -t.wheelDelta / 120 : t.detail && (a = t.detail > 0 ? 1 : -1), this.zoom(-a * i, t))) }, cropStart (t) { const e = t.buttons; const i = t.button; if (!(this.disabled || (t.type === 'mousedown' || t.type === 'pointerdown' && t.pointerType === 'mouse') && (dt(e) && e !== 1 || dt(i) && i !== 0 || t.ctrlKey))) { let a; const n = this.options; const r = this.pointers; t.changedTouches ? yt(t.changedTouches, function (t) { r[t.identifier] = Ft(t) }) : r[t.pointerId || 0] = Ft(t), a = Object.keys(r).length > 1 && n.zoomable && n.zoomOnTouch ? b : Wt(t.target, j), it.test(a) && !1 !== Yt(this.element, P, { originalEvent: t, action: a }) && (t.preventDefault(), this.action = a, this.cropping = !1, a === v && (this.cropping = !0, Et(this.dragBox, H))) } }, cropMove (t) { const e = this.action; if (!this.disabled && e) { const i = this.pointers; t.preventDefault(), !1 !== Yt(this.element, _, { originalEvent: t, action: e }) && (t.changedTouches ? yt(t.changedTouches, function (t) { xt(i[t.identifier] || {}, Ft(t, !0)) }) : xt(i[t.pointerId || 0] || {}, Ft(t, !0)), this.change(t)) } }, cropEnd (t) { if (!this.disabled) { const e = this.action; const i = this.pointers; t.changedTouches ? yt(t.changedTouches, function (t) { delete i[t.identifier] }) : delete i[t.pointerId || 0], e && (t.preventDefault(), Object.keys(i).length || (this.action = ''), this.cropping && (this.cropping = !1, Tt(this.dragBox, H, this.cropped && this.options.modal)), Yt(this.element, A, { originalEvent: t, action: e })) } } }; const ce = { change (t) { let e; const i = this.options; const a = this.canvasData; const n = this.containerData; const r = this.cropBoxData; const o = this.pointers; let s = this.action; let h = i.aspectRatio; let c = r.left; let l = r.top; let d = r.width; let p = r.height; const u = c + d; const m = l + p; let g = 0; let B = 0; let T = n.width; let N = n.height; let W = !0; !h && t.shiftKey && (h = d && p ? d / p : 1), this.limited && (g = r.minLeft, B = r.minTop, T = g + Math.min(n.width, a.width, a.left + a.width), N = B + Math.min(n.height, a.height, a.top + a.height)); const H = o[Object.keys(o)[0]]; const L = { x: H.endX - H.startX, y: H.endY - H.startY }; const j = function (t) { switch (t) { case y:u + L.x > T && (L.x = T - u); break; case x:c + L.x < g && (L.x = g - c); break; case C:l + L.y < B && (L.y = B - l); break; case M:m + L.y > N && (L.y = N - m); break; default: } }; switch (s) { case f:c += L.x, l += L.y; break; case y:if (L.x >= 0 && (u >= T || h && (l <= B || m >= N))) { W = !1; break }j(y), d += L.x, d < 0 && (s = x, d = -d, c -= d), h && (p = d / h, l += (r.height - p) / 2); break; case C:if (L.y <= 0 && (l <= B || h && (c <= g || u >= T))) { W = !1; break }j(C), p -= L.y, l += L.y, p < 0 && (s = M, p = -p, l -= p), h && (d = p * h, c += (r.width - d) / 2); break; case x:if (L.x <= 0 && (c <= g || h && (l <= B || m >= N))) { W = !1; break }j(x), d -= L.x, c += L.x, d < 0 && (s = y, d = -d, c -= d), h && (p = d / h, l += (r.height - p) / 2); break; case M:if (L.y >= 0 && (m >= N || h && (c <= g || u >= T))) { W = !1; break }j(M), p += L.y, p < 0 && (s = C, p = -p, l -= p), h && (d = p * h, c += (r.width - d) / 2); break; case D:if (h) { if (L.y <= 0 && (l <= B || u >= T)) { W = !1; break }j(C), p -= L.y, l += L.y, d = p * h } else { j(C), j(y), L.x >= 0 ? u < T ? d += L.x : L.y <= 0 && l <= B && (W = !1) : d += L.x, L.y <= 0 ? l > B && (p -= L.y, l += L.y) : (p -= L.y, l += L.y) }d < 0 && p < 0 ? (s = E, p = -p, d = -d, l -= p, c -= d) : d < 0 ? (s = k, d = -d, c -= d) : p < 0 && (s = O, p = -p, l -= p); break; case k:if (h) { if (L.y <= 0 && (l <= B || c <= g)) { W = !1; break }j(C), p -= L.y, l += L.y, d = p * h, c += r.width - d } else { j(C), j(x), L.x <= 0 ? c > g ? (d -= L.x, c += L.x) : L.y <= 0 && l <= B && (W = !1) : (d -= L.x, c += L.x), L.y <= 0 ? l > B && (p -= L.y, l += L.y) : (p -= L.y, l += L.y) }d < 0 && p < 0 ? (s = O, p = -p, d = -d, l -= p, c -= d) : d < 0 ? (s = D, d = -d, c -= d) : p < 0 && (s = E, p = -p, l -= p); break; case E:if (h) { if (L.x <= 0 && (c <= g || m >= N)) { W = !1; break }j(x), d -= L.x, c += L.x, p = d / h } else { j(M), j(x), L.x <= 0 ? c > g ? (d -= L.x, c += L.x) : L.y >= 0 && m >= N && (W = !1) : (d -= L.x, c += L.x), L.y >= 0 ? m < N && (p += L.y) : p += L.y }d < 0 && p < 0 ? (s = D, p = -p, d = -d, l -= p, c -= d) : d < 0 ? (s = O, d = -d, c -= d) : p < 0 && (s = k, p = -p, l -= p); break; case O:if (h) { if (L.x >= 0 && (u >= T || m >= N)) { W = !1; break }j(y), d += L.x, p = d / h } else { j(M), j(y), L.x >= 0 ? u < T ? d += L.x : L.y >= 0 && m >= N && (W = !1) : d += L.x, L.y >= 0 ? m < N && (p += L.y) : p += L.y }d < 0 && p < 0 ? (s = k, p = -p, d = -d, l -= p, c -= d) : d < 0 ? (s = E, d = -d, c -= d) : p < 0 && (s = D, p = -p, l -= p); break; case w:this.move(L.x, L.y), W = !1; break; case b:this.zoom($t(o), t), W = !1; break; case v:if (!L.x || !L.y) { W = !1; break }e = Xt(this.cropper), c = H.startX - e.left, l = H.startY - e.top, d = r.minWidth, p = r.minHeight, L.x > 0 ? s = L.y > 0 ? O : D : L.x < 0 && (c -= d, s = L.y > 0 ? E : k), L.y < 0 && (l -= p), this.cropped || (Bt(this.cropBox, R), this.cropped = !0, this.limited && this.limitCropBox(!0, !0)); break; default: }W && (r.width = d, r.height = p, r.left = c, r.top = l, this.action = s, this.renderCropBox()), yt(o, function (t) { t.startX = t.endX, t.startY = t.endY }) } }; const le = { crop () { return !this.ready || this.cropped || this.disabled || (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && Et(this.dragBox, H), Bt(this.cropBox, R), this.setCropBoxData(this.initialCropBoxData)), this }, reset () { return this.ready && !this.disabled && (this.imageData = xt({}, this.initialImageData), this.canvasData = xt({}, this.initialCanvasData), this.cropBoxData = xt({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this }, clear () { return this.cropped && !this.disabled && (xt(this.cropBoxData, { left: 0, top: 0, width: 0, height: 0 }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), Bt(this.dragBox, H), Et(this.cropBox, R)), this }, replace (t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; return !this.disabled && t && (this.isImg && (this.element.src = t), e ? (this.url = t, this.image.src = t, this.ready && (this.viewBoxImage.src = t, yt(this.previews, function (e) { e.getElementsByTagName('img')[0].src = t }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(t))), this }, enable () { return this.ready && this.disabled && (this.disabled = !1, Bt(this.cropper, T)), this }, disable () { return this.ready && !this.disabled && (this.disabled = !0, Et(this.cropper, T)), this }, destroy () { const t = this.element; return t[g] ? (t[g] = void 0, this.isImg && this.replaced && (t.src = this.originalUrl), this.uncreate(), this) : this }, move (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t; const i = this.canvasData; const a = i.left; const n = i.top; return this.moveTo(ut(t) ? t : a + Number(t), ut(e) ? e : n + Number(e)) }, moveTo (t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t; const i = this.canvasData; let a = !1; return t = Number(t), e = Number(e), this.ready && !this.disabled && this.options.movable && (dt(t) && (i.left = t, a = !0), dt(e) && (i.top = e, a = !0), a && this.renderCanvas(!0)), this }, zoom (t, e) { const i = this.canvasData; return t = Number(t), t = t < 0 ? 1 / (1 - t) : 1 + t, this.zoomTo(i.width * t / i.naturalWidth, null, e) }, zoomTo (t, e, i) { const a = this.options; const n = this.canvasData; const r = n.width; const o = n.height; const s = n.naturalWidth; const h = n.naturalHeight; if (t = Number(t), t >= 0 && this.ready && !this.disabled && a.zoomable) { const c = s * t; const l = h * t; if (!1 === Yt(this.element, tt, { ratio: t, oldRatio: r / s, originalEvent: i })) { return this } if (i) { const d = this.pointers; const p = Xt(this.cropper); const u = d && Object.keys(d).length ? Qt(d) : { pageX: i.pageX, pageY: i.pageY }; n.left -= (c - r) * ((u.pageX - p.left - n.left) / r), n.top -= (l - o) * ((u.pageY - p.top - n.top) / o) } else { ft(e) && dt(e.x) && dt(e.y) ? (n.left -= (c - r) * ((e.x - n.left) / r), n.top -= (l - o) * ((e.y - n.top) / o)) : (n.left -= (c - r) / 2, n.top -= (l - o) / 2) }n.width = c, n.height = l, this.renderCanvas(!0) } return this }, rotate (t) { return this.rotateTo((this.imageData.rotate || 0) + Number(t)) }, rotateTo (t) { return t = Number(t), dt(t) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = t % 360, this.renderCanvas(!0, !0)), this }, scaleX (t) { const e = this.imageData.scaleY; return this.scale(t, dt(e) ? e : 1) }, scaleY (t) { const e = this.imageData.scaleX; return this.scale(dt(e) ? e : 1, t) }, scale (t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t; const i = this.imageData; let a = !1; return t = Number(t), e = Number(e), this.ready && !this.disabled && this.options.scalable && (dt(t) && (i.scaleX = t, a = !0), dt(e) && (i.scaleY = e, a = !0), a && this.renderCanvas(!0, !0)), this }, getData () { let t; const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const i = this.options; const a = this.imageData; const n = this.canvasData; const r = this.cropBoxData; if (this.ready && this.cropped) { t = { x: r.left - n.left, y: r.top - n.top, width: r.width, height: r.height }; const o = a.width / a.naturalWidth; if (yt(t, function (e, i) { t[i] = e / o }), e) { const s = Math.round(t.y + t.height); const h = Math.round(t.x + t.width); t.x = Math.round(t.x), t.y = Math.round(t.y), t.width = h - t.x, t.height = s - t.y } } else { t = { x: 0, y: 0, width: 0, height: 0 } } return i.rotatable && (t.rotate = a.rotate || 0), i.scalable && (t.scaleX = a.scaleX || 1, t.scaleY = a.scaleY || 1), t }, setData (t) { const e = this.options; const i = this.imageData; const a = this.canvasData; const n = {}; if (this.ready && !this.disabled && ft(t)) { let r = !1; e.rotatable && dt(t.rotate) && t.rotate !== i.rotate && (i.rotate = t.rotate, r = !0), e.scalable && (dt(t.scaleX) && t.scaleX !== i.scaleX && (i.scaleX = t.scaleX, r = !0), dt(t.scaleY) && t.scaleY !== i.scaleY && (i.scaleY = t.scaleY, r = !0)), r && this.renderCanvas(!0, !0); const o = i.width / i.naturalWidth; dt(t.x) && (n.left = t.x * o + a.left), dt(t.y) && (n.top = t.y * o + a.top), dt(t.width) && (n.width = t.width * o), dt(t.height) && (n.height = t.height * o), this.setCropBoxData(n) } return this }, getContainerData () { return this.ready ? xt({}, this.containerData) : {} }, getImageData () { return this.sized ? xt({}, this.imageData) : {} }, getCanvasData () { const t = this.canvasData; const e = {}; return this.ready && yt(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (i) { e[i] = t[i] }), e }, setCanvasData (t) { const e = this.canvasData; const i = e.aspectRatio; return this.ready && !this.disabled && ft(t) && (dt(t.left) && (e.left = t.left), dt(t.top) && (e.top = t.top), dt(t.width) ? (e.width = t.width, e.height = t.width / i) : dt(t.height) && (e.height = t.height, e.width = t.height * i), this.renderCanvas(!0)), this }, getCropBoxData () { let t; const e = this.cropBoxData; return this.ready && this.cropped && (t = { left: e.left, top: e.top, width: e.width, height: e.height }), t || {} }, setCropBoxData (t) { let e; let i; const a = this.cropBoxData; const n = this.options.aspectRatio; return this.ready && this.cropped && !this.disabled && ft(t) && (dt(t.left) && (a.left = t.left), dt(t.top) && (a.top = t.top), dt(t.width) && t.width !== a.width && (e = !0, a.width = t.width), dt(t.height) && t.height !== a.height && (i = !0, a.height = t.height), n && (e ? a.height = a.width / n : i && (a.width = a.height * n)), this.renderCropBox()), this }, getCroppedCanvas () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (!this.ready || !window.HTMLCanvasElement) { return null } const e = this.canvasData; const i = Zt(this.image, this.imageData, e, t); if (!this.cropped) { return i } const a = this.getData(); let n = a.x; let r = a.y; let o = a.width; let h = a.height; const c = i.width / Math.floor(e.naturalWidth); c !== 1 && (n *= c, r *= c, o *= c, h *= c); const l = o / h; const d = Vt({ aspectRatio: l, width: t.maxWidth || 1 / 0, height: t.maxHeight || 1 / 0 }); const p = Vt({ aspectRatio: l, width: t.minWidth || 0, height: t.minHeight || 0 }, 'cover'); const u = Vt({ aspectRatio: l, width: t.width || (c !== 1 ? i.width : o), height: t.height || (c !== 1 ? i.height : h) }); let m = u.width; let g = u.height; m = Math.min(d.width, Math.max(p.width, m)), g = Math.min(d.height, Math.max(p.height, g)); const f = document.createElement('canvas'); const v = f.getContext('2d'); f.width = Ct(m), f.height = Ct(g), v.fillStyle = t.fillColor || 'transparent', v.fillRect(0, 0, m, g); const w = t.imageSmoothingEnabled; const b = void 0 === w || w; const y = t.imageSmoothingQuality; v.imageSmoothingEnabled = b, y && (v.imageSmoothingQuality = y); let x; let M; let C; let D; let k; let O; const E = i.width; const B = i.height; let T = n; let R = r; T <= -o || T > E ? (T = 0, x = 0, C = 0, k = 0) : T <= 0 ? (C = -T, T = 0, x = Math.min(E, o + T), k = x) : T <= E && (C = 0, x = Math.min(o, E - T), k = x), x <= 0 || R <= -h || R > B ? (R = 0, M = 0, D = 0, O = 0) : R <= 0 ? (D = -R, R = 0, M = Math.min(B, h + R), O = M) : R <= B && (D = 0, M = Math.min(h, B - R), O = M); const N = [T, R, x, M]; if (k > 0 && O > 0) { const W = m / o; N.push(C * W, D * W, k * W, O * W) } return v.drawImage.apply(v, [i].concat(s(N.map(function (t) { return Math.floor(Ct(t)) })))), f }, setAspectRatio (t) { const e = this.options; return this.disabled || ut(t) || (e.aspectRatio = Math.max(0, t) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this }, setDragMode (t) { const e = this.options; const i = this.dragBox; const a = this.face; if (this.ready && !this.disabled) { const n = t === S; const r = e.movable && t === I; t = n || r ? t : Y, e.dragMode = t, Ht(i, j, t), Tt(i, B, n), Tt(i, L, r), e.cropBoxMovable || (Ht(a, j, t), Tt(a, B, n), Tt(a, L, r)) } return this } }; const de = p.Cropper; const pe = (function () { function t (i) { const a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (e(this, t), !i || !rt.test(i.tagName)) { throw new Error('The first argument is required and must be an <img> or <canvas> element.') } this.element = i, this.options = xt({}, ht, ft(a) && a), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init() } return a(t, [{ key: 'init', value () { let t; const e = this.element; const i = e.tagName.toLowerCase(); if (!e[g]) { if (e[g] = this, i === 'img') { if (this.isImg = !0, t = e.getAttribute('src') || '', this.originalUrl = t, !t) { return } t = e.src } else { i === 'canvas' && window.HTMLCanvasElement && (t = e.toDataURL()) } this.load(t) } } }, { key: 'load', value (t) { const e = this; if (t) { this.url = t, this.imageData = {}; const i = this.element; const a = this.options; if (a.rotatable || a.scalable || (a.checkOrientation = !1), a.checkOrientation && window.ArrayBuffer) { if (at.test(t)) { nt.test(t) ? this.read(ee(t)) : this.clone() } else { const n = new XMLHttpRequest(); const r = this.clone.bind(this); this.reloading = !0, this.xhr = n, n.onabort = r, n.onerror = r, n.ontimeout = r, n.onprogress = function () { n.getResponseHeader('content-type') !== et && n.abort() }, n.onload = function () { e.read(n.response) }, n.onloadend = function () { e.reloading = !1, e.xhr = null }, a.checkCrossOrigin && Pt(t) && i.crossOrigin && (t = Ut(t)), n.open('GET', t), n.responseType = 'arraybuffer', n.withCredentials = i.crossOrigin === 'use-credentials', n.send() } } else { this.clone() } } } }, { key: 'read', value (t) { const e = this.options; const i = this.imageData; const a = ae(t); let n = 0; let r = 1; let o = 1; if (a > 1) { this.url = ie(t, et); const s = ne(a); n = s.rotate, r = s.scaleX, o = s.scaleY }e.rotatable && (i.rotate = n), e.scalable && (i.scaleX = r, i.scaleY = o), this.clone() } }, { key: 'clone', value () { const t = this.element; const e = this.url; let i = t.crossOrigin; let a = e; this.options.checkCrossOrigin && Pt(e) && (i || (i = 'anonymous'), a = Ut(e)), this.crossOrigin = i, this.crossOriginUrl = a; const n = document.createElement('img'); i && (n.crossOrigin = i), n.src = a || e, n.alt = t.alt || 'The image to crop', this.image = n, n.onload = this.start.bind(this), n.onerror = this.stop.bind(this), Et(n, N), t.parentNode.insertBefore(n, t.nextSibling) } }, { key: 'start', value () { const t = this; const e = this.image; e.onload = null, e.onerror = null, this.sizing = !0; const i = p.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(p.navigator.userAgent); const a = function (e, i) { xt(t.imageData, { naturalWidth: e, naturalHeight: i, aspectRatio: e / i }), t.sizing = !1, t.sized = !0, t.build() }; if (!e.naturalWidth || i) { const n = document.createElement('img'); const r = document.body || document.documentElement; this.sizingImage = n, n.onload = function () { a(n.width, n.height), i || r.removeChild(n) }, n.src = e.src, i || (n.style.cssText = 'left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;', r.appendChild(n)) } else { a(e.naturalWidth, e.naturalHeight) } } }, { key: 'stop', value () { const t = this.image; t.onload = null, t.onerror = null, t.parentNode.removeChild(t), this.image = null } }, { key: 'build', value () { if (this.sized && !this.ready) { const t = this.element; const e = this.options; const i = this.image; const a = t.parentNode; const n = document.createElement('div'); n.innerHTML = ct; const r = n.querySelector('.'.concat(g, '-container')); const o = r.querySelector('.'.concat(g, '-canvas')); const s = r.querySelector('.'.concat(g, '-drag-box')); const h = r.querySelector('.'.concat(g, '-crop-box')); const c = h.querySelector('.'.concat(g, '-face')); this.container = a, this.cropper = r, this.canvas = o, this.dragBox = s, this.cropBox = h, this.viewBox = r.querySelector('.'.concat(g, '-view-box')), this.face = c, o.appendChild(i), Et(t, R), a.insertBefore(r, t.nextSibling), this.isImg || Bt(i, N), this.initPreview(), this.bind(), e.initialAspectRatio = Math.max(0, e.initialAspectRatio) || NaN, e.aspectRatio = Math.max(0, e.aspectRatio) || NaN, e.viewMode = Math.max(0, Math.min(3, Math.round(e.viewMode))) || 0, Et(h, R), e.guides || Et(h.getElementsByClassName(''.concat(g, '-dashed')), R), e.center || Et(h.getElementsByClassName(''.concat(g, '-center')), R), e.background && Et(r, ''.concat(g, '-bg')), e.highlight || Et(c, W), e.cropBoxMovable && (Et(c, L), Ht(c, j, f)), e.cropBoxResizable || (Et(h.getElementsByClassName(''.concat(g, '-line')), R), Et(h.getElementsByClassName(''.concat(g, '-point')), R)), this.render(), this.ready = !0, this.setDragMode(e.dragMode), e.autoCrop && this.crop(), this.setData(e.data), vt(e.ready) && It(t, Z, e.ready, { once: !0 }), Yt(t, Z) } } }, { key: 'unbuild', value () { this.ready && (this.ready = !1, this.unbind(), this.resetPreview(), this.cropper.parentNode.removeChild(this.cropper), Bt(this.element, R)) } }, { key: 'uncreate', value () { this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop() } }], [{ key: 'noConflict', value () { return window.Cropper = de, t } }, { key: 'setDefaults', value (t) { xt(ht, ft(t) && t) } }]), t }()); return xt(pe.prototype, re, oe, se, he, ce, le), pe })
  },
  f118 (t, e, i) { 'use strict'; const a = i('51e1'); const n = i.n(a); n.a },
  fab5 (t, e, i) { 'use strict'; i.r(e); const a = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return !1 === t.hasAllRequiredFields ? i('v-notice', [t._v(' File preview can only be used on directus_files. ')]) : i('div', [t.isImage ? i('div', { staticClass: 'image' }, [t.imgError ? t._e() : i('img', { key: t.image.hash, attrs: { id: 'image', src: t.url }, on: { error (e) { t.imgError = !0 } } }), t.imgError ? i('div', { staticClass: 'broken-image' }, [i('v-icon', { attrs: { name: 'broken_image' } })], 1) : t._e(), t.canBeEdited && !t.imgError && !t.editMode && t.isImage && t.options.edit.includes('image_editor') ? i('button', { staticClass: 'image-edit-start', attrs: { type: 'button', title: 'Edit image' }, on: { click (e) { return t.initImageEdit() } } }, [i('v-icon', { attrs: { name: 'crop_rotate' } })], 1) : t._e()]) : t.isVideo ? i('div', { staticClass: 'video' }, [i('video', { attrs: { controls: '' } }, [i('source', { attrs: { src: t.url, type: t.values.type } }), t._v(" I'm sorry; your browser doesn't support HTML5 video in this format. ")])]) : t.isAudio ? i('div', { staticClass: 'audio' }, [i('audio', { attrs: { controls: '' } }, [i('source', { attrs: { src: t.url, type: t.values.type } }), t._v(" I'm sorry; your browser doesn't support HTML5 audio in this format. ")])]) : t.isYouTube ? i('div', { staticClass: 'embed' }, [i('iframe', { attrs: { width: '620', height: '349', src: 'https://www.youtube.com/embed/' + t.values.embed, frameborder: '0', allow: 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture', allowfullscreen: '' } })]) : t.isVimeo ? i('div', { staticClass: 'embed' }, [i('iframe', { attrs: { width: '620', height: '349', src: 'https://player.vimeo.com/video/' + t.values.embed + '?color=039be5&title=0&byline=0&portrait=0', frameborder: '0', webkitallowfullscreen: '', mozallowfullscreen: '', allowfullscreen: '' } })]) : i('div', { staticClass: 'file' }, [t._v(t._s(t.fileType))]), i('div', { staticClass: 'toolbar' }, [!1 !== t.canBeEdited && t.editMode ? t._e() : i('div', { staticClass: 'original' }, [i('a', { staticClass: 'file-link', attrs: { href: t.url, target: '_blank' } }, [i('v-icon', { attrs: { name: 'link' } }), t._v(' ' + t._s(t.url) + ' ')], 1)]), t.canBeEdited && t.editMode ? i('ul', { staticClass: 'image-edit' }, [i('li', [i('div', { staticClass: 'image-aspect-ratio' }, [i('v-icon', { attrs: { name: 'image_aspect_ratio' } }), i('span', [t._v(t._s(t.image.cropRatioOptions[t.image.cropRatio]))]), i('v-icon', { attrs: { name: 'arrow_drop_down' } }), i('select', { directives: [{ name: 'model', rawName: 'v-model', value: t.image.cropRatio, expression: 'image.cropRatio' }], attrs: { title: 'Select aspect ratio' }, on: { change (e) { const i = Array.prototype.filter.call(e.target.options, function (t) { return t.selected }).map(function (t) { const e = '_value' in t ? t._value : t.value; return e }); t.$set(t.image, 'cropRatio', e.target.multiple ? i : i[0]) } } }, t._l(t.image.cropRatioOptions, function (e, a) { return i('option', { key: a, domProps: { value: a } }, [t._v(' ' + t._s(e) + ' ')]) }), 0)], 1)]), i('li', [i('button', { attrs: { type: 'button', title: 'Discard changes' }, on: { click (e) { return t.cancelImageEdit() } } }, [i('v-icon', { attrs: { name: 'not_interested' } })], 1), i('button', { attrs: { type: 'button', title: 'Save changes' }, on: { click (e) { return t.saveImage() } } }, [i('v-icon', { attrs: { name: 'check_circle' } })], 1)]), i('li', [i('button', { attrs: { type: 'button', title: 'Flip horizontally' }, on: { click (e) { return t.flipImage() } } }, [i('v-icon', { attrs: { name: 'flip' } })], 1), i('button', { attrs: { type: 'button', title: 'Rotate counter-clockwise' }, on: { click (e) { return t.rotateImage() } } }, [i('v-icon', { attrs: { name: 'rotate_90_degrees_ccw' } })], 1)])]) : t._e()])]) }; const n = []; const r = (i('a4d3'), i('4de4'), i('4160'), i('e439'), i('dbb4'), i('b64b'), i('d3b7'), i('ac1f'), i('1276'), i('159b'), i('ddb0'), i('96cf'), i('1da1')); const o = i('ade3'); const s = i('8db2'); const h = i.n(s); const c = i('bab4'); const l = i.n(c); const d = (i('4604'), i('8dee')); const p = i.n(d); const u = i('2ef0'); function m (t, e) { const i = Object.keys(t); if (Object.getOwnPropertySymbols) { let a = Object.getOwnPropertySymbols(t); e && (a = a.filter(function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable })), i.push.apply(i, a) } return i } function g (t) { for (let e = 1; e < arguments.length; e++) { var i = arguments[e] != null ? arguments[e] : {}; e % 2 ? m(Object(i), !0).forEach(function (e) { Object(o.a)(t, e, i[e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : m(Object(i)).forEach(function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)) }) } return t } const f = { mixins: [h.a], data () { return { editMode: null, imgError: !1, image: { hash: p.a.generate(), cropper: null, cropRatio: 'free', cropRatioOptions: { free: 'Free', original: 'Original', '1:1': 'Square', '16:9': '16:9', '4:3': '4:3', '3:2': '3:2' }, initOptions: { background: !1, viewMode: 0, autoCropArea: 1, zoomable: !1 } } } }, computed: { hasAllRequiredFields () { const t = this; const e = ['type', 'filesize', 'data', 'id']; let i = !0; return e.forEach(function (e) { !1 === Object(u.has)(t.values, e) && (i = !1) }), i }, canBeEdited () { let t; return ((t = this.values) === null || void 0 === t ? void 0 : t.filesize) <= 1e6 && this.isImage }, isImage () { let t; switch ((t = this.values) === null || void 0 === t ? void 0 : t.type) { case 'image/jpeg':case 'image/gif':case 'image/png':case 'image/svg+xml':case 'image/webp':case 'image/bmp':return !0 } return !1 }, isVideo () { let t; switch ((t = this.values) === null || void 0 === t ? void 0 : t.type) { case 'video/mp4':case 'video/webm':case 'video/ogg':return !0 } return !1 }, isAudio () { let t; switch ((t = this.values) === null || void 0 === t ? void 0 : t.type) { case 'audio/mpeg':case 'audio/ogg':case 'audio/wav':return !0 } return !1 }, isYouTube () { let t; return ((t = this.values) === null || void 0 === t ? void 0 : t.type) === 'embed/youtube' }, isVimeo () { let t; return ((t = this.values) === null || void 0 === t ? void 0 : t.type) === 'embed/vimeo' }, fileType () { let t; return (t = this.values) === null || void 0 === t ? void 0 : t.type.split('/')[1] }, url () { let t; return (t = this.values) === null || void 0 === t ? void 0 : t.data.asset_url } }, watch: { 'image.cropRatio' (t) { this.setAspectRatio(t) } }, methods: { initImageEdit () { this.editMode = 'image', this.image.show = !1; const t = document.getElementById('image'); this.image.cropper = new l.a(t, g({}, this.image.initOptions)), window.addEventListener('keydown', this.escapeEditImage) }, escapeEditImage (t) { this.editMode == 'image' && t.key == 'Escape' && (this.cancelImageEdit(), window.removeEventListener('keydown', this.escapeEditImage)) }, cancelImageEdit () { this.editMode = null, this.image.cropRatio = 'free', this.image.cropper.destroy() }, setAspectRatio (t) { let e; switch (t) { case 'free':e = 'free'; break; case 'original':e = this.image.cropper.getImageData().aspectRatio; break; default:var i = t.split(':'); e = i[0] / i[1]; break } this.image.cropper.setAspectRatio(e) }, flipImage () { this.image.cropper.scale(-this.image.cropper.getData().scaleX, 1) }, rotateImage () { this.image.cropper.rotate(-90) }, saveImage () { const t = this; return Object(r.a)(regeneratorRuntime.mark(function e () { let i, a, n, r; return regeneratorRuntime.wrap(function (e) { while (1) { switch (e.prev = e.next) { case 0:return a = t.$helpers.shortid.generate(), t.$store.dispatch('loadingStart', { id: a }), n = t.image.cropper.getCroppedCanvas({ imageSmoothingQuality: 'high' }).toDataURL((i = t.values) === null || void 0 === i ? void 0 : i.type), e.prev = 3, e.next = 6, t.$api.api.patch('/files/'.concat((r = t.values) === null || void 0 === r ? void 0 : r.id), { data: n }); case 6:t.$events.emit('success', { notify: 'Image updated.' }), t.image.hash = p.a.generate(), t.editMode = null, t.image.cropRatio = 'free', t.image.cropper.destroy(), e.next = 16; break; case 13:e.prev = 13, e.t0 = e.catch(3), t.$events.emit('error', { notify: 'There was an error while saving the image', error: e.t0 }); case 16:return e.prev = 16, t.$store.dispatch('loadingFinished', a), e.finish(16); case 19:case 'end':return e.stop() } } }, e, null, [[3, 13, 16, 19]]) }))() } } }; const v = f; const w = (i('2709'), i('f118'), i('2877')); const b = Object(w.a)(v, a, n, !1, null, '0d464381', null); e.default = b.exports }
}])
// # sourceMappingURL=chunk-7a5057ef.47464fcb.js.map
