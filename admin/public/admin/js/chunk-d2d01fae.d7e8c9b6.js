(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-d2d01fae'], {
  3750 (t, e, i) {},
  4662 (t, e, i) { 'use strict'; i.r(e); const n = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'interface-map' }, [i('div', { staticClass: 'map', class: { 'map-readonly': t.readonly } }, [i('div', { staticClass: 'map-container', style: { height: t.options.height + 'px' }, attrs: { id: t.name } }), i('div', { staticClass: 'map-actions' }, [t.options.address_to_code ? i('div', { staticClass: 'address-input' }, [i('v-input', { attrs: { placeholder: 'Enter address to geocode' }, model: { value: t.placeName, callback (e) { t.placeName = e }, expression: 'placeName' } }), t.isInteractive ? i('button', { directives: [{ name: 'tooltip', rawName: 'v-tooltip', value: t.$t('interfaces.map.address_location'), expression: "$t('interfaces.map.address_location')" }], on: { click (e) { return t.getCoordinatesforPlaceName() } } }, [i('v-icon', { attrs: { name: 'search' } })], 1) : t._e()], 1) : t._e(), t.isInteractive ? i('button', { directives: [{ name: 'tooltip', rawName: 'v-tooltip', value: t.$t('interfaces.map.my_location'), expression: "$t('interfaces.map.my_location')" }], staticClass: 'map-my-location', on: { click (e) { return t.locateMe() } } }, [i('v-icon', { attrs: { name: 'my_location' } })], 1) : t._e(), t.isInteractive ? i('button', { directives: [{ name: 'tooltip', rawName: 'v-tooltip', value: t.$t('interfaces.map.clear_location'), expression: "$t('interfaces.map.clear_location')" }], staticClass: 'clear-location', on: { click (e) { return t.setValue() } } }, [i('v-icon', { attrs: { name: 'clear' } })], 1) : t._e()])]), i('div', { staticClass: 'map-coordinates' }, [t.latlng ? i('span', [t._v(' Latitude: '), i('b', [t._v(t._s(t.latlng.lat))]), t._v(' , ')]) : t._e(), t.latlng ? i('span', [t._v(' Longitude: '), i('b', [t._v(t._s(t.latlng.lng))])]) : t._e()])]) }; const o = []; const s = (i('99af'), i('4160'), i('d81d'), i('b0c0'), i('ac1f'), i('5319'), i('498a'), i('159b'), i('8db2')); const a = i.n(s); const r = i('e11e'); const h = i.n(r); const l = (i('3750'), i('2ef0')); const u = { name: 'InterfaceMap', mixins: [a.a], data () { return { test: null, map: null, marker: null, latlng: null, isLocating: !1, placeName: '', mapInteractions: ['boxZoom', 'doubleClickZoom', 'dragging', 'keyboard', 'scrollWheelZoom', 'tap', 'touchZoom'] } }, computed: { isInteractive () { return !this.readonly }, accentColor () { return getComputedStyle(document.documentElement).getPropertyValue('--blue-grey-900').trim() }, darkAccentColor () { return getComputedStyle(document.documentElement).getPropertyValue('--blue-grey-900').trim() } }, watch: { 'options.theme' (t) { h.a.tileLayer(t).addTo(this.map) }, readonly (t) { this.toggleMapInteractions(!t), this.toggleMarkerInteractions(!t), t ? (this.unbindMapEvents(), this.unbindMarkerEvents()) : (this.bindMapEvents(), this.bindMarkerEvents()) }, latlng (t) { this.setMarker(t) } }, mounted () { this.init() }, methods: { init () { let t; t = this.value ? h.a.latLng(this.value.lat, this.value.lng) : h.a.latLng(this.options.mapLat, this.options.mapLng), this.createMap(t) }, createMap (t) { this.map = h.a.map(this.name, { center: t, zoom: this.options.defaultZoom, maxZoom: this.options.maxZoom, zoomControl: !0 }), h.a.tileLayer(this.options.theme, { attribution: '&copy; <a href="https://carto.com/">Carto</a>' }).addTo(this.map), this.value && this.setValue(this.value), this.isInteractive ? this.bindMapEvents() : this.unbindMapEvents() }, setMarker (t) { if (this.marker) { t ? this.marker.setLatLng(t).setOpacity(1) : this.marker.setOpacity(0) } else { const e = h.a.icon({ iconUrl: this.markerSVG(), iconSize: [36, 36], iconAnchor: [18, 36] }); this.marker = h.a.marker(t, { icon: e, draggable: this.isInteractive }).addTo(this.map), this.isInteractive && (this.bindMarkerEvents(), this.toggleMapInteractions(!0)) } }, setValue (t) { this.latlng = t, this.$emit('input', this.latlng ? JSON.parse(JSON.stringify(this.latlng)) : null) }, toggleMarkerInteractions (t) { t ? this.marker.dragging.enable() : this.marker.dragging.disable() }, unbindMarkerEvents () { this.marker.off('drag') }, bindMarkerEvents () { const t = this; this.marker.on('drag', Object(l.debounce)(function (e) { t.setValue(e.latlng) }, 100)) }, toggleMapInteractions (t) { const e = this; this.mapInteractions.forEach(function (i) { e.map[i] && (t ? e.map[i].enable() : e.map[i].disable()) }) }, unbindMapEvents () { this.map.off('click') }, bindMapEvents () { const t = this; this.map.on('click', function (e) { t.setValue(e.latlng) }), this.map.on('locationerror', function (e) { t.$events.emit('error', { notify: e.code == 1 ? t.$t('interfaces.map.user_location_error_blocked') : t.$t('interfaces.map.user_location_error'), error: e }), t.isLocating && t.$store.dispatch('loadingFinished', t.isLocating) }), this.map.on('locationfound', function (e) { t.isLocating && t.$store.dispatch('loadingFinished', t.isLocating), t.setValue(e.latlng) }) }, locateMe () { this.isLocating = this.isLocating || this.$helpers.shortid.generate(), this.$store.dispatch('loadingStart', { id: this.isLocating }), this.map.locate({ setView: !0, maxZoom: this.options.maxZoom }) }, markerSVG () { return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="'.concat(this.accentColor.replace('#', '%23'), '" stroke-width="1" stroke="').concat(this.darkAccentColor.replace('#', '%23'), '" d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>') }, getCoordinatesforPlaceName () { const t = this; this.$store.dispatch('loadingStart', { id: this.isLocating }), this.$axios.get('https://nominatim.openstreetmap.org/search?q='.concat(encodeURI(this.placeName), '&format=geojson&addressdetails=1&limit=1')).then(function (e) { if (e.status === 200) { if (e.data.features[0]) { const i = e.data.features[0].geometry.coordinates; const n = { lat: i[1], lng: i[0] }; t.setValue(n), t.map.panTo(new h.a.LatLng(i[1], i[0])), t.$store.dispatch('loadingFinished', t.isLocating) } else { t.$events.emit('error', { notify: t.$t('interfaces.map.address_to_code_error'), error: 'result' }) } } }).catch(function (e) { t.$events.emit('error', { notify: e, error: 'result' }), t.$store.dispatch('loadingFinished', t.isLocating) }) } } }; const c = u; const d = (i('b139'), i('2877')); const _ = Object(d.a)(c, n, o, !1, null, 'b2045852', null); e.default = _.exports },
  '8db2' (t, e) { t.exports = { props: { id: { type: String, required: !0 }, name: { type: String, required: !0 }, value: { type: null, default: null }, type: { type: String, required: !0 }, length: { type: [String, Number], default: null }, readonly: { type: Boolean, default: !1 }, collection: { type: String, default: null }, primaryKey: { type: [Number, String], default: null }, required: { type: Boolean, default: !1 }, options: { type: Object, default: () => ({}) }, newItem: { type: Boolean, default: !1 }, relation: { type: Object, default: null }, fields: { type: Object, default: null }, values: { type: Object, default: null }, width: { type: String, default: null, validator (t) { return ['half', 'half-left', 'half-right', 'full', 'fill'].includes(t) } } } } },
  b139 (t, e, i) { 'use strict'; const n = i('b228'); const o = i.n(n); o.a },
  b228 (t, e, i) {},
  e11e (t, e, i) {
    /* @preserve
 * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
    (function (t, i) { i(e) })(0, function (t) { 'use strict'; const e = '1.6.0'; const i = Object.freeze; function n (t) { let e, i, n, o; for (i = 1, n = arguments.length; i < n; i++) { for (e in o = arguments[i], o) { t[e] = o[e] } } return t }Object.freeze = function (t) { return t }; const o = Object.create || (function () { function t () {} return function (e) { return t.prototype = e, new t() } }()); function s (t, e) { const i = Array.prototype.slice; if (t.bind) { return t.bind.apply(t, i.call(arguments, 1)) } const n = i.call(arguments, 2); return function () { return t.apply(e, n.length ? n.concat(i.call(arguments)) : arguments) } } let a = 0; function r (t) { return t._leaflet_id = t._leaflet_id || ++a, t._leaflet_id } function h (t, e, i) { let n, o, s, a; return a = function () { n = !1, o && (s.apply(i, o), o = !1) }, s = function () { n ? o = arguments : (t.apply(i, arguments), setTimeout(a, e), n = !0) }, s } function l (t, e, i) { const n = e[1]; const o = e[0]; const s = n - o; return t === n && i ? t : ((t - o) % s + s) % s + o } function u () { return !1 } function c (t, e) { const i = Math.pow(10, void 0 === e ? 6 : e); return Math.round(t * i) / i } function d (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '') } function _ (t) { return d(t).split(/\s+/) } function p (t, e) { for (const i in t.hasOwnProperty('options') || (t.options = t.options ? o(t.options) : {}), e) { t.options[i] = e[i] } return t.options } function m (t, e, i) { const n = []; for (const o in t) { n.push(encodeURIComponent(i ? o.toUpperCase() : o) + '=' + encodeURIComponent(t[o])) } return (e && e.includes('?') ? '&' : '?') + n.join('&') } const f = /\{ *([\w_-]+) *\}/g; function g (t, e) { return t.replace(f, function (t, i) { let n = e[i]; if (void 0 === n) { throw new Error('No value provided for variable ' + t) } return typeof n === 'function' && (n = n(e)), n }) } const v = Array.isArray || function (t) { return Object.prototype.toString.call(t) === '[object Array]' }; function y (t, e) { for (let i = 0; i < t.length; i++) { if (t[i] === e) { return i } } return -1 } const x = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; function w (t) { return window['webkit' + t] || window['moz' + t] || window['ms' + t] } let b = 0; function P (t) { const e = +new Date(); const i = Math.max(0, 16 - (e - b)); return b = e + i, window.setTimeout(t, i) } const T = window.requestAnimationFrame || w('RequestAnimationFrame') || P; const M = window.cancelAnimationFrame || w('CancelAnimationFrame') || w('CancelRequestAnimationFrame') || function (t) { window.clearTimeout(t) }; function z (t, e, i) { if (!i || T !== P) { return T.call(window, s(t, e)) } t.call(e) } function C (t) { t && M.call(window, t) } const k = (Object.freeze || Object)({ freeze: i, extend: n, create: o, bind: s, lastId: a, stamp: r, throttle: h, wrapNum: l, falseFn: u, formatNum: c, trim: d, splitWords: _, setOptions: p, getParamString: m, template: g, isArray: v, indexOf: y, emptyImageUrl: x, requestFn: T, cancelFn: M, requestAnimFrame: z, cancelAnimFrame: C }); function S () {} function E (t) { if (typeof L !== 'undefined' && L && L.Mixin) { t = v(t) ? t : [t]; for (let e = 0; e < t.length; e++) { t[e] === L.Mixin.Events && console.warn('Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.', (new Error()).stack) } } }S.extend = function (t) { const e = function () { this.initialize && this.initialize.apply(this, arguments), this.callInitHooks() }; const i = e.__super__ = this.prototype; const s = o(i); for (const a in s.constructor = e, e.prototype = s, this) { this.hasOwnProperty(a) && a !== 'prototype' && a !== '__super__' && (e[a] = this[a]) } return t.statics && (n(e, t.statics), delete t.statics), t.includes && (E(t.includes), n.apply(null, [s].concat(t.includes)), delete t.includes), s.options && (t.options = n(o(s.options), t.options)), n(s, t), s._initHooks = [], s.callInitHooks = function () { if (!this._initHooksCalled) { i.callInitHooks && i.callInitHooks.call(this), this._initHooksCalled = !0; for (let t = 0, e = s._initHooks.length; t < e; t++) { s._initHooks[t].call(this) } } }, e }, S.include = function (t) { return n(this.prototype, t), this }, S.mergeOptions = function (t) { return n(this.prototype.options, t), this }, S.addInitHook = function (t) { const e = Array.prototype.slice.call(arguments, 1); const i = typeof t === 'function' ? t : function () { this[t].apply(this, e) }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i), this }; const Z = { on (t, e, i) { if (typeof t === 'object') { for (const n in t) { this._on(n, t[n], e) } } else { t = _(t); for (let o = 0, s = t.length; o < s; o++) { this._on(t[o], e, i) } } return this }, off (t, e, i) { if (t) { if (typeof t === 'object') { for (const n in t) { this._off(n, t[n], e) } } else { t = _(t); for (let o = 0, s = t.length; o < s; o++) { this._off(t[o], e, i) } } } else { delete this._events } return this }, _on (t, e, i) { this._events = this._events || {}; let n = this._events[t]; n || (n = [], this._events[t] = n), i === this && (i = void 0); for (var o = { fn: e, ctx: i }, s = n, a = 0, r = s.length; a < r; a++) { if (s[a].fn === e && s[a].ctx === i) { return } } s.push(o) }, _off (t, e, i) { let n, o, s; if (this._events && (n = this._events[t], n)) { if (e) { if (i === this && (i = void 0), n) { for (o = 0, s = n.length; o < s; o++) { const a = n[o]; if (a.ctx === i && a.fn === e) { return a.fn = u, this._firingCount && (this._events[t] = n = n.slice()), void n.splice(o, 1) } } } } else { for (o = 0, s = n.length; o < s; o++) { n[o].fn = u } delete this._events[t] } } }, fire (t, e, i) { if (!this.listens(t, i)) { return this } const o = n({}, e, { type: t, target: this, sourceTarget: e && e.sourceTarget || this }); if (this._events) { const s = this._events[t]; if (s) { this._firingCount = this._firingCount + 1 || 1; for (let a = 0, r = s.length; a < r; a++) { const h = s[a]; h.fn.call(h.ctx || this, o) } this._firingCount-- } } return i && this._propagateEvent(o), this }, listens (t, e) { const i = this._events && this._events[t]; if (i && i.length) { return !0 } if (e) { for (const n in this._eventParents) { if (this._eventParents[n].listens(t, e)) { return !0 } } } return !1 }, once (t, e, i) { if (typeof t === 'object') { for (const n in t) { this.once(n, t[n], e) } return this } var o = s(function () { this.off(t, e, i).off(t, o, i) }, this); return this.on(t, e, i).on(t, o, i) }, addEventParent (t) { return this._eventParents = this._eventParents || {}, this._eventParents[r(t)] = t, this }, removeEventParent (t) { return this._eventParents && delete this._eventParents[r(t)], this }, _propagateEvent (t) { for (const e in this._eventParents) { this._eventParents[e].fire(t.type, n({ layer: t.target, propagatedFrom: t.target }, t), !0) } } }; Z.addEventListener = Z.on, Z.removeEventListener = Z.clearAllEventListeners = Z.off, Z.addOneTimeEventListener = Z.once, Z.fireEvent = Z.fire, Z.hasEventListeners = Z.listens; const I = S.extend(Z); function B (t, e, i) { this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e } const A = Math.trunc || function (t) { return t > 0 ? Math.floor(t) : Math.ceil(t) }; function O (t, e, i) { return t instanceof B ? t : v(t) ? new B(t[0], t[1]) : void 0 === t || t === null ? t : typeof t === 'object' && 'x' in t && 'y' in t ? new B(t.x, t.y) : new B(t, e, i) } function N (t, e) { if (t) { for (let i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++) { this.extend(i[n]) } } } function R (t, e) { return !t || t instanceof N ? t : new N(t, e) } function j (t, e) { if (t) { for (let i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++) { this.extend(i[n]) } } } function D (t, e) { return t instanceof j ? t : new j(t, e) } function W (t, e, i) { if (isNaN(t) || isNaN(e)) { throw new TypeError('Invalid LatLng object: (' + t + ', ' + e + ')') } this.lat = +t, this.lng = +e, void 0 !== i && (this.alt = +i) } function H (t, e, i) { return t instanceof W ? t : v(t) && typeof t[0] !== 'object' ? t.length === 3 ? new W(t[0], t[1], t[2]) : t.length === 2 ? new W(t[0], t[1]) : null : void 0 === t || t === null ? t : typeof t === 'object' && 'lat' in t ? new W(t.lat, 'lng' in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new W(t, e, i) }B.prototype = { clone () { return new B(this.x, this.y) }, add (t) { return this.clone()._add(O(t)) }, _add (t) { return this.x += t.x, this.y += t.y, this }, subtract (t) { return this.clone()._subtract(O(t)) }, _subtract (t) { return this.x -= t.x, this.y -= t.y, this }, divideBy (t) { return this.clone()._divideBy(t) }, _divideBy (t) { return this.x /= t, this.y /= t, this }, multiplyBy (t) { return this.clone()._multiplyBy(t) }, _multiplyBy (t) { return this.x *= t, this.y *= t, this }, scaleBy (t) { return new B(this.x * t.x, this.y * t.y) }, unscaleBy (t) { return new B(this.x / t.x, this.y / t.y) }, round () { return this.clone()._round() }, _round () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, floor () { return this.clone()._floor() }, _floor () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil () { return this.clone()._ceil() }, _ceil () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, trunc () { return this.clone()._trunc() }, _trunc () { return this.x = A(this.x), this.y = A(this.y), this }, distanceTo (t) { t = O(t); const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i) }, equals (t) { return t = O(t), t.x === this.x && t.y === this.y }, contains (t) { return t = O(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y) }, toString () { return 'Point(' + c(this.x) + ', ' + c(this.y) + ')' } }, N.prototype = { extend (t) { return t = O(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this }, getCenter (t) { return new B((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t) }, getBottomLeft () { return new B(this.min.x, this.max.y) }, getTopRight () { return new B(this.max.x, this.min.y) }, getTopLeft () { return this.min }, getBottomRight () { return this.max }, getSize () { return this.max.subtract(this.min) }, contains (t) { let e, i; return t = typeof t[0] === 'number' || t instanceof B ? O(t) : R(t), t instanceof N ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y }, intersects (t) { t = R(t); const e = this.min; const i = this.max; const n = t.min; const o = t.max; const s = o.x >= e.x && n.x <= i.x; const a = o.y >= e.y && n.y <= i.y; return s && a }, overlaps (t) { t = R(t); const e = this.min; const i = this.max; const n = t.min; const o = t.max; const s = o.x > e.x && n.x < i.x; const a = o.y > e.y && n.y < i.y; return s && a }, isValid () { return !(!this.min || !this.max) } }, j.prototype = { extend (t) { let e; let i; const n = this._southWest; const o = this._northEast; if (t instanceof W) { e = t, i = t } else { if (!(t instanceof j)) { return t ? this.extend(H(t) || D(t)) : this } if (e = t._southWest, i = t._northEast, !e || !i) { return this } } return n || o ? (n.lat = Math.min(e.lat, n.lat), n.lng = Math.min(e.lng, n.lng), o.lat = Math.max(i.lat, o.lat), o.lng = Math.max(i.lng, o.lng)) : (this._southWest = new W(e.lat, e.lng), this._northEast = new W(i.lat, i.lng)), this }, pad (t) { const e = this._southWest; const i = this._northEast; const n = Math.abs(e.lat - i.lat) * t; const o = Math.abs(e.lng - i.lng) * t; return new j(new W(e.lat - n, e.lng - o), new W(i.lat + n, i.lng + o)) }, getCenter () { return new W((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2) }, getSouthWest () { return this._southWest }, getNorthEast () { return this._northEast }, getNorthWest () { return new W(this.getNorth(), this.getWest()) }, getSouthEast () { return new W(this.getSouth(), this.getEast()) }, getWest () { return this._southWest.lng }, getSouth () { return this._southWest.lat }, getEast () { return this._northEast.lng }, getNorth () { return this._northEast.lat }, contains (t) { t = typeof t[0] === 'number' || t instanceof W || 'lat' in t ? H(t) : D(t); let e; let i; const n = this._southWest; const o = this._northEast; return t instanceof j ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng }, intersects (t) { t = D(t); const e = this._southWest; const i = this._northEast; const n = t.getSouthWest(); const o = t.getNorthEast(); const s = o.lat >= e.lat && n.lat <= i.lat; const a = o.lng >= e.lng && n.lng <= i.lng; return s && a }, overlaps (t) { t = D(t); const e = this._southWest; const i = this._northEast; const n = t.getSouthWest(); const o = t.getNorthEast(); const s = o.lat > e.lat && n.lat < i.lat; const a = o.lng > e.lng && n.lng < i.lng; return s && a }, toBBoxString () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',') }, equals (t, e) { return !!t && (t = D(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) }, isValid () { return !(!this._southWest || !this._northEast) } }, W.prototype = { equals (t, e) { if (!t) { return !1 } t = H(t); const i = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)); return i <= (void 0 === e ? 1e-9 : e) }, toString (t) { return 'LatLng(' + c(this.lat, t) + ', ' + c(this.lng, t) + ')' }, distanceTo (t) { return V.distance(this, H(t)) }, wrap () { return V.wrapLatLng(this) }, toBounds (t) { const e = 180 * t / 40075017; const i = e / Math.cos(Math.PI / 180 * this.lat); return D([this.lat - e, this.lng - i], [this.lat + e, this.lng + i]) }, clone () { return new W(this.lat, this.lng, this.alt) } }; const F = { latLngToPoint (t, e) { const i = this.projection.project(t); const n = this.scale(e); return this.transformation._transform(i, n) }, pointToLatLng (t, e) { const i = this.scale(e); const n = this.transformation.untransform(t, i); return this.projection.unproject(n) }, project (t) { return this.projection.project(t) }, unproject (t) { return this.projection.unproject(t) }, scale (t) { return 256 * Math.pow(2, t) }, zoom (t) { return Math.log(t / 256) / Math.LN2 }, getProjectedBounds (t) { if (this.infinite) { return null } const e = this.projection.bounds; const i = this.scale(t); const n = this.transformation.transform(e.min, i); const o = this.transformation.transform(e.max, i); return new N(n, o) }, infinite: !1, wrapLatLng (t) { const e = this.wrapLng ? l(t.lng, this.wrapLng, !0) : t.lng; const i = this.wrapLat ? l(t.lat, this.wrapLat, !0) : t.lat; const n = t.alt; return new W(i, e, n) }, wrapLatLngBounds (t) { const e = t.getCenter(); const i = this.wrapLatLng(e); const n = e.lat - i.lat; const o = e.lng - i.lng; if (n === 0 && o === 0) { return t } const s = t.getSouthWest(); const a = t.getNorthEast(); const r = new W(s.lat - n, s.lng - o); const h = new W(a.lat - n, a.lng - o); return new j(r, h) } }; var V = n({}, F, { wrapLng: [-180, 180], R: 6371e3, distance (t, e) { const i = Math.PI / 180; const n = t.lat * i; const o = e.lat * i; const s = Math.sin((e.lat - t.lat) * i / 2); const a = Math.sin((e.lng - t.lng) * i / 2); const r = s * s + Math.cos(n) * Math.cos(o) * a * a; const h = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1 - r)); return this.R * h } }); const U = 6378137; const q = { R: U, MAX_LATITUDE: 85.0511287798, project (t) { const e = Math.PI / 180; const i = this.MAX_LATITUDE; const n = Math.max(Math.min(i, t.lat), -i); const o = Math.sin(n * e); return new B(this.R * t.lng * e, this.R * Math.log((1 + o) / (1 - o)) / 2) }, unproject (t) { const e = 180 / Math.PI; return new W((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R) }, bounds: (function () { const t = U * Math.PI; return new N([-t, -t], [t, t]) }()) }; function G (t, e, i, n) { if (v(t)) { return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]) } this._a = t, this._b = e, this._c = i, this._d = n } function K (t, e, i, n) { return new G(t, e, i, n) }G.prototype = { transform (t, e) { return this._transform(t.clone(), e) }, _transform (t, e) { return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t }, untransform (t, e) { return e = e || 1, new B((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c) } }; const Y = n({}, V, { code: 'EPSG:3857', projection: q, transformation: (function () { const t = 0.5 / (Math.PI * q.R); return K(t, 0.5, -t, 0.5) }()) }); const $ = n({}, Y, { code: 'EPSG:900913' }); function J (t) { return document.createElementNS('http://www.w3.org/2000/svg', t) } function X (t, e) { let i; let n; let o; let s; let a; let r; let h = ''; for (i = 0, o = t.length; i < o; i++) { for (a = t[i], n = 0, s = a.length; n < s; n++) { r = a[n], h += (n ? 'L' : 'M') + r.x + ' ' + r.y }h += e ? St ? 'z' : 'x' : '' } return h || 'M0 0' } const Q = document.documentElement.style; const tt = 'ActiveXObject' in window; const et = tt && !document.addEventListener; const it = 'msLaunchUri' in navigator && !('documentMode' in document); const nt = Zt('webkit'); const ot = Zt('android'); const st = Zt('android 2') || Zt('android 3'); const at = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); const rt = ot && Zt('Google') && at < 537 && !('AudioNode' in window); const ht = !!window.opera; const lt = Zt('chrome'); const ut = Zt('gecko') && !nt && !ht && !tt; const ct = !lt && Zt('safari'); const dt = Zt('phantom'); const _t = 'OTransition' in Q; const pt = navigator.platform.indexOf('Win') === 0; const mt = tt && 'transition' in Q; const ft = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !st; const gt = 'MozPerspective' in Q; const vt = !window.L_DISABLE_3D && (mt || ft || gt) && !_t && !dt; const yt = typeof orientation !== 'undefined' || Zt('mobile'); const xt = yt && nt; const wt = yt && ft; const bt = !window.PointerEvent && window.MSPointerEvent; const Lt = !nt && !(!window.PointerEvent && !bt); const Pt = !window.L_NO_TOUCH && (Lt || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); const Tt = yt && ht; const Mt = yt && ut; const zt = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; const Ct = function () { let t = !1; try { const e = Object.defineProperty({}, 'passive', { get () { t = !0 } }); window.addEventListener('testPassiveEventSupport', u, e), window.removeEventListener('testPassiveEventSupport', u, e) } catch (i) {} return t }; const kt = (function () { return !!document.createElement('canvas').getContext }()); var St = !(!document.createElementNS || !J('svg').createSVGRect); const Et = !St && (function () { try { const t = document.createElement('div'); t.innerHTML = '<v:shape adj="1"/>'; const e = t.firstChild; return e.style.behavior = 'url(#default#VML)', e && typeof e.adj === 'object' } catch (i) { return !1 } }()); function Zt (t) { return navigator.userAgent.toLowerCase().includes(t) } const It = (Object.freeze || Object)({ ie: tt, ielt9: et, edge: it, webkit: nt, android: ot, android23: st, androidStock: rt, opera: ht, chrome: lt, gecko: ut, safari: ct, phantom: dt, opera12: _t, win: pt, ie3d: mt, webkit3d: ft, gecko3d: gt, any3d: vt, mobile: yt, mobileWebkit: xt, mobileWebkit3d: wt, msPointer: bt, pointer: Lt, touch: Pt, mobileOpera: Tt, mobileGecko: Mt, retina: zt, passiveEvents: Ct, canvas: kt, svg: St, vml: Et }); const Bt = bt ? 'MSPointerDown' : 'pointerdown'; const At = bt ? 'MSPointerMove' : 'pointermove'; const Ot = bt ? 'MSPointerUp' : 'pointerup'; const Nt = bt ? 'MSPointerCancel' : 'pointercancel'; const Rt = ['INPUT', 'SELECT', 'OPTION']; const jt = {}; let Dt = !1; let Wt = 0; function Ht (t, e, i, n) { return e === 'touchstart' ? Vt(t, i, n) : e === 'touchmove' ? Yt(t, i, n) : e === 'touchend' && $t(t, i, n), this } function Ft (t, e, i) { const n = t['_leaflet_' + e + i]; return e === 'touchstart' ? t.removeEventListener(Bt, n, !1) : e === 'touchmove' ? t.removeEventListener(At, n, !1) : e === 'touchend' && (t.removeEventListener(Ot, n, !1), t.removeEventListener(Nt, n, !1)), this } function Vt (t, e, i) { const n = s(function (t) { if (t.pointerType !== 'mouse' && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) { if (Rt.includes(t.target.tagName)) { return } Ve(t) }Kt(t, e) }); t['_leaflet_touchstart' + i] = n, t.addEventListener(Bt, n, !1), Dt || (document.documentElement.addEventListener(Bt, Ut, !0), document.documentElement.addEventListener(At, qt, !0), document.documentElement.addEventListener(Ot, Gt, !0), document.documentElement.addEventListener(Nt, Gt, !0), Dt = !0) } function Ut (t) { jt[t.pointerId] = t, Wt++ } function qt (t) { jt[t.pointerId] && (jt[t.pointerId] = t) } function Gt (t) { delete jt[t.pointerId], Wt-- } function Kt (t, e) { for (const i in t.touches = [], jt) { t.touches.push(jt[i]) }t.changedTouches = [t], e(t) } function Yt (t, e, i) { const n = function (t) { (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && t.pointerType !== 'mouse' || t.buttons !== 0) && Kt(t, e) }; t['_leaflet_touchmove' + i] = n, t.addEventListener(At, n, !1) } function $t (t, e, i) { const n = function (t) { Kt(t, e) }; t['_leaflet_touchend' + i] = n, t.addEventListener(Ot, n, !1), t.addEventListener(Nt, n, !1) } const Jt = bt ? 'MSPointerDown' : Lt ? 'pointerdown' : 'touchstart'; const Xt = bt ? 'MSPointerUp' : Lt ? 'pointerup' : 'touchend'; const Qt = '_leaflet_'; function te (t, e, i) { let n; let o; let s = !1; const a = 250; function r (t) { let e; if (Lt) { if (!it || t.pointerType === 'mouse') { return } e = Wt } else { e = t.touches.length } if (!(e > 1)) { const i = Date.now(); const r = i - (n || i); o = t.touches ? t.touches[0] : t, s = r > 0 && r <= a, n = i } } function h (t) { if (s && !o.cancelBubble) { if (Lt) { if (!it || t.pointerType === 'mouse') { return } let i; let a; const r = {}; for (a in o) { i = o[a], r[a] = i && i.bind ? i.bind(o) : i }o = r }o.type = 'dblclick', o.button = 0, e(o), n = null } } return t[Qt + Jt + i] = r, t[Qt + Xt + i] = h, t[Qt + 'dblclick' + i] = e, t.addEventListener(Jt, r, !!Ct && { passive: !1 }), t.addEventListener(Xt, h, !!Ct && { passive: !1 }), t.addEventListener('dblclick', e, !1), this } function ee (t, e) { const i = t[Qt + Jt + e]; const n = t[Qt + Xt + e]; const o = t[Qt + 'dblclick' + e]; return t.removeEventListener(Jt, i, !!Ct && { passive: !1 }), t.removeEventListener(Xt, n, !!Ct && { passive: !1 }), it || t.removeEventListener('dblclick', o, !1), this } let ie; let ne; let oe; let se; let ae; const re = Pe(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); const he = Pe(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); const le = he === 'webkitTransition' || he === 'OTransition' ? he + 'End' : 'transitionend'; function ue (t) { return typeof t === 'string' ? document.getElementById(t) : t } function ce (t, e) { let i = t.style[e] || t.currentStyle && t.currentStyle[e]; if ((!i || i === 'auto') && document.defaultView) { const n = document.defaultView.getComputedStyle(t, null); i = n ? n[e] : null } return i === 'auto' ? null : i } function de (t, e, i) { const n = document.createElement(t); return n.className = e || '', i && i.appendChild(n), n } function _e (t) { const e = t.parentNode; e && e.removeChild(t) } function pe (t) { while (t.firstChild) { t.removeChild(t.firstChild) } } function me (t) { const e = t.parentNode; e && e.lastChild !== t && e.appendChild(t) } function fe (t) { const e = t.parentNode; e && e.firstChild !== t && e.insertBefore(t, e.firstChild) } function ge (t, e) { if (void 0 !== t.classList) { return t.classList.contains(e) } const i = we(t); return i.length > 0 && new RegExp('(^|\\s)' + e + '(\\s|$)').test(i) } function ve (t, e) { if (void 0 !== t.classList) { for (let i = _(e), n = 0, o = i.length; n < o; n++) { t.classList.add(i[n]) } } else if (!ge(t, e)) { const s = we(t); xe(t, (s ? s + ' ' : '') + e) } } function ye (t, e) { void 0 !== t.classList ? t.classList.remove(e) : xe(t, d((' ' + we(t) + ' ').replace(' ' + e + ' ', ' '))) } function xe (t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e } function we (t) { return t.correspondingElement && (t = t.correspondingElement), void 0 === t.className.baseVal ? t.className : t.className.baseVal } function be (t, e) { 'opacity' in t.style ? t.style.opacity = e : 'filter' in t.style && Le(t, e) } function Le (t, e) { let i = !1; const n = 'DXImageTransform.Microsoft.Alpha'; try { i = t.filters.item(n) } catch (o) { if (e === 1) { return } }e = Math.round(100 * e), i ? (i.Enabled = e !== 100, i.Opacity = e) : t.style.filter += ' progid:' + n + '(opacity=' + e + ')' } function Pe (t) { for (let e = document.documentElement.style, i = 0; i < t.length; i++) { if (t[i] in e) { return t[i] } } return !1 } function Te (t, e, i) { const n = e || new B(0, 0); t.style[re] = (mt ? 'translate(' + n.x + 'px,' + n.y + 'px)' : 'translate3d(' + n.x + 'px,' + n.y + 'px,0)') + (i ? ' scale(' + i + ')' : '') } function Me (t, e) { t._leaflet_pos = e, vt ? Te(t, e) : (t.style.left = e.x + 'px', t.style.top = e.y + 'px') } function ze (t) { return t._leaflet_pos || new B(0, 0) } if ('onselectstart' in document) { ie = function () { Oe(window, 'selectstart', Ve) }, ne = function () { Re(window, 'selectstart', Ve) } } else { const Ce = Pe(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']); ie = function () { if (Ce) { const t = document.documentElement.style; oe = t[Ce], t[Ce] = 'none' } }, ne = function () { Ce && (document.documentElement.style[Ce] = oe, oe = void 0) } } function ke () { Oe(window, 'dragstart', Ve) } function Se () { Re(window, 'dragstart', Ve) } function Ee (t) { while (t.tabIndex === -1) { t = t.parentNode }t.style && (Ze(), se = t, ae = t.style.outline, t.style.outline = 'none', Oe(window, 'keydown', Ze)) } function Ze () { se && (se.style.outline = ae, se = void 0, ae = void 0, Re(window, 'keydown', Ze)) } function Ie (t) { do { t = t.parentNode } while ((!t.offsetWidth || !t.offsetHeight) && t !== document.body); return t } function Be (t) { const e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e } } const Ae = (Object.freeze || Object)({ TRANSFORM: re, TRANSITION: he, TRANSITION_END: le, get: ue, getStyle: ce, create: de, remove: _e, empty: pe, toFront: me, toBack: fe, hasClass: ge, addClass: ve, removeClass: ye, setClass: xe, getClass: we, setOpacity: be, testProp: Pe, setTransform: Te, setPosition: Me, getPosition: ze, disableTextSelection: ie, enableTextSelection: ne, disableImageDrag: ke, enableImageDrag: Se, preventOutline: Ee, restoreOutline: Ze, getSizedParentNode: Ie, getScale: Be }); function Oe (t, e, i, n) { if (typeof e === 'object') { for (const o in e) { je(t, o, e[o], i) } } else { e = _(e); for (let s = 0, a = e.length; s < a; s++) { je(t, e[s], i, n) } } return this } const Ne = '_leaflet_events'; function Re (t, e, i, n) { if (typeof e === 'object') { for (const o in e) { De(t, o, e[o], i) } } else if (e) { e = _(e); for (let s = 0, a = e.length; s < a; s++) { De(t, e[s], i, n) } } else { for (const r in t[Ne]) { De(t, r, t[Ne][r]) } delete t[Ne] } return this } function je (t, e, i, n) { const o = e + r(i) + (n ? '_' + r(n) : ''); if (t[Ne] && t[Ne][o]) { return this } let s = function (e) { return i.call(n || t, e || window.event) }; const a = s; Lt && e.indexOf('touch') === 0 ? Ht(t, e, s, o) : !Pt || e !== 'dblclick' || !te || Lt && lt ? 'addEventListener' in t ? e === 'mousewheel' ? t.addEventListener('onwheel' in t ? 'wheel' : 'mousewheel', s, !!Ct && { passive: !1 }) : e === 'mouseenter' || e === 'mouseleave' ? (s = function (e) { e = e || window.event, Qe(t, e) && a(e) }, t.addEventListener(e === 'mouseenter' ? 'mouseover' : 'mouseout', s, !1)) : (e === 'click' && ot && (s = function (t) { ti(t, a) }), t.addEventListener(e, s, !1)) : 'attachEvent' in t && t.attachEvent('on' + e, s) : te(t, s, o), t[Ne] = t[Ne] || {}, t[Ne][o] = s } function De (t, e, i, n) { const o = e + r(i) + (n ? '_' + r(n) : ''); const s = t[Ne] && t[Ne][o]; if (!s) { return this } Lt && e.indexOf('touch') === 0 ? Ft(t, e, o) : !Pt || e !== 'dblclick' || !ee || Lt && lt ? 'removeEventListener' in t ? e === 'mousewheel' ? t.removeEventListener('onwheel' in t ? 'wheel' : 'mousewheel', s, !!Ct && { passive: !1 }) : t.removeEventListener(e === 'mouseenter' ? 'mouseover' : e === 'mouseleave' ? 'mouseout' : e, s, !1) : 'detachEvent' in t && t.detachEvent('on' + e, s) : ee(t, o), t[Ne][o] = null } function We (t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, Xe(t), this } function He (t) { return je(t, 'mousewheel', We), this } function Fe (t) { return Oe(t, 'mousedown touchstart dblclick', We), je(t, 'click', Je), this } function Ve (t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this } function Ue (t) { return Ve(t), We(t), this } function qe (t, e) { if (!e) { return new B(t.clientX, t.clientY) } const i = Be(e); const n = i.boundingClientRect; return new B((t.clientX - n.left) / i.x - e.clientLeft, (t.clientY - n.top) / i.y - e.clientTop) } const Ge = pt && lt ? 2 * window.devicePixelRatio : ut ? window.devicePixelRatio : 1; function Ke (t) { return it ? t.wheelDeltaY / 2 : t.deltaY && t.deltaMode === 0 ? -t.deltaY / Ge : t.deltaY && t.deltaMode === 1 ? 20 * -t.deltaY : t.deltaY && t.deltaMode === 2 ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0 } let Ye; const $e = {}; function Je (t) { $e[t.type] = !0 } function Xe (t) { const e = $e[t.type]; return $e[t.type] = !1, e } function Qe (t, e) { let i = e.relatedTarget; if (!i) { return !0 } try { while (i && i !== t) { i = i.parentNode } } catch (n) { return !1 } return i !== t } function ti (t, e) { const i = t.timeStamp || t.originalEvent && t.originalEvent.timeStamp; const n = Ye && i - Ye; n && n > 100 && n < 500 || t.target._simulatedClick && !t._simulated ? Ue(t) : (Ye = i, e(t)) } const ei = (Object.freeze || Object)({ on: Oe, off: Re, stopPropagation: We, disableScrollPropagation: He, disableClickPropagation: Fe, preventDefault: Ve, stop: Ue, getMousePosition: qe, getWheelDelta: Ke, fakeStop: Je, skipped: Xe, isExternalTarget: Qe, addListener: Oe, removeListener: Re }); const ii = I.extend({ run (t, e, i, n) { this.stop(), this._el = t, this._inProgress = !0, this._duration = i || 0.25, this._easeOutPower = 1 / Math.max(n || 0.5, 0.2), this._startPos = ze(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date(), this.fire('start'), this._animate() }, stop () { this._inProgress && (this._step(!0), this._complete()) }, _animate () { this._animId = z(this._animate, this), this._step() }, _step (t) { const e = +new Date() - this._startTime; const i = 1e3 * this._duration; e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1), this._complete()) }, _runFrame (t, e) { const i = this._startPos.add(this._offset.multiplyBy(t)); e && i._round(), Me(this._el, i), this.fire('step') }, _complete () { C(this._animId), this._inProgress = !1, this.fire('end') }, _easeOut (t) { return 1 - Math.pow(1 - t, this._easeOutPower) } }); const ni = I.extend({ options: { crs: Y, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: !0, zoomAnimationThreshold: 4, fadeAnimation: !0, markerZoomAnimation: !0, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: !0 }, initialize (t, e) { e = p(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = s(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(H(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = he && vt && !Tt && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Oe(this._proxy, le, this._catchTransitionEnd, this)), this._addLayers(this.options.layers) }, setView (t, e, i) { if (e = void 0 === e ? this._zoom : this._limitZoom(e), t = this._limitCenter(H(t), e, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && !0 !== i) { void 0 !== i.animate && (i.zoom = n({ animate: i.animate }, i.zoom), i.pan = n({ animate: i.animate, duration: i.duration }, i.pan)); const o = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan); if (o) { return clearTimeout(this._sizeTimer), this } } return this._resetView(t, e), this }, setZoom (t, e) { return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this) }, zoomIn (t, e) { return t = t || (vt ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e) }, zoomOut (t, e) { return t = t || (vt ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e) }, setZoomAround (t, e, i) { const n = this.getZoomScale(e); const o = this.getSize().divideBy(2); const s = t instanceof B ? t : this.latLngToContainerPoint(t); const a = s.subtract(o).multiplyBy(1 - 1 / n); const r = this.containerPointToLatLng(o.add(a)); return this.setView(r, e, { zoom: i }) }, _getBoundsCenterZoom (t, e) { e = e || {}, t = t.getBounds ? t.getBounds() : D(t); const i = O(e.paddingTopLeft || e.padding || [0, 0]); const n = O(e.paddingBottomRight || e.padding || [0, 0]); let o = this.getBoundsZoom(t, !1, i.add(n)); if (o = typeof e.maxZoom === 'number' ? Math.min(e.maxZoom, o) : o, o === 1 / 0) { return { center: t.getCenter(), zoom: o } } const s = n.subtract(i).divideBy(2); const a = this.project(t.getSouthWest(), o); const r = this.project(t.getNorthEast(), o); const h = this.unproject(a.add(r).divideBy(2).add(s), o); return { center: h, zoom: o } }, fitBounds (t, e) { if (t = D(t), !t.isValid()) { throw new Error('Bounds are not valid.') } const i = this._getBoundsCenterZoom(t, e); return this.setView(i.center, i.zoom, e) }, fitWorld (t) { return this.fitBounds([[-90, -180], [90, 180]], t) }, panTo (t, e) { return this.setView(t, this._zoom, { pan: e }) }, panBy (t, e) { if (t = O(t).round(), e = e || {}, !t.x && !t.y) { return this.fire('moveend') } if (!0 !== e.animate && !this.getSize().contains(t)) { return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this } if (this._panAnim || (this._panAnim = new ii(), this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e.noMoveStart || this.fire('movestart'), !1 !== e.animate) { ve(this._mapPane, 'leaflet-pan-anim'); const i = this._getMapPanePos().subtract(t).round(); this._panAnim.run(this._mapPane, i, e.duration || 0.25, e.easeLinearity) } else { this._rawPanBy(t), this.fire('move').fire('moveend') } return this }, flyTo (t, e, i) { if (i = i || {}, !1 === i.animate || !vt) { return this.setView(t, e, i) } this._stop(); const n = this.project(this.getCenter()); const o = this.project(t); const s = this.getSize(); const a = this._zoom; t = H(t), e = void 0 === e ? a : e; const r = Math.max(s.x, s.y); const h = r * this.getZoomScale(a, e); const l = o.distanceTo(n) || 1; const u = 1.42; const c = u * u; function d (t) { const e = t ? -1 : 1; const i = t ? h : r; const n = h * h - r * r + e * c * c * l * l; const o = 2 * i * c * l; const s = n / o; const a = Math.sqrt(s * s + 1) - s; const u = a < 1e-9 ? -18 : Math.log(a); return u } function _ (t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function p (t) { return (Math.exp(t) + Math.exp(-t)) / 2 } function m (t) { return _(t) / p(t) } const f = d(0); function g (t) { return r * (p(f) / p(f + u * t)) } function v (t) { return r * (p(f) * m(f + u * t) - _(f)) / c } function y (t) { return 1 - Math.pow(1 - t, 1.5) } const x = Date.now(); const w = (d(1) - f) / u; const b = i.duration ? 1e3 * i.duration : 1e3 * w * 0.8; function L () { const i = (Date.now() - x) / b; const s = y(i) * w; i <= 1 ? (this._flyToFrame = z(L, this), this._move(this.unproject(n.add(o.subtract(n).multiplyBy(v(s) / l)), a), this.getScaleZoom(r / g(s), a), { flyTo: !0 })) : this._move(t, e)._moveEnd(!0) } return this._moveStart(!0, i.noMoveStart), L.call(this), this }, flyToBounds (t, e) { const i = this._getBoundsCenterZoom(t, e); return this.flyTo(i.center, i.zoom, e) }, setMaxBounds (t) { return t = D(t), t.isValid() ? (this.options.maxBounds && this.off('moveend', this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on('moveend', this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off('moveend', this._panInsideMaxBounds)) }, setMinZoom (t) { const e = this.options.minZoom; return this.options.minZoom = t, this._loaded && e !== t && (this.fire('zoomlevelschange'), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this }, setMaxZoom (t) { const e = this.options.maxZoom; return this.options.maxZoom = t, this._loaded && e !== t && (this.fire('zoomlevelschange'), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this }, panInsideBounds (t, e) { this._enforcingBounds = !0; const i = this.getCenter(); const n = this._limitCenter(i, this._zoom, D(t)); return i.equals(n) || this.panTo(n, e), this._enforcingBounds = !1, this }, panInside (t, e) { e = e || {}; const i = O(e.paddingTopLeft || e.padding || [0, 0]); const n = O(e.paddingBottomRight || e.padding || [0, 0]); const o = this.getCenter(); const s = this.project(o); const a = this.project(t); const r = this.getPixelBounds(); const h = r.getSize().divideBy(2); const l = R([r.min.add(i), r.max.subtract(n)]); if (!l.contains(a)) { this._enforcingBounds = !0; const u = s.subtract(a); const c = O(a.x + u.x, a.y + u.y); (a.x < l.min.x || a.x > l.max.x) && (c.x = s.x - u.x, u.x > 0 ? c.x += h.x - i.x : c.x -= h.x - n.x), (a.y < l.min.y || a.y > l.max.y) && (c.y = s.y - u.y, u.y > 0 ? c.y += h.y - i.y : c.y -= h.y - n.y), this.panTo(this.unproject(c), e), this._enforcingBounds = !1 } return this }, invalidateSize (t) { if (!this._loaded) { return this } t = n({ animate: !1, pan: !0 }, !0 === t ? { animate: !0 } : t); const e = this.getSize(); this._sizeChanged = !0, this._lastCenter = null; const i = this.getSize(); const o = e.divideBy(2).round(); const a = i.divideBy(2).round(); const r = o.subtract(a); return r.x || r.y ? (t.animate && t.pan ? this.panBy(r) : (t.pan && this._rawPanBy(r), this.fire('move'), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(s(this.fire, this, 'moveend'), 200)) : this.fire('moveend')), this.fire('resize', { oldSize: e, newSize: i })) : this }, stop () { return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire('viewreset'), this._stop() }, locate (t) { if (t = this._locateOptions = n({ timeout: 1e4, watch: !1 }, t), !('geolocation' in navigator)) { return this._handleGeolocationError({ code: 0, message: 'Geolocation not supported.' }), this } const e = s(this._handleGeolocationResponse, this); const i = s(this._handleGeolocationError, this); return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this }, stopLocate () { return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this }, _handleGeolocationError (t) { const e = t.code; const i = t.message || (e === 1 ? 'permission denied' : e === 2 ? 'position unavailable' : 'timeout'); this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire('locationerror', { code: e, message: 'Geolocation error: ' + i + '.' }) }, _handleGeolocationResponse (t) { const e = t.coords.latitude; const i = t.coords.longitude; const n = new W(e, i); const o = n.toBounds(2 * t.coords.accuracy); const s = this._locateOptions; if (s.setView) { const a = this.getBoundsZoom(o); this.setView(n, s.maxZoom ? Math.min(a, s.maxZoom) : a) } const r = { latlng: n, bounds: o, timestamp: t.timestamp }; for (const h in t.coords) { typeof t.coords[h] === 'number' && (r[h] = t.coords[h]) } this.fire('locationfound', r) }, addHandler (t, e) { if (!e) { return this } const i = this[t] = new e(this); return this._handlers.push(i), this.options[t] && i.enable(), this }, remove () { if (this._initEvents(!0), this._containerId !== this._container._leaflet_id) { throw new Error('Map container is being reused by another instance') } try { delete this._container._leaflet_id, delete this._containerId } catch (e) { this._container._leaflet_id = void 0, this._containerId = void 0 } let t; for (t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), _e(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (C(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire('unload'), this._layers) { this._layers[t].remove() } for (t in this._panes) { _e(this._panes[t]) } return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this }, createPane (t, e) { const i = 'leaflet-pane' + (t ? ' leaflet-' + t.replace('Pane', '') + '-pane' : ''); const n = de('div', i, e || this._mapPane); return t && (this._panes[t] = n), n }, getCenter () { return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint()) }, getZoom () { return this._zoom }, getBounds () { const t = this.getPixelBounds(); const e = this.unproject(t.getBottomLeft()); const i = this.unproject(t.getTopRight()); return new j(e, i) }, getMinZoom () { return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom }, getMaxZoom () { return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom }, getBoundsZoom (t, e, i) { t = D(t), i = O(i || [0, 0]); let n = this.getZoom() || 0; const o = this.getMinZoom(); const s = this.getMaxZoom(); const a = t.getNorthWest(); const r = t.getSouthEast(); const h = this.getSize().subtract(i); const l = R(this.project(r, n), this.project(a, n)).getSize(); const u = vt ? this.options.zoomSnap : 1; const c = h.x / l.x; const d = h.y / l.y; const _ = e ? Math.max(c, d) : Math.min(c, d); return n = this.getScaleZoom(_, n), u && (n = Math.round(n / (u / 100)) * (u / 100), n = e ? Math.ceil(n / u) * u : Math.floor(n / u) * u), Math.max(o, Math.min(s, n)) }, getSize () { return this._size && !this._sizeChanged || (this._size = new B(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone() }, getPixelBounds (t, e) { const i = this._getTopLeftPoint(t, e); return new N(i, i.add(this.getSize())) }, getPixelOrigin () { return this._checkIfLoaded(), this._pixelOrigin }, getPixelWorldBounds (t) { return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t) }, getPane (t) { return typeof t === 'string' ? this._panes[t] : t }, getPanes () { return this._panes }, getContainer () { return this._container }, getZoomScale (t, e) { const i = this.options.crs; return e = void 0 === e ? this._zoom : e, i.scale(t) / i.scale(e) }, getScaleZoom (t, e) { const i = this.options.crs; e = void 0 === e ? this._zoom : e; const n = i.zoom(t * i.scale(e)); return isNaN(n) ? 1 / 0 : n }, project (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(H(t), e) }, unproject (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(O(t), e) }, layerPointToLatLng (t) { const e = O(t).add(this.getPixelOrigin()); return this.unproject(e) }, latLngToLayerPoint (t) { const e = this.project(H(t))._round(); return e._subtract(this.getPixelOrigin()) }, wrapLatLng (t) { return this.options.crs.wrapLatLng(H(t)) }, wrapLatLngBounds (t) { return this.options.crs.wrapLatLngBounds(D(t)) }, distance (t, e) { return this.options.crs.distance(H(t), H(e)) }, containerPointToLayerPoint (t) { return O(t).subtract(this._getMapPanePos()) }, layerPointToContainerPoint (t) { return O(t).add(this._getMapPanePos()) }, containerPointToLatLng (t) { const e = this.containerPointToLayerPoint(O(t)); return this.layerPointToLatLng(e) }, latLngToContainerPoint (t) { return this.layerPointToContainerPoint(this.latLngToLayerPoint(H(t))) }, mouseEventToContainerPoint (t) { return qe(t, this._container) }, mouseEventToLayerPoint (t) { return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t)) }, mouseEventToLatLng (t) { return this.layerPointToLatLng(this.mouseEventToLayerPoint(t)) }, _initContainer (t) { const e = this._container = ue(t); if (!e) { throw new Error('Map container not found.') } if (e._leaflet_id) { throw new Error('Map container is already initialized.') } Oe(e, 'scroll', this._onScroll, this), this._containerId = r(e) }, _initLayout () { const t = this._container; this._fadeAnimated = this.options.fadeAnimation && vt, ve(t, 'leaflet-container' + (Pt ? ' leaflet-touch' : '') + (zt ? ' leaflet-retina' : '') + (et ? ' leaflet-oldie' : '') + (ct ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : '')); const e = ce(t, 'position'); e !== 'absolute' && e !== 'relative' && e !== 'fixed' && (t.style.position = 'relative'), this._initPanes(), this._initControlPos && this._initControlPos() }, _initPanes () { const t = this._panes = {}; this._paneRenderers = {}, this._mapPane = this.createPane('mapPane', this._container), Me(this._mapPane, new B(0, 0)), this.createPane('tilePane'), this.createPane('shadowPane'), this.createPane('overlayPane'), this.createPane('markerPane'), this.createPane('tooltipPane'), this.createPane('popupPane'), this.options.markerZoomAnimation || (ve(t.markerPane, 'leaflet-zoom-hide'), ve(t.shadowPane, 'leaflet-zoom-hide')) }, _resetView (t, e) { Me(this._mapPane, new B(0, 0)); const i = !this._loaded; this._loaded = !0, e = this._limitZoom(e), this.fire('viewprereset'); const n = this._zoom !== e; this._moveStart(n, !1)._move(t, e)._moveEnd(n), this.fire('viewreset'), i && this.fire('load') }, _moveStart (t, e) { return t && this.fire('zoomstart'), e || this.fire('movestart'), this }, _move (t, e, i) { void 0 === e && (e = this._zoom); const n = this._zoom !== e; return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (n || i && i.pinch) && this.fire('zoom', i), this.fire('move', i) }, _moveEnd (t) { return t && this.fire('zoomend'), this.fire('moveend') }, _stop () { return C(this._flyToFrame), this._panAnim && this._panAnim.stop(), this }, _rawPanBy (t) { Me(this._mapPane, this._getMapPanePos().subtract(t)) }, _getZoomSpan () { return this.getMaxZoom() - this.getMinZoom() }, _panInsideMaxBounds () { this._enforcingBounds || this.panInsideBounds(this.options.maxBounds) }, _checkIfLoaded () { if (!this._loaded) { throw new Error('Set map center and zoom first.') } }, _initEvents (t) { this._targets = {}, this._targets[r(this._container)] = this; const e = t ? Re : Oe; e(this._container, 'click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this), this.options.trackResize && e(window, 'resize', this._onResize, this), vt && this.options.transform3DLimit && (t ? this.off : this.on).call(this, 'moveend', this._onMoveEnd) }, _onResize () { C(this._resizeRequest), this._resizeRequest = z(function () { this.invalidateSize({ debounceMoveend: !0 }) }, this) }, _onScroll () { this._container.scrollTop = 0, this._container.scrollLeft = 0 }, _onMoveEnd () { const t = this._getMapPanePos(); Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom()) }, _findEventTargets (t, e) { let i; let n = []; const o = e === 'mouseout' || e === 'mouseover'; let s = t.target || t.srcElement; let a = !1; while (s) { if (i = this._targets[r(s)], i && (e === 'click' || e === 'preclick') && !t._simulated && this._draggableMoved(i)) { a = !0; break } if (i && i.listens(e, !0)) { if (o && !Qe(s, t)) { break } if (n.push(i), o) { break } } if (s === this._container) { break } s = s.parentNode } return n.length || a || o || !Qe(s, t) || (n = [this]), n }, _handleDOMEvent (t) { if (this._loaded && !Xe(t)) { const e = t.type; e !== 'mousedown' && e !== 'keypress' && e !== 'keyup' && e !== 'keydown' || Ee(t.target || t.srcElement), this._fireDOMEvent(t, e) } }, _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'], _fireDOMEvent (t, e, i) { if (t.type === 'click') { const o = n({}, t); o.type = 'preclick', this._fireDOMEvent(o, o.type, i) } if (!t._stopped && (i = (i || []).concat(this._findEventTargets(t, e)), i.length)) { const s = i[0]; e === 'contextmenu' && s.listens(e, !0) && Ve(t); const a = { originalEvent: t }; if (t.type !== 'keypress' && t.type !== 'keydown' && t.type !== 'keyup') { const r = s.getLatLng && (!s._radius || s._radius <= 10); a.containerPoint = r ? this.latLngToContainerPoint(s.getLatLng()) : this.mouseEventToContainerPoint(t), a.layerPoint = this.containerPointToLayerPoint(a.containerPoint), a.latlng = r ? s.getLatLng() : this.layerPointToLatLng(a.layerPoint) } for (let h = 0; h < i.length; h++) { if (i[h].fire(e, a, !0), a.originalEvent._stopped || !1 === i[h].options.bubblingMouseEvents && y(this._mouseEvents, e) !== -1) { return } } } }, _draggableMoved (t) { return t = t.dragging && t.dragging.enabled() ? t : this, t.dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved() }, _clearHandlers () { for (let t = 0, e = this._handlers.length; t < e; t++) { this._handlers[t].disable() } }, whenReady (t, e) { return this._loaded ? t.call(e || this, { target: this }) : this.on('load', t, e), this }, _getMapPanePos () { return ze(this._mapPane) || new B(0, 0) }, _moved () { const t = this._getMapPanePos(); return t && !t.equals([0, 0]) }, _getTopLeftPoint (t, e) { const i = t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin(); return i.subtract(this._getMapPanePos()) }, _getNewPixelOrigin (t, e) { const i = this.getSize()._divideBy(2); return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round() }, _latLngToNewLayerPoint (t, e, i) { const n = this._getNewPixelOrigin(i, e); return this.project(t, e)._subtract(n) }, _latLngBoundsToNewLayerBounds (t, e, i) { const n = this._getNewPixelOrigin(i, e); return R([this.project(t.getSouthWest(), e)._subtract(n), this.project(t.getNorthWest(), e)._subtract(n), this.project(t.getSouthEast(), e)._subtract(n), this.project(t.getNorthEast(), e)._subtract(n)]) }, _getCenterLayerPoint () { return this.containerPointToLayerPoint(this.getSize()._divideBy(2)) }, _getCenterOffset (t) { return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint()) }, _limitCenter (t, e, i) { if (!i) { return t } const n = this.project(t, e); const o = this.getSize().divideBy(2); const s = new N(n.subtract(o), n.add(o)); const a = this._getBoundsOffset(s, i, e); return a.round().equals([0, 0]) ? t : this.unproject(n.add(a), e) }, _limitOffset (t, e) { if (!e) { return t } const i = this.getPixelBounds(); const n = new N(i.min.add(t), i.max.add(t)); return t.add(this._getBoundsOffset(n, e)) }, _getBoundsOffset (t, e, i) { const n = R(this.project(e.getNorthEast(), i), this.project(e.getSouthWest(), i)); const o = n.min.subtract(t.min); const s = n.max.subtract(t.max); const a = this._rebound(o.x, -s.x); const r = this._rebound(o.y, -s.y); return new B(a, r) }, _rebound (t, e) { return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e)) }, _limitZoom (t) { const e = this.getMinZoom(); const i = this.getMaxZoom(); const n = vt ? this.options.zoomSnap : 1; return n && (t = Math.round(t / n) * n), Math.max(e, Math.min(i, t)) }, _onPanTransitionStep () { this.fire('move') }, _onPanTransitionEnd () { ye(this._mapPane, 'leaflet-pan-anim'), this.fire('moveend') }, _tryAnimatedPan (t, e) { const i = this._getCenterOffset(t)._trunc(); return !(!0 !== (e && e.animate) && !this.getSize().contains(i)) && (this.panBy(i, e), !0) }, _createAnimProxy () { const t = this._proxy = de('div', 'leaflet-proxy leaflet-zoom-animated'); this._panes.mapPane.appendChild(t), this.on('zoomanim', function (t) { const e = re; const i = this._proxy.style[e]; Te(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), i === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd() }, this), this.on('load moveend', this._animMoveEnd, this), this._on('unload', this._destroyAnimProxy, this) }, _destroyAnimProxy () { _e(this._proxy), this.off('load moveend', this._animMoveEnd, this), delete this._proxy }, _animMoveEnd () { const t = this.getCenter(); const e = this.getZoom(); Te(this._proxy, this.project(t, e), this.getZoomScale(e, 1)) }, _catchTransitionEnd (t) { this._animatingZoom && t.propertyName.includes('transform') && this._onZoomTransitionEnd() }, _nothingToAnimate () { return !this._container.getElementsByClassName('leaflet-zoom-animated').length }, _tryAnimatedZoom (t, e, i) { if (this._animatingZoom) { return !0 } if (i = i || {}, !this._zoomAnimated || !1 === i.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) { return !1 } const n = this.getZoomScale(e); const o = this._getCenterOffset(t)._divideBy(1 - 1 / n); return !(!0 !== i.animate && !this.getSize().contains(o)) && (z(function () { this._moveStart(!0, !1)._animateZoom(t, e, !0) }, this), !0) }, _animateZoom (t, e, i, n) { this._mapPane && (i && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, ve(this._mapPane, 'leaflet-zoom-anim')), this.fire('zoomanim', { center: t, zoom: e, noUpdate: n }), setTimeout(s(this._onZoomTransitionEnd, this), 250)) }, _onZoomTransitionEnd () { this._animatingZoom && (this._mapPane && ye(this._mapPane, 'leaflet-zoom-anim'), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), z(function () { this._moveEnd(!0) }, this)) } }); function oi (t, e) { return new ni(t, e) } const si = S.extend({ options: { position: 'topright' }, initialize (t) { p(this, t) }, getPosition () { return this.options.position }, setPosition (t) { const e = this._map; return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this }, getContainer () { return this._container }, addTo (t) { this.remove(), this._map = t; const e = this._container = this.onAdd(t); const i = this.getPosition(); const n = t._controlCorners[i]; return ve(e, 'leaflet-control'), i.includes('bottom') ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this._map.on('unload', this.remove, this), this }, remove () { return this._map ? (_e(this._container), this.onRemove && this.onRemove(this._map), this._map.off('unload', this.remove, this), this._map = null, this) : this }, _refocusOnMap (t) { this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus() } }); const ai = function (t) { return new si(t) }; ni.include({ addControl (t) { return t.addTo(this), this }, removeControl (t) { return t.remove(), this }, _initControlPos () { const t = this._controlCorners = {}; const e = 'leaflet-'; const i = this._controlContainer = de('div', e + 'control-container', this._container); function n (n, o) { const s = e + n + ' ' + e + o; t[n + o] = de('div', s, i) }n('top', 'left'), n('top', 'right'), n('bottom', 'left'), n('bottom', 'right') }, _clearControlPos () { for (const t in this._controlCorners) { _e(this._controlCorners[t]) }_e(this._controlContainer), delete this._controlCorners, delete this._controlContainer } }); const ri = si.extend({ options: { collapsed: !0, position: 'topright', autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, sortFunction (t, e, i, n) { return i < n ? -1 : n < i ? 1 : 0 } }, initialize (t, e, i) { for (var n in p(this, i), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, t) { this._addLayer(t[n], n) } for (n in e) { this._addLayer(e[n], n, !0) } }, onAdd (t) { this._initLayout(), this._update(), this._map = t, t.on('zoomend', this._checkDisabledLayers, this); for (let e = 0; e < this._layers.length; e++) { this._layers[e].layer.on('add remove', this._onLayerChange, this) } return this._container }, addTo (t) { return si.prototype.addTo.call(this, t), this._expandIfNotCollapsed() }, onRemove () { this._map.off('zoomend', this._checkDisabledLayers, this); for (let t = 0; t < this._layers.length; t++) { this._layers[t].layer.off('add remove', this._onLayerChange, this) } }, addBaseLayer (t, e) { return this._addLayer(t, e), this._map ? this._update() : this }, addOverlay (t, e) { return this._addLayer(t, e, !0), this._map ? this._update() : this }, removeLayer (t) { t.off('add remove', this._onLayerChange, this); const e = this._getLayer(r(t)); return e && this._layers.splice(this._layers.indexOf(e), 1), this._map ? this._update() : this }, expand () { ve(this._container, 'leaflet-control-layers-expanded'), this._section.style.height = null; const t = this._map.getSize().y - (this._container.offsetTop + 50); return t < this._section.clientHeight ? (ve(this._section, 'leaflet-control-layers-scrollbar'), this._section.style.height = t + 'px') : ye(this._section, 'leaflet-control-layers-scrollbar'), this._checkDisabledLayers(), this }, collapse () { return ye(this._container, 'leaflet-control-layers-expanded'), this }, _initLayout () { const t = 'leaflet-control-layers'; const e = this._container = de('div', t); const i = this.options.collapsed; e.setAttribute('aria-haspopup', !0), Fe(e), He(e); const n = this._section = de('section', t + '-list'); i && (this._map.on('click', this.collapse, this), ot || Oe(e, { mouseenter: this.expand, mouseleave: this.collapse }, this)); const o = this._layersLink = de('a', t + '-toggle', e); o.href = '#', o.title = 'Layers', Pt ? (Oe(o, 'click', Ue), Oe(o, 'click', this.expand, this)) : Oe(o, 'focus', this.expand, this), i || this.expand(), this._baseLayersList = de('div', t + '-base', n), this._separator = de('div', t + '-separator', n), this._overlaysList = de('div', t + '-overlays', n), e.appendChild(n) }, _getLayer (t) { for (let e = 0; e < this._layers.length; e++) { if (this._layers[e] && r(this._layers[e].layer) === t) { return this._layers[e] } } }, _addLayer (t, e, i) { this._map && t.on('add remove', this._onLayerChange, this), this._layers.push({ layer: t, name: e, overlay: i }), this.options.sortLayers && this._layers.sort(s(function (t, e) { return this.options.sortFunction(t.layer, e.layer, t.name, e.name) }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed() }, _update () { if (!this._container) { return this } pe(this._baseLayersList), pe(this._overlaysList), this._layerControlInputs = []; let t; let e; let i; let n; let o = 0; for (i = 0; i < this._layers.length; i++) { n = this._layers[i], this._addItem(n), e = e || n.overlay, t = t || !n.overlay, o += n.overlay ? 0 : 1 } return this.options.hideSingleBase && (t = t && o > 1, this._baseLayersList.style.display = t ? '' : 'none'), this._separator.style.display = e && t ? '' : 'none', this }, _onLayerChange (t) { this._handlingClick || this._update(); const e = this._getLayer(r(t.target)); const i = e.overlay ? t.type === 'add' ? 'overlayadd' : 'overlayremove' : t.type === 'add' ? 'baselayerchange' : null; i && this._map.fire(i, e) }, _createRadioElement (t, e) { const i = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : '') + '/>'; const n = document.createElement('div'); return n.innerHTML = i, n.firstChild }, _addItem (t) { let e; const i = document.createElement('label'); const n = this._map.hasLayer(t.layer); t.overlay ? (e = document.createElement('input'), e.type = 'checkbox', e.className = 'leaflet-control-layers-selector', e.defaultChecked = n) : e = this._createRadioElement('leaflet-base-layers_' + r(this), n), this._layerControlInputs.push(e), e.layerId = r(t.layer), Oe(e, 'click', this._onInputClick, this); const o = document.createElement('span'); o.innerHTML = ' ' + t.name; const s = document.createElement('div'); i.appendChild(s), s.appendChild(e), s.appendChild(o); const a = t.overlay ? this._overlaysList : this._baseLayersList; return a.appendChild(i), this._checkDisabledLayers(), i }, _onInputClick () { let t; let e; const i = this._layerControlInputs; const n = []; const o = []; this._handlingClick = !0; for (var s = i.length - 1; s >= 0; s--) { t = i[s], e = this._getLayer(t.layerId).layer, t.checked ? n.push(e) : t.checked || o.push(e) } for (s = 0; s < o.length; s++) { this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]) } for (s = 0; s < n.length; s++) { this._map.hasLayer(n[s]) || this._map.addLayer(n[s]) } this._handlingClick = !1, this._refocusOnMap() }, _checkDisabledLayers () { for (var t, e, i = this._layerControlInputs, n = this._map.getZoom(), o = i.length - 1; o >= 0; o--) { t = i[o], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && n < e.options.minZoom || void 0 !== e.options.maxZoom && n > e.options.maxZoom } }, _expandIfNotCollapsed () { return this._map && !this.options.collapsed && this.expand(), this }, _expand () { return this.expand() }, _collapse () { return this.collapse() } }); const hi = function (t, e, i) { return new ri(t, e, i) }; const li = si.extend({ options: { position: 'topleft', zoomInText: '+', zoomInTitle: 'Zoom in', zoomOutText: '&#x2212;', zoomOutTitle: 'Zoom out' }, onAdd (t) { const e = 'leaflet-control-zoom'; const i = de('div', e + ' leaflet-bar'); const n = this.options; return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, e + '-in', i, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, e + '-out', i, this._zoomOut), this._updateDisabled(), t.on('zoomend zoomlevelschange', this._updateDisabled, this), i }, onRemove (t) { t.off('zoomend zoomlevelschange', this._updateDisabled, this) }, disable () { return this._disabled = !0, this._updateDisabled(), this }, enable () { return this._disabled = !1, this._updateDisabled(), this }, _zoomIn (t) { !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _zoomOut (t) { !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _createButton (t, e, i, n, o) { const s = de('a', i, n); return s.innerHTML = t, s.href = '#', s.title = e, s.setAttribute('role', 'button'), s.setAttribute('aria-label', e), Fe(s), Oe(s, 'click', Ue), Oe(s, 'click', o, this), Oe(s, 'click', this._refocusOnMap, this), s }, _updateDisabled () { const t = this._map; const e = 'leaflet-disabled'; ye(this._zoomInButton, e), ye(this._zoomOutButton, e), (this._disabled || t._zoom === t.getMinZoom()) && ve(this._zoomOutButton, e), (this._disabled || t._zoom === t.getMaxZoom()) && ve(this._zoomInButton, e) } }); ni.mergeOptions({ zoomControl: !0 }), ni.addInitHook(function () { this.options.zoomControl && (this.zoomControl = new li(), this.addControl(this.zoomControl)) }); const ui = function (t) { return new li(t) }; const ci = si.extend({ options: { position: 'bottomleft', maxWidth: 100, metric: !0, imperial: !0 }, onAdd (t) { const e = 'leaflet-control-scale'; const i = de('div', e); const n = this.options; return this._addScales(n, e + '-line', i), t.on(n.updateWhenIdle ? 'moveend' : 'move', this._update, this), t.whenReady(this._update, this), i }, onRemove (t) { t.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this) }, _addScales (t, e, i) { t.metric && (this._mScale = de('div', e, i)), t.imperial && (this._iScale = de('div', e, i)) }, _update () { const t = this._map; const e = t.getSize().y / 2; const i = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e])); this._updateScales(i) }, _updateScales (t) { this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t) }, _updateMetric (t) { const e = this._getRoundNum(t); const i = e < 1e3 ? e + ' m' : e / 1e3 + ' km'; this._updateScale(this._mScale, i, e / t) }, _updateImperial (t) { let e; let i; let n; const o = 3.2808399 * t; o > 5280 ? (e = o / 5280, i = this._getRoundNum(e), this._updateScale(this._iScale, i + ' mi', i / e)) : (n = this._getRoundNum(o), this._updateScale(this._iScale, n + ' ft', n / o)) }, _updateScale (t, e, i) { t.style.width = Math.round(this.options.maxWidth * i) + 'px', t.innerHTML = e }, _getRoundNum (t) { const e = Math.pow(10, (Math.floor(t) + '').length - 1); let i = t / e; return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i } }); const di = function (t) { return new ci(t) }; const _i = si.extend({ options: { position: 'bottomright', prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>' }, initialize (t) { p(this, t), this._attributions = {} }, onAdd (t) { for (const e in t.attributionControl = this, this._container = de('div', 'leaflet-control-attribution'), Fe(this._container), t._layers) { t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution()) } return this._update(), this._container }, setPrefix (t) { return this.options.prefix = t, this._update(), this }, addAttribution (t) { return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : this }, removeAttribution (t) { return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : this }, _update () { if (this._map) { const t = []; for (const e in this._attributions) { this._attributions[e] && t.push(e) } const i = []; this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(', ')), this._container.innerHTML = i.join(' | ') } } }); ni.mergeOptions({ attributionControl: !0 }), ni.addInitHook(function () { this.options.attributionControl && (new _i()).addTo(this) }); const pi = function (t) { return new _i(t) }; si.Layers = ri, si.Zoom = li, si.Scale = ci, si.Attribution = _i, ai.layers = hi, ai.zoom = ui, ai.scale = di, ai.attribution = pi; const mi = S.extend({ initialize (t) { this._map = t }, enable () { return this._enabled ? this : (this._enabled = !0, this.addHooks(), this) }, disable () { return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this }, enabled () { return !!this._enabled } }); mi.addTo = function (t, e) { return t.addHandler(e, this), this }; let fi; const gi = { Events: Z }; const vi = Pt ? 'touchstart mousedown' : 'mousedown'; const yi = { mousedown: 'mouseup', touchstart: 'touchend', pointerdown: 'touchend', MSPointerDown: 'touchend' }; const xi = { mousedown: 'mousemove', touchstart: 'touchmove', pointerdown: 'touchmove', MSPointerDown: 'touchmove' }; var wi = I.extend({ options: { clickTolerance: 3 }, initialize (t, e, i, n) { p(this, n), this._element = t, this._dragStartTarget = e || t, this._preventOutline = i }, enable () { this._enabled || (Oe(this._dragStartTarget, vi, this._onDown, this), this._enabled = !0) }, disable () { this._enabled && (wi._dragging === this && this.finishDrag(), Re(this._dragStartTarget, vi, this._onDown, this), this._enabled = !1, this._moved = !1) }, _onDown (t) { if (!t._simulated && this._enabled && (this._moved = !1, !ge(this._element, 'leaflet-zoom-anim') && !(wi._dragging || t.shiftKey || t.which !== 1 && t.button !== 1 && !t.touches) && (wi._dragging = this, this._preventOutline && Ee(this._element), ke(), ie(), !this._moving))) { this.fire('down'); const e = t.touches ? t.touches[0] : t; const i = Ie(this._element); this._startPoint = new B(e.clientX, e.clientY), this._parentScale = Be(i), Oe(document, xi[t.type], this._onMove, this), Oe(document, yi[t.type], this._onUp, this) } }, _onMove (t) { if (!t._simulated && this._enabled) { if (t.touches && t.touches.length > 1) { this._moved = !0 } else { const e = t.touches && t.touches.length === 1 ? t.touches[0] : t; const i = new B(e.clientX, e.clientY)._subtract(this._startPoint); (i.x || i.y) && (Math.abs(i.x) + Math.abs(i.y) < this.options.clickTolerance || (i.x /= this._parentScale.x, i.y /= this._parentScale.y, Ve(t), this._moved || (this.fire('dragstart'), this._moved = !0, this._startPos = ze(this._element).subtract(i), ve(document.body, 'leaflet-dragging'), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), ve(this._lastTarget, 'leaflet-drag-target')), this._newPos = this._startPos.add(i), this._moving = !0, C(this._animRequest), this._lastEvent = t, this._animRequest = z(this._updatePosition, this, !0))) } } }, _updatePosition () { const t = { originalEvent: this._lastEvent }; this.fire('predrag', t), Me(this._element, this._newPos), this.fire('drag', t) }, _onUp (t) { !t._simulated && this._enabled && this.finishDrag() }, finishDrag () { for (const t in ye(document.body, 'leaflet-dragging'), this._lastTarget && (ye(this._lastTarget, 'leaflet-drag-target'), this._lastTarget = null), xi) { Re(document, xi[t], this._onMove, this), Re(document, yi[t], this._onUp, this) }Se(), ne(), this._moved && this._moving && (C(this._animRequest), this.fire('dragend', { distance: this._newPos.distanceTo(this._startPos) })), this._moving = !1, wi._dragging = !1 } }); function bi (t, e) { if (!e || !t.length) { return t.slice() } const i = e * e; return t = zi(t, i), t = Ti(t, i), t } function Li (t, e, i) { return Math.sqrt(Zi(t, e, i, !0)) } function Pi (t, e, i) { return Zi(t, e, i) } function Ti (t, e) { const i = t.length; const n = typeof Uint8Array !== void 0 + '' ? Uint8Array : Array; const o = new n(i); o[0] = o[i - 1] = 1, Mi(t, o, e, 0, i - 1); let s; const a = []; for (s = 0; s < i; s++) { o[s] && a.push(t[s]) } return a } function Mi (t, e, i, n, o) { let s; let a; let r; let h = 0; for (a = n + 1; a <= o - 1; a++) { r = Zi(t[a], t[n], t[o], !0), r > h && (s = a, h = r) }h > i && (e[s] = 1, Mi(t, e, i, n, s), Mi(t, e, i, s, o)) } function zi (t, e) { for (var i = [t[0]], n = 1, o = 0, s = t.length; n < s; n++) { Ei(t[n], t[o]) > e && (i.push(t[n]), o = n) } return o < s - 1 && i.push(t[s - 1]), i } function Ci (t, e, i, n, o) { let s; let a; let r; let h = n ? fi : Si(t, i); let l = Si(e, i); fi = l; while (1) { if (!(h | l)) { return [t, e] } if (h & l) { return !1 } s = h || l, a = ki(t, e, s, i, o), r = Si(a, i), s === h ? (t = a, h = r) : (e = a, l = r) } } function ki (t, e, i, n, o) { let s; let a; const r = e.x - t.x; const h = e.y - t.y; const l = n.min; const u = n.max; return 8 & i ? (s = t.x + r * (u.y - t.y) / h, a = u.y) : 4 & i ? (s = t.x + r * (l.y - t.y) / h, a = l.y) : 2 & i ? (s = u.x, a = t.y + h * (u.x - t.x) / r) : 1 & i && (s = l.x, a = t.y + h * (l.x - t.x) / r), new B(s, a, o) } function Si (t, e) { let i = 0; return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i } function Ei (t, e) { const i = e.x - t.x; const n = e.y - t.y; return i * i + n * n } function Zi (t, e, i, n) { let o; let s = e.x; let a = e.y; let r = i.x - s; let h = i.y - a; const l = r * r + h * h; return l > 0 && (o = ((t.x - s) * r + (t.y - a) * h) / l, o > 1 ? (s = i.x, a = i.y) : o > 0 && (s += r * o, a += h * o)), r = t.x - s, h = t.y - a, n ? r * r + h * h : new B(s, a) } function Ii (t) { return !v(t[0]) || typeof t[0][0] !== 'object' && typeof t[0][0] !== 'undefined' } function Bi (t) { return console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.'), Ii(t) } const Ai = (Object.freeze || Object)({ simplify: bi, pointToSegmentDistance: Li, closestPointOnSegment: Pi, clipSegment: Ci, _getEdgeIntersection: ki, _getBitCode: Si, _sqClosestPointOnSegment: Zi, isFlat: Ii, _flat: Bi }); function Oi (t, e, i) { let n; let o; let s; let a; let r; let h; let l; let u; let c; const d = [1, 4, 2, 8]; for (o = 0, l = t.length; o < l; o++) { t[o]._code = Si(t[o], e) } for (a = 0; a < 4; a++) { for (u = d[a], n = [], o = 0, l = t.length, s = l - 1; o < l; s = o++) { r = t[o], h = t[s], r._code & u ? h._code & u || (c = ki(h, r, u, e, i), c._code = Si(c, e), n.push(c)) : (h._code & u && (c = ki(h, r, u, e, i), c._code = Si(c, e), n.push(c)), n.push(r)) }t = n } return t } const Ni = (Object.freeze || Object)({ clipPolygon: Oi }); const Ri = { project (t) { return new B(t.lng, t.lat) }, unproject (t) { return new W(t.y, t.x) }, bounds: new N([-180, -90], [180, 90]) }; const ji = { R: 6378137, R_MINOR: 6356752.314245179, bounds: new N([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project (t) { const e = Math.PI / 180; const i = this.R; let n = t.lat * e; const o = this.R_MINOR / i; const s = Math.sqrt(1 - o * o); const a = s * Math.sin(n); const r = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - a) / (1 + a), s / 2); return n = -i * Math.log(Math.max(r, 1e-10)), new B(t.lng * e * i, n) }, unproject (t) { for (var e, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), a = Math.exp(-t.y / n), r = Math.PI / 2 - 2 * Math.atan(a), h = 0, l = 0.1; h < 15 && Math.abs(l) > 1e-7; h++) { e = s * Math.sin(r), e = Math.pow((1 - e) / (1 + e), s / 2), l = Math.PI / 2 - 2 * Math.atan(a * e) - r, r += l } return new W(r * i, t.x * i / n) } }; const Di = (Object.freeze || Object)({ LonLat: Ri, Mercator: ji, SphericalMercator: q }); const Wi = n({}, V, { code: 'EPSG:3395', projection: ji, transformation: (function () { const t = 0.5 / (Math.PI * ji.R); return K(t, 0.5, -t, 0.5) }()) }); const Hi = n({}, V, { code: 'EPSG:4326', projection: Ri, transformation: K(1 / 180, 1, -1 / 180, 0.5) }); const Fi = n({}, F, { projection: Ri, transformation: K(1, 0, -1, 0), scale (t) { return Math.pow(2, t) }, zoom (t) { return Math.log(t) / Math.LN2 }, distance (t, e) { const i = e.lng - t.lng; const n = e.lat - t.lat; return Math.sqrt(i * i + n * n) }, infinite: !0 }); F.Earth = V, F.EPSG3395 = Wi, F.EPSG3857 = Y, F.EPSG900913 = $, F.EPSG4326 = Hi, F.Simple = Fi; const Vi = I.extend({ options: { pane: 'overlayPane', attribution: null, bubblingMouseEvents: !0 }, addTo (t) { return t.addLayer(this), this }, remove () { return this.removeFrom(this._map || this._mapToAdd) }, removeFrom (t) { return t && t.removeLayer(this), this }, getPane (t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane) }, addInteractiveTarget (t) { return this._map._targets[r(t)] = this, this }, removeInteractiveTarget (t) { return delete this._map._targets[r(t)], this }, getAttribution () { return this.options.attribution }, _layerAdd (t) { const e = t.target; if (e.hasLayer(this)) { if (this._map = e, this._zoomAnimated = e._zoomAnimated, this.getEvents) { const i = this.getEvents(); e.on(i, this), this.once('remove', function () { e.off(i, this) }, this) } this.onAdd(e), this.getAttribution && e.attributionControl && e.attributionControl.addAttribution(this.getAttribution()), this.fire('add'), e.fire('layeradd', { layer: this }) } } }); ni.include({ addLayer (t) { if (!t._layerAdd) { throw new Error('The provided object is not a Layer.') } const e = r(t); return this._layers[e] ? this : (this._layers[e] = t, t._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t), this) }, removeLayer (t) { const e = r(t); return this._layers[e] ? (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[e], this._loaded && (this.fire('layerremove', { layer: t }), t.fire('remove')), t._map = t._mapToAdd = null, this) : this }, hasLayer (t) { return !!t && r(t) in this._layers }, eachLayer (t, e) { for (const i in this._layers) { t.call(e, this._layers[i]) } return this }, _addLayers (t) { t = t ? v(t) ? t : [t] : []; for (let e = 0, i = t.length; e < i; e++) { this.addLayer(t[e]) } }, _addZoomLimit (t) { !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[r(t)] = t, this._updateZoomLevels()) }, _removeZoomLimit (t) { const e = r(t); this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()) }, _updateZoomLevels () { let t = 1 / 0; let e = -1 / 0; const i = this._getZoomSpan(); for (const n in this._zoomBoundLayers) { const o = this._zoomBoundLayers[n].options; t = void 0 === o.minZoom ? t : Math.min(t, o.minZoom), e = void 0 === o.maxZoom ? e : Math.max(e, o.maxZoom) } this._layersMaxZoom = e === -1 / 0 ? void 0 : e, this._layersMinZoom = t === 1 / 0 ? void 0 : t, i !== this._getZoomSpan() && this.fire('zoomlevelschange'), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom) } }); const Ui = Vi.extend({ initialize (t, e) { let i, n; if (p(this, e), this._layers = {}, t) { for (i = 0, n = t.length; i < n; i++) { this.addLayer(t[i]) } } }, addLayer (t) { const e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this }, removeLayer (t) { const e = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this }, hasLayer (t) { return !!t && (t in this._layers || this.getLayerId(t) in this._layers) }, clearLayers () { return this.eachLayer(this.removeLayer, this) }, invoke (t) { let e; let i; const n = Array.prototype.slice.call(arguments, 1); for (e in this._layers) { i = this._layers[e], i[t] && i[t].apply(i, n) } return this }, onAdd (t) { this.eachLayer(t.addLayer, t) }, onRemove (t) { this.eachLayer(t.removeLayer, t) }, eachLayer (t, e) { for (const i in this._layers) { t.call(e, this._layers[i]) } return this }, getLayer (t) { return this._layers[t] }, getLayers () { const t = []; return this.eachLayer(t.push, t), t }, setZIndex (t) { return this.invoke('setZIndex', t) }, getLayerId (t) { return r(t) } }); const qi = function (t, e) { return new Ui(t, e) }; const Gi = Ui.extend({ addLayer (t) { return this.hasLayer(t) ? this : (t.addEventParent(this), Ui.prototype.addLayer.call(this, t), this.fire('layeradd', { layer: t })) }, removeLayer (t) { return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), Ui.prototype.removeLayer.call(this, t), this.fire('layerremove', { layer: t })) : this }, setStyle (t) { return this.invoke('setStyle', t) }, bringToFront () { return this.invoke('bringToFront') }, bringToBack () { return this.invoke('bringToBack') }, getBounds () { const t = new j(); for (const e in this._layers) { const i = this._layers[e]; t.extend(i.getBounds ? i.getBounds() : i.getLatLng()) } return t } }); const Ki = function (t) { return new Gi(t) }; const Yi = S.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0] }, initialize (t) { p(this, t) }, createIcon (t) { return this._createIcon('icon', t) }, createShadow (t) { return this._createIcon('shadow', t) }, _createIcon (t, e) { const i = this._getIconUrl(t); if (!i) { if (t === 'icon') { throw new Error('iconUrl not set in Icon options (see the docs).') } return null } const n = this._createImg(i, e && e.tagName === 'IMG' ? e : null); return this._setIconStyles(n, t), n }, _setIconStyles (t, e) { const i = this.options; let n = i[e + 'Size']; typeof n === 'number' && (n = [n, n]); const o = O(n); const s = O(e === 'shadow' && i.shadowAnchor || i.iconAnchor || o && o.divideBy(2, !0)); t.className = 'leaflet-marker-' + e + ' ' + (i.className || ''), s && (t.style.marginLeft = -s.x + 'px', t.style.marginTop = -s.y + 'px'), o && (t.style.width = o.x + 'px', t.style.height = o.y + 'px') }, _createImg (t, e) { return e = e || document.createElement('img'), e.src = t, e }, _getIconUrl (t) { return zt && this.options[t + 'RetinaUrl'] || this.options[t + 'Url'] } }); function $i (t) { return new Yi(t) } var Ji = Yi.extend({ options: { iconUrl: 'marker-icon.png', iconRetinaUrl: 'marker-icon-2x.png', shadowUrl: 'marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl (t) { return Ji.imagePath || (Ji.imagePath = this._detectIconPath()), (this.options.imagePath || Ji.imagePath) + Yi.prototype._getIconUrl.call(this, t) }, _detectIconPath () { const t = de('div', 'leaflet-default-icon-path', document.body); let e = ce(t, 'background-image') || ce(t, 'backgroundImage'); return document.body.removeChild(t), e = e === null || e.indexOf('url') !== 0 ? '' : e.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, ''), e } }); const Xi = mi.extend({ initialize (t) { this._marker = t }, addHooks () { const t = this._marker._icon; this._draggable || (this._draggable = new wi(t, t, !0)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), ve(t, 'leaflet-marker-draggable') }, removeHooks () { this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && ye(this._marker._icon, 'leaflet-marker-draggable') }, moved () { return this._draggable && this._draggable._moved }, _adjustPan (t) { const e = this._marker; const i = e._map; const n = this._marker.options.autoPanSpeed; const o = this._marker.options.autoPanPadding; const s = ze(e._icon); const a = i.getPixelBounds(); const r = i.getPixelOrigin(); const h = R(a.min._subtract(r).add(o), a.max._subtract(r).subtract(o)); if (!h.contains(s)) { const l = O((Math.max(h.max.x, s.x) - h.max.x) / (a.max.x - h.max.x) - (Math.min(h.min.x, s.x) - h.min.x) / (a.min.x - h.min.x), (Math.max(h.max.y, s.y) - h.max.y) / (a.max.y - h.max.y) - (Math.min(h.min.y, s.y) - h.min.y) / (a.min.y - h.min.y)).multiplyBy(n); i.panBy(l, { animate: !1 }), this._draggable._newPos._add(l), this._draggable._startPos._add(l), Me(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = z(this._adjustPan.bind(this, t)) } }, _onDragStart () { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire('movestart').fire('dragstart') }, _onPreDrag (t) { this._marker.options.autoPan && (C(this._panRequest), this._panRequest = z(this._adjustPan.bind(this, t))) }, _onDrag (t) { const e = this._marker; const i = e._shadow; const n = ze(e._icon); const o = e._map.layerPointToLatLng(n); i && Me(i, n), e._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, e.fire('move', t).fire('drag', t) }, _onDragEnd (t) { C(this._panRequest), delete this._oldLatLng, this._marker.fire('moveend').fire('dragend', t) } }); const Qi = Vi.extend({ options: { icon: new Ji(), interactive: !0, keyboard: !0, title: '', alt: '', zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: 'markerPane', shadowPane: 'shadowPane', bubblingMouseEvents: !1, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize (t, e) { p(this, e), this._latlng = H(t) }, onAdd (t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on('zoomanim', this._animateZoom, this), this._initIcon(), this.update() }, onRemove (t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off('zoomanim', this._animateZoom, this), this._removeIcon(), this._removeShadow() }, getEvents () { return { zoom: this.update, viewreset: this.update } }, getLatLng () { return this._latlng }, setLatLng (t) { const e = this._latlng; return this._latlng = H(t), this.update(), this.fire('move', { oldLatLng: e, latlng: this._latlng }) }, setZIndexOffset (t) { return this.options.zIndexOffset = t, this.update() }, getIcon () { return this.options.icon }, setIcon (t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this }, getElement () { return this._icon }, update () { if (this._icon && this._map) { const t = this._map.latLngToLayerPoint(this._latlng).round(); this._setPos(t) } return this }, _initIcon () { const t = this.options; const e = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'); const i = t.icon.createIcon(this._icon); let n = !1; i !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (i.title = t.title), i.tagName === 'IMG' && (i.alt = t.alt || '')), ve(i, e), t.keyboard && (i.tabIndex = '0'), this._icon = i, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }); const o = t.icon.createShadow(this._shadow); let s = !1; o !== this._shadow && (this._removeShadow(), s = !0), o && (ve(o, e), o.alt = ''), this._shadow = o, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), o && s && this.getPane(t.shadowPane).appendChild(this._shadow) }, _removeIcon () { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), _e(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null }, _removeShadow () { this._shadow && _e(this._shadow), this._shadow = null }, _setPos (t) { this._icon && Me(this._icon, t), this._shadow && Me(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex() }, _updateZIndex (t) { this._icon && (this._icon.style.zIndex = this._zIndex + t) }, _animateZoom (t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(e) }, _initInteraction () { if (this.options.interactive && (ve(this._icon, 'leaflet-interactive'), this.addInteractiveTarget(this._icon), Xi)) { let t = this.options.draggable; this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Xi(this), t && this.dragging.enable() } }, setOpacity (t) { return this.options.opacity = t, this._map && this._updateOpacity(), this }, _updateOpacity () { const t = this.options.opacity; this._icon && be(this._icon, t), this._shadow && be(this._shadow, t) }, _bringToFront () { this._updateZIndex(this.options.riseOffset) }, _resetZIndex () { this._updateZIndex(0) }, _getPopupAnchor () { return this.options.icon.options.popupAnchor }, _getTooltipAnchor () { return this.options.icon.options.tooltipAnchor } }); function tn (t, e) { return new Qi(t, e) } const en = Vi.extend({ options: { stroke: !0, color: '#3388ff', weight: 3, opacity: 1, lineCap: 'round', lineJoin: 'round', dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: 0.2, fillRule: 'evenodd', interactive: !0, bubblingMouseEvents: !0 }, beforeAdd (t) { this._renderer = t.getRenderer(this) }, onAdd () { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this) }, onRemove () { this._renderer._removePath(this) }, redraw () { return this._map && this._renderer._updatePath(this), this }, setStyle (t) { return p(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && t.hasOwnProperty('weight') && this._updateBounds()), this }, bringToFront () { return this._renderer && this._renderer._bringToFront(this), this }, bringToBack () { return this._renderer && this._renderer._bringToBack(this), this }, getElement () { return this._path }, _reset () { this._project(), this._update() }, _clickTolerance () { return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance } }); const nn = en.extend({ options: { fill: !0, radius: 10 }, initialize (t, e) { p(this, e), this._latlng = H(t), this._radius = this.options.radius }, setLatLng (t) { const e = this._latlng; return this._latlng = H(t), this.redraw(), this.fire('move', { oldLatLng: e, latlng: this._latlng }) }, getLatLng () { return this._latlng }, setRadius (t) { return this.options.radius = this._radius = t, this.redraw() }, getRadius () { return this._radius }, setStyle (t) { const e = t && t.radius || this._radius; return en.prototype.setStyle.call(this, t), this.setRadius(e), this }, _project () { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds() }, _updateBounds () { const t = this._radius; const e = this._radiusY || t; const i = this._clickTolerance(); const n = [t + i, e + i]; this._pxBounds = new N(this._point.subtract(n), this._point.add(n)) }, _update () { this._map && this._updatePath() }, _updatePath () { this._renderer._updateCircle(this) }, _empty () { return this._radius && !this._renderer._bounds.intersects(this._pxBounds) }, _containsPoint (t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance() } }); function on (t, e) { return new nn(t, e) } const sn = nn.extend({ initialize (t, e, i) { if (typeof e === 'number' && (e = n({}, i, { radius: e })), p(this, e), this._latlng = H(t), isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN') } this._mRadius = this.options.radius }, setRadius (t) { return this._mRadius = t, this.redraw() }, getRadius () { return this._mRadius }, getBounds () { const t = [this._radius, this._radiusY || this._radius]; return new j(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))) }, setStyle: en.prototype.setStyle, _project () { const t = this._latlng.lng; const e = this._latlng.lat; const i = this._map; const n = i.options.crs; if (n.distance === V.distance) { const o = Math.PI / 180; const s = this._mRadius / V.R / o; const a = i.project([e + s, t]); const r = i.project([e - s, t]); const h = a.add(r).divideBy(2); const l = i.unproject(h).lat; let u = Math.acos((Math.cos(s * o) - Math.sin(e * o) * Math.sin(l * o)) / (Math.cos(e * o) * Math.cos(l * o))) / o; (isNaN(u) || u === 0) && (u = s / Math.cos(Math.PI / 180 * e)), this._point = h.subtract(i.getPixelOrigin()), this._radius = isNaN(u) ? 0 : h.x - i.project([l, t - u]).x, this._radiusY = h.y - a.y } else { const c = n.unproject(n.project(this._latlng).subtract([this._mRadius, 0])); this._point = i.latLngToLayerPoint(this._latlng), this._radius = this._point.x - i.latLngToLayerPoint(c).x } this._updateBounds() } }); function an (t, e, i) { return new sn(t, e, i) } const rn = en.extend({ options: { smoothFactor: 1, noClip: !1 }, initialize (t, e) { p(this, e), this._setLatLngs(t) }, getLatLngs () { return this._latlngs }, setLatLngs (t) { return this._setLatLngs(t), this.redraw() }, isEmpty () { return !this._latlngs.length }, closestLayerPoint (t) { for (var e, i, n = 1 / 0, o = null, s = Zi, a = 0, r = this._parts.length; a < r; a++) { for (let h = this._parts[a], l = 1, u = h.length; l < u; l++) { e = h[l - 1], i = h[l]; const c = s(t, e, i, !0); c < n && (n = c, o = s(t, e, i)) } } return o && (o.distance = Math.sqrt(n)), o }, getCenter () { if (!this._map) { throw new Error('Must add layer to map before using getCenter()') } let t; let e; let i; let n; let o; let s; let a; const r = this._rings[0]; const h = r.length; if (!h) { return null } for (t = 0, e = 0; t < h - 1; t++) { e += r[t].distanceTo(r[t + 1]) / 2 } if (e === 0) { return this._map.layerPointToLatLng(r[0]) } for (t = 0, n = 0; t < h - 1; t++) { if (o = r[t], s = r[t + 1], i = o.distanceTo(s), n += i, n > e) { return a = (n - e) / i, this._map.layerPointToLatLng([s.x - a * (s.x - o.x), s.y - a * (s.y - o.y)]) } } }, getBounds () { return this._bounds }, addLatLng (t, e) { return e = e || this._defaultShape(), t = H(t), e.push(t), this._bounds.extend(t), this.redraw() }, _setLatLngs (t) { this._bounds = new j(), this._latlngs = this._convertLatLngs(t) }, _defaultShape () { return Ii(this._latlngs) ? this._latlngs : this._latlngs[0] }, _convertLatLngs (t) { for (var e = [], i = Ii(t), n = 0, o = t.length; n < o; n++) { i ? (e[n] = H(t[n]), this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]) } return e }, _project () { const t = new N(); this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds()) }, _updateBounds () { const t = this._clickTolerance(); const e = new B(t, t); this._pxBounds = new N([this._rawPxBounds.min.subtract(e), this._rawPxBounds.max.add(e)]) }, _projectLatlngs (t, e, i) { let n; let o; const s = t[0] instanceof W; const a = t.length; if (s) { for (o = [], n = 0; n < a; n++) { o[n] = this._map.latLngToLayerPoint(t[n]), i.extend(o[n]) }e.push(o) } else { for (n = 0; n < a; n++) { this._projectLatlngs(t[n], e, i) } } }, _clipPoints () { const t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) { if (this.options.noClip) { this._parts = this._rings } else { let e; let i; let n; let o; let s; let a; let r; const h = this._parts; for (e = 0, n = 0, o = this._rings.length; e < o; e++) { for (r = this._rings[e], i = 0, s = r.length; i < s - 1; i++) { a = Ci(r[i], r[i + 1], t, i, !0), a && (h[n] = h[n] || [], h[n].push(a[0]), a[1] === r[i + 1] && i !== s - 2 || (h[n].push(a[1]), n++)) } } } } }, _simplifyPoints () { for (let t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++) { t[i] = bi(t[i], e) } }, _update () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()) }, _updatePath () { this._renderer._updatePoly(this) }, _containsPoint (t, e) { let i; let n; let o; let s; let a; let r; const h = this._clickTolerance(); if (!this._pxBounds || !this._pxBounds.contains(t)) { return !1 } for (i = 0, s = this._parts.length; i < s; i++) { for (r = this._parts[i], n = 0, a = r.length, o = a - 1; n < a; o = n++) { if ((e || n !== 0) && Li(t, r[o], r[n]) <= h) { return !0 } } } return !1 } }); function hn (t, e) { return new rn(t, e) }rn._flat = Bi; const ln = rn.extend({ options: { fill: !0 }, isEmpty () { return !this._latlngs.length || !this._latlngs[0].length }, getCenter () { if (!this._map) { throw new Error('Must add layer to map before using getCenter()') } let t; let e; let i; let n; let o; let s; let a; let r; let h; const l = this._rings[0]; const u = l.length; if (!u) { return null } for (s = a = r = 0, t = 0, e = u - 1; t < u; e = t++) { i = l[t], n = l[e], o = i.y * n.x - n.y * i.x, a += (i.x + n.x) * o, r += (i.y + n.y) * o, s += 3 * o } return h = s === 0 ? l[0] : [a / s, r / s], this._map.layerPointToLatLng(h) }, _convertLatLngs (t) { const e = rn.prototype._convertLatLngs.call(this, t); const i = e.length; return i >= 2 && e[0] instanceof W && e[0].equals(e[i - 1]) && e.pop(), e }, _setLatLngs (t) { rn.prototype._setLatLngs.call(this, t), Ii(this._latlngs) && (this._latlngs = [this._latlngs]) }, _defaultShape () { return Ii(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0] }, _clipPoints () { let t = this._renderer._bounds; const e = this.options.weight; const i = new B(e, e); if (t = new N(t.min.subtract(i), t.max.add(i)), this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) { if (this.options.noClip) { this._parts = this._rings } else { for (var n, o = 0, s = this._rings.length; o < s; o++) { n = Oi(this._rings[o], t, !0), n.length && this._parts.push(n) } } } }, _updatePath () { this._renderer._updatePoly(this, !0) }, _containsPoint (t) { let e; let i; let n; let o; let s; let a; let r; let h; let l = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) { return !1 } for (o = 0, r = this._parts.length; o < r; o++) { for (e = this._parts[o], s = 0, h = e.length, a = h - 1; s < h; a = s++) { i = e[s], n = e[a], i.y > t.y !== n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (l = !l) } } return l || rn.prototype._containsPoint.call(this, t, !0) } }); function un (t, e) { return new ln(t, e) } const cn = Gi.extend({ initialize (t, e) { p(this, e), this._layers = {}, t && this.addData(t) }, addData (t) { let e; let i; let n; const o = v(t) ? t : t.features; if (o) { for (e = 0, i = o.length; e < i; e++) { n = o[e], (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(n) } return this } const s = this.options; if (s.filter && !s.filter(t)) { return this } const a = dn(t, s); return a ? (a.feature = yn(t), a.defaultOptions = a.options, this.resetStyle(a), s.onEachFeature && s.onEachFeature(t, a), this.addLayer(a)) : this }, resetStyle (t) { return void 0 === t ? this.eachLayer(this.resetStyle, this) : (t.options = n({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this) }, setStyle (t) { return this.eachLayer(function (e) { this._setLayerStyle(e, t) }, this) }, _setLayerStyle (t, e) { t.setStyle && (typeof e === 'function' && (e = e(t.feature)), t.setStyle(e)) } }); function dn (t, e) { let i; let n; let o; let s; const a = t.type === 'Feature' ? t.geometry : t; const r = a ? a.coordinates : null; const h = []; const l = e && e.pointToLayer; const u = e && e.coordsToLatLng || pn; if (!r && !a) { return null } switch (a.type) { case 'Point':return i = u(r), _n(l, t, i, e); case 'MultiPoint':for (o = 0, s = r.length; o < s; o++) { i = u(r[o]), h.push(_n(l, t, i, e)) } return new Gi(h); case 'LineString':case 'MultiLineString':return n = mn(r, a.type === 'LineString' ? 0 : 1, u), new rn(n, e); case 'Polygon':case 'MultiPolygon':return n = mn(r, a.type === 'Polygon' ? 1 : 2, u), new ln(n, e); case 'GeometryCollection':for (o = 0, s = a.geometries.length; o < s; o++) { const c = dn({ geometry: a.geometries[o], type: 'Feature', properties: t.properties }, e); c && h.push(c) } return new Gi(h); default:throw new Error('Invalid GeoJSON object.') } } function _n (t, e, i, n) { return t ? t(e, i) : new Qi(i, n && n.markersInheritOptions && n) } function pn (t) { return new W(t[1], t[0], t[2]) } function mn (t, e, i) { for (var n, o = [], s = 0, a = t.length; s < a; s++) { n = e ? mn(t[s], e - 1, i) : (i || pn)(t[s]), o.push(n) } return o } function fn (t, e) { return e = typeof e === 'number' ? e : 6, void 0 !== t.alt ? [c(t.lng, e), c(t.lat, e), c(t.alt, e)] : [c(t.lng, e), c(t.lat, e)] } function gn (t, e, i, n) { for (var o = [], s = 0, a = t.length; s < a; s++) { o.push(e ? gn(t[s], e - 1, i, n) : fn(t[s], n)) } return !e && i && o.push(o[0]), o } function vn (t, e) { return t.feature ? n({}, t.feature, { geometry: e }) : yn(e) } function yn (t) { return t.type === 'Feature' || t.type === 'FeatureCollection' ? t : { type: 'Feature', properties: {}, geometry: t } } const xn = { toGeoJSON (t) { return vn(this, { type: 'Point', coordinates: fn(this.getLatLng(), t) }) } }; function wn (t, e) { return new cn(t, e) }Qi.include(xn), sn.include(xn), nn.include(xn), rn.include({ toGeoJSON (t) { const e = !Ii(this._latlngs); const i = gn(this._latlngs, e ? 1 : 0, !1, t); return vn(this, { type: (e ? 'Multi' : '') + 'LineString', coordinates: i }) } }), ln.include({ toGeoJSON (t) { const e = !Ii(this._latlngs); const i = e && !Ii(this._latlngs[0]); let n = gn(this._latlngs, i ? 2 : e ? 1 : 0, !0, t); return e || (n = [n]), vn(this, { type: (i ? 'Multi' : '') + 'Polygon', coordinates: n }) } }), Ui.include({ toMultiPoint (t) { const e = []; return this.eachLayer(function (i) { e.push(i.toGeoJSON(t).geometry.coordinates) }), vn(this, { type: 'MultiPoint', coordinates: e }) }, toGeoJSON (t) { const e = this.feature && this.feature.geometry && this.feature.geometry.type; if (e === 'MultiPoint') { return this.toMultiPoint(t) } const i = e === 'GeometryCollection'; const n = []; return this.eachLayer(function (e) { if (e.toGeoJSON) { const o = e.toGeoJSON(t); if (i) { n.push(o.geometry) } else { const s = yn(o); s.type === 'FeatureCollection' ? n.push.apply(n, s.features) : n.push(s) } } }), i ? vn(this, { geometries: n, type: 'GeometryCollection' }) : { type: 'FeatureCollection', features: n } } }); const bn = wn; const Ln = Vi.extend({ options: { opacity: 1, alt: '', interactive: !1, crossOrigin: !1, errorOverlayUrl: '', zIndex: 1, className: '' }, initialize (t, e, i) { this._url = t, this._bounds = D(e), p(this, i) }, onAdd () { this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (ve(this._image, 'leaflet-interactive'), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset() }, onRemove () { _e(this._image), this.options.interactive && this.removeInteractiveTarget(this._image) }, setOpacity (t) { return this.options.opacity = t, this._image && this._updateOpacity(), this }, setStyle (t) { return t.opacity && this.setOpacity(t.opacity), this }, bringToFront () { return this._map && me(this._image), this }, bringToBack () { return this._map && fe(this._image), this }, setUrl (t) { return this._url = t, this._image && (this._image.src = t), this }, setBounds (t) { return this._bounds = D(t), this._map && this._reset(), this }, getEvents () { const t = { zoom: this._reset, viewreset: this._reset }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, setZIndex (t) { return this.options.zIndex = t, this._updateZIndex(), this }, getBounds () { return this._bounds }, getElement () { return this._image }, _initImage () { const t = this._url.tagName === 'IMG'; const e = this._image = t ? this._url : de('img'); ve(e, 'leaflet-image-layer'), this._zoomAnimated && ve(e, 'leaflet-zoom-animated'), this.options.className && ve(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onload = s(this.fire, this, 'load'), e.onerror = s(this._overlayOnError, this, 'error'), (this.options.crossOrigin || this.options.crossOrigin === '') && (e.crossOrigin = !0 === this.options.crossOrigin ? '' : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = e.src : (e.src = this._url, e.alt = this.options.alt) }, _animateZoom (t) { const e = this._map.getZoomScale(t.zoom); const i = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min; Te(this._image, i, e) }, _reset () { const t = this._image; const e = new N(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())); const i = e.getSize(); Me(t, e.min), t.style.width = i.x + 'px', t.style.height = i.y + 'px' }, _updateOpacity () { be(this._image, this.options.opacity) }, _updateZIndex () { this._image && void 0 !== this.options.zIndex && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex) }, _overlayOnError () { this.fire('error'); const t = this.options.errorOverlayUrl; t && this._url !== t && (this._url = t, this._image.src = t) } }); const Pn = function (t, e, i) { return new Ln(t, e, i) }; const Tn = Ln.extend({ options: { autoplay: !0, loop: !0, keepAspectRatio: !0 }, _initImage () { const t = this._url.tagName === 'VIDEO'; const e = this._image = t ? this._url : de('video'); if (ve(e, 'leaflet-image-layer'), this._zoomAnimated && ve(e, 'leaflet-zoom-animated'), this.options.className && ve(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onloadeddata = s(this.fire, this, 'load'), t) { for (var i = e.getElementsByTagName('source'), n = [], o = 0; o < i.length; o++) { n.push(i[o].src) } this._url = i.length > 0 ? n : [e.src] } else { v(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && e.style.hasOwnProperty('objectFit') && (e.style.objectFit = 'fill'), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop; for (let a = 0; a < this._url.length; a++) { const r = de('source'); r.src = this._url[a], e.appendChild(r) } } } }); function Mn (t, e, i) { return new Tn(t, e, i) } const zn = Ln.extend({ _initImage () { const t = this._image = this._url; ve(t, 'leaflet-image-layer'), this._zoomAnimated && ve(t, 'leaflet-zoom-animated'), this.options.className && ve(t, this.options.className), t.onselectstart = u, t.onmousemove = u } }); function Cn (t, e, i) { return new zn(t, e, i) } const kn = Vi.extend({ options: { offset: [0, 7], className: '', pane: 'popupPane' }, initialize (t, e) { p(this, t), this._source = e }, onAdd (t) { this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && be(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && be(this._container, 1), this.bringToFront() }, onRemove (t) { t._fadeAnimated ? (be(this._container, 0), this._removeTimeout = setTimeout(s(_e, void 0, this._container), 200)) : _e(this._container) }, getLatLng () { return this._latlng }, setLatLng (t) { return this._latlng = H(t), this._map && (this._updatePosition(), this._adjustPan()), this }, getContent () { return this._content }, setContent (t) { return this._content = t, this.update(), this }, getElement () { return this._container }, update () { this._map && (this._container.style.visibility = 'hidden', this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = '', this._adjustPan()) }, getEvents () { const t = { zoom: this._updatePosition, viewreset: this._updatePosition }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, isOpen () { return !!this._map && this._map.hasLayer(this) }, bringToFront () { return this._map && me(this._container), this }, bringToBack () { return this._map && fe(this._container), this }, _prepareOpen (t, e, i) { if (e instanceof Vi || (i = e, e = t), e instanceof Gi) { for (const n in t._layers) { e = t._layers[n]; break } } if (!i) { if (e.getCenter) { i = e.getCenter() } else { if (!e.getLatLng) { throw new Error('Unable to get source layer LatLng.') } i = e.getLatLng() } } return this._source = e, this.update(), i }, _updateContent () { if (this._content) { const t = this._contentNode; const e = typeof this._content === 'function' ? this._content(this._source || this) : this._content; if (typeof e === 'string') { t.innerHTML = e } else { while (t.hasChildNodes()) { t.removeChild(t.firstChild) }t.appendChild(e) } this.fire('contentupdate') } }, _updatePosition () { if (this._map) { const t = this._map.latLngToLayerPoint(this._latlng); let e = O(this.options.offset); const i = this._getAnchor(); this._zoomAnimated ? Me(this._container, t.add(i)) : e = e.add(t).add(i); const n = this._containerBottom = -e.y; const o = this._containerLeft = -Math.round(this._containerWidth / 2) + e.x; this._container.style.bottom = n + 'px', this._container.style.left = o + 'px' } }, _getAnchor () { return [0, 0] } }); const Sn = kn.extend({ options: { maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: !0, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: !1, closeButton: !0, autoClose: !0, closeOnEscapeKey: !0, className: '' }, openOn (t) { return t.openPopup(this), this }, onAdd (t) { kn.prototype.onAdd.call(this, t), t.fire('popupopen', { popup: this }), this._source && (this._source.fire('popupopen', { popup: this }, !0), this._source instanceof en || this._source.on('preclick', We)) }, onRemove (t) { kn.prototype.onRemove.call(this, t), t.fire('popupclose', { popup: this }), this._source && (this._source.fire('popupclose', { popup: this }, !0), this._source instanceof en || this._source.off('preclick', We)) }, getEvents () { const t = kn.prototype.getEvents.call(this); return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t }, _close () { this._map && this._map.closePopup(this) }, _initLayout () { const t = 'leaflet-popup'; const e = this._container = de('div', t + ' ' + (this.options.className || '') + ' leaflet-zoom-animated'); const i = this._wrapper = de('div', t + '-content-wrapper', e); if (this._contentNode = de('div', t + '-content', i), Fe(i), He(this._contentNode), Oe(i, 'contextmenu', We), this._tipContainer = de('div', t + '-tip-container', e), this._tip = de('div', t + '-tip', this._tipContainer), this.options.closeButton) { const n = this._closeButton = de('a', t + '-close-button', e); n.href = '#close', n.innerHTML = '&#215;', Oe(n, 'click', this._onCloseButtonClick, this) } }, _updateLayout () { const t = this._contentNode; const e = t.style; e.width = '', e.whiteSpace = 'nowrap'; let i = t.offsetWidth; i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + 'px', e.whiteSpace = '', e.height = ''; const n = t.offsetHeight; const o = this.options.maxHeight; const s = 'leaflet-popup-scrolled'; o && n > o ? (e.height = o + 'px', ve(t, s)) : ye(t, s), this._containerWidth = this._container.offsetWidth }, _animateZoom (t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); const i = this._getAnchor(); Me(this._container, e.add(i)) }, _adjustPan () { if (this.options.autoPan) { this._map._panAnim && this._map._panAnim.stop(); const t = this._map; const e = parseInt(ce(this._container, 'marginBottom'), 10) || 0; const i = this._container.offsetHeight + e; const n = this._containerWidth; const o = new B(this._containerLeft, -i - this._containerBottom); o._add(ze(this._container)); const s = t.layerPointToContainerPoint(o); const a = O(this.options.autoPanPadding); const r = O(this.options.autoPanPaddingTopLeft || a); const h = O(this.options.autoPanPaddingBottomRight || a); const l = t.getSize(); let u = 0; let c = 0; s.x + n + h.x > l.x && (u = s.x + n - l.x + h.x), s.x - u - r.x < 0 && (u = s.x - r.x), s.y + i + h.y > l.y && (c = s.y + i - l.y + h.y), s.y - c - r.y < 0 && (c = s.y - r.y), (u || c) && t.fire('autopanstart').panBy([u, c]) } }, _onCloseButtonClick (t) { this._close(), Ue(t) }, _getAnchor () { return O(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]) } }); const En = function (t, e) { return new Sn(t, e) }; ni.mergeOptions({ closePopupOnClick: !0 }), ni.include({ openPopup (t, e, i) { return t instanceof Sn || (t = new Sn(i).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t)) }, closePopup (t) { return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this } }), Vi.include({ bindPopup (t, e) { return t instanceof Sn ? (p(t, e), this._popup = t, t._source = this) : (this._popup && !e || (this._popup = new Sn(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !0), this }, unbindPopup () { return this._popup && (this.off({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !1, this._popup = null), this }, openPopup (t, e) { return this._popup && this._map && (e = this._popup._prepareOpen(this, t, e), this._map.openPopup(this._popup, e)), this }, closePopup () { return this._popup && this._popup._close(), this }, togglePopup (t) { return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this }, isPopupOpen () { return !!this._popup && this._popup.isOpen() }, setPopupContent (t) { return this._popup && this._popup.setContent(t), this }, getPopup () { return this._popup }, _openPopup (t) { const e = t.layer || t.target; this._popup && this._map && (Ue(t), e instanceof en ? this.openPopup(t.layer || t.target, t.latlng) : this._map.hasLayer(this._popup) && this._popup._source === e ? this.closePopup() : this.openPopup(e, t.latlng)) }, _movePopup (t) { this._popup.setLatLng(t.latlng) }, _onKeyPress (t) { t.originalEvent.keyCode === 13 && this._openPopup(t) } }); const Zn = kn.extend({ options: { pane: 'tooltipPane', offset: [0, 0], direction: 'auto', permanent: !1, sticky: !1, interactive: !1, opacity: 0.9 }, onAdd (t) { kn.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire('tooltipopen', { tooltip: this }), this._source && this._source.fire('tooltipopen', { tooltip: this }, !0) }, onRemove (t) { kn.prototype.onRemove.call(this, t), t.fire('tooltipclose', { tooltip: this }), this._source && this._source.fire('tooltipclose', { tooltip: this }, !0) }, getEvents () { const t = kn.prototype.getEvents.call(this); return Pt && !this.options.permanent && (t.preclick = this._close), t }, _close () { this._map && this._map.closeTooltip(this) }, _initLayout () { const t = 'leaflet-tooltip'; const e = t + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'); this._contentNode = this._container = de('div', e) }, _updateLayout () {}, _adjustPan () {}, _setPosition (t) { const e = this._map; const i = this._container; const n = e.latLngToContainerPoint(e.getCenter()); const o = e.layerPointToContainerPoint(t); let s = this.options.direction; const a = i.offsetWidth; const r = i.offsetHeight; const h = O(this.options.offset); const l = this._getAnchor(); s === 'top' ? t = t.add(O(-a / 2 + h.x, -r + h.y + l.y, !0)) : s === 'bottom' ? t = t.subtract(O(a / 2 - h.x, -h.y, !0)) : s === 'center' ? t = t.subtract(O(a / 2 + h.x, r / 2 - l.y + h.y, !0)) : s === 'right' || s === 'auto' && o.x < n.x ? (s = 'right', t = t.add(O(h.x + l.x, l.y - r / 2 + h.y, !0))) : (s = 'left', t = t.subtract(O(a + l.x - h.x, r / 2 - l.y - h.y, !0))), ye(i, 'leaflet-tooltip-right'), ye(i, 'leaflet-tooltip-left'), ye(i, 'leaflet-tooltip-top'), ye(i, 'leaflet-tooltip-bottom'), ve(i, 'leaflet-tooltip-' + s), Me(i, t) }, _updatePosition () { const t = this._map.latLngToLayerPoint(this._latlng); this._setPosition(t) }, setOpacity (t) { this.options.opacity = t, this._container && be(this._container, t) }, _animateZoom (t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); this._setPosition(e) }, _getAnchor () { return O(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]) } }); const In = function (t, e) { return new Zn(t, e) }; ni.include({ openTooltip (t, e, i) { return t instanceof Zn || (t = new Zn(i).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : this.addLayer(t) }, closeTooltip (t) { return t && this.removeLayer(t), this } }), Vi.include({ bindTooltip (t, e) { return t instanceof Zn ? (p(t, e), this._tooltip = t, t._source = this) : (this._tooltip && !e || (this._tooltip = new Zn(e, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this }, unbindTooltip () { return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this }, _initTooltipInteractions (t) { if (t || !this._tooltipHandlersAdded) { const e = t ? 'off' : 'on'; const i = { remove: this.closeTooltip, move: this._moveTooltip }; this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip, i.mouseout = this.closeTooltip, this._tooltip.options.sticky && (i.mousemove = this._moveTooltip), Pt && (i.click = this._openTooltip)), this[e](i), this._tooltipHandlersAdded = !t } }, openTooltip (t, e) { return this._tooltip && this._map && (e = this._tooltip._prepareOpen(this, t, e), this._map.openTooltip(this._tooltip, e), this._tooltip.options.interactive && this._tooltip._container && (ve(this._tooltip._container, 'leaflet-clickable'), this.addInteractiveTarget(this._tooltip._container))), this }, closeTooltip () { return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (ye(this._tooltip._container, 'leaflet-clickable'), this.removeInteractiveTarget(this._tooltip._container))), this }, toggleTooltip (t) { return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this }, isTooltipOpen () { return this._tooltip.isOpen() }, setTooltipContent (t) { return this._tooltip && this._tooltip.setContent(t), this }, getTooltip () { return this._tooltip }, _openTooltip (t) { const e = t.layer || t.target; this._tooltip && this._map && this.openTooltip(e, this._tooltip.options.sticky ? t.latlng : void 0) }, _moveTooltip (t) { let e; let i; let n = t.latlng; this._tooltip.options.sticky && t.originalEvent && (e = this._map.mouseEventToContainerPoint(t.originalEvent), i = this._map.containerPointToLayerPoint(e), n = this._map.layerPointToLatLng(i)), this._tooltip.setLatLng(n) } }); const Bn = Yi.extend({ options: { iconSize: [12, 12], html: !1, bgPos: null, className: 'leaflet-div-icon' }, createIcon (t) { const e = t && t.tagName === 'DIV' ? t : document.createElement('div'); const i = this.options; if (i.html instanceof Element ? (pe(e), e.appendChild(i.html)) : e.innerHTML = !1 !== i.html ? i.html : '', i.bgPos) { const n = O(i.bgPos); e.style.backgroundPosition = -n.x + 'px ' + -n.y + 'px' } return this._setIconStyles(e, 'icon'), e }, createShadow () { return null } }); function An (t) { return new Bn(t) }Yi.Default = Ji; const On = Vi.extend({ options: { tileSize: 256, opacity: 1, updateWhenIdle: yt, updateWhenZooming: !0, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: !1, pane: 'tilePane', className: '', keepBuffer: 2 }, initialize (t) { p(this, t) }, onAdd () { this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update() }, beforeAdd (t) { t._addZoomLimit(this) }, onRemove (t) { this._removeAllTiles(), _e(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0 }, bringToFront () { return this._map && (me(this._container), this._setAutoZIndex(Math.max)), this }, bringToBack () { return this._map && (fe(this._container), this._setAutoZIndex(Math.min)), this }, getContainer () { return this._container }, setOpacity (t) { return this.options.opacity = t, this._updateOpacity(), this }, setZIndex (t) { return this.options.zIndex = t, this._updateZIndex(), this }, isLoading () { return this._loading }, redraw () { return this._map && (this._removeAllTiles(), this._update()), this }, getEvents () { const t = { viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd }; return this.options.updateWhenIdle || (this._onMove || (this._onMove = h(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, createTile () { return document.createElement('div') }, getTileSize () { const t = this.options.tileSize; return t instanceof B ? t : new B(t, t) }, _updateZIndex () { this._container && void 0 !== this.options.zIndex && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex) }, _setAutoZIndex (t) { for (var e, i = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = i.length; o < s; o++) { e = i[o].style.zIndex, i[o] !== this._container && e && (n = t(n, +e)) }isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex()) }, _updateOpacity () { if (this._map && !et) { be(this._container, this.options.opacity); const t = +new Date(); let e = !1; let i = !1; for (const n in this._tiles) { const o = this._tiles[n]; if (o.current && o.loaded) { const s = Math.min(1, (t - o.loaded) / 200); be(o.el, s), s < 1 ? e = !0 : (o.active ? i = !0 : this._onOpaqueTile(o), o.active = !0) } }i && !this._noPrune && this._pruneTiles(), e && (C(this._fadeFrame), this._fadeFrame = z(this._updateOpacity, this)) } }, _onOpaqueTile: u, _initContainer () { this._container || (this._container = de('div', 'leaflet-layer ' + (this.options.className || '')), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container)) }, _updateLevels () { const t = this._tileZoom; const e = this.options.maxZoom; if (void 0 !== t) { for (const i in this._levels) { this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i), this._onUpdateLevel(i)) : (_e(this._levels[i].el), this._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this._levels[i]) } let n = this._levels[t]; const o = this._map; return n || (n = this._levels[t] = {}, n.el = de('div', 'leaflet-tile-container leaflet-zoom-animated', this._container), n.el.style.zIndex = e, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), u(n.el.offsetWidth), this._onCreateLevel(n)), this._level = n, n } }, _onUpdateLevel: u, _onRemoveLevel: u, _onCreateLevel: u, _pruneTiles () { if (this._map) { let t; let e; const i = this._map.getZoom(); if (i > this.options.maxZoom || i < this.options.minZoom) { this._removeAllTiles() } else { for (t in this._tiles) { e = this._tiles[t], e.retain = e.current } for (t in this._tiles) { if (e = this._tiles[t], e.current && !e.active) { const n = e.coords; this._retainParent(n.x, n.y, n.z, n.z - 5) || this._retainChildren(n.x, n.y, n.z, n.z + 2) } } for (t in this._tiles) { this._tiles[t].retain || this._removeTile(t) } } } }, _removeTilesAtZoom (t) { for (const e in this._tiles) { this._tiles[e].coords.z === t && this._removeTile(e) } }, _removeAllTiles () { for (const t in this._tiles) { this._removeTile(t) } }, _invalidateAll () { for (const t in this._levels) { _e(this._levels[t].el), this._onRemoveLevel(t), delete this._levels[t] } this._removeAllTiles(), this._tileZoom = void 0 }, _retainParent (t, e, i, n) { const o = Math.floor(t / 2); const s = Math.floor(e / 2); const a = i - 1; const r = new B(+o, +s); r.z = +a; const h = this._tileCoordsToKey(r); const l = this._tiles[h]; return l && l.active ? (l.retain = !0, !0) : (l && l.loaded && (l.retain = !0), a > n && this._retainParent(o, s, a, n)) }, _retainChildren (t, e, i, n) { for (let o = 2 * t; o < 2 * t + 2; o++) { for (let s = 2 * e; s < 2 * e + 2; s++) { const a = new B(o, s); a.z = i + 1; const r = this._tileCoordsToKey(a); const h = this._tiles[r]; h && h.active ? h.retain = !0 : (h && h.loaded && (h.retain = !0), i + 1 < n && this._retainChildren(o, s, i + 1, n)) } } }, _resetView (t) { const e = t && (t.pinch || t.flyTo); this._setView(this._map.getCenter(), this._map.getZoom(), e, e) }, _animateZoom (t) { this._setView(t.center, t.zoom, !0, t.noUpdate) }, _clampZoom (t) { const e = this.options; return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t }, _setView (t, e, i, n) { let o = this._clampZoom(Math.round(e)); (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom) && (o = void 0); const s = this.options.updateWhenZooming && o !== this._tileZoom; n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), i || this._pruneTiles(), this._noPrune = !!i), this._setZoomTransforms(t, e) }, _setZoomTransforms (t, e) { for (const i in this._levels) { this._setZoomTransform(this._levels[i], t, e) } }, _setZoomTransform (t, e, i) { const n = this._map.getZoomScale(i, t.zoom); const o = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round(); vt ? Te(t.el, o, n) : Me(t.el, o) }, _resetGrid () { const t = this._map; const e = t.options.crs; const i = this._tileSize = this.getTileSize(); const n = this._tileZoom; const o = this._map.getPixelWorldBounds(this._tileZoom); o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x), Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x), Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)] }, _onMoveEnd () { this._map && !this._map._animatingZoom && this._update() }, _getTiledPixelBounds (t) { const e = this._map; const i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(); const n = e.getZoomScale(i, this._tileZoom); const o = e.project(t, this._tileZoom).floor(); const s = e.getSize().divideBy(2 * n); return new N(o.subtract(s), o.add(s)) }, _update (t) { const e = this._map; if (e) { const i = this._clampZoom(e.getZoom()); if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) { const n = this._getTiledPixelBounds(t); const o = this._pxBoundsToTileRange(n); const s = o.getCenter(); const a = []; const r = this.options.keepBuffer; const h = new N(o.getBottomLeft().subtract([r, -r]), o.getTopRight().add([r, -r])); if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) { throw new TypeError('Attempted to load an infinite number of tiles') } for (const l in this._tiles) { const u = this._tiles[l].coords; u.z === this._tileZoom && h.contains(new B(u.x, u.y)) || (this._tiles[l].current = !1) } if (Math.abs(i - this._tileZoom) > 1) { this._setView(t, i) } else { for (let c = o.min.y; c <= o.max.y; c++) { for (var d = o.min.x; d <= o.max.x; d++) { const _ = new B(d, c); if (_.z = this._tileZoom, this._isValidTile(_)) { const p = this._tiles[this._tileCoordsToKey(_)]; p ? p.current = !0 : a.push(_) } } } if (a.sort(function (t, e) { return t.distanceTo(s) - e.distanceTo(s) }), a.length !== 0) { this._loading || (this._loading = !0, this.fire('loading')); const m = document.createDocumentFragment(); for (d = 0; d < a.length; d++) { this._addTile(a[d], m) } this._level.el.appendChild(m) } } } } }, _isValidTile (t) { const e = this._map.options.crs; if (!e.infinite) { const i = this._globalTileRange; if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y)) { return !1 } } if (!this.options.bounds) { return !0 } const n = this._tileCoordsToBounds(t); return D(this.options.bounds).overlaps(n) }, _keyToBounds (t) { return this._tileCoordsToBounds(this._keyToTileCoords(t)) }, _tileCoordsToNwSe (t) { const e = this._map; const i = this.getTileSize(); const n = t.scaleBy(i); const o = n.add(i); const s = e.unproject(n, t.z); const a = e.unproject(o, t.z); return [s, a] }, _tileCoordsToBounds (t) { const e = this._tileCoordsToNwSe(t); let i = new j(e[0], e[1]); return this.options.noWrap || (i = this._map.wrapLatLngBounds(i)), i }, _tileCoordsToKey (t) { return t.x + ':' + t.y + ':' + t.z }, _keyToTileCoords (t) { const e = t.split(':'); const i = new B(+e[0], +e[1]); return i.z = +e[2], i }, _removeTile (t) { const e = this._tiles[t]; e && (_e(e.el), delete this._tiles[t], this.fire('tileunload', { tile: e.el, coords: this._keyToTileCoords(t) })) }, _initTile (t) { ve(t, 'leaflet-tile'); const e = this.getTileSize(); t.style.width = e.x + 'px', t.style.height = e.y + 'px', t.onselectstart = u, t.onmousemove = u, et && this.options.opacity < 1 && be(t, this.options.opacity), ot && !st && (t.style.WebkitBackfaceVisibility = 'hidden') }, _addTile (t, e) { const i = this._getTilePos(t); const n = this._tileCoordsToKey(t); const o = this.createTile(this._wrapCoords(t), s(this._tileReady, this, t)); this._initTile(o), this.createTile.length < 2 && z(s(this._tileReady, this, t, null, o)), Me(o, i), this._tiles[n] = { el: o, coords: t, current: !0 }, e.appendChild(o), this.fire('tileloadstart', { tile: o, coords: t }) }, _tileReady (t, e, i) { e && this.fire('tileerror', { error: e, tile: i, coords: t }); const n = this._tileCoordsToKey(t); i = this._tiles[n], i && (i.loaded = +new Date(), this._map._fadeAnimated ? (be(i.el, 0), C(this._fadeFrame), this._fadeFrame = z(this._updateOpacity, this)) : (i.active = !0, this._pruneTiles()), e || (ve(i.el, 'leaflet-tile-loaded'), this.fire('tileload', { tile: i.el, coords: t })), this._noTilesToLoad() && (this._loading = !1, this.fire('load'), et || !this._map._fadeAnimated ? z(this._pruneTiles, this) : setTimeout(s(this._pruneTiles, this), 250))) }, _getTilePos (t) { return t.scaleBy(this.getTileSize()).subtract(this._level.origin) }, _wrapCoords (t) { const e = new B(this._wrapX ? l(t.x, this._wrapX) : t.x, this._wrapY ? l(t.y, this._wrapY) : t.y); return e.z = t.z, e }, _pxBoundsToTileRange (t) { const e = this.getTileSize(); return new N(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1])) }, _noTilesToLoad () { for (const t in this._tiles) { if (!this._tiles[t].loaded) { return !1 } } return !0 } }); function Nn (t) { return new On(t) } const Rn = On.extend({ options: { minZoom: 0, maxZoom: 18, subdomains: 'abc', errorTileUrl: '', zoomOffset: 0, tms: !1, zoomReverse: !1, detectRetina: !1, crossOrigin: !1 }, initialize (t, e) { this._url = t, e = p(this, e), e.detectRetina && zt && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom++) : (e.zoomOffset++, e.maxZoom--), e.minZoom = Math.max(0, e.minZoom)), typeof e.subdomains === 'string' && (e.subdomains = e.subdomains.split('')), ot || this.on('tileunload', this._onTileRemove) }, setUrl (t, e) { return this._url === t && void 0 === e && (e = !0), this._url = t, e || this.redraw(), this }, createTile (t, e) { const i = document.createElement('img'); return Oe(i, 'load', s(this._tileOnLoad, this, e, i)), Oe(i, 'error', s(this._tileOnError, this, e, i)), (this.options.crossOrigin || this.options.crossOrigin === '') && (i.crossOrigin = !0 === this.options.crossOrigin ? '' : this.options.crossOrigin), i.alt = '', i.setAttribute('role', 'presentation'), i.src = this.getTileUrl(t), i }, getTileUrl (t) { const e = { r: zt ? '@2x' : '', s: this._getSubdomain(t), x: t.x, y: t.y, z: this._getZoomForUrl() }; if (this._map && !this._map.options.crs.infinite) { const i = this._globalTileRange.max.y - t.y; this.options.tms && (e.y = i), e['-y'] = i } return g(this._url, n(e, this.options)) }, _tileOnLoad (t, e) { et ? setTimeout(s(t, this, null, e), 0) : t(null, e) }, _tileOnError (t, e, i) { const n = this.options.errorTileUrl; n && e.getAttribute('src') !== n && (e.src = n), t(i, e) }, _onTileRemove (t) { t.tile.onload = null }, _getZoomForUrl () { let t = this._tileZoom; const e = this.options.maxZoom; const i = this.options.zoomReverse; const n = this.options.zoomOffset; return i && (t = e - t), t + n }, _getSubdomain (t) { const e = Math.abs(t.x + t.y) % this.options.subdomains.length; return this.options.subdomains[e] }, _abortLoading () { let t, e; for (t in this._tiles) { this._tiles[t].coords.z !== this._tileZoom && (e = this._tiles[t].el, e.onload = u, e.onerror = u, e.complete || (e.src = x, _e(e), delete this._tiles[t])) } }, _removeTile (t) { const e = this._tiles[t]; if (e) { return rt || e.el.setAttribute('src', x), On.prototype._removeTile.call(this, t) } }, _tileReady (t, e, i) { if (this._map && (!i || i.getAttribute('src') !== x)) { return On.prototype._tileReady.call(this, t, e, i) } } }); function jn (t, e) { return new Rn(t, e) } const Dn = Rn.extend({ defaultWmsParams: { service: 'WMS', request: 'GetMap', layers: '', styles: '', format: 'image/jpeg', transparent: !1, version: '1.1.1' }, options: { crs: null, uppercase: !1 }, initialize (t, e) { this._url = t; const i = n({}, this.defaultWmsParams); for (const o in e) { o in this.options || (i[o] = e[o]) }e = p(this, e); const s = e.detectRetina && zt ? 2 : 1; const a = this.getTileSize(); i.width = a.x * s, i.height = a.y * s, this.wmsParams = i }, onAdd (t) { this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version); const e = this._wmsVersion >= 1.3 ? 'crs' : 'srs'; this.wmsParams[e] = this._crs.code, Rn.prototype.onAdd.call(this, t) }, getTileUrl (t) { const e = this._tileCoordsToNwSe(t); const i = this._crs; const n = R(i.project(e[0]), i.project(e[1])); const o = n.min; const s = n.max; const a = (this._wmsVersion >= 1.3 && this._crs === Hi ? [o.y, o.x, s.y, s.x] : [o.x, o.y, s.x, s.y]).join(','); const r = Rn.prototype.getTileUrl.call(this, t); return r + m(this.wmsParams, r, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + a }, setParams (t, e) { return n(this.wmsParams, t), e || this.redraw(), this } }); function Wn (t, e) { return new Dn(t, e) }Rn.WMS = Dn, jn.wms = Wn; const Hn = Vi.extend({ options: { padding: 0.1, tolerance: 0 }, initialize (t) { p(this, t), r(this), this._layers = this._layers || {} }, onAdd () { this._container || (this._initContainer(), this._zoomAnimated && ve(this._container, 'leaflet-zoom-animated')), this.getPane().appendChild(this._container), this._update(), this.on('update', this._updatePaths, this) }, onRemove () { this.off('update', this._updatePaths, this), this._destroyContainer() }, getEvents () { const t = { viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd }; return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t }, _onAnimZoom (t) { this._updateTransform(t.center, t.zoom) }, _onZoom () { this._updateTransform(this._map.getCenter(), this._map.getZoom()) }, _updateTransform (t, e) { const i = this._map.getZoomScale(e, this._zoom); const n = ze(this._container); const o = this._map.getSize().multiplyBy(0.5 + this.options.padding); const s = this._map.project(this._center, e); const a = this._map.project(t, e); const r = a.subtract(s); const h = o.multiplyBy(-i).add(n).add(o).subtract(r); vt ? Te(this._container, h, i) : Me(this._container, h) }, _reset () { for (const t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) { this._layers[t]._reset() } }, _onZoomEnd () { for (const t in this._layers) { this._layers[t]._project() } }, _updatePaths () { for (const t in this._layers) { this._layers[t]._update() } }, _update () { const t = this.options.padding; const e = this._map.getSize(); const i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round(); this._bounds = new N(i, i.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom() } }); const Fn = Hn.extend({ getEvents () { const t = Hn.prototype.getEvents.call(this); return t.viewprereset = this._onViewPreReset, t }, _onViewPreReset () { this._postponeUpdatePaths = !0 }, onAdd () { Hn.prototype.onAdd.call(this), this._draw() }, _initContainer () { const t = this._container = document.createElement('canvas'); Oe(t, 'mousemove', this._onMouseMove, this), Oe(t, 'click dblclick mousedown mouseup contextmenu', this._onClick, this), Oe(t, 'mouseout', this._handleMouseOut, this), this._ctx = t.getContext('2d') }, _destroyContainer () { C(this._redrawRequest), delete this._ctx, _e(this._container), Re(this._container), delete this._container }, _updatePaths () { if (!this._postponeUpdatePaths) { let t; for (const e in this._redrawBounds = null, this._layers) { t = this._layers[e], t._update() } this._redraw() } }, _update () { if (!this._map._animatingZoom || !this._bounds) { Hn.prototype._update.call(this); const t = this._bounds; const e = this._container; const i = t.getSize(); const n = zt ? 2 : 1; Me(e, t.min), e.width = n * i.x, e.height = n * i.y, e.style.width = i.x + 'px', e.style.height = i.y + 'px', zt && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire('update') } }, _reset () { Hn.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths()) }, _initPath (t) { this._updateDashArray(t), this._layers[r(t)] = t; const e = t._order = { layer: t, prev: this._drawLast, next: null }; this._drawLast && (this._drawLast.next = e), this._drawLast = e, this._drawFirst = this._drawFirst || this._drawLast }, _addPath (t) { this._requestRedraw(t) }, _removePath (t) { const e = t._order; const i = e.next; const n = e.prev; i ? i.prev = n : this._drawLast = n, n ? n.next = i : this._drawFirst = i, delete t._order, delete this._layers[r(t)], this._requestRedraw(t) }, _updatePath (t) { this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t) }, _updateStyle (t) { this._updateDashArray(t), this._requestRedraw(t) }, _updateDashArray (t) { if (typeof t.options.dashArray === 'string') { let e; let i; const n = t.options.dashArray.split(/[, ]+/); const o = []; for (i = 0; i < n.length; i++) { if (e = Number(n[i]), isNaN(e)) { return } o.push(e) }t.options._dashArray = o } else { t.options._dashArray = t.options.dashArray } }, _requestRedraw (t) { this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || z(this._redraw, this)) }, _extendRedrawBounds (t) { if (t._pxBounds) { const e = (t.options.weight || 0) + 1; this._redrawBounds = this._redrawBounds || new N(), this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e])) } }, _redraw () { this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null }, _clear () { const t = this._redrawBounds; if (t) { const e = t.getSize(); this._ctx.clearRect(t.min.x, t.min.y, e.x, e.y) } else { this._ctx.clearRect(0, 0, this._container.width, this._container.height) } }, _draw () { let t; const e = this._redrawBounds; if (this._ctx.save(), e) { const i = e.getSize(); this._ctx.beginPath(), this._ctx.rect(e.min.x, e.min.y, i.x, i.y), this._ctx.clip() } this._drawing = !0; for (let n = this._drawFirst; n; n = n.next) { t = n.layer, (!e || t._pxBounds && t._pxBounds.intersects(e)) && t._updatePath() } this._drawing = !1, this._ctx.restore() }, _updatePoly (t, e) { if (this._drawing) { let i; let n; let o; let s; const a = t._parts; const r = a.length; const h = this._ctx; if (r) { for (h.beginPath(), i = 0; i < r; i++) { for (n = 0, o = a[i].length; n < o; n++) { s = a[i][n], h[n ? 'lineTo' : 'moveTo'](s.x, s.y) }e && h.closePath() } this._fillStroke(h, t) } } }, _updateCircle (t) { if (this._drawing && !t._empty()) { const e = t._point; const i = this._ctx; const n = Math.max(Math.round(t._radius), 1); const o = (Math.max(Math.round(t._radiusY), 1) || n) / n; o !== 1 && (i.save(), i.scale(1, o)), i.beginPath(), i.arc(e.x, e.y / o, n, 0, 2 * Math.PI, !1), o !== 1 && i.restore(), this._fillStroke(i, t) } }, _fillStroke (t, e) { const i = e.options; i.fill && (t.globalAlpha = i.fillOpacity, t.fillStyle = i.fillColor || i.color, t.fill(i.fillRule || 'evenodd')), i.stroke && i.weight !== 0 && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = i.opacity, t.lineWidth = i.weight, t.strokeStyle = i.color, t.lineCap = i.lineCap, t.lineJoin = i.lineJoin, t.stroke()) }, _onClick (t) { for (var e, i, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next) { e = o.layer, e.options.interactive && e._containsPoint(n) && !this._map._draggableMoved(e) && (i = e) }i && (Je(t), this._fireEvent([i], t)) }, _onMouseMove (t) { if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) { const e = this._map.mouseEventToLayerPoint(t); this._handleMouseHover(t, e) } }, _handleMouseOut (t) { const e = this._hoveredLayer; e && (ye(this._container, 'leaflet-interactive'), this._fireEvent([e], t, 'mouseout'), this._hoveredLayer = null, this._mouseHoverThrottled = !1) }, _handleMouseHover (t, e) { if (!this._mouseHoverThrottled) { for (var i, n, o = this._drawFirst; o; o = o.next) { i = o.layer, i.options.interactive && i._containsPoint(e) && (n = i) }n !== this._hoveredLayer && (this._handleMouseOut(t), n && (ve(this._container, 'leaflet-interactive'), this._fireEvent([n], t, 'mouseover'), this._hoveredLayer = n)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t), this._mouseHoverThrottled = !0, setTimeout(L.bind(function () { this._mouseHoverThrottled = !1 }, this), 32) } }, _fireEvent (t, e, i) { this._map._fireDOMEvent(e, i || e.type, t) }, _bringToFront (t) { const e = t._order; if (e) { const i = e.next; const n = e.prev; i && (i.prev = n, n ? n.next = i : i && (this._drawFirst = i), e.prev = this._drawLast, this._drawLast.next = e, e.next = null, this._drawLast = e, this._requestRedraw(t)) } }, _bringToBack (t) { const e = t._order; if (e) { const i = e.next; const n = e.prev; n && (n.next = i, i ? i.prev = n : n && (this._drawLast = n), e.prev = null, e.next = this._drawFirst, this._drawFirst.prev = e, this._drawFirst = e, this._requestRedraw(t)) } } }); function Vn (t) { return kt ? new Fn(t) : null } const Un = (function () { try { return document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml'), function (t) { return document.createElement('<lvml:' + t + ' class="lvml">') } } catch (t) { return function (t) { return document.createElement('<' + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">') } } }()); const qn = { _initContainer () { this._container = de('div', 'leaflet-vml-container') }, _update () { this._map._animatingZoom || (Hn.prototype._update.call(this), this.fire('update')) }, _initPath (t) { const e = t._container = Un('shape'); ve(e, 'leaflet-vml-shape ' + (this.options.className || '')), e.coordsize = '1 1', t._path = Un('path'), e.appendChild(t._path), this._updateStyle(t), this._layers[r(t)] = t }, _addPath (t) { const e = t._container; this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e) }, _removePath (t) { const e = t._container; _e(e), t.removeInteractiveTarget(e), delete this._layers[r(t)] }, _updateStyle (t) { let e = t._stroke; let i = t._fill; const n = t.options; const o = t._container; o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (e || (e = t._stroke = Un('stroke')), o.appendChild(e), e.weight = n.weight + 'px', e.color = n.color, e.opacity = n.opacity, n.dashArray ? e.dashStyle = v(n.dashArray) ? n.dashArray.join(' ') : n.dashArray.replace(/( *, *)/g, ' ') : e.dashStyle = '', e.endcap = n.lineCap.replace('butt', 'flat'), e.joinstyle = n.lineJoin) : e && (o.removeChild(e), t._stroke = null), n.fill ? (i || (i = t._fill = Un('fill')), o.appendChild(i), i.color = n.fillColor || n.color, i.opacity = n.fillOpacity) : i && (o.removeChild(i), t._fill = null) }, _updateCircle (t) { const e = t._point.round(); const i = Math.round(t._radius); const n = Math.round(t._radiusY || i); this._setPath(t, t._empty() ? 'M0 0' : 'AL ' + e.x + ',' + e.y + ' ' + i + ',' + n + ' 0,23592600') }, _setPath (t, e) { t._path.v = e }, _bringToFront (t) { me(t._container) }, _bringToBack (t) { fe(t._container) } }; const Gn = Et ? Un : J; const Kn = Hn.extend({ getEvents () { const t = Hn.prototype.getEvents.call(this); return t.zoomstart = this._onZoomStart, t }, _initContainer () { this._container = Gn('svg'), this._container.setAttribute('pointer-events', 'none'), this._rootGroup = Gn('g'), this._container.appendChild(this._rootGroup) }, _destroyContainer () { _e(this._container), Re(this._container), delete this._container, delete this._rootGroup, delete this._svgSize }, _onZoomStart () { this._update() }, _update () { if (!this._map._animatingZoom || !this._bounds) { Hn.prototype._update.call(this); const t = this._bounds; const e = t.getSize(); const i = this._container; this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, i.setAttribute('width', e.x), i.setAttribute('height', e.y)), Me(i, t.min), i.setAttribute('viewBox', [t.min.x, t.min.y, e.x, e.y].join(' ')), this.fire('update') } }, _initPath (t) { const e = t._path = Gn('path'); t.options.className && ve(e, t.options.className), t.options.interactive && ve(e, 'leaflet-interactive'), this._updateStyle(t), this._layers[r(t)] = t }, _addPath (t) { this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path) }, _removePath (t) { _e(t._path), t.removeInteractiveTarget(t._path), delete this._layers[r(t)] }, _updatePath (t) { t._project(), t._update() }, _updateStyle (t) { const e = t._path; const i = t.options; e && (i.stroke ? (e.setAttribute('stroke', i.color), e.setAttribute('stroke-opacity', i.opacity), e.setAttribute('stroke-width', i.weight), e.setAttribute('stroke-linecap', i.lineCap), e.setAttribute('stroke-linejoin', i.lineJoin), i.dashArray ? e.setAttribute('stroke-dasharray', i.dashArray) : e.removeAttribute('stroke-dasharray'), i.dashOffset ? e.setAttribute('stroke-dashoffset', i.dashOffset) : e.removeAttribute('stroke-dashoffset')) : e.setAttribute('stroke', 'none'), i.fill ? (e.setAttribute('fill', i.fillColor || i.color), e.setAttribute('fill-opacity', i.fillOpacity), e.setAttribute('fill-rule', i.fillRule || 'evenodd')) : e.setAttribute('fill', 'none')) }, _updatePoly (t, e) { this._setPath(t, X(t._parts, e)) }, _updateCircle (t) { const e = t._point; const i = Math.max(Math.round(t._radius), 1); const n = Math.max(Math.round(t._radiusY), 1) || i; const o = 'a' + i + ',' + n + ' 0 1,0 '; const s = t._empty() ? 'M0 0' : 'M' + (e.x - i) + ',' + e.y + o + 2 * i + ',0 ' + o + 2 * -i + ',0 '; this._setPath(t, s) }, _setPath (t, e) { t._path.setAttribute('d', e) }, _bringToFront (t) { me(t._path) }, _bringToBack (t) { fe(t._path) } }); function Yn (t) { return St || Et ? new Kn(t) : null }Et && Kn.include(qn), ni.include({ getRenderer (t) { let e = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer; return e || (e = this._renderer = this._createRenderer()), this.hasLayer(e) || this.addLayer(e), e }, _getPaneRenderer (t) { if (t === 'overlayPane' || void 0 === t) { return !1 } let e = this._paneRenderers[t]; return void 0 === e && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e }, _createRenderer (t) { return this.options.preferCanvas && Vn(t) || Yn(t) } }); const $n = ln.extend({ initialize (t, e) { ln.prototype.initialize.call(this, this._boundsToLatLngs(t), e) }, setBounds (t) { return this.setLatLngs(this._boundsToLatLngs(t)) }, _boundsToLatLngs (t) { return t = D(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()] } }); function Jn (t, e) { return new $n(t, e) }Kn.create = Gn, Kn.pointsToPath = X, cn.geometryToLayer = dn, cn.coordsToLatLng = pn, cn.coordsToLatLngs = mn, cn.latLngToCoords = fn, cn.latLngsToCoords = gn, cn.getFeature = vn, cn.asFeature = yn, ni.mergeOptions({ boxZoom: !0 }); const Xn = mi.extend({ initialize (t) { this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on('unload', this._destroy, this) }, addHooks () { Oe(this._container, 'mousedown', this._onMouseDown, this) }, removeHooks () { Re(this._container, 'mousedown', this._onMouseDown, this) }, moved () { return this._moved }, _destroy () { _e(this._pane), delete this._pane }, _resetState () { this._resetStateTimeout = 0, this._moved = !1 }, _clearDeferredResetState () { this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0) }, _onMouseDown (t) { if (!t.shiftKey || t.which !== 1 && t.button !== 1) { return !1 } this._clearDeferredResetState(), this._resetState(), ie(), ke(), this._startPoint = this._map.mouseEventToContainerPoint(t), Oe(document, { contextmenu: Ue, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseMove (t) { this._moved || (this._moved = !0, this._box = de('div', 'leaflet-zoom-box', this._container), ve(this._container, 'leaflet-crosshair'), this._map.fire('boxzoomstart')), this._point = this._map.mouseEventToContainerPoint(t); const e = new N(this._point, this._startPoint); const i = e.getSize(); Me(this._box, e.min), this._box.style.width = i.x + 'px', this._box.style.height = i.y + 'px' }, _finish () { this._moved && (_e(this._box), ye(this._container, 'leaflet-crosshair')), ne(), Se(), Re(document, { contextmenu: Ue, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseUp (t) { if ((t.which === 1 || t.button === 1) && (this._finish(), this._moved)) { this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(s(this._resetState, this), 0); const e = new j(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)); this._map.fitBounds(e).fire('boxzoomend', { boxZoomBounds: e }) } }, _onKeyDown (t) { t.keyCode === 27 && this._finish() } }); ni.addInitHook('addHandler', 'boxZoom', Xn), ni.mergeOptions({ doubleClickZoom: !0 }); const Qn = mi.extend({ addHooks () { this._map.on('dblclick', this._onDoubleClick, this) }, removeHooks () { this._map.off('dblclick', this._onDoubleClick, this) }, _onDoubleClick (t) { const e = this._map; const i = e.getZoom(); const n = e.options.zoomDelta; const o = t.originalEvent.shiftKey ? i - n : i + n; e.options.doubleClickZoom === 'center' ? e.setZoom(o) : e.setZoomAround(t.containerPoint, o) } }); ni.addInitHook('addHandler', 'doubleClickZoom', Qn), ni.mergeOptions({ dragging: !0, inertia: !st, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: 0.2, worldCopyJump: !1, maxBoundsViscosity: 0 }); const to = mi.extend({ addHooks () { if (!this._draggable) { const t = this._map; this._draggable = new wi(t._mapPane, t._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on('predrag', this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on('predrag', this._onPreDragWrap, this), t.on('zoomend', this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this)) }ve(this._map._container, 'leaflet-grab leaflet-touch-drag'), this._draggable.enable(), this._positions = [], this._times = [] }, removeHooks () { ye(this._map._container, 'leaflet-grab'), ye(this._map._container, 'leaflet-touch-drag'), this._draggable.disable() }, moved () { return this._draggable && this._draggable._moved }, moving () { return this._draggable && this._draggable._moving }, _onDragStart () { const t = this._map; if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) { const e = D(this._map.options.maxBounds); this._offsetLimit = R(this._map.latLngToContainerPoint(e.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(e.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity)) } else { this._offsetLimit = null }t.fire('movestart').fire('dragstart'), t.options.inertia && (this._positions = [], this._times = []) }, _onDrag (t) { if (this._map.options.inertia) { const e = this._lastTime = +new Date(); const i = this._lastPos = this._draggable._absPos || this._draggable._newPos; this._positions.push(i), this._times.push(e), this._prunePositions(e) } this._map.fire('move', t).fire('drag', t) }, _prunePositions (t) { while (this._positions.length > 1 && t - this._times[0] > 50) { this._positions.shift(), this._times.shift() } }, _onZoomEnd () { const t = this._map.getSize().divideBy(2); const e = this._map.latLngToLayerPoint([0, 0]); this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x }, _viscousLimit (t, e) { return t - (t - e) * this._viscosity }, _onPreDragLimit () { if (this._viscosity && this._offsetLimit) { const t = this._draggable._newPos.subtract(this._draggable._startPos); const e = this._offsetLimit; t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t) } }, _onPreDragWrap () { const t = this._worldWidth; const e = Math.round(t / 2); const i = this._initialWorldOffset; const n = this._draggable._newPos.x; const o = (n - e + i) % t + e - i; const s = (n + e + i) % t - e - i; const a = Math.abs(o + i) < Math.abs(s + i) ? o : s; this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = a }, _onDragEnd (t) { const e = this._map; const i = e.options; const n = !i.inertia || this._times.length < 2; if (e.fire('dragend', t), n) { e.fire('moveend') } else { this._prunePositions(+new Date()); const o = this._lastPos.subtract(this._positions[0]); const s = (this._lastTime - this._times[0]) / 1e3; const a = i.easeLinearity; const r = o.multiplyBy(a / s); const h = r.distanceTo([0, 0]); const l = Math.min(i.inertiaMaxSpeed, h); const u = r.multiplyBy(l / h); const c = l / (i.inertiaDeceleration * a); let d = u.multiplyBy(-c / 2).round(); d.x || d.y ? (d = e._limitOffset(d, e.options.maxBounds), z(function () { e.panBy(d, { duration: c, easeLinearity: a, noMoveStart: !0, animate: !0 }) })) : e.fire('moveend') } } }); ni.addInitHook('addHandler', 'dragging', to), ni.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 }); const eo = mi.extend({ keyCodes: { left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173] }, initialize (t) { this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta) }, addHooks () { const t = this._map._container; t.tabIndex <= 0 && (t.tabIndex = '0'), Oe(t, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this) }, removeHooks () { this._removeHooks(), Re(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this) }, _onMouseDown () { if (!this._focused) { const t = document.body; const e = document.documentElement; const i = t.scrollTop || e.scrollTop; const n = t.scrollLeft || e.scrollLeft; this._map._container.focus(), window.scrollTo(n, i) } }, _onFocus () { this._focused = !0, this._map.fire('focus') }, _onBlur () { this._focused = !1, this._map.fire('blur') }, _setPanDelta (t) { let e; let i; const n = this._panKeys = {}; const o = this.keyCodes; for (e = 0, i = o.left.length; e < i; e++) { n[o.left[e]] = [-1 * t, 0] } for (e = 0, i = o.right.length; e < i; e++) { n[o.right[e]] = [t, 0] } for (e = 0, i = o.down.length; e < i; e++) { n[o.down[e]] = [0, t] } for (e = 0, i = o.up.length; e < i; e++) { n[o.up[e]] = [0, -1 * t] } }, _setZoomDelta (t) { let e; let i; const n = this._zoomKeys = {}; const o = this.keyCodes; for (e = 0, i = o.zoomIn.length; e < i; e++) { n[o.zoomIn[e]] = t } for (e = 0, i = o.zoomOut.length; e < i; e++) { n[o.zoomOut[e]] = -t } }, _addHooks () { Oe(document, 'keydown', this._onKeyDown, this) }, _removeHooks () { Re(document, 'keydown', this._onKeyDown, this) }, _onKeyDown (t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { let e; const i = t.keyCode; const n = this._map; if (i in this._panKeys) { n._panAnim && n._panAnim._inProgress || (e = this._panKeys[i], t.shiftKey && (e = O(e).multiplyBy(3)), n.panBy(e), n.options.maxBounds && n.panInsideBounds(n.options.maxBounds)) } else if (i in this._zoomKeys) { n.setZoom(n.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[i]) } else { if (i !== 27 || !n._popup || !n._popup.options.closeOnEscapeKey) { return } n.closePopup() }Ue(t) } } }); ni.addInitHook('addHandler', 'keyboard', eo), ni.mergeOptions({ scrollWheelZoom: !0, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }); const io = mi.extend({ addHooks () { Oe(this._map._container, 'mousewheel', this._onWheelScroll, this), this._delta = 0 }, removeHooks () { Re(this._map._container, 'mousewheel', this._onWheelScroll, this) }, _onWheelScroll (t) { const e = Ke(t); const i = this._map.options.wheelDebounceTime; this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date()); const n = Math.max(i - (+new Date() - this._startTime), 0); clearTimeout(this._timer), this._timer = setTimeout(s(this._performZoom, this), n), Ue(t) }, _performZoom () { const t = this._map; const e = t.getZoom(); const i = this._map.options.zoomSnap || 0; t._stop(); const n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel); const o = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2; const s = i ? Math.ceil(o / i) * i : o; const a = t._limitZoom(e + (this._delta > 0 ? s : -s)) - e; this._delta = 0, this._startTime = null, a && (t.options.scrollWheelZoom === 'center' ? t.setZoom(e + a) : t.setZoomAround(this._lastMousePos, e + a)) } }); ni.addInitHook('addHandler', 'scrollWheelZoom', io), ni.mergeOptions({ tap: !0, tapTolerance: 15 }); const no = mi.extend({ addHooks () { Oe(this._map._container, 'touchstart', this._onDown, this) }, removeHooks () { Re(this._map._container, 'touchstart', this._onDown, this) }, _onDown (t) { if (t.touches) { if (Ve(t), this._fireClick = !0, t.touches.length > 1) { return this._fireClick = !1, void clearTimeout(this._holdTimeout) } const e = t.touches[0]; const i = e.target; this._startPos = this._newPos = new B(e.clientX, e.clientY), i.tagName && i.tagName.toLowerCase() === 'a' && ve(i, 'leaflet-active'), this._holdTimeout = setTimeout(s(function () { this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent('contextmenu', e)) }, this), 1e3), this._simulateEvent('mousedown', e), Oe(document, { touchmove: this._onMove, touchend: this._onUp }, this) } }, _onUp (t) { if (clearTimeout(this._holdTimeout), Re(document, { touchmove: this._onMove, touchend: this._onUp }, this), this._fireClick && t && t.changedTouches) { const e = t.changedTouches[0]; const i = e.target; i && i.tagName && i.tagName.toLowerCase() === 'a' && ye(i, 'leaflet-active'), this._simulateEvent('mouseup', e), this._isTapValid() && this._simulateEvent('click', e) } }, _isTapValid () { return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance }, _onMove (t) { const e = t.touches[0]; this._newPos = new B(e.clientX, e.clientY), this._simulateEvent('mousemove', e) }, _simulateEvent (t, e) { const i = document.createEvent('MouseEvents'); i._simulated = !0, e.target._simulatedClick = !0, i.initMouseEvent(t, !0, !0, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(i) } }); Pt && !Lt && ni.addInitHook('addHandler', 'tap', no), ni.mergeOptions({ touchZoom: Pt && !st, bounceAtZoomLimits: !0 }); const oo = mi.extend({ addHooks () { ve(this._map._container, 'leaflet-touch-zoom'), Oe(this._map._container, 'touchstart', this._onTouchStart, this) }, removeHooks () { ye(this._map._container, 'leaflet-touch-zoom'), Re(this._map._container, 'touchstart', this._onTouchStart, this) }, _onTouchStart (t) { const e = this._map; if (t.touches && t.touches.length === 2 && !e._animatingZoom && !this._zooming) { const i = e.mouseEventToContainerPoint(t.touches[0]); const n = e.mouseEventToContainerPoint(t.touches[1]); this._centerPoint = e.getSize()._divideBy(2), this._startLatLng = e.containerPointToLatLng(this._centerPoint), e.options.touchZoom !== 'center' && (this._pinchStartLatLng = e.containerPointToLatLng(i.add(n)._divideBy(2))), this._startDist = i.distanceTo(n), this._startZoom = e.getZoom(), this._moved = !1, this._zooming = !0, e._stop(), Oe(document, 'touchmove', this._onTouchMove, this), Oe(document, 'touchend', this._onTouchEnd, this), Ve(t) } }, _onTouchMove (t) { if (t.touches && t.touches.length === 2 && this._zooming) { const e = this._map; const i = e.mouseEventToContainerPoint(t.touches[0]); const n = e.mouseEventToContainerPoint(t.touches[1]); const o = i.distanceTo(n) / this._startDist; if (this._zoom = e.getScaleZoom(o, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && o > 1) && (this._zoom = e._limitZoom(this._zoom)), e.options.touchZoom === 'center') { if (this._center = this._startLatLng, o === 1) { return } } else { const a = i._add(n)._divideBy(2)._subtract(this._centerPoint); if (o === 1 && a.x === 0 && a.y === 0) { return } this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(a), this._zoom) } this._moved || (e._moveStart(!0, !1), this._moved = !0), C(this._animRequest); const r = s(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }); this._animRequest = z(r, this, !0), Ve(t) } }, _onTouchEnd () { this._moved && this._zooming ? (this._zooming = !1, C(this._animRequest), Re(document, 'touchmove', this._onTouchMove), Re(document, 'touchend', this._onTouchEnd), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1 } }); ni.addInitHook('addHandler', 'touchZoom', oo), ni.BoxZoom = Xn, ni.DoubleClickZoom = Qn, ni.Drag = to, ni.Keyboard = eo, ni.ScrollWheelZoom = io, ni.Tap = no, ni.TouchZoom = oo, Object.freeze = i, t.version = e, t.Control = si, t.control = ai, t.Browser = It, t.Evented = I, t.Mixin = gi, t.Util = k, t.Class = S, t.Handler = mi, t.extend = n, t.bind = s, t.stamp = r, t.setOptions = p, t.DomEvent = ei, t.DomUtil = Ae, t.PosAnimation = ii, t.Draggable = wi, t.LineUtil = Ai, t.PolyUtil = Ni, t.Point = B, t.point = O, t.Bounds = N, t.bounds = R, t.Transformation = G, t.transformation = K, t.Projection = Di, t.LatLng = W, t.latLng = H, t.LatLngBounds = j, t.latLngBounds = D, t.CRS = F, t.GeoJSON = cn, t.geoJSON = wn, t.geoJson = bn, t.Layer = Vi, t.LayerGroup = Ui, t.layerGroup = qi, t.FeatureGroup = Gi, t.featureGroup = Ki, t.ImageOverlay = Ln, t.imageOverlay = Pn, t.VideoOverlay = Tn, t.videoOverlay = Mn, t.SVGOverlay = zn, t.svgOverlay = Cn, t.DivOverlay = kn, t.Popup = Sn, t.popup = En, t.Tooltip = Zn, t.tooltip = In, t.Icon = Yi, t.icon = $i, t.DivIcon = Bn, t.divIcon = An, t.Marker = Qi, t.marker = tn, t.TileLayer = Rn, t.tileLayer = jn, t.GridLayer = On, t.gridLayer = Nn, t.SVG = Kn, t.svg = Yn, t.Renderer = Hn, t.Canvas = Fn, t.canvas = Vn, t.Path = en, t.CircleMarker = nn, t.circleMarker = on, t.Circle = sn, t.circle = an, t.Polyline = rn, t.polyline = hn, t.Polygon = ln, t.polygon = un, t.Rectangle = $n, t.rectangle = Jn, t.Map = ni, t.map = oi; const so = window.L; t.noConflict = function () { return window.L = so, this }, window.L = t })
  }
}])
// # sourceMappingURL=chunk-d2d01fae.d7e8c9b6.js.map
