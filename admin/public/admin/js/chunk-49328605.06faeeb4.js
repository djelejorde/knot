(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-49328605'], { '53ca' (e, t, n) { 'use strict'; n.d(t, 'a', function () { return r }); n('a4d3'), n('e01a'), n('d28b'), n('e260'), n('d3b7'), n('3ca3'), n('ddb0'); function r (e) { return r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, r(e) } }, '56b3' (e, t, n) { (function (t, n) { e.exports = n() })(0, function () { 'use strict'; const e = navigator.userAgent; const t = navigator.platform; const n = /gecko\/\d/i.test(e); const r = /MSIE \d/.test(e); const i = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e); const o = /Edge\/(\d+)/.exec(e); const l = r || i || o; const a = l && (r ? document.documentMode || 6 : +(o || i)[1]); let s = !o && /WebKit\//.test(e); const u = s && /Qt\/\d+\.\d+/.test(e); const c = !o && /Chrome\//.test(e); let f = /Opera\//.test(e); const h = /Apple Computer/.test(navigator.vendor); const d = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e); const p = /PhantomJS/.test(e); const g = !o && /AppleWebKit/.test(e) && /Mobile\/\w+/.test(e); const m = /Android/.test(e); const v = g || m || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e); const y = g || /Mac/.test(t); const b = /\bCrOS\b/.test(e); const w = /win/i.test(t); let x = f && e.match(/Version\/(\d*\.\d*)/); x && (x = Number(x[1])), x && x >= 15 && (f = !1, s = !0); const C = y && (u || f && (x == null || x < 12.11)); const k = n || l && a >= 9; function S (e) { return new RegExp('(^|\\s)' + e + '(?:$|\\s)\\s*') } let L; const T = function (e, t) { const n = e.className; const r = S(t).exec(n); if (r) { const i = n.slice(r.index + r[0].length); e.className = n.slice(0, r.index) + (i ? r[1] + i : '') } }; function M (e) { for (let t = e.childNodes.length; t > 0; --t) { e.removeChild(e.firstChild) } return e } function O (e, t) { return M(e).appendChild(t) } function A (e, t, n, r) { const i = document.createElement(e); if (n && (i.className = n), r && (i.style.cssText = r), typeof t === 'string') { i.appendChild(document.createTextNode(t)) } else if (t) { for (let o = 0; o < t.length; ++o) { i.appendChild(t[o]) } } return i } function N (e, t, n, r) { const i = A(e, t, n, r); return i.setAttribute('role', 'presentation'), i } function D (e, t) { if (t.nodeType == 3 && (t = t.parentNode), e.contains) { return e.contains(t) } do { if (t.nodeType == 11 && (t = t.host), t == e) { return !0 } } while (t = t.parentNode) } function W () { let e; try { e = document.activeElement } catch (t) { e = document.body || null } while (e && e.shadowRoot && e.shadowRoot.activeElement) { e = e.shadowRoot.activeElement } return e } function H (e, t) { const n = e.className; S(t).test(n) || (e.className += (n ? ' ' : '') + t) } function E (e, t) { for (let n = e.split(' '), r = 0; r < n.length; r++) { n[r] && !S(n[r]).test(t) && (t += ' ' + n[r]) } return t }L = document.createRange ? function (e, t, n, r) { const i = document.createRange(); return i.setEnd(r || e, n), i.setStart(e, t), i } : function (e, t, n) { const r = document.body.createTextRange(); try { r.moveToElementText(e.parentNode) } catch (i) { return r } return r.collapse(!0), r.moveEnd('character', n), r.moveStart('character', t), r }; let F = function (e) { e.select() }; function P (e) { const t = Array.prototype.slice.call(arguments, 1); return function () { return e.apply(null, t) } } function z (e, t, n) { for (const r in t || (t = {}), e) { !e.hasOwnProperty(r) || !1 === n && t.hasOwnProperty(r) || (t[r] = e[r]) } return t } function I (e, t, n, r, i) { t == null && (t = e.search(/[^\s\u00A0]/), t == -1 && (t = e.length)); for (let o = r || 0, l = i || 0; ;) { const a = e.indexOf('\t', o); if (a < 0 || a >= t) { return l + (t - o) } l += a - o, l += n - l % n, o = a + 1 } }g ? F = function (e) { e.selectionStart = 0, e.selectionEnd = e.value.length } : l && (F = function (e) { try { e.select() } catch (t) {} }); const R = function () { this.id = null, this.f = null, this.time = 0, this.handler = P(this.onTimeout, this) }; function B (e, t) { for (let n = 0; n < e.length; ++n) { if (e[n] == t) { return n } } return -1 }R.prototype.onTimeout = function (e) { e.id = 0, e.time <= +new Date() ? e.f() : setTimeout(e.handler, e.time - +new Date()) }, R.prototype.set = function (e, t) { this.f = t; const n = +new Date() + e; (!this.id || n < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = n) }; const j = 30; const V = { toString () { return 'CodeMirror.Pass' } }; const G = { scroll: !1 }; const U = { origin: '*mouse' }; const _ = { origin: '+move' }; function K (e, t, n) { for (let r = 0, i = 0; ;) { let o = e.indexOf('\t', r); o == -1 && (o = e.length); const l = o - r; if (o == e.length || i + l >= t) { return r + Math.min(l, t - i) } if (i += o - r, i += n - i % n, r = o + 1, i >= t) { return r } } } const $ = ['']; function X (e) { while ($.length <= e) { $.push(q($) + ' ') } return $[e] } function q (e) { return e[e.length - 1] } function Y (e, t) { for (var n = [], r = 0; r < e.length; r++) { n[r] = t(e[r], r) } return n } function Z (e, t, n) { let r = 0; const i = n(t); while (r < e.length && n(e[r]) <= i) { r++ }e.splice(r, 0, t) } function J () {} function Q (e, t) { let n; return Object.create ? n = Object.create(e) : (J.prototype = e, n = new J()), t && z(t, n), n } const ee = /[\u00DF\u0587\u0590-\u05F4\u0600-\u06FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DB5\u4E00-\u9FCC\uAC00-\uD7AF]/; function te (e) { return /\w/.test(e) || e > '' && (e.toUpperCase() != e.toLowerCase() || ee.test(e)) } function ne (e, t) { return t ? !!(t.source.includes('\\w') && te(e)) || t.test(e) : te(e) } function re (e) { for (const t in e) { if (e.hasOwnProperty(t) && e[t]) { return !1 } } return !0 } const ie = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065E\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0900-\u0902\u093C\u0941-\u0948\u094D\u0951-\u0955\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFD-\u1DFF\u200C\u200D\u20D0-\u20F0\u2CEF-\u2CF1\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uDC00-\uDFFF\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\uFF9E\uFF9F]/; function oe (e) { return e.charCodeAt(0) >= 768 && ie.test(e) } function le (e, t, n) { while ((n < 0 ? t > 0 : t < e.length) && oe(e.charAt(t))) { t += n } return t } function ae (e, t, n) { for (let r = t > n ? -1 : 1; ;) { if (t == n) { return t } const i = (t + n) / 2; const o = r < 0 ? Math.ceil(i) : Math.floor(i); if (o == t) { return e(o) ? t : n } e(o) ? n = o : t = o + r } } function se (e, t, n, r) { if (!e) { return r(t, n, 'ltr', 0) } for (var i = !1, o = 0; o < e.length; ++o) { const l = e[o]; (l.from < n && l.to > t || t == n && l.to == t) && (r(Math.max(l.from, t), Math.min(l.to, n), l.level == 1 ? 'rtl' : 'ltr', o), i = !0) }i || r(t, n, 'ltr') } let ue = null; function ce (e, t, n) { let r; ue = null; for (let i = 0; i < e.length; ++i) { const o = e[i]; if (o.from < t && o.to > t) { return i } o.to == t && (o.from != o.to && n == 'before' ? r = i : ue = i), o.from == t && (o.from != o.to && n != 'before' ? r = i : ue = i) } return r != null ? r : ue } const fe = (function () { const e = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN'; const t = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111'; function n (n) { return n <= 247 ? e.charAt(n) : n >= 1424 && n <= 1524 ? 'R' : n >= 1536 && n <= 1785 ? t.charAt(n - 1536) : n >= 1774 && n <= 2220 ? 'r' : n >= 8192 && n <= 8203 ? 'w' : n == 8204 ? 'b' : 'L' } const r = /[\u0590-\u05F4\u0600-\u06FF\u0700-\u08AC]/; const i = /[stwN]/; const o = /[LRr]/; const l = /[Lb1n]/; const a = /[1n]/; function s (e, t, n) { this.level = e, this.from = t, this.to = n } return function (e, t) { const u = t == 'ltr' ? 'L' : 'R'; if (e.length == 0 || t == 'ltr' && !r.test(e)) { return !1 } for (var c = e.length, f = [], h = 0; h < c; ++h) { f.push(n(e.charCodeAt(h))) } for (let d = 0, p = u; d < c; ++d) { const g = f[d]; g == 'm' ? f[d] = p : p = g } for (let m = 0, v = u; m < c; ++m) { const y = f[m]; y == '1' && v == 'r' ? f[m] = 'n' : o.test(y) && (v = y, y == 'r' && (f[m] = 'R')) } for (let b = 1, w = f[0]; b < c - 1; ++b) { const x = f[b]; x == '+' && w == '1' && f[b + 1] == '1' ? f[b] = '1' : x != ',' || w != f[b + 1] || w != '1' && w != 'n' || (f[b] = w), w = x } for (let C = 0; C < c; ++C) { const k = f[C]; if (k == ',') { f[C] = 'N' } else if (k == '%') { let S = void 0; for (S = C + 1; S < c && f[S] == '%'; ++S) { ; } for (let L = C && f[C - 1] == '!' || S < c && f[S] == '1' ? '1' : 'N', T = C; T < S; ++T) { f[T] = L }C = S - 1 } } for (let M = 0, O = u; M < c; ++M) { const A = f[M]; O == 'L' && A == '1' ? f[M] = 'L' : o.test(A) && (O = A) } for (let N = 0; N < c; ++N) { if (i.test(f[N])) { let D = void 0; for (D = N + 1; D < c && i.test(f[D]); ++D) { ; } for (let W = (N ? f[N - 1] : u) == 'L', H = (D < c ? f[D] : u) == 'L', E = W == H ? W ? 'L' : 'R' : u, F = N; F < D; ++F) { f[F] = E }N = D - 1 } } for (var P, z = [], I = 0; I < c;) { if (l.test(f[I])) { const R = I; for (++I; I < c && l.test(f[I]); ++I) { ; }z.push(new s(0, R, I)) } else { let B = I; const j = z.length; for (++I; I < c && f[I] != 'L'; ++I) { ; } for (let V = B; V < I;) { if (a.test(f[V])) { B < V && z.splice(j, 0, new s(1, B, V)); const G = V; for (++V; V < I && a.test(f[V]); ++V) { ; }z.splice(j, 0, new s(2, G, V)), B = V } else { ++V } } B < I && z.splice(j, 0, new s(1, B, I)) } } return t == 'ltr' && (z[0].level == 1 && (P = e.match(/^\s+/)) && (z[0].from = P[0].length, z.unshift(new s(0, 0, P[0].length))), q(z).level == 1 && (P = e.match(/\s+$/)) && (q(z).to -= P[0].length, z.push(new s(0, c - P[0].length, c)))), t == 'rtl' ? z.reverse() : z } }()); function he (e, t) { let n = e.order; return n == null && (n = e.order = fe(e.text, t)), n } const de = []; const pe = function (e, t, n) { if (e.addEventListener) { e.addEventListener(t, n, !1) } else if (e.attachEvent) { e.attachEvent('on' + t, n) } else { const r = e._handlers || (e._handlers = {}); r[t] = (r[t] || de).concat(n) } }; function ge (e, t) { return e._handlers && e._handlers[t] || de } function me (e, t, n) { if (e.removeEventListener) { e.removeEventListener(t, n, !1) } else if (e.detachEvent) { e.detachEvent('on' + t, n) } else { const r = e._handlers; const i = r && r[t]; if (i) { const o = B(i, n); o > -1 && (r[t] = i.slice(0, o).concat(i.slice(o + 1))) } } } function ve (e, t) { const n = ge(e, t); if (n.length) { for (let r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i) { n[i].apply(null, r) } } } function ye (e, t, n) { return typeof t === 'string' && (t = { type: t, preventDefault () { this.defaultPrevented = !0 } }), ve(e, n || t.type, e, t), Se(t) || t.codemirrorIgnore } function be (e) { const t = e._handlers && e._handlers.cursorActivity; if (t) { for (let n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r) { B(n, t[r]) == -1 && n.push(t[r]) } } } function we (e, t) { return ge(e, t).length > 0 } function xe (e) { e.prototype.on = function (e, t) { pe(this, e, t) }, e.prototype.off = function (e, t) { me(this, e, t) } } function Ce (e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1 } function ke (e) { e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0 } function Se (e) { return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == 0 } function Le (e) { Ce(e), ke(e) } function Te (e) { return e.target || e.srcElement } function Me (e) { let t = e.which; return t == null && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), y && e.ctrlKey && t == 1 && (t = 3), t } let Oe; let Ae; const Ne = (function () { if (l && a < 9) { return !1 } const e = A('div'); return 'draggable' in e || 'dragDrop' in e }()); function De (e) { if (Oe == null) { const t = A('span', '​'); O(e, A('span', [t, document.createTextNode('x')])), e.firstChild.offsetHeight != 0 && (Oe = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(l && a < 8)) } const n = Oe ? A('span', '​') : A('span', ' ', null, 'display: inline-block; width: 1px; margin-right: -1px'); return n.setAttribute('cm-text', ''), n } function We (e) { if (Ae != null) { return Ae } const t = O(e, document.createTextNode('AخA')); const n = L(t, 0, 1).getBoundingClientRect(); const r = L(t, 1, 2).getBoundingClientRect(); return M(e), !(!n || n.left == n.right) && (Ae = r.right - n.right < 3) } const He = '\n\nb'.split(/\n/).length != 3 ? function (e) { let t = 0; const n = []; const r = e.length; while (t <= r) { let i = e.indexOf('\n', t); i == -1 && (i = e.length); const o = e.slice(t, e.charAt(i - 1) == '\r' ? i - 1 : i); const l = o.indexOf('\r'); l != -1 ? (n.push(o.slice(0, l)), t += l + 1) : (n.push(o), t = i + 1) } return n } : function (e) { return e.split(/\r\n?|\n/) }; const Ee = window.getSelection ? function (e) { try { return e.selectionStart != e.selectionEnd } catch (t) { return !1 } } : function (e) { let t; try { t = e.ownerDocument.selection.createRange() } catch (n) {} return !(!t || t.parentElement() != e) && t.compareEndPoints('StartToEnd', t) != 0 }; const Fe = (function () { const e = A('div'); return 'oncopy' in e || (e.setAttribute('oncopy', 'return;'), typeof e.oncopy === 'function') }()); let Pe = null; function ze (e) { if (Pe != null) { return Pe } const t = O(e, A('span', 'x')); const n = t.getBoundingClientRect(); const r = L(t, 0, 1).getBoundingClientRect(); return Pe = Math.abs(n.left - r.left) > 1 } const Ie = {}; const Re = {}; function Be (e, t) { arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), Ie[e] = t } function je (e, t) { Re[e] = t } function Ve (e) { if (typeof e === 'string' && Re.hasOwnProperty(e)) { e = Re[e] } else if (e && typeof e.name === 'string' && Re.hasOwnProperty(e.name)) { let t = Re[e.name]; typeof t === 'string' && (t = { name: t }), e = Q(t, e), e.name = t.name } else { if (typeof e === 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) { return Ve('application/xml') } if (typeof e === 'string' && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) { return Ve('application/json') } } return typeof e === 'string' ? { name: e } : e || { name: 'null' } } function Ge (e, t) { t = Ve(t); const n = Ie[t.name]; if (!n) { return Ge(e, 'text/plain') } const r = n(e, t); if (Ue.hasOwnProperty(t.name)) { const i = Ue[t.name]; for (const o in i) { i.hasOwnProperty(o) && (r.hasOwnProperty(o) && (r['_' + o] = r[o]), r[o] = i[o]) } } if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps) { for (const l in t.modeProps) { r[l] = t.modeProps[l] } } return r } var Ue = {}; function _e (e, t) { const n = Ue.hasOwnProperty(e) ? Ue[e] : Ue[e] = {}; z(t, n) } function Ke (e, t) { if (!0 === t) { return t } if (e.copyState) { return e.copyState(t) } const n = {}; for (const r in t) { let i = t[r]; Array.isArray(i) && (i = i.concat([])), n[r] = i } return n } function $e (e, t) { let n; while (e.innerMode) { if (n = e.innerMode(t), !n || n.mode == e) { break } t = n.state, e = n.mode } return n || { mode: e, state: t } } function Xe (e, t, n) { return !e.startState || e.startState(t, n) } const qe = function (e, t, n) { this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n }; function Ye (e, t) { if (t -= e.first, t < 0 || t >= e.size) { throw new Error('There is no line ' + (t + e.first) + ' in the document.') } let n = e; while (!n.lines) { for (let r = 0; ;++r) { const i = n.children[r]; const o = i.chunkSize(); if (t < o) { n = i; break }t -= o } } return n.lines[t] } function Ze (e, t, n) { const r = []; let i = t.line; return e.iter(t.line, n.line + 1, function (e) { let o = e.text; i == n.line && (o = o.slice(0, n.ch)), i == t.line && (o = o.slice(t.ch)), r.push(o), ++i }), r } function Je (e, t, n) { const r = []; return e.iter(t, n, function (e) { r.push(e.text) }), r } function Qe (e, t) { const n = t - e.height; if (n) { for (let r = e; r; r = r.parent) { r.height += n } } } function et (e) { if (e.parent == null) { return null } for (var t = e.parent, n = B(t.lines, e), r = t.parent; r; t = r, r = r.parent) { for (let i = 0; ;++i) { if (r.children[i] == t) { break } n += r.children[i].chunkSize() } } return n + t.first } function tt (e, t) { let n = e.first; e:do { for (let r = 0; r < e.children.length; ++r) { const i = e.children[r]; const o = i.height; if (t < o) { e = i; continue e }t -= o, n += i.chunkSize() } return n } while (!e.lines); for (var l = 0; l < e.lines.length; ++l) { const a = e.lines[l]; const s = a.height; if (t < s) { break } t -= s } return n + l } function nt (e, t) { return t >= e.first && t < e.first + e.size } function rt (e, t) { return String(e.lineNumberFormatter(t + e.firstLineNumber)) } function it (e, t, n) { if (void 0 === n && (n = null), !(this instanceof it)) { return new it(e, t, n) } this.line = e, this.ch = t, this.sticky = n } function ot (e, t) { return e.line - t.line || e.ch - t.ch } function lt (e, t) { return e.sticky == t.sticky && ot(e, t) == 0 } function at (e) { return it(e.line, e.ch) } function st (e, t) { return ot(e, t) < 0 ? t : e } function ut (e, t) { return ot(e, t) < 0 ? e : t } function ct (e, t) { return Math.max(e.first, Math.min(t, e.first + e.size - 1)) } function ft (e, t) { if (t.line < e.first) { return it(e.first, 0) } const n = e.first + e.size - 1; return t.line > n ? it(n, Ye(e, n).text.length) : ht(t, Ye(e, t.line).text.length) } function ht (e, t) { const n = e.ch; return n == null || n > t ? it(e.line, t) : n < 0 ? it(e.line, 0) : e } function dt (e, t) { for (var n = [], r = 0; r < t.length; r++) { n[r] = ft(e, t[r]) } return n }qe.prototype.eol = function () { return this.pos >= this.string.length }, qe.prototype.sol = function () { return this.pos == this.lineStart }, qe.prototype.peek = function () { return this.string.charAt(this.pos) || void 0 }, qe.prototype.next = function () { if (this.pos < this.string.length) { return this.string.charAt(this.pos++) } }, qe.prototype.eat = function (e) { let t; const n = this.string.charAt(this.pos); if (t = typeof e === 'string' ? n == e : n && (e.test ? e.test(n) : e(n)), t) { return ++this.pos, n } }, qe.prototype.eatWhile = function (e) { const t = this.pos; while (this.eat(e)) { ; } return this.pos > t }, qe.prototype.eatSpace = function () { const e = this.pos; while (/[\s\u00A0]/.test(this.string.charAt(this.pos))) { ++this.pos } return this.pos > e }, qe.prototype.skipToEnd = function () { this.pos = this.string.length }, qe.prototype.skipTo = function (e) { const t = this.string.indexOf(e, this.pos); if (t > -1) { return this.pos = t, !0 } }, qe.prototype.backUp = function (e) { this.pos -= e }, qe.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = I(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? I(this.string, this.lineStart, this.tabSize) : 0) }, qe.prototype.indentation = function () { return I(this.string, null, this.tabSize) - (this.lineStart ? I(this.string, this.lineStart, this.tabSize) : 0) }, qe.prototype.match = function (e, t, n) { if (typeof e !== 'string') { const r = this.string.slice(this.pos).match(e); return r && r.index > 0 ? null : (r && !1 !== t && (this.pos += r[0].length), r) } const i = function (e) { return n ? e.toLowerCase() : e }; const o = this.string.substr(this.pos, e.length); if (i(o) == i(e)) { return !1 !== t && (this.pos += e.length), !0 } }, qe.prototype.current = function () { return this.string.slice(this.start, this.pos) }, qe.prototype.hideFirstChars = function (e, t) { this.lineStart += e; try { return t() } finally { this.lineStart -= e } }, qe.prototype.lookAhead = function (e) { const t = this.lineOracle; return t && t.lookAhead(e) }, qe.prototype.baseToken = function () { const e = this.lineOracle; return e && e.baseToken(this.pos) }; const pt = function (e, t) { this.state = e, this.lookAhead = t }; const gt = function (e, t, n, r) { this.state = t, this.doc = e, this.line = n, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1 }; function mt (e, t, n, r) { const i = [e.state.modeGen]; const o = {}; Lt(e, t.text, e.doc.mode, n, function (e, t) { return i.push(e, t) }, o, r); for (var l = n.state, a = function (r) { n.baseTokens = i; const a = e.state.overlays[r]; let s = 1; let u = 0; n.state = !0, Lt(e, t.text, a.mode, n, function (e, t) { let n = s; while (u < e) { const r = i[s]; r > e && i.splice(s, 1, e, i[s + 1], r), s += 2, u = Math.min(e, r) } if (t) { if (a.opaque) { i.splice(n, s - n, e, 'overlay ' + t), s = n + 2 } else { for (;n < s; n += 2) { const o = i[n + 1]; i[n + 1] = (o ? o + ' ' : '') + 'overlay ' + t } } } }, o), n.state = l, n.baseTokens = null, n.baseTokenPos = 1 }, s = 0; s < e.state.overlays.length; ++s) { a(s) } return { styles: i, classes: o.bgClass || o.textClass ? o : null } } function vt (e, t, n) { if (!t.styles || t.styles[0] != e.state.modeGen) { const r = yt(e, et(t)); const i = t.text.length > e.options.maxHighlightLength && Ke(e.doc.mode, r.state); const o = mt(e, t, r); i && (r.state = i), t.stateAfter = r.save(!i), t.styles = o.styles, o.classes ? t.styleClasses = o.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier)) } return t.styles } function yt (e, t, n) { const r = e.doc; const i = e.display; if (!r.mode.startState) { return new gt(r, !0, t) } const o = Tt(e, t, n); const l = o > r.first && Ye(r, o - 1).stateAfter; const a = l ? gt.fromSaved(r, l, o) : new gt(r, Xe(r.mode), o); return r.iter(o, t, function (n) { bt(e, n.text, a); const r = a.line; n.stateAfter = r == t - 1 || r % 5 == 0 || r >= i.viewFrom && r < i.viewTo ? a.save() : null, a.nextLine() }), n && (r.modeFrontier = a.line), a } function bt (e, t, n, r) { const i = e.doc.mode; const o = new qe(t, e.options.tabSize, n); o.start = o.pos = r || 0, t == '' && wt(i, n.state); while (!o.eol()) { xt(i, o, n.state), o.start = o.pos } } function wt (e, t) { if (e.blankLine) { return e.blankLine(t) } if (e.innerMode) { const n = $e(e, t); return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0 } } function xt (e, t, n, r) { for (let i = 0; i < 10; i++) { r && (r[0] = $e(e, n).mode); const o = e.token(t, n); if (t.pos > t.start) { return o } } throw new Error('Mode ' + e.name + ' failed to advance stream.') }gt.prototype.lookAhead = function (e) { const t = this.doc.getLine(this.line + e); return t != null && e > this.maxLookAhead && (this.maxLookAhead = e), t }, gt.prototype.baseToken = function (e) { if (!this.baseTokens) { return null } while (this.baseTokens[this.baseTokenPos] <= e) { this.baseTokenPos += 2 } const t = this.baseTokens[this.baseTokenPos + 1]; return { type: t && t.replace(/( |^)overlay .*/, ''), size: this.baseTokens[this.baseTokenPos] - e } }, gt.prototype.nextLine = function () { this.line++, this.maxLookAhead > 0 && this.maxLookAhead-- }, gt.fromSaved = function (e, t, n) { return t instanceof pt ? new gt(e, Ke(e.mode, t.state), n, t.lookAhead) : new gt(e, Ke(e.mode, t), n) }, gt.prototype.save = function (e) { const t = !1 !== e ? Ke(this.doc.mode, this.state) : this.state; return this.maxLookAhead > 0 ? new pt(t, this.maxLookAhead) : t }; const Ct = function (e, t, n) { this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = n }; function kt (e, t, n, r) { let i; const o = e.doc; const l = o.mode; t = ft(o, t); let a; const s = Ye(o, t.line); const u = yt(e, t.line, n); const c = new qe(s.text, e.options.tabSize, u); r && (a = []); while ((r || c.pos < t.ch) && !c.eol()) { c.start = c.pos, i = xt(l, c, u.state), r && a.push(new Ct(c, i, Ke(o.mode, u.state))) } return r ? a : new Ct(c, i, u.state) } function St (e, t) { if (e) { for (;;) { const n = e.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!n) { break } e = e.slice(0, n.index) + e.slice(n.index + n[0].length); const r = n[1] ? 'bgClass' : 'textClass'; t[r] == null ? t[r] = n[2] : new RegExp('(?:^|s)' + n[2] + '(?:$|s)').test(t[r]) || (t[r] += ' ' + n[2]) } } return e } function Lt (e, t, n, r, i, o, l) { let a = n.flattenSpans; a == null && (a = e.options.flattenSpans); let s; let u = 0; let c = null; const f = new qe(t, e.options.tabSize, r); const h = e.options.addModeClass && [null]; t == '' && St(wt(n, r.state), o); while (!f.eol()) { if (f.pos > e.options.maxHighlightLength ? (a = !1, l && bt(e, t, r, f.pos), f.pos = t.length, s = null) : s = St(xt(n, f, r.state, h), o), h) { const d = h[0].name; d && (s = 'm-' + (s ? d + ' ' + s : d)) } if (!a || c != s) { while (u < f.start) { u = Math.min(f.start, u + 5e3), i(u, c) }c = s }f.start = f.pos } while (u < f.pos) { const p = Math.min(f.pos, u + 5e3); i(p, c), u = p } } function Tt (e, t, n) { for (var r, i, o = e.doc, l = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), a = t; a > l; --a) { if (a <= o.first) { return o.first } const s = Ye(o, a - 1); const u = s.stateAfter; if (u && (!n || a + (u instanceof pt ? u.lookAhead : 0) <= o.modeFrontier)) { return a } const c = I(s.text, null, e.options.tabSize); (i == null || r > c) && (i = a - 1, r = c) } return i } function Mt (e, t) { if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) { for (var n = e.first, r = t - 1; r > n; r--) { const i = Ye(e, r).stateAfter; if (i && (!(i instanceof pt) || r + i.lookAhead < t)) { n = r + 1; break } }e.highlightFrontier = Math.min(e.highlightFrontier, n) } } let Ot = !1; let At = !1; function Nt () { Ot = !0 } function Dt () { At = !0 } function Wt (e, t, n) { this.marker = e, this.from = t, this.to = n } function Ht (e, t) { if (e) { for (let n = 0; n < e.length; ++n) { const r = e[n]; if (r.marker == t) { return r } } } } function Et (e, t) { for (var n, r = 0; r < e.length; ++r) { e[r] != t && (n || (n = [])).push(e[r]) } return n } function Ft (e, t) { e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e) } function Pt (e, t, n) { let r; if (e) { for (let i = 0; i < e.length; ++i) { const o = e[i]; const l = o.marker; const a = o.from == null || (l.inclusiveLeft ? o.from <= t : o.from < t); if (a || o.from == t && l.type == 'bookmark' && (!n || !o.marker.insertLeft)) { const s = o.to == null || (l.inclusiveRight ? o.to >= t : o.to > t); (r || (r = [])).push(new Wt(l, o.from, s ? null : o.to)) } } } return r } function zt (e, t, n) { let r; if (e) { for (let i = 0; i < e.length; ++i) { const o = e[i]; const l = o.marker; const a = o.to == null || (l.inclusiveRight ? o.to >= t : o.to > t); if (a || o.from == t && l.type == 'bookmark' && (!n || o.marker.insertLeft)) { const s = o.from == null || (l.inclusiveLeft ? o.from <= t : o.from < t); (r || (r = [])).push(new Wt(l, s ? null : o.from - t, o.to == null ? null : o.to - t)) } } } return r } function It (e, t) { if (t.full) { return null } const n = nt(e, t.from.line) && Ye(e, t.from.line).markedSpans; const r = nt(e, t.to.line) && Ye(e, t.to.line).markedSpans; if (!n && !r) { return null } const i = t.from.ch; const o = t.to.ch; const l = ot(t.from, t.to) == 0; let a = Pt(n, i, l); let s = zt(r, o, l); const u = t.text.length == 1; const c = q(t.text).length + (u ? i : 0); if (a) { for (let f = 0; f < a.length; ++f) { const h = a[f]; if (h.to == null) { const d = Ht(s, h.marker); d ? u && (h.to = d.to == null ? null : d.to + c) : h.to = i } } } if (s) { for (let p = 0; p < s.length; ++p) { const g = s[p]; if (g.to != null && (g.to += c), g.from == null) { const m = Ht(a, g.marker); m || (g.from = c, u && (a || (a = [])).push(g)) } else { g.from += c, u && (a || (a = [])).push(g) } } }a && (a = Rt(a)), s && s != a && (s = Rt(s)); const v = [a]; if (!u) { let y; const b = t.text.length - 2; if (b > 0 && a) { for (let w = 0; w < a.length; ++w) { a[w].to == null && (y || (y = [])).push(new Wt(a[w].marker, null, null)) } } for (let x = 0; x < b; ++x) { v.push(y) }v.push(s) } return v } function Rt (e) { for (let t = 0; t < e.length; ++t) { const n = e[t]; n.from != null && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1) } return e.length ? e : null } function Bt (e, t, n) { let r = null; if (e.iter(t.line, n.line + 1, function (e) { if (e.markedSpans) { for (let t = 0; t < e.markedSpans.length; ++t) { const n = e.markedSpans[t].marker; !n.readOnly || r && B(r, n) != -1 || (r || (r = [])).push(n) } } }), !r) { return null } for (var i = [{ from: t, to: n }], o = 0; o < r.length; ++o) { for (let l = r[o], a = l.find(0), s = 0; s < i.length; ++s) { const u = i[s]; if (!(ot(u.to, a.from) < 0 || ot(u.from, a.to) > 0)) { const c = [s, 1]; const f = ot(u.from, a.from); const h = ot(u.to, a.to); (f < 0 || !l.inclusiveLeft && !f) && c.push({ from: u.from, to: a.from }), (h > 0 || !l.inclusiveRight && !h) && c.push({ from: a.to, to: u.to }), i.splice.apply(i, c), s += c.length - 3 } } } return i } function jt (e) { const t = e.markedSpans; if (t) { for (let n = 0; n < t.length; ++n) { t[n].marker.detachLine(e) }e.markedSpans = null } } function Vt (e, t) { if (t) { for (let n = 0; n < t.length; ++n) { t[n].marker.attachLine(e) }e.markedSpans = t } } function Gt (e) { return e.inclusiveLeft ? -1 : 0 } function Ut (e) { return e.inclusiveRight ? 1 : 0 } function _t (e, t) { const n = e.lines.length - t.lines.length; if (n != 0) { return n } const r = e.find(); const i = t.find(); const o = ot(r.from, i.from) || Gt(e) - Gt(t); if (o) { return -o } const l = ot(r.to, i.to) || Ut(e) - Ut(t); return l || t.id - e.id } function Kt (e, t) { let n; const r = At && e.markedSpans; if (r) { for (let i = void 0, o = 0; o < r.length; ++o) { i = r[o], i.marker.collapsed && (t ? i.from : i.to) == null && (!n || _t(n, i.marker) < 0) && (n = i.marker) } } return n } function $t (e) { return Kt(e, !0) } function Xt (e) { return Kt(e, !1) } function qt (e, t) { let n; const r = At && e.markedSpans; if (r) { for (let i = 0; i < r.length; ++i) { const o = r[i]; o.marker.collapsed && (o.from == null || o.from < t) && (o.to == null || o.to > t) && (!n || _t(n, o.marker) < 0) && (n = o.marker) } } return n } function Yt (e, t, n, r, i) { const o = Ye(e, t); const l = At && o.markedSpans; if (l) { for (let a = 0; a < l.length; ++a) { const s = l[a]; if (s.marker.collapsed) { const u = s.marker.find(0); const c = ot(u.from, n) || Gt(s.marker) - Gt(i); const f = ot(u.to, r) || Ut(s.marker) - Ut(i); if (!(c >= 0 && f <= 0 || c <= 0 && f >= 0) && (c <= 0 && (s.marker.inclusiveRight && i.inclusiveLeft ? ot(u.to, n) >= 0 : ot(u.to, n) > 0) || c >= 0 && (s.marker.inclusiveRight && i.inclusiveLeft ? ot(u.from, r) <= 0 : ot(u.from, r) < 0))) { return !0 } } } } } function Zt (e) { let t; while (t = $t(e)) { e = t.find(-1, !0).line } return e } function Jt (e) { let t; while (t = Xt(e)) { e = t.find(1, !0).line } return e } function Qt (e) { let t, n; while (t = Xt(e)) { e = t.find(1, !0).line, (n || (n = [])).push(e) } return n } function en (e, t) { const n = Ye(e, t); const r = Zt(n); return n == r ? t : et(r) } function tn (e, t) { if (t > e.lastLine()) { return t } let n; let r = Ye(e, t); if (!nn(e, r)) { return t } while (n = Xt(r)) { r = n.find(1, !0).line } return et(r) + 1 } function nn (e, t) { const n = At && t.markedSpans; if (n) { for (let r = void 0, i = 0; i < n.length; ++i) { if (r = n[i], r.marker.collapsed) { if (r.from == null) { return !0 } if (!r.marker.widgetNode && r.from == 0 && r.marker.inclusiveLeft && rn(e, t, r)) { return !0 } } } } } function rn (e, t, n) { if (n.to == null) { const r = n.marker.find(1, !0); return rn(e, r.line, Ht(r.line.markedSpans, n.marker)) } if (n.marker.inclusiveRight && n.to == t.text.length) { return !0 } for (let i = void 0, o = 0; o < t.markedSpans.length; ++o) { if (i = t.markedSpans[o], i.marker.collapsed && !i.marker.widgetNode && i.from == n.to && (i.to == null || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && rn(e, t, i)) { return !0 } } } function on (e) { e = Zt(e); for (var t = 0, n = e.parent, r = 0; r < n.lines.length; ++r) { const i = n.lines[r]; if (i == e) { break } t += i.height } for (let o = n.parent; o; n = o, o = n.parent) { for (let l = 0; l < o.children.length; ++l) { const a = o.children[l]; if (a == n) { break } t += a.height } } return t } function ln (e) { if (e.height == 0) { return 0 } let t; let n = e.text.length; let r = e; while (t = $t(r)) { const i = t.find(0, !0); r = i.from.line, n += i.from.ch - i.to.ch }r = e; while (t = Xt(r)) { const o = t.find(0, !0); n -= r.text.length - o.from.ch, r = o.to.line, n += r.text.length - o.to.ch } return n } function an (e) { const t = e.display; const n = e.doc; t.maxLine = Ye(n, n.first), t.maxLineLength = ln(t.maxLine), t.maxLineChanged = !0, n.iter(function (e) { const n = ln(e); n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e) }) } const sn = function (e, t, n) { this.text = e, Vt(this, t), this.height = n ? n(this) : 1 }; function un (e, t, n, r) { e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), e.order != null && (e.order = null), jt(e), Vt(e, n); const i = r ? r(e) : 1; i != e.height && Qe(e, i) } function cn (e) { e.parent = null, jt(e) }sn.prototype.lineNo = function () { return et(this) }, xe(sn); const fn = {}; const hn = {}; function dn (e, t) { if (!e || /^\s*$/.test(e)) { return null } const n = t.addModeClass ? hn : fn; return n[e] || (n[e] = e.replace(/\S+/g, 'cm-$&')) } function pn (e, t) { const n = N('span', null, null, s ? 'padding-right: .1px' : null); const r = { pre: N('pre', [n], 'CodeMirror-line'), content: n, col: 0, pos: 0, cm: e, trailingSpace: !1, splitSpaces: e.getOption('lineWrapping') }; t.measure = {}; for (let i = 0; i <= (t.rest ? t.rest.length : 0); i++) { const o = i ? t.rest[i - 1] : t.line; let l = void 0; r.pos = 0, r.addToken = mn, We(e.display.measure) && (l = he(o, e.doc.direction)) && (r.addToken = yn(r.addToken, l)), r.map = []; const a = t != e.display.externalMeasured && et(o); wn(o, r, vt(e, o, a)), o.styleClasses && (o.styleClasses.bgClass && (r.bgClass = E(o.styleClasses.bgClass, r.bgClass || '')), o.styleClasses.textClass && (r.textClass = E(o.styleClasses.textClass, r.textClass || ''))), r.map.length == 0 && r.map.push(0, 0, r.content.appendChild(De(e.display.measure))), i == 0 ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({})) } if (s) { const u = r.content.lastChild; (/\bcm-tab\b/.test(u.className) || u.querySelector && u.querySelector('.cm-tab')) && (r.content.className = 'cm-tab-wrap-hack') } return ve(e, 'renderLine', e, t.line, r.pre), r.pre.className && (r.textClass = E(r.pre.className, r.textClass || '')), r } function gn (e) { const t = A('span', '•', 'cm-invalidchar'); return t.title = '\\u' + e.charCodeAt(0).toString(16), t.setAttribute('aria-label', t.title), t } function mn (e, t, n, r, i, o, s) { if (t) { let u; const c = e.splitSpaces ? vn(t, e.trailingSpace) : t; const f = e.cm.state.specialChars; let h = !1; if (f.test(t)) { u = document.createDocumentFragment(); let d = 0; while (1) { f.lastIndex = d; const p = f.exec(t); const g = p ? p.index - d : t.length - d; if (g) { const m = document.createTextNode(c.slice(d, d + g)); l && a < 9 ? u.appendChild(A('span', [m])) : u.appendChild(m), e.map.push(e.pos, e.pos + g, m), e.col += g, e.pos += g } if (!p) { break } d += g + 1; let v = void 0; if (p[0] == '\t') { const y = e.cm.options.tabSize; const b = y - e.col % y; v = u.appendChild(A('span', X(b), 'cm-tab')), v.setAttribute('role', 'presentation'), v.setAttribute('cm-text', '\t'), e.col += b } else { p[0] == '\r' || p[0] == '\n' ? (v = u.appendChild(A('span', p[0] == '\r' ? '␍' : '␤', 'cm-invalidchar')), v.setAttribute('cm-text', p[0]), e.col += 1) : (v = e.cm.options.specialCharPlaceholder(p[0]), v.setAttribute('cm-text', p[0]), l && a < 9 ? u.appendChild(A('span', [v])) : u.appendChild(v), e.col += 1) } e.map.push(e.pos, e.pos + 1, v), e.pos++ } } else { e.col += t.length, u = document.createTextNode(c), e.map.push(e.pos, e.pos + t.length, u), l && a < 9 && (h = !0), e.pos += t.length } if (e.trailingSpace = c.charCodeAt(t.length - 1) == 32, n || r || i || h || o) { let w = n || ''; r && (w += r), i && (w += i); const x = A('span', [u], w, o); if (s) { for (const C in s) { s.hasOwnProperty(C) && C != 'style' && C != 'class' && x.setAttribute(C, s[C]) } } return e.content.appendChild(x) }e.content.appendChild(u) } } function vn (e, t) { if (e.length > 1 && !/ {2}/.test(e)) { return e } for (var n = t, r = '', i = 0; i < e.length; i++) { let o = e.charAt(i); o != ' ' || !n || i != e.length - 1 && e.charCodeAt(i + 1) != 32 || (o = ' '), r += o, n = o == ' ' } return r } function yn (e, t) { return function (n, r, i, o, l, a, s) { i = i ? i + ' cm-force-border' : 'cm-force-border'; for (let u = n.pos, c = u + r.length; ;) { for (var f = void 0, h = 0; h < t.length; h++) { if (f = t[h], f.to > u && f.from <= u) { break } } if (f.to >= c) { return e(n, r, i, o, l, a, s) } e(n, r.slice(0, f.to - u), i, o, null, a, s), o = null, r = r.slice(f.to - u), u = f.to } } } function bn (e, t, n, r) { let i = !r && n.widgetNode; i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i || (i = e.content.appendChild(document.createElement('span'))), i.setAttribute('cm-marker', n.id)), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t, e.trailingSpace = !1 } function wn (e, t, n) { const r = e.markedSpans; const i = e.text; let o = 0; if (r) { for (var l, a, s, u, c, f, h, d = i.length, p = 0, g = 1, m = '', v = 0; ;) { if (v == p) { s = u = c = a = '', h = null, f = null, v = 1 / 0; for (var y = [], b = void 0, w = 0; w < r.length; ++w) { const x = r[w]; const C = x.marker; if (C.type == 'bookmark' && x.from == p && C.widgetNode) { y.push(C) } else if (x.from <= p && (x.to == null || x.to > p || C.collapsed && x.to == p && x.from == p)) { if (x.to != null && x.to != p && v > x.to && (v = x.to, u = ''), C.className && (s += ' ' + C.className), C.css && (a = (a ? a + ';' : '') + C.css), C.startStyle && x.from == p && (c += ' ' + C.startStyle), C.endStyle && x.to == v && (b || (b = [])).push(C.endStyle, x.to), C.title && ((h || (h = {})).title = C.title), C.attributes) { for (const k in C.attributes) { (h || (h = {}))[k] = C.attributes[k] } }C.collapsed && (!f || _t(f.marker, C) < 0) && (f = x) } else { x.from > p && v > x.from && (v = x.from) } } if (b) { for (let S = 0; S < b.length; S += 2) { b[S + 1] == v && (u += ' ' + b[S]) } } if (!f || f.from == p) { for (let L = 0; L < y.length; ++L) { bn(t, 0, y[L]) } } if (f && (f.from || 0) == p) { if (bn(t, (f.to == null ? d + 1 : f.to) - p, f.marker, f.from == null), f.to == null) { return } f.to == p && (f = !1) } } if (p >= d) { break } const T = Math.min(d, v); while (1) { if (m) { const M = p + m.length; if (!f) { const O = M > T ? m.slice(0, T - p) : m; t.addToken(t, O, l ? l + s : s, c, p + O.length == v ? u : '', a, h) } if (M >= T) { m = m.slice(T - p), p = T; break }p = M, c = '' }m = i.slice(o, o = n[g++]), l = dn(n[g++], t.cm.options) } } } else { for (let A = 1; A < n.length; A += 2) { t.addToken(t, i.slice(o, o = n[A]), dn(n[A + 1], t.cm.options)) } } } function xn (e, t, n) { this.line = t, this.rest = Qt(t), this.size = this.rest ? et(q(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = nn(e, t) } function Cn (e, t, n) { for (var r, i = [], o = t; o < n; o = r) { const l = new xn(e.doc, Ye(e.doc, o), o); r = o + l.size, i.push(l) } return i } let kn = null; function Sn (e) { kn ? kn.ops.push(e) : e.ownsGroup = kn = { ops: [e], delayedCallbacks: [] } } function Ln (e) { const t = e.delayedCallbacks; let n = 0; do { for (;n < t.length; n++) { t[n].call(null) } for (let r = 0; r < e.ops.length; r++) { const i = e.ops[r]; if (i.cursorActivityHandlers) { while (i.cursorActivityCalled < i.cursorActivityHandlers.length) { i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm) } } } } while (n < t.length) } function Tn (e, t) { const n = e.ownsGroup; if (n) { try { Ln(n) } finally { kn = null, t(n) } } } let Mn = null; function On (e, t) { const n = ge(e, t); if (n.length) { let r; const i = Array.prototype.slice.call(arguments, 2); kn ? r = kn.delayedCallbacks : Mn ? r = Mn : (r = Mn = [], setTimeout(An, 0)); for (let o = function (e) { r.push(function () { return n[e].apply(null, i) }) }, l = 0; l < n.length; ++l) { o(l) } } } function An () { const e = Mn; Mn = null; for (let t = 0; t < e.length; ++t) { e[t]() } } function Nn (e, t, n, r) { for (let i = 0; i < t.changes.length; i++) { const o = t.changes[i]; o == 'text' ? En(e, t) : o == 'gutter' ? Pn(e, t, n, r) : o == 'class' ? Fn(e, t) : o == 'widget' && zn(e, t, r) }t.changes = null } function Dn (e) { return e.node == e.text && (e.node = A('div', null, null, 'position: relative'), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), l && a < 8 && (e.node.style.zIndex = 2)), e.node } function Wn (e, t) { let n = t.bgClass ? t.bgClass + ' ' + (t.line.bgClass || '') : t.line.bgClass; if (n && (n += ' CodeMirror-linebackground'), t.background) { n ? t.background.className = n : (t.background.parentNode.removeChild(t.background), t.background = null) } else if (n) { const r = Dn(t); t.background = r.insertBefore(A('div', null, n), r.firstChild), e.display.input.setUneditable(t.background) } } function Hn (e, t) { const n = e.display.externalMeasured; return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : pn(e, t) } function En (e, t) { const n = t.text.className; const r = Hn(e, t); t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, Fn(e, t)) : n && (t.text.className = n) } function Fn (e, t) { Wn(e, t), t.line.wrapClass ? Dn(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = ''); const n = t.textClass ? t.textClass + ' ' + (t.line.textClass || '') : t.line.textClass; t.text.className = n || '' } function Pn (e, t, n, r) { if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) { const i = Dn(t); t.gutterBackground = A('div', null, 'CodeMirror-gutter-background ' + t.line.gutterClass, 'left: ' + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + 'px; width: ' + r.gutterTotalWidth + 'px'), e.display.input.setUneditable(t.gutterBackground), i.insertBefore(t.gutterBackground, t.text) } const o = t.line.gutterMarkers; if (e.options.lineNumbers || o) { const l = Dn(t); const a = t.gutter = A('div', null, 'CodeMirror-gutter-wrapper', 'left: ' + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + 'px'); if (e.display.input.setUneditable(a), l.insertBefore(a, t.text), t.line.gutterClass && (a.className += ' ' + t.line.gutterClass), !e.options.lineNumbers || o && o['CodeMirror-linenumbers'] || (t.lineNumber = a.appendChild(A('div', rt(e.options, n), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + r.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + e.display.lineNumInnerWidth + 'px'))), o) { for (let s = 0; s < e.display.gutterSpecs.length; ++s) { const u = e.display.gutterSpecs[s].className; const c = o.hasOwnProperty(u) && o[u]; c && a.appendChild(A('div', [c], 'CodeMirror-gutter-elt', 'left: ' + r.gutterLeft[u] + 'px; width: ' + r.gutterWidth[u] + 'px')) } } } } function zn (e, t, n) { t.alignable && (t.alignable = null); for (let r = S('CodeMirror-linewidget'), i = t.node.firstChild, o = void 0; i; i = o) { o = i.nextSibling, r.test(i.className) && t.node.removeChild(i) }Rn(e, t, n) } function In (e, t, n, r) { const i = Hn(e, t); return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), Fn(e, t), Pn(e, t, n, r), Rn(e, t, r), t.node } function Rn (e, t, n) { if (Bn(e, t.line, t, n, !0), t.rest) { for (let r = 0; r < t.rest.length; r++) { Bn(e, t.rest[r], t, n, !1) } } } function Bn (e, t, n, r, i) { if (t.widgets) { for (let o = Dn(n), l = 0, a = t.widgets; l < a.length; ++l) { const s = a[l]; const u = A('div', [s.node], 'CodeMirror-linewidget' + (s.className ? ' ' + s.className : '')); s.handleMouseEvents || u.setAttribute('cm-ignore-events', 'true'), jn(s, u, n, r), e.display.input.setUneditable(u), i && s.above ? o.insertBefore(u, n.gutter || n.text) : o.appendChild(u), On(s, 'redraw') } } } function jn (e, t, n, r) { if (e.noHScroll) { (n.alignable || (n.alignable = [])).push(t); let i = r.wrapperWidth; t.style.left = r.fixedPos + 'px', e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + 'px'), t.style.width = i + 'px' }e.coverGutter && (t.style.zIndex = 5, t.style.position = 'relative', e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + 'px')) } function Vn (e) { if (e.height != null) { return e.height } const t = e.doc.cm; if (!t) { return 0 } if (!D(document.body, e.node)) { let n = 'position: relative;'; e.coverGutter && (n += 'margin-left: -' + t.display.gutters.offsetWidth + 'px;'), e.noHScroll && (n += 'width: ' + t.display.wrapper.clientWidth + 'px;'), O(t.display.measure, A('div', [e.node], null, n)) } return e.height = e.node.parentNode.offsetHeight } function Gn (e, t) { for (let n = Te(t); n != e.wrapper; n = n.parentNode) { if (!n || n.nodeType == 1 && n.getAttribute('cm-ignore-events') == 'true' || n.parentNode == e.sizer && n != e.mover) { return !0 } } } function Un (e) { return e.lineSpace.offsetTop } function _n (e) { return e.mover.offsetHeight - e.lineSpace.offsetHeight } function Kn (e) { if (e.cachedPaddingH) { return e.cachedPaddingH } const t = O(e.measure, A('pre', 'x', 'CodeMirror-line-like')); const n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle; const r = { left: parseInt(n.paddingLeft), right: parseInt(n.paddingRight) }; return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r } function $n (e) { return j - e.display.nativeBarWidth } function Xn (e) { return e.display.scroller.clientWidth - $n(e) - e.display.barWidth } function qn (e) { return e.display.scroller.clientHeight - $n(e) - e.display.barHeight } function Yn (e, t, n) { const r = e.options.lineWrapping; const i = r && Xn(e); if (!t.measure.heights || r && t.measure.width != i) { const o = t.measure.heights = []; if (r) { t.measure.width = i; for (let l = t.text.firstChild.getClientRects(), a = 0; a < l.length - 1; a++) { const s = l[a]; const u = l[a + 1]; Math.abs(s.bottom - u.bottom) > 2 && o.push((s.bottom + u.top) / 2 - n.top) } }o.push(n.bottom - n.top) } } function Zn (e, t, n) { if (e.line == t) { return { map: e.measure.map, cache: e.measure.cache } } for (let r = 0; r < e.rest.length; r++) { if (e.rest[r] == t) { return { map: e.measure.maps[r], cache: e.measure.caches[r] } } } for (let i = 0; i < e.rest.length; i++) { if (et(e.rest[i]) > n) { return { map: e.measure.maps[i], cache: e.measure.caches[i], before: !0 } } } } function Jn (e, t) { t = Zt(t); const n = et(t); const r = e.display.externalMeasured = new xn(e.doc, t, n); r.lineN = n; const i = r.built = pn(e, r); return r.text = i.pre, O(e.display.lineMeasure, i.pre), r } function Qn (e, t, n, r) { return nr(e, tr(e, t), n, r) } function er (e, t) { if (t >= e.display.viewFrom && t < e.display.viewTo) { return e.display.view[Fr(e, t)] } const n = e.display.externalMeasured; return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0 } function tr (e, t) { const n = et(t); let r = er(e, n); r && !r.text ? r = null : r && r.changes && (Nn(e, r, n, Nr(e)), e.curOp.forceUpdate = !0), r || (r = Jn(e, t)); const i = Zn(r, t, n); return { line: t, view: r, rect: null, map: i.map, cache: i.cache, before: i.before, hasHeights: !1 } } function nr (e, t, n, r, i) { t.before && (n = -1); let o; const l = n + (r || ''); return t.cache.hasOwnProperty(l) ? o = t.cache[l] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (Yn(e, t.view, t.rect), t.hasHeights = !0), o = ar(e, t, n, r), o.bogus || (t.cache[l] = o)), { left: o.left, right: o.right, top: i ? o.rtop : o.top, bottom: i ? o.rbottom : o.bottom } } let rr; const ir = { left: 0, right: 0, top: 0, bottom: 0 }; function or (e, t, n) { for (var r, i, o, l, a, s, u = 0; u < e.length; u += 3) { if (a = e[u], s = e[u + 1], t < a ? (i = 0, o = 1, l = 'left') : t < s ? (i = t - a, o = i + 1) : (u == e.length - 3 || t == s && e[u + 3] > t) && (o = s - a, i = o - 1, t >= s && (l = 'right')), i != null) { if (r = e[u + 2], a == s && n == (r.insertLeft ? 'left' : 'right') && (l = n), n == 'left' && i == 0) { while (u && e[u - 2] == e[u - 3] && e[u - 1].insertLeft) { r = e[2 + (u -= 3)], l = 'left' } } if (n == 'right' && i == s - a) { while (u < e.length - 3 && e[u + 3] == e[u + 4] && !e[u + 5].insertLeft) { r = e[(u += 3) + 2], l = 'right' } } break } } return { node: r, start: i, end: o, collapse: l, coverStart: a, coverEnd: s } } function lr (e, t) { let n = ir; if (t == 'left') { for (let r = 0; r < e.length; r++) { if ((n = e[r]).left != n.right) { break } } } else { for (let i = e.length - 1; i >= 0; i--) { if ((n = e[i]).left != n.right) { break } } } return n } function ar (e, t, n, r) { let i; const o = or(t.map, n, r); const s = o.node; let u = o.start; let c = o.end; let f = o.collapse; if (s.nodeType == 3) { for (let h = 0; h < 4; h++) { while (u && oe(t.line.text.charAt(o.coverStart + u))) { --u } while (o.coverStart + c < o.coverEnd && oe(t.line.text.charAt(o.coverStart + c))) { ++c } if (i = l && a < 9 && u == 0 && c == o.coverEnd - o.coverStart ? s.parentNode.getBoundingClientRect() : lr(L(s, u, c).getClientRects(), r), i.left || i.right || u == 0) { break } c = u, u -= 1, f = 'right' }l && a < 11 && (i = sr(e.display.measure, i)) } else { let d; u > 0 && (f = r = 'right'), i = e.options.lineWrapping && (d = s.getClientRects()).length > 1 ? d[r == 'right' ? d.length - 1 : 0] : s.getBoundingClientRect() } if (l && a < 9 && !u && (!i || !i.left && !i.right)) { const p = s.parentNode.getClientRects()[0]; i = p ? { left: p.left, right: p.left + Ar(e.display), top: p.top, bottom: p.bottom } : ir } for (var g = i.top - t.rect.top, m = i.bottom - t.rect.top, v = (g + m) / 2, y = t.view.measure.heights, b = 0; b < y.length - 1; b++) { if (v < y[b]) { break } } const w = b ? y[b - 1] : 0; const x = y[b]; const C = { left: (f == 'right' ? i.right : i.left) - t.rect.left, right: (f == 'left' ? i.left : i.right) - t.rect.left, top: w, bottom: x }; return i.left || i.right || (C.bogus = !0), e.options.singleCursorHeightPerLine || (C.rtop = g, C.rbottom = m), C } function sr (e, t) { if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !ze(e)) { return t } const n = screen.logicalXDPI / screen.deviceXDPI; const r = screen.logicalYDPI / screen.deviceYDPI; return { left: t.left * n, right: t.right * n, top: t.top * r, bottom: t.bottom * r } } function ur (e) { if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest)) { for (let t = 0; t < e.rest.length; t++) { e.measure.caches[t] = {} } } } function cr (e) { e.display.externalMeasure = null, M(e.display.lineMeasure); for (let t = 0; t < e.display.view.length; t++) { ur(e.display.view[t]) } } function fr (e) { cr(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null } function hr () { return c && m ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft } function dr () { return c && m ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop } function pr (e) { let t = 0; if (e.widgets) { for (let n = 0; n < e.widgets.length; ++n) { e.widgets[n].above && (t += Vn(e.widgets[n])) } } return t } function gr (e, t, n, r, i) { if (!i) { const o = pr(t); n.top += o, n.bottom += o } if (r == 'line') { return n } r || (r = 'local'); let l = on(t); if (r == 'local' ? l += Un(e.display) : l -= e.display.viewOffset, r == 'page' || r == 'window') { const a = e.display.lineSpace.getBoundingClientRect(); l += a.top + (r == 'window' ? 0 : dr()); const s = a.left + (r == 'window' ? 0 : hr()); n.left += s, n.right += s } return n.top += l, n.bottom += l, n } function mr (e, t, n) { if (n == 'div') { return t } let r = t.left; let i = t.top; if (n == 'page') { r -= hr(), i -= dr() } else if (n == 'local' || !n) { const o = e.display.sizer.getBoundingClientRect(); r += o.left, i += o.top } const l = e.display.lineSpace.getBoundingClientRect(); return { left: r - l.left, top: i - l.top } } function vr (e, t, n, r, i) { return r || (r = Ye(e.doc, t.line)), gr(e, r, Qn(e, r, t.ch, i), n) } function yr (e, t, n, r, i, o) { function l (t, l) { const a = nr(e, i, t, l ? 'right' : 'left', o); return l ? a.left = a.right : a.right = a.left, gr(e, r, a, n) }r = r || Ye(e.doc, t.line), i || (i = tr(e, r)); const a = he(r, e.doc.direction); let s = t.ch; let u = t.sticky; if (s >= r.text.length ? (s = r.text.length, u = 'before') : s <= 0 && (s = 0, u = 'after'), !a) { return l(u == 'before' ? s - 1 : s, u == 'before') } function c (e, t, n) { const r = a[t]; const i = r.level == 1; return l(n ? e - 1 : e, i != n) } const f = ce(a, s, u); const h = ue; const d = c(s, f, u == 'before'); return h != null && (d.other = c(s, h, u != 'before')), d } function br (e, t) { let n = 0; t = ft(e.doc, t), e.options.lineWrapping || (n = Ar(e.display) * t.ch); const r = Ye(e.doc, t.line); const i = on(r) + Un(e.display); return { left: n, right: n, top: i, bottom: i + r.height } } function wr (e, t, n, r, i) { const o = it(e, t, n); return o.xRel = i, r && (o.outside = r), o } function xr (e, t, n) { const r = e.doc; if (n += e.display.viewOffset, n < 0) { return wr(r.first, 0, null, -1, -1) } let i = tt(r, n); const o = r.first + r.size - 1; if (i > o) { return wr(r.first + r.size - 1, Ye(r, o).text.length, null, 1, 1) } t < 0 && (t = 0); for (let l = Ye(r, i); ;) { const a = Lr(e, l, i, t, n); const s = qt(l, a.ch + (a.xRel > 0 || a.outside > 0 ? 1 : 0)); if (!s) { return a } const u = s.find(1); if (u.line == i) { return u } l = Ye(r, i = u.line) } } function Cr (e, t, n, r) { r -= pr(t); let i = t.text.length; const o = ae(function (t) { return nr(e, n, t - 1).bottom <= r }, i, 0); return i = ae(function (t) { return nr(e, n, t).top > r }, o, i), { begin: o, end: i } } function kr (e, t, n, r) { n || (n = tr(e, t)); const i = gr(e, t, nr(e, n, r), 'line').top; return Cr(e, t, n, i) } function Sr (e, t, n, r) { return !(e.bottom <= n) && (e.top > n || (r ? e.left : e.right) > t) } function Lr (e, t, n, r, i) { i -= on(t); const o = tr(e, t); const l = pr(t); let a = 0; let s = t.text.length; let u = !0; const c = he(t, e.doc.direction); if (c) { const f = (e.options.lineWrapping ? Mr : Tr)(e, t, n, o, c, r, i); u = f.level != 1, a = u ? f.from : f.to - 1, s = u ? f.to : f.from - 1 } let h; let d; let p = null; let g = null; let m = ae(function (t) { const n = nr(e, o, t); return n.top += l, n.bottom += l, !!Sr(n, r, i, !1) && (n.top <= i && n.left <= r && (p = t, g = n), !0) }, a, s); let v = !1; if (g) { const y = r - g.left < g.right - r; const b = y == u; m = p + (b ? 0 : 1), d = b ? 'after' : 'before', h = y ? g.left : g.right } else { u || m != s && m != a || m++, d = m == 0 ? 'after' : m == t.text.length ? 'before' : nr(e, o, m - (u ? 1 : 0)).bottom + l <= i == u ? 'after' : 'before'; const w = yr(e, it(n, m, d), 'line', t, o); h = w.left, v = i < w.top ? -1 : i >= w.bottom ? 1 : 0 } return m = le(t.text, m, 1), wr(n, m, d, v, r - h) } function Tr (e, t, n, r, i, o, l) { const a = ae(function (a) { const s = i[a]; const u = s.level != 1; return Sr(yr(e, it(n, u ? s.to : s.from, u ? 'before' : 'after'), 'line', t, r), o, l, !0) }, 0, i.length - 1); let s = i[a]; if (a > 0) { const u = s.level != 1; const c = yr(e, it(n, u ? s.from : s.to, u ? 'after' : 'before'), 'line', t, r); Sr(c, o, l, !0) && c.top > l && (s = i[a - 1]) } return s } function Mr (e, t, n, r, i, o, l) { const a = Cr(e, t, r, l); const s = a.begin; let u = a.end; /\s/.test(t.text.charAt(u - 1)) && u--; for (var c = null, f = null, h = 0; h < i.length; h++) { const d = i[h]; if (!(d.from >= u || d.to <= s)) { const p = d.level != 1; const g = nr(e, r, p ? Math.min(u, d.to) - 1 : Math.max(s, d.from)).right; const m = g < o ? o - g + 1e9 : g - o; (!c || f > m) && (c = d, f = m) } } return c || (c = i[i.length - 1]), c.from < s && (c = { from: s, to: c.to, level: c.level }), c.to > u && (c = { from: c.from, to: u, level: c.level }), c } function Or (e) { if (e.cachedTextHeight != null) { return e.cachedTextHeight } if (rr == null) { rr = A('pre', null, 'CodeMirror-line-like'); for (let t = 0; t < 49; ++t) { rr.appendChild(document.createTextNode('x')), rr.appendChild(A('br')) }rr.appendChild(document.createTextNode('x')) }O(e.measure, rr); const n = rr.offsetHeight / 50; return n > 3 && (e.cachedTextHeight = n), M(e.measure), n || 1 } function Ar (e) { if (e.cachedCharWidth != null) { return e.cachedCharWidth } const t = A('span', 'xxxxxxxxxx'); const n = A('pre', [t], 'CodeMirror-line-like'); O(e.measure, n); const r = t.getBoundingClientRect(); const i = (r.right - r.left) / 10; return i > 2 && (e.cachedCharWidth = i), i || 10 } function Nr (e) { for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, l = 0; o; o = o.nextSibling, ++l) { const a = e.display.gutterSpecs[l].className; n[a] = o.offsetLeft + o.clientLeft + i, r[a] = o.clientWidth } return { fixedPos: Dr(t), gutterTotalWidth: t.gutters.offsetWidth, gutterLeft: n, gutterWidth: r, wrapperWidth: t.wrapper.clientWidth } } function Dr (e) { return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left } function Wr (e) { const t = Or(e.display); const n = e.options.lineWrapping; const r = n && Math.max(5, e.display.scroller.clientWidth / Ar(e.display) - 3); return function (i) { if (nn(e.doc, i)) { return 0 } let o = 0; if (i.widgets) { for (let l = 0; l < i.widgets.length; l++) { i.widgets[l].height && (o += i.widgets[l].height) } } return n ? o + (Math.ceil(i.text.length / r) || 1) * t : o + t } } function Hr (e) { const t = e.doc; const n = Wr(e); t.iter(function (e) { const t = n(e); t != e.height && Qe(e, t) }) } function Er (e, t, n, r) { const i = e.display; if (!n && Te(t).getAttribute('cm-not-content') == 'true') { return null } let o; let l; const a = i.lineSpace.getBoundingClientRect(); try { o = t.clientX - a.left, l = t.clientY - a.top } catch (t) { return null } let s; let u = xr(e, o, l); if (r && u.xRel > 0 && (s = Ye(e.doc, u.line).text).length == u.ch) { const c = I(s, s.length, e.options.tabSize) - s.length; u = it(u.line, Math.max(0, Math.round((o - Kn(e.display).left) / Ar(e.display)) - c)) } return u } function Fr (e, t) { if (t >= e.display.viewTo) { return null } if (t -= e.display.viewFrom, t < 0) { return null } for (let n = e.display.view, r = 0; r < n.length; r++) { if (t -= n[r].size, t < 0) { return r } } } function Pr (e, t, n, r) { t == null && (t = e.doc.first), n == null && (n = e.doc.first + e.doc.size), r || (r = 0); const i = e.display; if (r && n < i.viewTo && (i.updateLineNumbers == null || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo) { At && en(e.doc, t) < i.viewTo && Ir(e) } else if (n <= i.viewFrom) { At && tn(e.doc, n + r) > i.viewFrom ? Ir(e) : (i.viewFrom += r, i.viewTo += r) } else if (t <= i.viewFrom && n >= i.viewTo) { Ir(e) } else if (t <= i.viewFrom) { const o = Rr(e, n, n + r, 1); o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : Ir(e) } else if (n >= i.viewTo) { const l = Rr(e, t, t, -1); l ? (i.view = i.view.slice(0, l.index), i.viewTo = l.lineN) : Ir(e) } else { const a = Rr(e, t, t, -1); const s = Rr(e, n, n + r, 1); a && s ? (i.view = i.view.slice(0, a.index).concat(Cn(e, a.lineN, s.lineN)).concat(i.view.slice(s.index)), i.viewTo += r) : Ir(e) } const u = i.externalMeasured; u && (n < u.lineN ? u.lineN += r : t < u.lineN + u.size && (i.externalMeasured = null)) } function zr (e, t, n) { e.curOp.viewChanged = !0; const r = e.display; const i = e.display.externalMeasured; if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) { const o = r.view[Fr(e, t)]; if (o.node != null) { const l = o.changes || (o.changes = []); B(l, n) == -1 && l.push(n) } } } function Ir (e) { e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0 } function Rr (e, t, n, r) { let i; let o = Fr(e, t); const l = e.display.view; if (!At || n == e.doc.first + e.doc.size) { return { index: o, lineN: n } } for (var a = e.display.viewFrom, s = 0; s < o; s++) { a += l[s].size } if (a != t) { if (r > 0) { if (o == l.length - 1) { return null } i = a + l[o].size - t, o++ } else { i = a - t }t += i, n += i } while (en(e.doc, n) != n) { if (o == (r < 0 ? 0 : l.length - 1)) { return null } n += r * l[o - (r < 0 ? 1 : 0)].size, o += r } return { index: o, lineN: n } } function Br (e, t, n) { const r = e.display; const i = r.view; i.length == 0 || t >= r.viewTo || n <= r.viewFrom ? (r.view = Cn(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = Cn(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(Fr(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(Cn(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, Fr(e, n)))), r.viewTo = n } function jr (e) { for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) { const i = t[r]; i.hidden || i.node && !i.changes || ++n } return n } function Vr (e) { e.display.input.showSelection(e.display.input.prepareSelection()) } function Gr (e, t) { void 0 === t && (t = !0); for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), l = 0; l < n.sel.ranges.length; l++) { if (t || l != n.sel.primIndex) { const a = n.sel.ranges[l]; if (!(a.from().line >= e.display.viewTo || a.to().line < e.display.viewFrom)) { const s = a.empty(); (s || e.options.showCursorWhenSelecting) && Ur(e, a.head, i), s || Kr(e, a, o) } } } return r } function Ur (e, t, n) { const r = yr(e, t, 'div', null, null, !e.options.singleCursorHeightPerLine); const i = n.appendChild(A('div', ' ', 'CodeMirror-cursor')); if (i.style.left = r.left + 'px', i.style.top = r.top + 'px', i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + 'px', r.other) { const o = n.appendChild(A('div', ' ', 'CodeMirror-cursor CodeMirror-secondarycursor')); o.style.display = '', o.style.left = r.other.left + 'px', o.style.top = r.other.top + 'px', o.style.height = 0.85 * (r.other.bottom - r.other.top) + 'px' } } function _r (e, t) { return e.top - t.top || e.left - t.left } function Kr (e, t, n) { const r = e.display; const i = e.doc; const o = document.createDocumentFragment(); const l = Kn(e.display); const a = l.left; const s = Math.max(r.sizerWidth, Xn(e) - r.sizer.offsetLeft) - l.right; const u = i.direction == 'ltr'; function c (e, t, n, r) { t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), o.appendChild(A('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + e + 'px;\n                             top: ' + t + 'px; width: ' + (n == null ? s - e : n) + 'px;\n                             height: ' + (r - t) + 'px')) } function f (t, n, r) { let o; let l; const f = Ye(i, t); const h = f.text.length; function d (n, r) { return vr(e, it(t, n), 'div', f, r) } function p (t, n, r) { const i = kr(e, f, null, t); const o = n == 'ltr' == (r == 'after') ? 'left' : 'right'; const l = r == 'after' ? i.begin : i.end - (/\s/.test(f.text.charAt(i.end - 1)) ? 2 : 1); return d(l, o)[o] } const g = he(f, i.direction); return se(g, n || 0, r == null ? h : r, function (e, t, i, f) { const m = i == 'ltr'; const v = d(e, m ? 'left' : 'right'); const y = d(t - 1, m ? 'right' : 'left'); const b = n == null && e == 0; const w = r == null && t == h; const x = f == 0; const C = !g || f == g.length - 1; if (y.top - v.top <= 3) { const k = (u ? b : w) && x; const S = (u ? w : b) && C; const L = k ? a : (m ? v : y).left; const T = S ? s : (m ? y : v).right; c(L, v.top, T - L, v.bottom) } else { let M, O, A, N; m ? (M = u && b && x ? a : v.left, O = u ? s : p(e, i, 'before'), A = u ? a : p(t, i, 'after'), N = u && w && C ? s : y.right) : (M = u ? p(e, i, 'before') : a, O = !u && b && x ? s : v.right, A = !u && w && C ? a : y.left, N = u ? p(t, i, 'after') : s), c(M, v.top, O - M, v.bottom), v.bottom < y.top && c(a, v.bottom, null, y.top), c(A, y.top, N - A, y.bottom) }(!o || _r(v, o) < 0) && (o = v), _r(y, o) < 0 && (o = y), (!l || _r(v, l) < 0) && (l = v), _r(y, l) < 0 && (l = y) }), { start: o, end: l } } const h = t.from(); const d = t.to(); if (h.line == d.line) { f(h.line, h.ch, d.ch) } else { const p = Ye(i, h.line); const g = Ye(i, d.line); const m = Zt(p) == Zt(g); const v = f(h.line, h.ch, m ? p.text.length + 1 : null).end; const y = f(d.line, m ? 0 : null, d.ch).start; m && (v.top < y.top - 2 ? (c(v.right, v.top, null, v.bottom), c(a, y.top, y.left, y.bottom)) : c(v.right, v.top, y.left - v.right, v.bottom)), v.bottom < y.top && c(a, v.bottom, null, y.top) }n.appendChild(o) } function $r (e) { if (e.state.focused) { const t = e.display; clearInterval(t.blinker); let n = !0; t.cursorDiv.style.visibility = '', e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function () { return t.cursorDiv.style.visibility = (n = !n) ? '' : 'hidden' }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = 'hidden') } } function Xr (e) { e.state.focused || (e.display.input.focus(), Yr(e)) } function qr (e) { e.state.delayingBlurEvent = !0, setTimeout(function () { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, Zr(e)) }, 100) } function Yr (e, t) { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1), e.options.readOnly != 'nocursor' && (e.state.focused || (ve(e, 'focus', e, t), e.state.focused = !0, H(e.display.wrapper, 'CodeMirror-focused'), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), s && setTimeout(function () { return e.display.input.reset(!0) }, 20)), e.display.input.receivedFocus()), $r(e)) } function Zr (e, t) { e.state.delayingBlurEvent || (e.state.focused && (ve(e, 'blur', e, t), e.state.focused = !1, T(e.display.wrapper, 'CodeMirror-focused')), clearInterval(e.display.blinker), setTimeout(function () { e.state.focused || (e.display.shift = !1) }, 150)) } function Jr (e) { for (let t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) { const i = t.view[r]; const o = e.options.lineWrapping; let s = void 0; let u = 0; if (!i.hidden) { if (l && a < 8) { const c = i.node.offsetTop + i.node.offsetHeight; s = c - n, n = c } else { const f = i.node.getBoundingClientRect(); s = f.bottom - f.top, !o && i.text.firstChild && (u = i.text.firstChild.getBoundingClientRect().right - f.left - 1) } const h = i.line.height - s; if ((h > 0.005 || h < -0.005) && (Qe(i.line, s), Qr(i.line), i.rest)) { for (let d = 0; d < i.rest.length; d++) { Qr(i.rest[d]) } } if (u > e.display.sizerWidth) { const p = Math.ceil(u / Ar(e.display)); p > e.display.maxLineLength && (e.display.maxLineLength = p, e.display.maxLine = i.line, e.display.maxLineChanged = !0) } } } } function Qr (e) { if (e.widgets) { for (let t = 0; t < e.widgets.length; ++t) { const n = e.widgets[t]; const r = n.node.parentNode; r && (n.height = r.offsetHeight) } } } function ei (e, t, n) { let r = n && n.top != null ? Math.max(0, n.top) : e.scroller.scrollTop; r = Math.floor(r - Un(e)); const i = n && n.bottom != null ? n.bottom : r + e.wrapper.clientHeight; let o = tt(t, r); let l = tt(t, i); if (n && n.ensure) { const a = n.ensure.from.line; const s = n.ensure.to.line; a < o ? (o = a, l = tt(t, on(Ye(t, a)) + e.wrapper.clientHeight)) : Math.min(s, t.lastLine()) >= l && (o = tt(t, on(Ye(t, s)) - e.wrapper.clientHeight), l = s) } return { from: o, to: Math.max(l, o + 1) } } function ti (e, t) { if (!ye(e, 'scrollCursorIntoView')) { const n = e.display; const r = n.sizer.getBoundingClientRect(); let i = null; if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), i != null && !p) { const o = A('div', '​', null, 'position: absolute;\n                         top: ' + (t.top - n.viewOffset - Un(e.display)) + 'px;\n                         height: ' + (t.bottom - t.top + $n(e) + n.barHeight) + 'px;\n                         left: ' + t.left + 'px; width: ' + Math.max(2, t.right - t.left) + 'px;'); e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o) } } } function ni (e, t, n, r) { let i; r == null && (r = 0), e.options.lineWrapping || t != n || (t = t.ch ? it(t.line, t.sticky == 'before' ? t.ch - 1 : t.ch, 'after') : t, n = t.sticky == 'before' ? it(t.line, t.ch + 1, 'before') : t); for (let o = 0; o < 5; o++) { let l = !1; const a = yr(e, t); const s = n && n != t ? yr(e, n) : a; i = { left: Math.min(a.left, s.left), top: Math.min(a.top, s.top) - r, right: Math.max(a.left, s.left), bottom: Math.max(a.bottom, s.bottom) + r }; const u = ii(e, i); const c = e.doc.scrollTop; const f = e.doc.scrollLeft; if (u.scrollTop != null && (fi(e, u.scrollTop), Math.abs(e.doc.scrollTop - c) > 1 && (l = !0)), u.scrollLeft != null && (di(e, u.scrollLeft), Math.abs(e.doc.scrollLeft - f) > 1 && (l = !0)), !l) { break } } return i } function ri (e, t) { const n = ii(e, t); n.scrollTop != null && fi(e, n.scrollTop), n.scrollLeft != null && di(e, n.scrollLeft) } function ii (e, t) { const n = e.display; const r = Or(e.display); t.top < 0 && (t.top = 0); const i = e.curOp && e.curOp.scrollTop != null ? e.curOp.scrollTop : n.scroller.scrollTop; const o = qn(e); const l = {}; t.bottom - t.top > o && (t.bottom = t.top + o); const a = e.doc.height + _n(n); const s = t.top < r; const u = t.bottom > a - r; if (t.top < i) { l.scrollTop = s ? 0 : t.top } else if (t.bottom > i + o) { const c = Math.min(t.top, (u ? a : t.bottom) - o); c != i && (l.scrollTop = c) } const f = e.curOp && e.curOp.scrollLeft != null ? e.curOp.scrollLeft : n.scroller.scrollLeft; const h = Xn(e) - (e.options.fixedGutter ? n.gutters.offsetWidth : 0); const d = t.right - t.left > h; return d && (t.right = t.left + h), t.left < 10 ? l.scrollLeft = 0 : t.left < f ? l.scrollLeft = Math.max(0, t.left - (d ? 0 : 10)) : t.right > h + f - 3 && (l.scrollLeft = t.right + (d ? 0 : 10) - h), l } function oi (e, t) { t != null && (ui(e), e.curOp.scrollTop = (e.curOp.scrollTop == null ? e.doc.scrollTop : e.curOp.scrollTop) + t) } function li (e) { ui(e); const t = e.getCursor(); e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin } } function ai (e, t, n) { t == null && n == null || ui(e), t != null && (e.curOp.scrollLeft = t), n != null && (e.curOp.scrollTop = n) } function si (e, t) { ui(e), e.curOp.scrollToPos = t } function ui (e) { const t = e.curOp.scrollToPos; if (t) { e.curOp.scrollToPos = null; const n = br(e, t.from); const r = br(e, t.to); ci(e, n, r, t.margin) } } function ci (e, t, n, r) { const i = ii(e, { left: Math.min(t.left, n.left), top: Math.min(t.top, n.top) - r, right: Math.max(t.right, n.right), bottom: Math.max(t.bottom, n.bottom) + r }); ai(e, i.scrollLeft, i.scrollTop) } function fi (e, t) { Math.abs(e.doc.scrollTop - t) < 2 || (n || Vi(e, { top: t }), hi(e, t, !0), n && Vi(e), Ei(e, 100)) } function hi (e, t, n) { t = Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t), (e.display.scroller.scrollTop != t || n) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t)) } function di (e, t, n, r) { t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, Ki(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t)) } function pi (e) { const t = e.display; const n = t.gutters.offsetWidth; const r = Math.round(e.doc.height + _n(e.display)); return { clientHeight: t.scroller.clientHeight, viewHeight: t.wrapper.clientHeight, scrollWidth: t.scroller.scrollWidth, clientWidth: t.scroller.clientWidth, viewWidth: t.wrapper.clientWidth, barLeft: e.options.fixedGutter ? n : 0, docHeight: r, scrollHeight: r + $n(e) + t.barHeight, nativeBarWidth: t.nativeBarWidth, gutterWidth: n } } const gi = function (e, t, n) { this.cm = n; const r = this.vert = A('div', [A('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar'); const i = this.horiz = A('div', [A('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar'); r.tabIndex = i.tabIndex = -1, e(r), e(i), pe(r, 'scroll', function () { r.clientHeight && t(r.scrollTop, 'vertical') }), pe(i, 'scroll', function () { i.clientWidth && t(i.scrollLeft, 'horizontal') }), this.checkedZeroWidth = !1, l && a < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = '18px') }; gi.prototype.update = function (e) { const t = e.scrollWidth > e.clientWidth + 1; const n = e.scrollHeight > e.clientHeight + 1; const r = e.nativeBarWidth; if (n) { this.vert.style.display = 'block', this.vert.style.bottom = t ? r + 'px' : '0'; const i = e.viewHeight - (t ? r : 0); this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + i) + 'px' } else { this.vert.style.display = '', this.vert.firstChild.style.height = '0' } if (t) { this.horiz.style.display = 'block', this.horiz.style.right = n ? r + 'px' : '0', this.horiz.style.left = e.barLeft + 'px'; const o = e.viewWidth - e.barLeft - (n ? r : 0); this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + o) + 'px' } else { this.horiz.style.display = '', this.horiz.firstChild.style.width = '0' } return !this.checkedZeroWidth && e.clientHeight > 0 && (r == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: n ? r : 0, bottom: t ? r : 0 } }, gi.prototype.setScrollLeft = function (e) { this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz') }, gi.prototype.setScrollTop = function (e) { this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, 'vert') }, gi.prototype.zeroWidthHack = function () { const e = y && !d ? '12px' : '18px'; this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = 'none', this.disableHoriz = new R(), this.disableVert = new R() }, gi.prototype.enableZeroWidthBar = function (e, t, n) { function r () { const i = e.getBoundingClientRect(); const o = n == 'vert' ? document.elementFromPoint(i.right - 1, (i.top + i.bottom) / 2) : document.elementFromPoint((i.right + i.left) / 2, i.bottom - 1); o != e ? e.style.pointerEvents = 'none' : t.set(1e3, r) }e.style.pointerEvents = 'auto', t.set(1e3, r) }, gi.prototype.clear = function () { const e = this.horiz.parentNode; e.removeChild(this.horiz), e.removeChild(this.vert) }; const mi = function () {}; function vi (e, t) { t || (t = pi(e)); let n = e.display.barWidth; let r = e.display.barHeight; yi(e, t); for (let i = 0; i < 4 && n != e.display.barWidth || r != e.display.barHeight; i++) { n != e.display.barWidth && e.options.lineWrapping && Jr(e), yi(e, pi(e)), n = e.display.barWidth, r = e.display.barHeight } } function yi (e, t) { const n = e.display; const r = n.scrollbars.update(t); n.sizer.style.paddingRight = (n.barWidth = r.right) + 'px', n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + 'px', n.heightForcer.style.borderBottom = r.bottom + 'px solid transparent', r.right && r.bottom ? (n.scrollbarFiller.style.display = 'block', n.scrollbarFiller.style.height = r.bottom + 'px', n.scrollbarFiller.style.width = r.right + 'px') : n.scrollbarFiller.style.display = '', r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = 'block', n.gutterFiller.style.height = r.bottom + 'px', n.gutterFiller.style.width = t.gutterWidth + 'px') : n.gutterFiller.style.display = '' }mi.prototype.update = function () { return { bottom: 0, right: 0 } }, mi.prototype.setScrollLeft = function () {}, mi.prototype.setScrollTop = function () {}, mi.prototype.clear = function () {}; const bi = { native: gi, null: mi }; function wi (e) { e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && T(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new bi[e.options.scrollbarStyle](function (t) { e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), pe(t, 'mousedown', function () { e.state.focused && setTimeout(function () { return e.display.input.focus() }, 0) }), t.setAttribute('cm-not-content', 'true') }, function (t, n) { n == 'horizontal' ? di(e, t) : fi(e, t) }, e), e.display.scrollbars.addClass && H(e.display.wrapper, e.display.scrollbars.addClass) } let xi = 0; function Ci (e) { e.curOp = { cm: e, viewChanged: !1, startHeight: e.doc.height, forceUpdate: !1, updateInput: 0, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++xi }, Sn(e.curOp) } function ki (e) { const t = e.curOp; t && Tn(t, function (e) { for (let t = 0; t < e.ops.length; t++) { e.ops[t].cm.curOp = null }Si(e) }) } function Si (e) { for (var t = e.ops, n = 0; n < t.length; n++) { Li(t[n]) } for (let r = 0; r < t.length; r++) { Ti(t[r]) } for (let i = 0; i < t.length; i++) { Mi(t[i]) } for (let o = 0; o < t.length; o++) { Oi(t[o]) } for (let l = 0; l < t.length; l++) { Ai(t[l]) } } function Li (e) { const t = e.cm; const n = t.display; zi(t), e.updateMaxLine && an(t), e.mustUpdate = e.viewChanged || e.forceUpdate || e.scrollTop != null || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new Pi(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate) } function Ti (e) { e.updatedDisplay = e.mustUpdate && Bi(e.cm, e.update) } function Mi (e) { const t = e.cm; const n = t.display; e.updatedDisplay && Jr(t), e.barMeasure = pi(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Qn(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + $n(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - Xn(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection()) } function Oi (e) { const t = e.cm; e.adjustWidthTo != null && (t.display.sizer.style.minWidth = e.adjustWidthTo + 'px', e.maxScrollLeft < t.doc.scrollLeft && di(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1); const n = e.focus && e.focus == W(); e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), (e.updatedDisplay || e.startHeight != t.doc.height) && vi(t, e.barMeasure), e.updatedDisplay && _i(t, e.barMeasure), e.selectionChanged && $r(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && Xr(e.cm) } function Ai (e) { const t = e.cm; const n = t.display; const r = t.doc; if (e.updatedDisplay && ji(t, e.update), n.wheelStartX == null || e.scrollTop == null && e.scrollLeft == null && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), e.scrollTop != null && hi(t, e.scrollTop, e.forceScroll), e.scrollLeft != null && di(t, e.scrollLeft, !0, !0), e.scrollToPos) { const i = ni(t, ft(r, e.scrollToPos.from), ft(r, e.scrollToPos.to), e.scrollToPos.margin); ti(t, i) } const o = e.maybeHiddenMarkers; const l = e.maybeUnhiddenMarkers; if (o) { for (let a = 0; a < o.length; ++a) { o[a].lines.length || ve(o[a], 'hide') } } if (l) { for (let s = 0; s < l.length; ++s) { l[s].lines.length && ve(l[s], 'unhide') } }n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && ve(t, 'changes', t, e.changeObjs), e.update && e.update.finish() } function Ni (e, t) { if (e.curOp) { return t() } Ci(e); try { return t() } finally { ki(e) } } function Di (e, t) { return function () { if (e.curOp) { return t.apply(e, arguments) } Ci(e); try { return t.apply(e, arguments) } finally { ki(e) } } } function Wi (e) { return function () { if (this.curOp) { return e.apply(this, arguments) } Ci(this); try { return e.apply(this, arguments) } finally { ki(this) } } } function Hi (e) { return function () { const t = this.cm; if (!t || t.curOp) { return e.apply(this, arguments) } Ci(t); try { return e.apply(this, arguments) } finally { ki(t) } } } function Ei (e, t) { e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, P(Fi, e)) } function Fi (e) { const t = e.doc; if (!(t.highlightFrontier >= e.display.viewTo)) { const n = +new Date() + e.options.workTime; const r = yt(e, t.highlightFrontier); const i = []; t.iter(r.line, Math.min(t.first + t.size, e.display.viewTo + 500), function (o) { if (r.line >= e.display.viewFrom) { const l = o.styles; const a = o.text.length > e.options.maxHighlightLength ? Ke(t.mode, r.state) : null; const s = mt(e, o, r, !0); a && (r.state = a), o.styles = s.styles; const u = o.styleClasses; const c = s.classes; c ? o.styleClasses = c : u && (o.styleClasses = null); for (var f = !l || l.length != o.styles.length || u != c && (!u || !c || u.bgClass != c.bgClass || u.textClass != c.textClass), h = 0; !f && h < l.length; ++h) { f = l[h] != o.styles[h] }f && i.push(r.line), o.stateAfter = r.save(), r.nextLine() } else { o.text.length <= e.options.maxHighlightLength && bt(e, o.text, r), o.stateAfter = r.line % 5 == 0 ? r.save() : null, r.nextLine() } if (+new Date() > n) { return Ei(e, e.options.workDelay), !0 } }), t.highlightFrontier = r.line, t.modeFrontier = Math.max(t.modeFrontier, r.line), i.length && Ni(e, function () { for (let t = 0; t < i.length; t++) { zr(e, i[t], 'text') } }) } } var Pi = function (e, t, n) { const r = e.display; this.viewport = t, this.visible = ei(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = Xn(e), this.force = n, this.dims = Nr(e), this.events = [] }; function zi (e) { const t = e.display; !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = $n(e) + 'px', t.sizer.style.marginBottom = -t.nativeBarWidth + 'px', t.sizer.style.borderRightWidth = $n(e) + 'px', t.scrollbarsClipped = !0) } function Ii (e) { if (e.hasFocus()) { return null } const t = W(); if (!t || !D(e.display.lineDiv, t)) { return null } const n = { activeElt: t }; if (window.getSelection) { const r = window.getSelection(); r.anchorNode && r.extend && D(e.display.lineDiv, r.anchorNode) && (n.anchorNode = r.anchorNode, n.anchorOffset = r.anchorOffset, n.focusNode = r.focusNode, n.focusOffset = r.focusOffset) } return n } function Ri (e) { if (e && e.activeElt && e.activeElt != W() && (e.activeElt.focus(), e.anchorNode && D(document.body, e.anchorNode) && D(document.body, e.focusNode))) { const t = window.getSelection(); const n = document.createRange(); n.setEnd(e.anchorNode, e.anchorOffset), n.collapse(!1), t.removeAllRanges(), t.addRange(n), t.extend(e.focusNode, e.focusOffset) } } function Bi (e, t) { const n = e.display; const r = e.doc; if (t.editorIsHidden) { return Ir(e), !1 } if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (n.updateLineNumbers == null || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && jr(e) == 0) { return !1 } $i(e) && (Ir(e), t.dims = Nr(e)); const i = r.first + r.size; let o = Math.max(t.visible.from - e.options.viewportMargin, r.first); let l = Math.min(i, t.visible.to + e.options.viewportMargin); n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > l && n.viewTo - l < 20 && (l = Math.min(i, n.viewTo)), At && (o = en(e.doc, o), l = tn(e.doc, l)); const a = o != n.viewFrom || l != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth; Br(e, o, l), n.viewOffset = on(Ye(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + 'px'; const s = jr(e); if (!a && s == 0 && !t.force && n.renderedView == n.view && (n.updateLineNumbers == null || n.updateLineNumbers >= n.viewTo)) { return !1 } const u = Ii(e); return s > 4 && (n.lineDiv.style.display = 'none'), Gi(e, n.updateLineNumbers, t.dims), s > 4 && (n.lineDiv.style.display = ''), n.renderedView = n.view, Ri(u), M(n.cursorDiv), M(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, a && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, Ei(e, 400)), n.updateLineNumbers = null, !0 } function ji (e, t) { for (let n = t.viewport, r = !0; ;r = !1) { if ((!r || !e.options.lineWrapping || t.oldDisplayWidth == Xn(e)) && (n && n.top != null && (n = { top: Math.min(e.doc.height + _n(e.display) - qn(e), n.top) }), t.visible = ei(e.display, e.doc, n), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo)) { break } if (!Bi(e, t)) { break } Jr(e); const i = pi(e); Vr(e), vi(e, i), _i(e, i), t.force = !1 }t.signal(e, 'update', e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, 'viewportChange', e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo) } function Vi (e, t) { const n = new Pi(e, t); if (Bi(e, n)) { Jr(e), ji(e, n); const r = pi(e); Vr(e), vi(e, r), _i(e, r), n.finish() } } function Gi (e, t, n) { const r = e.display; const i = e.options.lineNumbers; const o = r.lineDiv; let l = o.firstChild; function a (t) { const n = t.nextSibling; return s && y && e.display.currentWheelTarget == t ? t.style.display = 'none' : t.parentNode.removeChild(t), n } for (let u = r.view, c = r.viewFrom, f = 0; f < u.length; f++) { const h = u[f]; if (h.hidden) { ; } else if (h.node && h.node.parentNode == o) { while (l != h.node) { l = a(l) } let d = i && t != null && t <= c && h.lineNumber; h.changes && (B(h.changes, 'gutter') > -1 && (d = !1), Nn(e, h, c, n)), d && (M(h.lineNumber), h.lineNumber.appendChild(document.createTextNode(rt(e.options, c)))), l = h.node.nextSibling } else { const p = In(e, h, c, n); o.insertBefore(p, l) }c += h.size } while (l) { l = a(l) } } function Ui (e) { const t = e.gutters.offsetWidth; e.sizer.style.marginLeft = t + 'px' } function _i (e, t) { e.display.sizer.style.minHeight = t.docHeight + 'px', e.display.heightForcer.style.top = t.docHeight + 'px', e.display.gutters.style.height = t.docHeight + e.display.barHeight + $n(e) + 'px' } function Ki (e) { const t = e.display; const n = t.view; if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) { for (var r = Dr(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = r + 'px', l = 0; l < n.length; l++) { if (!n[l].hidden) { e.options.fixedGutter && (n[l].gutter && (n[l].gutter.style.left = o), n[l].gutterBackground && (n[l].gutterBackground.style.left = o)); const a = n[l].alignable; if (a) { for (let s = 0; s < a.length; s++) { a[s].style.left = o } } } }e.options.fixedGutter && (t.gutters.style.left = r + i + 'px') } } function $i (e) { if (!e.options.lineNumbers) { return !1 } const t = e.doc; const n = rt(e.options, t.first + t.size - 1); const r = e.display; if (n.length != r.lineNumChars) { const i = r.measure.appendChild(A('div', [A('div', n)], 'CodeMirror-linenumber CodeMirror-gutter-elt')); const o = i.firstChild.offsetWidth; const l = i.offsetWidth - o; return r.lineGutter.style.width = '', r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - l) + 1, r.lineNumWidth = r.lineNumInnerWidth + l, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + 'px', Ui(e.display), !0 } return !1 } function Xi (e, t) { for (var n = [], r = !1, i = 0; i < e.length; i++) { let o = e[i]; let l = null; if (typeof o !== 'string' && (l = o.style, o = o.className), o == 'CodeMirror-linenumbers') { if (!t) { continue } r = !0 }n.push({ className: o, style: l }) } return t && !r && n.push({ className: 'CodeMirror-linenumbers', style: null }), n } function qi (e) { const t = e.gutters; const n = e.gutterSpecs; M(t), e.lineGutter = null; for (let r = 0; r < n.length; ++r) { const i = n[r]; const o = i.className; const l = i.style; const a = t.appendChild(A('div', null, 'CodeMirror-gutter ' + o)); l && (a.style.cssText = l), o == 'CodeMirror-linenumbers' && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + 'px') }t.style.display = n.length ? '' : 'none', Ui(e) } function Yi (e) { qi(e.display), Pr(e), Ki(e) } function Zi (e, t, r, i) { const o = this; this.input = r, o.scrollbarFiller = A('div', null, 'CodeMirror-scrollbar-filler'), o.scrollbarFiller.setAttribute('cm-not-content', 'true'), o.gutterFiller = A('div', null, 'CodeMirror-gutter-filler'), o.gutterFiller.setAttribute('cm-not-content', 'true'), o.lineDiv = N('div', null, 'CodeMirror-code'), o.selectionDiv = A('div', null, null, 'position: relative; z-index: 1'), o.cursorDiv = A('div', null, 'CodeMirror-cursors'), o.measure = A('div', null, 'CodeMirror-measure'), o.lineMeasure = A('div', null, 'CodeMirror-measure'), o.lineSpace = N('div', [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, 'position: relative; outline: none'); const u = N('div', [o.lineSpace], 'CodeMirror-lines'); o.mover = A('div', [u], null, 'position: relative'), o.sizer = A('div', [o.mover], 'CodeMirror-sizer'), o.sizerWidth = null, o.heightForcer = A('div', null, null, 'position: absolute; height: ' + j + 'px; width: 1px;'), o.gutters = A('div', null, 'CodeMirror-gutters'), o.lineGutter = null, o.scroller = A('div', [o.sizer, o.heightForcer, o.gutters], 'CodeMirror-scroll'), o.scroller.setAttribute('tabIndex', '-1'), o.wrapper = A('div', [o.scrollbarFiller, o.gutterFiller, o.scroller], 'CodeMirror'), l && a < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), s || n && v || (o.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(o.wrapper) : e(o.wrapper)), o.viewFrom = o.viewTo = t.first, o.reportedViewFrom = o.reportedViewTo = t.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, o.gutterSpecs = Xi(i.gutters, i.lineNumbers), qi(o), r.init(o) }Pi.prototype.signal = function (e, t) { we(e, t) && this.events.push(arguments) }, Pi.prototype.finish = function () { for (let e = 0; e < this.events.length; e++) { ve.apply(null, this.events[e]) } }; let Ji = 0; let Qi = null; function eo (e) { let t = e.wheelDeltaX; let n = e.wheelDeltaY; return t == null && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), n == null && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : n == null && (n = e.wheelDelta), { x: t, y: n } } function to (e) { const t = eo(e); return t.x *= Qi, t.y *= Qi, t } function no (e, t) { const r = eo(t); const i = r.x; const o = r.y; const l = e.display; const a = l.scroller; const u = a.scrollWidth > a.clientWidth; const c = a.scrollHeight > a.clientHeight; if (i && u || o && c) { if (o && y && s) { e:for (let h = t.target, d = l.view; h != a; h = h.parentNode) { for (let p = 0; p < d.length; p++) { if (d[p].node == h) { e.display.currentWheelTarget = h; break e } } } } if (i && !n && !f && Qi != null) { return o && c && fi(e, Math.max(0, a.scrollTop + o * Qi)), di(e, Math.max(0, a.scrollLeft + i * Qi)), (!o || o && c) && Ce(t), void (l.wheelStartX = null) } if (o && Qi != null) { const g = o * Qi; let m = e.doc.scrollTop; let v = m + l.wrapper.clientHeight; g < 0 ? m = Math.max(0, m + g - 50) : v = Math.min(e.doc.height, v + g + 50), Vi(e, { top: m, bottom: v }) }Ji < 20 && (l.wheelStartX == null ? (l.wheelStartX = a.scrollLeft, l.wheelStartY = a.scrollTop, l.wheelDX = i, l.wheelDY = o, setTimeout(function () { if (l.wheelStartX != null) { const e = a.scrollLeft - l.wheelStartX; const t = a.scrollTop - l.wheelStartY; const n = t && l.wheelDY && t / l.wheelDY || e && l.wheelDX && e / l.wheelDX; l.wheelStartX = l.wheelStartY = null, n && (Qi = (Qi * Ji + n) / (Ji + 1), ++Ji) } }, 200)) : (l.wheelDX += i, l.wheelDY += o)) } }l ? Qi = -0.53 : n ? Qi = 15 : c ? Qi = -0.7 : h && (Qi = -1 / 3); const ro = function (e, t) { this.ranges = e, this.primIndex = t }; ro.prototype.primary = function () { return this.ranges[this.primIndex] }, ro.prototype.equals = function (e) { if (e == this) { return !0 } if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) { return !1 } for (let t = 0; t < this.ranges.length; t++) { const n = this.ranges[t]; const r = e.ranges[t]; if (!lt(n.anchor, r.anchor) || !lt(n.head, r.head)) { return !1 } } return !0 }, ro.prototype.deepCopy = function () { for (var e = [], t = 0; t < this.ranges.length; t++) { e[t] = new io(at(this.ranges[t].anchor), at(this.ranges[t].head)) } return new ro(e, this.primIndex) }, ro.prototype.somethingSelected = function () { for (let e = 0; e < this.ranges.length; e++) { if (!this.ranges[e].empty()) { return !0 } } return !1 }, ro.prototype.contains = function (e, t) { t || (t = e); for (let n = 0; n < this.ranges.length; n++) { const r = this.ranges[n]; if (ot(t, r.from()) >= 0 && ot(e, r.to()) <= 0) { return n } } return -1 }; var io = function (e, t) { this.anchor = e, this.head = t }; function oo (e, t, n) { const r = e && e.options.selectionsMayTouch; const i = t[n]; t.sort(function (e, t) { return ot(e.from(), t.from()) }), n = B(t, i); for (let o = 1; o < t.length; o++) { const l = t[o]; const a = t[o - 1]; const s = ot(a.to(), l.from()); if (r && !l.empty() ? s > 0 : s >= 0) { const u = ut(a.from(), l.from()); const c = st(a.to(), l.to()); const f = a.empty() ? l.from() == l.head : a.from() == a.head; o <= n && --n, t.splice(--o, 2, new io(f ? c : u, f ? u : c)) } } return new ro(t, n) } function lo (e, t) { return new ro([new io(e, t || e)], 0) } function ao (e) { return e.text ? it(e.from.line + e.text.length - 1, q(e.text).length + (e.text.length == 1 ? e.from.ch : 0)) : e.to } function so (e, t) { if (ot(e, t.from) < 0) { return e } if (ot(e, t.to) <= 0) { return ao(t) } const n = e.line + t.text.length - (t.to.line - t.from.line) - 1; let r = e.ch; return e.line == t.to.line && (r += ao(t).ch - t.to.ch), it(n, r) } function uo (e, t) { for (var n = [], r = 0; r < e.sel.ranges.length; r++) { const i = e.sel.ranges[r]; n.push(new io(so(i.anchor, t), so(i.head, t))) } return oo(e.cm, n, e.sel.primIndex) } function co (e, t, n) { return e.line == t.line ? it(n.line, e.ch - t.ch + n.ch) : it(n.line + (e.line - t.line), e.ch) } function fo (e, t, n) { for (var r = [], i = it(e.first, 0), o = i, l = 0; l < t.length; l++) { const a = t[l]; const s = co(a.from, i, o); const u = co(ao(a), i, o); if (i = a.to, o = u, n == 'around') { const c = e.sel.ranges[l]; const f = ot(c.head, c.anchor) < 0; r[l] = new io(f ? u : s, f ? s : u) } else { r[l] = new io(s, s) } } return new ro(r, e.sel.primIndex) } function ho (e) { e.doc.mode = Ge(e.options, e.doc.modeOption), po(e) } function po (e) { e.doc.iter(function (e) { e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null) }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, Ei(e, 100), e.state.modeGen++, e.curOp && Pr(e) } function go (e, t) { return t.from.ch == 0 && t.to.ch == 0 && q(t.text) == '' && (!e.cm || e.cm.options.wholeLineUpdateBefore) } function mo (e, t, n, r) { function i (e) { return n ? n[e] : null } function o (e, n, i) { un(e, n, i, r), On(e, 'change', e, t) } function l (e, t) { for (var n = [], o = e; o < t; ++o) { n.push(new sn(u[o], i(o), r)) } return n } const a = t.from; const s = t.to; var u = t.text; const c = Ye(e, a.line); const f = Ye(e, s.line); const h = q(u); const d = i(u.length - 1); const p = s.line - a.line; if (t.full) { e.insert(0, l(0, u.length)), e.remove(u.length, e.size - u.length) } else if (go(e, t)) { const g = l(0, u.length - 1); o(f, f.text, d), p && e.remove(a.line, p), g.length && e.insert(a.line, g) } else if (c == f) { if (u.length == 1) { o(c, c.text.slice(0, a.ch) + h + c.text.slice(s.ch), d) } else { const m = l(1, u.length - 1); m.push(new sn(h + c.text.slice(s.ch), d, r)), o(c, c.text.slice(0, a.ch) + u[0], i(0)), e.insert(a.line + 1, m) } } else if (u.length == 1) { o(c, c.text.slice(0, a.ch) + u[0] + f.text.slice(s.ch), i(0)), e.remove(a.line + 1, p) } else { o(c, c.text.slice(0, a.ch) + u[0], i(0)), o(f, h + f.text.slice(s.ch), d); const v = l(1, u.length - 1); p > 1 && e.remove(a.line + 1, p - 1), e.insert(a.line + 1, v) }On(e, 'change', e, t) } function vo (e, t, n) { function r (e, i, o) { if (e.linked) { for (let l = 0; l < e.linked.length; ++l) { const a = e.linked[l]; if (a.doc != i) { const s = o && a.sharedHist; n && !s || (t(a.doc, s), r(a.doc, e, s)) } } } }r(e, null, !0) } function yo (e, t) { if (t.cm) { throw new Error('This document is already in use.') } e.doc = t, t.cm = e, Hr(e), ho(e), bo(e), e.options.lineWrapping || an(e), e.options.mode = t.modeOption, Pr(e) } function bo (e) { (e.doc.direction == 'rtl' ? H : T)(e.display.lineDiv, 'CodeMirror-rtl') } function wo (e) { Ni(e, function () { bo(e), Pr(e) }) } function xo (e) { this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e || 1 } function Co (e, t) { const n = { from: at(t.from), to: ao(t), text: Ze(e, t.from, t.to) }; return Ao(e, n, t.from.line, t.to.line + 1), vo(e, function (e) { return Ao(e, n, t.from.line, t.to.line + 1) }, !0), n } function ko (e) { while (e.length) { const t = q(e); if (!t.ranges) { break } e.pop() } } function So (e, t) { return t ? (ko(e.done), q(e.done)) : e.done.length && !q(e.done).ranges ? q(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), q(e.done)) : void 0 } function Lo (e, t, n, r) { const i = e.history; i.undone.length = 0; let o; let l; const a = +new Date(); if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == '+' && i.lastModTime > a - (e.cm ? e.cm.options.historyEventDelay : 500) || t.origin.charAt(0) == '*')) && (o = So(i, i.lastOp == r))) { l = q(o.changes), ot(t.from, t.to) == 0 && ot(t.from, l.to) == 0 ? l.to = ao(t) : o.changes.push(Co(e, t)) } else { const s = q(i.done); s && s.ranges || Oo(e.sel, i.done), o = { changes: [Co(e, t)], generation: i.generation }, i.done.push(o); while (i.done.length > i.undoDepth) { i.done.shift(), i.done[0].ranges || i.done.shift() } }i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = a, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, l || ve(e, 'historyAdded') } function To (e, t, n, r) { const i = t.charAt(0); return i == '*' || i == '+' && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date() - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500) } function Mo (e, t, n, r) { const i = e.history; const o = r && r.origin; n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || To(e, o, q(i.done), t)) ? i.done[i.done.length - 1] = t : Oo(t, i.done), i.lastSelTime = +new Date(), i.lastSelOrigin = o, i.lastSelOp = n, r && !1 !== r.clearRedo && ko(i.undone) } function Oo (e, t) { const n = q(t); n && n.ranges && n.equals(e) || t.push(e) } function Ao (e, t, n, r) { let i = t['spans_' + e.id]; let o = 0; e.iter(Math.max(e.first, n), Math.min(e.first + e.size, r), function (n) { n.markedSpans && ((i || (i = t['spans_' + e.id] = {}))[o] = n.markedSpans), ++o }) } function No (e) { if (!e) { return null } for (var t, n = 0; n < e.length; ++n) { e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]) } return t ? t.length ? t : null : e } function Do (e, t) { const n = t['spans_' + e.id]; if (!n) { return null } for (var r = [], i = 0; i < t.text.length; ++i) { r.push(No(n[i])) } return r } function Wo (e, t) { const n = Do(e, t); const r = It(e, t); if (!n) { return r } if (!r) { return n } for (let i = 0; i < n.length; ++i) { const o = n[i]; const l = r[i]; if (o && l) { e:for (let a = 0; a < l.length; ++a) { for (var s = l[a], u = 0; u < o.length; ++u) { if (o[u].marker == s.marker) { continue e } } o.push(s) } } else { l && (n[i] = l) } } return n } function Ho (e, t, n) { for (var r = [], i = 0; i < e.length; ++i) { const o = e[i]; if (o.ranges) { r.push(n ? ro.prototype.deepCopy.call(o) : o) } else { const l = o.changes; const a = []; r.push({ changes: a }); for (let s = 0; s < l.length; ++s) { const u = l[s]; let c = void 0; if (a.push({ from: u.from, to: u.to, text: u.text }), t) { for (const f in u) { (c = f.match(/^spans_(\d+)$/)) && B(t, Number(c[1])) > -1 && (q(a)[f] = u[f], delete u[f]) } } } } } return r } function Eo (e, t, n, r) { if (r) { let i = e.anchor; if (n) { const o = ot(t, i) < 0; o != ot(n, i) < 0 ? (i = t, t = n) : o != ot(t, n) < 0 && (t = n) } return new io(i, t) } return new io(n || t, t) } function Fo (e, t, n, r, i) { i == null && (i = e.cm && (e.cm.display.shift || e.extend)), jo(e, new ro([Eo(e.sel.primary(), t, n, i)], 0), r) } function Po (e, t, n) { for (var r = [], i = e.cm && (e.cm.display.shift || e.extend), o = 0; o < e.sel.ranges.length; o++) { r[o] = Eo(e.sel.ranges[o], t[o], null, i) } const l = oo(e.cm, r, e.sel.primIndex); jo(e, l, n) } function zo (e, t, n, r) { const i = e.sel.ranges.slice(0); i[t] = n, jo(e, oo(e.cm, i, e.sel.primIndex), r) } function Io (e, t, n, r) { jo(e, lo(t, n), r) } function Ro (e, t, n) { const r = { ranges: t.ranges, update (t) { this.ranges = []; for (let n = 0; n < t.length; n++) { this.ranges[n] = new io(ft(e, t[n].anchor), ft(e, t[n].head)) } }, origin: n && n.origin }; return ve(e, 'beforeSelectionChange', e, r), e.cm && ve(e.cm, 'beforeSelectionChange', e.cm, r), r.ranges != t.ranges ? oo(e.cm, r.ranges, r.ranges.length - 1) : t } function Bo (e, t, n) { const r = e.history.done; const i = q(r); i && i.ranges ? (r[r.length - 1] = t, Vo(e, t, n)) : jo(e, t, n) } function jo (e, t, n) { Vo(e, t, n), Mo(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n) } function Vo (e, t, n) { (we(e, 'beforeSelectionChange') || e.cm && we(e.cm, 'beforeSelectionChange')) && (t = Ro(e, t, n)); const r = n && n.bias || (ot(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1); Go(e, _o(e, t, r, !0)), n && !1 === n.scroll || !e.cm || li(e.cm) } function Go (e, t) { t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, be(e.cm)), On(e, 'cursorActivity', e)) } function Uo (e) { Go(e, _o(e, e.sel, null, !1)) } function _o (e, t, n, r) { for (var i, o = 0; o < t.ranges.length; o++) { const l = t.ranges[o]; const a = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o]; const s = $o(e, l.anchor, a && a.anchor, n, r); const u = $o(e, l.head, a && a.head, n, r); (i || s != l.anchor || u != l.head) && (i || (i = t.ranges.slice(0, o)), i[o] = new io(s, u)) } return i ? oo(e.cm, i, t.primIndex) : t } function Ko (e, t, n, r, i) { const o = Ye(e, t.line); if (o.markedSpans) { for (let l = 0; l < o.markedSpans.length; ++l) { const a = o.markedSpans[l]; const s = a.marker; const u = 'selectLeft' in s ? !s.selectLeft : s.inclusiveLeft; const c = 'selectRight' in s ? !s.selectRight : s.inclusiveRight; if ((a.from == null || (u ? a.from <= t.ch : a.from < t.ch)) && (a.to == null || (c ? a.to >= t.ch : a.to > t.ch))) { if (i && (ve(s, 'beforeCursorEnter'), s.explicitlyCleared)) { if (o.markedSpans) { --l; continue } break } if (!s.atomic) { continue } if (n) { let f = s.find(r < 0 ? 1 : -1); let h = void 0; if ((r < 0 ? c : u) && (f = Xo(e, f, -r, f && f.line == t.line ? o : null)), f && f.line == t.line && (h = ot(f, n)) && (r < 0 ? h < 0 : h > 0)) { return Ko(e, f, t, r, i) } } let d = s.find(r < 0 ? -1 : 1); return (r < 0 ? u : c) && (d = Xo(e, d, r, d.line == t.line ? o : null)), d ? Ko(e, d, t, r, i) : null } } } return t } function $o (e, t, n, r, i) { const o = r || 1; const l = Ko(e, t, n, o, i) || !i && Ko(e, t, n, o, !0) || Ko(e, t, n, -o, i) || !i && Ko(e, t, n, -o, !0); return l || (e.cantEdit = !0, it(e.first, 0)) } function Xo (e, t, n, r) { return n < 0 && t.ch == 0 ? t.line > e.first ? ft(e, it(t.line - 1)) : null : n > 0 && t.ch == (r || Ye(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? it(t.line + 1, 0) : null : new it(t.line, t.ch + n) } function qo (e) { e.setSelection(it(e.firstLine(), 0), it(e.lastLine()), G) } function Yo (e, t, n) { var r = { canceled: !1, from: t.from, to: t.to, text: t.text, origin: t.origin, cancel () { return r.canceled = !0 } }; return n && (r.update = function (t, n, i, o) { t && (r.from = ft(e, t)), n && (r.to = ft(e, n)), i && (r.text = i), void 0 !== o && (r.origin = o) }), ve(e, 'beforeChange', e, r), e.cm && ve(e.cm, 'beforeChange', e.cm, r), r.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : { from: r.from, to: r.to, text: r.text, origin: r.origin } } function Zo (e, t, n) { if (e.cm) { if (!e.cm.curOp) { return Di(e.cm, Zo)(e, t, n) } if (e.cm.state.suppressEdits) { return } } if (!(we(e, 'beforeChange') || e.cm && we(e.cm, 'beforeChange')) || (t = Yo(e, t, !0), t)) { const r = Ot && !n && Bt(e, t.from, t.to); if (r) { for (let i = r.length - 1; i >= 0; --i) { Jo(e, { from: r[i].from, to: r[i].to, text: i ? [''] : t.text, origin: t.origin }) } } else { Jo(e, t) } } } function Jo (e, t) { if (t.text.length != 1 || t.text[0] != '' || ot(t.from, t.to) != 0) { const n = uo(e, t); Lo(e, t, n, e.cm ? e.cm.curOp.id : NaN), tl(e, t, n, It(e, t)); const r = []; vo(e, function (e, n) { n || B(r, e.history) != -1 || (ll(e.history, t), r.push(e.history)), tl(e, t, null, It(e, t)) }) } } function Qo (e, t, n) { const r = e.cm && e.cm.state.suppressEdits; if (!r || n) { for (var i, o = e.history, l = e.sel, a = t == 'undo' ? o.done : o.undone, s = t == 'undo' ? o.undone : o.done, u = 0; u < a.length; u++) { if (i = a[u], n ? i.ranges && !i.equals(e.sel) : !i.ranges) { break } } if (u != a.length) { for (o.lastOrigin = o.lastSelOrigin = null; ;) { if (i = a.pop(), !i.ranges) { if (r) { return void a.push(i) } break } if (Oo(i, s), n && !i.equals(e.sel)) { return void jo(e, i, { clearRedo: !1 }) } l = i } const c = []; Oo(l, s), s.push({ changes: c, generation: o.generation }), o.generation = i.generation || ++o.maxGeneration; for (var f = we(e, 'beforeChange') || e.cm && we(e.cm, 'beforeChange'), h = function (n) { const r = i.changes[n]; if (r.origin = t, f && !Yo(e, r, !1)) { return a.length = 0, {} } c.push(Co(e, r)); const o = n ? uo(e, r) : q(a); tl(e, r, o, Wo(e, r)), !n && e.cm && e.cm.scrollIntoView({ from: r.from, to: ao(r) }); const l = []; vo(e, function (e, t) { t || B(l, e.history) != -1 || (ll(e.history, r), l.push(e.history)), tl(e, r, null, Wo(e, r)) }) }, d = i.changes.length - 1; d >= 0; --d) { const p = h(d); if (p) { return p.v } } } } } function el (e, t) { if (t != 0 && (e.first += t, e.sel = new ro(Y(e.sel.ranges, function (e) { return new io(it(e.anchor.line + t, e.anchor.ch), it(e.head.line + t, e.head.ch)) }), e.sel.primIndex), e.cm)) { Pr(e.cm, e.first, e.first - t, t); for (let n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++) { zr(e.cm, r, 'gutter') } } } function tl (e, t, n, r) { if (e.cm && !e.cm.curOp) { return Di(e.cm, tl)(e, t, n, r) } if (t.to.line < e.first) { el(e, t.text.length - 1 - (t.to.line - t.from.line)) } else if (!(t.from.line > e.lastLine())) { if (t.from.line < e.first) { const i = t.text.length - 1 - (e.first - t.from.line); el(e, i), t = { from: it(e.first, 0), to: it(t.to.line + i, t.to.ch), text: [q(t.text)], origin: t.origin } } const o = e.lastLine(); t.to.line > o && (t = { from: t.from, to: it(o, Ye(e, o).text.length), text: [t.text[0]], origin: t.origin }), t.removed = Ze(e, t.from, t.to), n || (n = uo(e, t)), e.cm ? nl(e.cm, t, r) : mo(e, t, r), Vo(e, n, G), e.cantEdit && $o(e, it(e.firstLine(), 0)) && (e.cantEdit = !1) } } function nl (e, t, n) { const r = e.doc; const i = e.display; const o = t.from; const l = t.to; let a = !1; let s = o.line; e.options.lineWrapping || (s = et(Zt(Ye(r, o.line))), r.iter(s, l.line + 1, function (e) { if (e == i.maxLine) { return a = !0, !0 } })), r.sel.contains(t.from, t.to) > -1 && be(e), mo(r, t, n, Wr(e)), e.options.lineWrapping || (r.iter(s, o.line + t.text.length, function (e) { const t = ln(e); t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, a = !1) }), a && (e.curOp.updateMaxLine = !0)), Mt(r, o.line), Ei(e, 400); const u = t.text.length - (l.line - o.line) - 1; t.full ? Pr(e) : o.line != l.line || t.text.length != 1 || go(e.doc, t) ? Pr(e, o.line, l.line + 1, u) : zr(e, o.line, 'text'); const c = we(e, 'changes'); const f = we(e, 'change'); if (f || c) { const h = { from: o, to: l, text: t.text, removed: t.removed, origin: t.origin }; f && On(e, 'change', e, h), c && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(h) }e.display.selForContextMenu = null } function rl (e, t, n, r, i) { let o; r || (r = n), ot(r, n) < 0 && (o = [r, n], n = o[0], r = o[1]), typeof t === 'string' && (t = e.splitLines(t)), Zo(e, { from: n, to: r, text: t, origin: i }) } function il (e, t, n, r) { n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0) } function ol (e, t, n, r) { for (let i = 0; i < e.length; ++i) { let o = e[i]; let l = !0; if (o.ranges) { o.copied || (o = e[i] = o.deepCopy(), o.copied = !0); for (let a = 0; a < o.ranges.length; a++) { il(o.ranges[a].anchor, t, n, r), il(o.ranges[a].head, t, n, r) } } else { for (let s = 0; s < o.changes.length; ++s) { const u = o.changes[s]; if (n < u.from.line) { u.from = it(u.from.line + r, u.from.ch), u.to = it(u.to.line + r, u.to.ch) } else if (t <= u.to.line) { l = !1; break } }l || (e.splice(0, i + 1), i = 0) } } } function ll (e, t) { const n = t.from.line; const r = t.to.line; const i = t.text.length - (r - n) - 1; ol(e.done, n, r, i), ol(e.undone, n, r, i) } function al (e, t, n, r) { let i = t; let o = t; return typeof t === 'number' ? o = Ye(e, ct(e, t)) : i = et(t), i == null ? null : (r(o, i) && e.cm && zr(e.cm, i, n), o) } function sl (e) { this.lines = e, this.parent = null; for (var t = 0, n = 0; n < e.length; ++n) { e[n].parent = this, t += e[n].height } this.height = t } function ul (e) { this.children = e; for (var t = 0, n = 0, r = 0; r < e.length; ++r) { const i = e[r]; t += i.chunkSize(), n += i.height, i.parent = this } this.size = t, this.height = n, this.parent = null }io.prototype.from = function () { return ut(this.anchor, this.head) }, io.prototype.to = function () { return st(this.anchor, this.head) }, io.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch }, sl.prototype = { chunkSize () { return this.lines.length }, removeInner (e, t) { for (let n = e, r = e + t; n < r; ++n) { const i = this.lines[n]; this.height -= i.height, cn(i), On(i, 'delete') } this.lines.splice(e, t) }, collapse (e) { e.push.apply(e, this.lines) }, insertInner (e, t, n) { this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e)); for (let r = 0; r < t.length; ++r) { t[r].parent = this } }, iterN (e, t, n) { for (let r = e + t; e < r; ++e) { if (n(this.lines[e])) { return !0 } } } }, ul.prototype = { chunkSize () { return this.size }, removeInner (e, t) { this.size -= t; for (let n = 0; n < this.children.length; ++n) { const r = this.children[n]; const i = r.chunkSize(); if (e < i) { const o = Math.min(t, i - e); const l = r.height; if (r.removeInner(e, o), this.height -= l - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), (t -= o) == 0) { break } e = 0 } else { e -= i } } if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof sl))) { const a = []; this.collapse(a), this.children = [new sl(a)], this.children[0].parent = this } }, collapse (e) { for (let t = 0; t < this.children.length; ++t) { this.children[t].collapse(e) } }, insertInner (e, t, n) { this.size += t.length, this.height += n; for (let r = 0; r < this.children.length; ++r) { const i = this.children[r]; const o = i.chunkSize(); if (e <= o) { if (i.insertInner(e, t, n), i.lines && i.lines.length > 50) { for (var l = i.lines.length % 25 + 25, a = l; a < i.lines.length;) { const s = new sl(i.lines.slice(a, a += 25)); i.height -= s.height, this.children.splice(++r, 0, s), s.parent = this }i.lines = i.lines.slice(0, l), this.maybeSpill() } break }e -= o } }, maybeSpill () { if (!(this.children.length <= 10)) { let e = this; do { const t = e.children.splice(e.children.length - 5, 5); const n = new ul(t); if (e.parent) { e.size -= n.size, e.height -= n.height; const r = B(e.parent.children, e); e.parent.children.splice(r + 1, 0, n) } else { const i = new ul(e.children); i.parent = e, e.children = [i, n], e = i }n.parent = e.parent } while (e.children.length > 10); e.parent.maybeSpill() } }, iterN (e, t, n) { for (let r = 0; r < this.children.length; ++r) { const i = this.children[r]; const o = i.chunkSize(); if (e < o) { const l = Math.min(t, o - e); if (i.iterN(e, l, n)) { return !0 } if ((t -= l) == 0) { break } e = 0 } else { e -= o } } } }; const cl = function (e, t, n) { if (n) { for (const r in n) { n.hasOwnProperty(r) && (this[r] = n[r]) } } this.doc = e, this.node = t }; function fl (e, t, n) { on(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && oi(e, n) } function hl (e, t, n, r) { const i = new cl(e, n, r); const o = e.cm; return o && i.noHScroll && (o.display.alignWidgets = !0), al(e, t, 'widget', function (t) { const n = t.widgets || (t.widgets = []); if (i.insertAt == null ? n.push(i) : n.splice(Math.min(n.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = t, o && !nn(e, t)) { const r = on(t) < e.scrollTop; Qe(t, t.height + Vn(i)), r && oi(o, i.height), o.curOp.forceUpdate = !0 } return !0 }), o && On(o, 'lineWidgetAdded', o, i, typeof t === 'number' ? t : et(t)), i }cl.prototype.clear = function () { const e = this.doc.cm; const t = this.line.widgets; const n = this.line; const r = et(n); if (r != null && t) { for (let i = 0; i < t.length; ++i) { t[i] == this && t.splice(i--, 1) }t.length || (n.widgets = null); const o = Vn(this); Qe(n, Math.max(0, n.height - o)), e && (Ni(e, function () { fl(e, n, -o), zr(e, r, 'widget') }), On(e, 'lineWidgetCleared', e, this, r)) } }, cl.prototype.changed = function () { const e = this; const t = this.height; const n = this.doc.cm; const r = this.line; this.height = null; const i = Vn(this) - t; i && (nn(this.doc, r) || Qe(r, r.height + i), n && Ni(n, function () { n.curOp.forceUpdate = !0, fl(n, r, i), On(n, 'lineWidgetChanged', n, e, et(r)) })) }, xe(cl); let dl = 0; const pl = function (e, t) { this.lines = [], this.type = t, this.doc = e, this.id = ++dl }; function gl (e, t, n, r, i) { if (r && r.shared) { return vl(e, t, n, r, i) } if (e.cm && !e.cm.curOp) { return Di(e.cm, gl)(e, t, n, r, i) } const o = new pl(e, i); const l = ot(t, n); if (r && z(r, o, !1), l > 0 || l == 0 && !1 !== o.clearWhenEmpty) { return o } if (o.replacedWith && (o.collapsed = !0, o.widgetNode = N('span', [o.replacedWith], 'CodeMirror-widget'), r.handleMouseEvents || o.widgetNode.setAttribute('cm-ignore-events', 'true'), r.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) { if (Yt(e, t.line, t, n, o) || t.line != n.line && Yt(e, n.line, t, n, o)) { throw new Error('Inserting collapsed marker partially overlapping an existing one') } Dt() }o.addToHistory && Lo(e, { from: t, to: n, origin: 'markText' }, e.sel, NaN); let a; let s = t.line; const u = e.cm; if (e.iter(s, n.line + 1, function (e) { u && o.collapsed && !u.options.lineWrapping && Zt(e) == u.display.maxLine && (a = !0), o.collapsed && s != t.line && Qe(e, 0), Ft(e, new Wt(o, s == t.line ? t.ch : null, s == n.line ? n.ch : null)), ++s }), o.collapsed && e.iter(t.line, n.line + 1, function (t) { nn(e, t) && Qe(t, 0) }), o.clearOnEnter && pe(o, 'beforeCursorEnter', function () { return o.clear() }), o.readOnly && (Nt(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed && (o.id = ++dl, o.atomic = !0), u) { if (a && (u.curOp.updateMaxLine = !0), o.collapsed) { Pr(u, t.line, n.line + 1) } else if (o.className || o.startStyle || o.endStyle || o.css || o.attributes || o.title) { for (let c = t.line; c <= n.line; c++) { zr(u, c, 'text') } }o.atomic && Uo(u.doc), On(u, 'markerAdded', u, o) } return o }pl.prototype.clear = function () { if (!this.explicitlyCleared) { const e = this.doc.cm; const t = e && !e.curOp; if (t && Ci(e), we(this, 'clear')) { const n = this.find(); n && On(this, 'clear', n.from, n.to) } for (var r = null, i = null, o = 0; o < this.lines.length; ++o) { const l = this.lines[o]; const a = Ht(l.markedSpans, this); e && !this.collapsed ? zr(e, et(l), 'text') : e && (a.to != null && (i = et(l)), a.from != null && (r = et(l))), l.markedSpans = Et(l.markedSpans, a), a.from == null && this.collapsed && !nn(this.doc, l) && e && Qe(l, Or(e.display)) } if (e && this.collapsed && !e.options.lineWrapping) { for (let s = 0; s < this.lines.length; ++s) { const u = Zt(this.lines[s]); const c = ln(u); c > e.display.maxLineLength && (e.display.maxLine = u, e.display.maxLineLength = c, e.display.maxLineChanged = !0) } }r != null && e && this.collapsed && Pr(e, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && Uo(e.doc)), e && On(e, 'markerCleared', e, this, r, i), t && ki(e), this.parent && this.parent.clear() } }, pl.prototype.find = function (e, t) { let n, r; e == null && this.type == 'bookmark' && (e = 1); for (let i = 0; i < this.lines.length; ++i) { const o = this.lines[i]; const l = Ht(o.markedSpans, this); if (l.from != null && (n = it(t ? o : et(o), l.from), e == -1)) { return n } if (l.to != null && (r = it(t ? o : et(o), l.to), e == 1)) { return r } } return n && { from: n, to: r } }, pl.prototype.changed = function () { const e = this; const t = this.find(-1, !0); const n = this; const r = this.doc.cm; t && r && Ni(r, function () { const i = t.line; const o = et(t.line); const l = er(r, o); if (l && (ur(l), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !nn(n.doc, i) && n.height != null) { const a = n.height; n.height = null; const s = Vn(n) - a; s && Qe(i, i.height + s) }On(r, 'markerChanged', r, e) }) }, pl.prototype.attachLine = function (e) { if (!this.lines.length && this.doc.cm) { const t = this.doc.cm.curOp; t.maybeHiddenMarkers && B(t.maybeHiddenMarkers, this) != -1 || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(e) }, pl.prototype.detachLine = function (e) { if (this.lines.splice(B(this.lines, e), 1), !this.lines.length && this.doc.cm) { const t = this.doc.cm.curOp; (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this) } }, xe(pl); const ml = function (e, t) { this.markers = e, this.primary = t; for (let n = 0; n < e.length; ++n) { e[n].parent = this } }; function vl (e, t, n, r, i) { r = z(r), r.shared = !1; const o = [gl(e, t, n, r, i)]; let l = o[0]; const a = r.widgetNode; return vo(e, function (e) { a && (r.widgetNode = a.cloneNode(!0)), o.push(gl(e, ft(e, t), ft(e, n), r, i)); for (let s = 0; s < e.linked.length; ++s) { if (e.linked[s].isParent) { return } } l = q(o) }), new ml(o, l) } function yl (e) { return e.findMarks(it(e.first, 0), e.clipPos(it(e.lastLine())), function (e) { return e.parent }) } function bl (e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; const i = r.find(); const o = e.clipPos(i.from); const l = e.clipPos(i.to); if (ot(o, l)) { const a = gl(e, o, l, r.primary, r.primary.type); r.markers.push(a), a.parent = r } } } function wl (e) { for (let t = function (t) { const n = e[t]; const r = [n.primary.doc]; vo(n.primary.doc, function (e) { return r.push(e) }); for (let i = 0; i < n.markers.length; i++) { const o = n.markers[i]; B(r, o.doc) == -1 && (o.parent = null, n.markers.splice(i--, 1)) } }, n = 0; n < e.length; n++) { t(n) } }ml.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (let e = 0; e < this.markers.length; ++e) { this.markers[e].clear() } On(this, 'clear') } }, ml.prototype.find = function (e, t) { return this.primary.find(e, t) }, xe(ml); let xl = 0; var Cl = function (e, t, n, r, i) { if (!(this instanceof Cl)) { return new Cl(e, t, n, r, i) } n == null && (n = 0), ul.call(this, [new sl([new sn('', null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = n; const o = it(n, 0); this.sel = lo(o), this.history = new xo(null), this.id = ++xl, this.modeOption = t, this.lineSep = r, this.direction = i == 'rtl' ? 'rtl' : 'ltr', this.extend = !1, typeof e === 'string' && (e = this.splitLines(e)), mo(this, { from: o, to: o, text: e }), jo(this, lo(o), G) }; Cl.prototype = Q(ul.prototype, { constructor: Cl, iter (e, t, n) { n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e) }, insert (e, t) { for (var n = 0, r = 0; r < t.length; ++r) { n += t[r].height } this.insertInner(e - this.first, t, n) }, remove (e, t) { this.removeInner(e - this.first, t) }, getValue (e) { const t = Je(this, this.first, this.first + this.size); return !1 === e ? t : t.join(e || this.lineSeparator()) }, setValue: Hi(function (e) { const t = it(this.first, 0); const n = this.first + this.size - 1; Zo(this, { from: t, to: it(n, Ye(this, n).text.length), text: this.splitLines(e), origin: 'setValue', full: !0 }, !0), this.cm && ai(this.cm, 0, 0), jo(this, lo(t), G) }), replaceRange (e, t, n, r) { t = ft(this, t), n = n ? ft(this, n) : t, rl(this, e, t, n, r) }, getRange (e, t, n) { const r = Ze(this, ft(this, e), ft(this, t)); return !1 === n ? r : r.join(n || this.lineSeparator()) }, getLine (e) { const t = this.getLineHandle(e); return t && t.text }, getLineHandle (e) { if (nt(this, e)) { return Ye(this, e) } }, getLineNumber (e) { return et(e) }, getLineHandleVisualStart (e) { return typeof e === 'number' && (e = Ye(this, e)), Zt(e) }, lineCount () { return this.size }, firstLine () { return this.first }, lastLine () { return this.first + this.size - 1 }, clipPos (e) { return ft(this, e) }, getCursor (e) { let t; const n = this.sel.primary(); return t = e == null || e == 'head' ? n.head : e == 'anchor' ? n.anchor : e == 'end' || e == 'to' || !1 === e ? n.to() : n.from(), t }, listSelections () { return this.sel.ranges }, somethingSelected () { return this.sel.somethingSelected() }, setCursor: Hi(function (e, t, n) { Io(this, ft(this, typeof e === 'number' ? it(e, t || 0) : e), null, n) }), setSelection: Hi(function (e, t, n) { Io(this, ft(this, e), ft(this, t || e), n) }), extendSelection: Hi(function (e, t, n) { Fo(this, ft(this, e), t && ft(this, t), n) }), extendSelections: Hi(function (e, t) { Po(this, dt(this, e), t) }), extendSelectionsBy: Hi(function (e, t) { const n = Y(this.sel.ranges, e); Po(this, dt(this, n), t) }), setSelections: Hi(function (e, t, n) { if (e.length) { for (var r = [], i = 0; i < e.length; i++) { r[i] = new io(ft(this, e[i].anchor), ft(this, e[i].head)) }t == null && (t = Math.min(e.length - 1, this.sel.primIndex)), jo(this, oo(this.cm, r, t), n) } }), addSelection: Hi(function (e, t, n) { const r = this.sel.ranges.slice(0); r.push(new io(ft(this, e), ft(this, t || e))), jo(this, oo(this.cm, r, r.length - 1), n) }), getSelection (e) { for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) { const i = Ze(this, n[r].from(), n[r].to()); t = t ? t.concat(i) : i } return !1 === e ? t : t.join(e || this.lineSeparator()) }, getSelections (e) { for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) { let i = Ze(this, n[r].from(), n[r].to()); !1 !== e && (i = i.join(e || this.lineSeparator())), t[r] = i } return t }, replaceSelection (e, t, n) { for (var r = [], i = 0; i < this.sel.ranges.length; i++) { r[i] = e } this.replaceSelections(r, t, n || '+input') }, replaceSelections: Hi(function (e, t, n) { for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) { const l = i.ranges[o]; r[o] = { from: l.from(), to: l.to(), text: this.splitLines(e[o]), origin: n } } for (var a = t && t != 'end' && fo(this, r, t), s = r.length - 1; s >= 0; s--) { Zo(this, r[s]) }a ? Bo(this, a) : this.cm && li(this.cm) }), undo: Hi(function () { Qo(this, 'undo') }), redo: Hi(function () { Qo(this, 'redo') }), undoSelection: Hi(function () { Qo(this, 'undo', !0) }), redoSelection: Hi(function () { Qo(this, 'redo', !0) }), setExtending (e) { this.extend = e }, getExtending () { return this.extend }, historySize () { for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++) { e.done[r].ranges || ++t } for (let i = 0; i < e.undone.length; i++) { e.undone[i].ranges || ++n } return { undo: t, redo: n } }, clearHistory () { const e = this; this.history = new xo(this.history.maxGeneration), vo(this, function (t) { return t.history = e.history }, !0) }, markClean () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration (e) { return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean (e) { return this.history.generation == (e || this.cleanGeneration) }, getHistory () { return { done: Ho(this.history.done), undone: Ho(this.history.undone) } }, setHistory (e) { const t = this.history = new xo(this.history.maxGeneration); t.done = Ho(e.done.slice(0), null, !0), t.undone = Ho(e.undone.slice(0), null, !0) }, setGutterMarker: Hi(function (e, t, n) { return al(this, e, 'gutter', function (e) { const r = e.gutterMarkers || (e.gutterMarkers = {}); return r[t] = n, !n && re(r) && (e.gutterMarkers = null), !0 }) }), clearGutter: Hi(function (e) { const t = this; this.iter(function (n) { n.gutterMarkers && n.gutterMarkers[e] && al(t, n, 'gutter', function () { return n.gutterMarkers[e] = null, re(n.gutterMarkers) && (n.gutterMarkers = null), !0 }) }) }), lineInfo (e) { let t; if (typeof e === 'number') { if (!nt(this, e)) { return null } if (t = e, e = Ye(this, e), !e) { return null } } else if (t = et(e), t == null) { return null } return { line: t, handle: e, text: e.text, gutterMarkers: e.gutterMarkers, textClass: e.textClass, bgClass: e.bgClass, wrapClass: e.wrapClass, widgets: e.widgets } }, addLineClass: Hi(function (e, t, n) { return al(this, e, t == 'gutter' ? 'gutter' : 'class', function (e) { const r = t == 'text' ? 'textClass' : t == 'background' ? 'bgClass' : t == 'gutter' ? 'gutterClass' : 'wrapClass'; if (e[r]) { if (S(n).test(e[r])) { return !1 } e[r] += ' ' + n } else { e[r] = n } return !0 }) }), removeLineClass: Hi(function (e, t, n) { return al(this, e, t == 'gutter' ? 'gutter' : 'class', function (e) { const r = t == 'text' ? 'textClass' : t == 'background' ? 'bgClass' : t == 'gutter' ? 'gutterClass' : 'wrapClass'; const i = e[r]; if (!i) { return !1 } if (n == null) { e[r] = null } else { const o = i.match(S(n)); if (!o) { return !1 } const l = o.index + o[0].length; e[r] = i.slice(0, o.index) + (o.index && l != i.length ? ' ' : '') + i.slice(l) || null } return !0 }) }), addLineWidget: Hi(function (e, t, n) { return hl(this, e, t, n) }), removeLineWidget (e) { e.clear() }, markText (e, t, n) { return gl(this, ft(this, e), ft(this, t), n, n && n.type || 'range') }, setBookmark (e, t) { const n = { replacedWith: t && (t.nodeType == null ? t.widget : t), insertLeft: t && t.insertLeft, clearWhenEmpty: !1, shared: t && t.shared, handleMouseEvents: t && t.handleMouseEvents }; return e = ft(this, e), gl(this, e, e, n, 'bookmark') }, findMarksAt (e) { e = ft(this, e); const t = []; const n = Ye(this, e.line).markedSpans; if (n) { for (let r = 0; r < n.length; ++r) { const i = n[r]; (i.from == null || i.from <= e.ch) && (i.to == null || i.to >= e.ch) && t.push(i.marker.parent || i.marker) } } return t }, findMarks (e, t, n) { e = ft(this, e), t = ft(this, t); const r = []; let i = e.line; return this.iter(e.line, t.line + 1, function (o) { const l = o.markedSpans; if (l) { for (let a = 0; a < l.length; a++) { const s = l[a]; s.to != null && i == e.line && e.ch >= s.to || s.from == null && i != e.line || s.from != null && i == t.line && s.from >= t.ch || n && !n(s.marker) || r.push(s.marker.parent || s.marker) } }++i }), r }, getAllMarks () { const e = []; return this.iter(function (t) { const n = t.markedSpans; if (n) { for (let r = 0; r < n.length; ++r) { n[r].from != null && e.push(n[r].marker) } } }), e }, posFromIndex (e) { let t; let n = this.first; const r = this.lineSeparator().length; return this.iter(function (i) { const o = i.text.length + r; if (o > e) { return t = e, !0 } e -= o, ++n }), ft(this, it(n, t)) }, indexFromPos (e) { e = ft(this, e); let t = e.ch; if (e.line < this.first || e.ch < 0) { return 0 } const n = this.lineSeparator().length; return this.iter(this.first, e.line, function (e) { t += e.text.length + n }), t }, copy (e) { const t = new Cl(Je(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t }, linkedDoc (e) { e || (e = {}); let t = this.first; let n = this.first + this.size; e.from != null && e.from > t && (t = e.from), e.to != null && e.to < n && (n = e.to); const r = new Cl(Je(this, t, n), e.mode || this.modeOption, t, this.lineSep, this.direction); return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({ doc: r, sharedHist: e.sharedHist }), r.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], bl(r, yl(this)), r }, unlinkDoc (e) { if (e instanceof Pa && (e = e.doc), this.linked) { for (let t = 0; t < this.linked.length; ++t) { const n = this.linked[t]; if (n.doc == e) { this.linked.splice(t, 1), e.unlinkDoc(this), wl(yl(this)); break } } } if (e.history == this.history) { const r = [e.id]; vo(e, function (e) { return r.push(e.id) }, !0), e.history = new xo(null), e.history.done = Ho(this.history.done, r), e.history.undone = Ho(this.history.undone, r) } }, iterLinkedDocs (e) { vo(this, e) }, getMode () { return this.mode }, getEditor () { return this.cm }, splitLines (e) { return this.lineSep ? e.split(this.lineSep) : He(e) }, lineSeparator () { return this.lineSep || '\n' }, setDirection: Hi(function (e) { e != 'rtl' && (e = 'ltr'), e != this.direction && (this.direction = e, this.iter(function (e) { return e.order = null }), this.cm && wo(this.cm)) }) }), Cl.prototype.eachLine = Cl.prototype.iter; let kl = 0; function Sl (e) { const t = this; if (Ml(t), !ye(t, e) && !Gn(t.display, e)) { Ce(e), l && (kl = +new Date()); let n = Er(t, e, !0); const r = e.dataTransfer.files; if (n && !t.isReadOnly()) { if (r && r.length && window.FileReader && window.File) { for (var i = r.length, o = Array(i), a = 0, s = function () { ++a == i && Di(t, function () { n = ft(t.doc, n); const e = { from: n, to: n, text: t.doc.splitLines(o.filter(function (e) { return e != null }).join(t.doc.lineSeparator())), origin: 'paste' }; Zo(t.doc, e), Bo(t.doc, lo(n, ao(e))) })() }, u = function (e, n) { if (t.options.allowDropFileTypes && B(t.options.allowDropFileTypes, e.type) == -1) { s() } else { const r = new FileReader(); r.onerror = function () { return s() }, r.onload = function () { const e = r.result; /[\x00-\x08\x0E-\x1F]{2}/.test(e) ? s() : (o[n] = e, s()) }, r.readAsText(e) } }, c = 0; c < r.length; c++) { u(r[c], c) } } else { if (t.state.draggingText && t.doc.sel.contains(n) > -1) { return t.state.draggingText(e), void setTimeout(function () { return t.display.input.focus() }, 20) } try { const f = e.dataTransfer.getData('Text'); if (f) { let h; if (t.state.draggingText && !t.state.draggingText.copy && (h = t.listSelections()), Vo(t.doc, lo(n, n)), h) { for (let d = 0; d < h.length; ++d) { rl(t.doc, '', h[d].anchor, h[d].head, 'drag') } }t.replaceSelection(f, 'around', 'paste'), t.display.input.focus() } } catch (e) {} } } } } function Ll (e, t) { if (l && (!e.state.draggingText || +new Date() - kl < 100)) { Le(t) } else if (!ye(e, t) && !Gn(e.display, t) && (t.dataTransfer.setData('Text', e.getSelection()), t.dataTransfer.effectAllowed = 'copyMove', t.dataTransfer.setDragImage && !h)) { const n = A('img', null, null, 'position: fixed; left: 0; top: 0;'); n.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==', f && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), f && n.parentNode.removeChild(n) } } function Tl (e, t) { const n = Er(e, t); if (n) { const r = document.createDocumentFragment(); Ur(e, n, r), e.display.dragCursor || (e.display.dragCursor = A('div', null, 'CodeMirror-cursors CodeMirror-dragcursors'), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), O(e.display.dragCursor, r) } } function Ml (e) { e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null) } function Ol (e) { if (document.getElementsByClassName) { for (var t = document.getElementsByClassName('CodeMirror'), n = [], r = 0; r < t.length; r++) { const i = t[r].CodeMirror; i && n.push(i) }n.length && n[0].operation(function () { for (let t = 0; t < n.length; t++) { e(n[t]) } }) } } let Al = !1; function Nl () { Al || (Dl(), Al = !0) } function Dl () { let e; pe(window, 'resize', function () { e == null && (e = setTimeout(function () { e = null, Ol(Wl) }, 100)) }), pe(window, 'blur', function () { return Ol(Zr) }) } function Wl (e) { const t = e.display; t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize() } for (var Hl = { 3: 'Pause', 8: 'Backspace', 9: 'Tab', 13: 'Enter', 16: 'Shift', 17: 'Ctrl', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Esc', 32: 'Space', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'Left', 38: 'Up', 39: 'Right', 40: 'Down', 44: 'PrintScrn', 45: 'Insert', 46: 'Delete', 59: ';', 61: '=', 91: 'Mod', 92: 'Mod', 93: 'Mod', 106: '*', 107: '=', 109: '-', 110: '.', 111: '/', 145: 'ScrollLock', 173: '-', 186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\', 221: ']', 222: "'", 63232: 'Up', 63233: 'Down', 63234: 'Left', 63235: 'Right', 63272: 'Delete', 63273: 'Home', 63275: 'End', 63276: 'PageUp', 63277: 'PageDown', 63302: 'Insert' }, El = 0; El < 10; El++) { Hl[El + 48] = Hl[El + 96] = String(El) } for (let Fl = 65; Fl <= 90; Fl++) { Hl[Fl] = String.fromCharCode(Fl) } for (let Pl = 1; Pl <= 12; Pl++) { Hl[Pl + 111] = Hl[Pl + 63235] = 'F' + Pl } const zl = {}; function Il (e) { let t; let n; let r; let i; const o = e.split(/-(?!$)/); e = o[o.length - 1]; for (let l = 0; l < o.length - 1; l++) { const a = o[l]; if (/^(cmd|meta|m)$/i.test(a)) { i = !0 } else if (/^a(lt)?$/i.test(a)) { t = !0 } else if (/^(c|ctrl|control)$/i.test(a)) { n = !0 } else { if (!/^s(hift)?$/i.test(a)) { throw new Error('Unrecognized modifier name: ' + a) } r = !0 } } return t && (e = 'Alt-' + e), n && (e = 'Ctrl-' + e), i && (e = 'Cmd-' + e), r && (e = 'Shift-' + e), e } function Rl (e) { const t = {}; for (const n in e) { if (e.hasOwnProperty(n)) { const r = e[n]; if (/^(name|fallthrough|(de|at)tach)$/.test(n)) { continue } if (r == '...') { delete e[n]; continue } for (let i = Y(n.split(' '), Il), o = 0; o < i.length; o++) { let l = void 0; let a = void 0; o == i.length - 1 ? (a = i.join(' '), l = r) : (a = i.slice(0, o + 1).join(' '), l = '...'); const s = t[a]; if (s) { if (s != l) { throw new Error('Inconsistent bindings for ' + a) } } else { t[a] = l } } delete e[n] } } for (const u in t) { e[u] = t[u] } return e } function Bl (e, t, n, r) { t = Ul(t); const i = t.call ? t.call(e, r) : t[e]; if (!1 === i) { return 'nothing' } if (i === '...') { return 'multi' } if (i != null && n(i)) { return 'handled' } if (t.fallthrough) { if (Object.prototype.toString.call(t.fallthrough) != '[object Array]') { return Bl(e, t.fallthrough, n, r) } for (let o = 0; o < t.fallthrough.length; o++) { const l = Bl(e, t.fallthrough[o], n, r); if (l) { return l } } } } function jl (e) { const t = typeof e === 'string' ? e : Hl[e.keyCode]; return t == 'Ctrl' || t == 'Alt' || t == 'Shift' || t == 'Mod' } function Vl (e, t, n) { const r = e; return t.altKey && r != 'Alt' && (e = 'Alt-' + e), (C ? t.metaKey : t.ctrlKey) && r != 'Ctrl' && (e = 'Ctrl-' + e), (C ? t.ctrlKey : t.metaKey) && r != 'Cmd' && (e = 'Cmd-' + e), !n && t.shiftKey && r != 'Shift' && (e = 'Shift-' + e), e } function Gl (e, t) { if (f && e.keyCode == 34 && e.char) { return !1 } let n = Hl[e.keyCode]; return n != null && !e.altGraphKey && (e.keyCode == 3 && e.code && (n = e.code), Vl(n, e, t)) } function Ul (e) { return typeof e === 'string' ? zl[e] : e } function _l (e, t) { for (var n = e.doc.sel.ranges, r = [], i = 0; i < n.length; i++) { const o = t(n[i]); while (r.length && ot(o.from, q(r).to) <= 0) { const l = r.pop(); if (ot(l.from, o.from) < 0) { o.from = l.from; break } }r.push(o) }Ni(e, function () { for (let t = r.length - 1; t >= 0; t--) { rl(e.doc, '', r[t].from, r[t].to, '+delete') }li(e) }) } function Kl (e, t, n) { const r = le(e.text, t + n, n); return r < 0 || r > e.text.length ? null : r } function $l (e, t, n) { const r = Kl(e, t.ch, n); return r == null ? null : new it(t.line, r, n < 0 ? 'after' : 'before') } function Xl (e, t, n, r, i) { if (e) { t.getOption('direction') == 'rtl' && (i = -i); const o = he(n, t.doc.direction); if (o) { let l; const a = i < 0 ? q(o) : o[0]; const s = i < 0 == (a.level == 1); const u = s ? 'after' : 'before'; if (a.level > 0 || t.doc.direction == 'rtl') { const c = tr(t, n); l = i < 0 ? n.text.length - 1 : 0; const f = nr(t, c, l).top; l = ae(function (e) { return nr(t, c, e).top == f }, i < 0 == (a.level == 1) ? a.from : a.to - 1, l), u == 'before' && (l = Kl(n, l, 1)) } else { l = i < 0 ? a.to : a.from } return new it(r, l, u) } } return new it(r, i < 0 ? n.text.length : 0, i < 0 ? 'before' : 'after') } function ql (e, t, n, r) { const i = he(t, e.doc.direction); if (!i) { return $l(t, n, r) } n.ch >= t.text.length ? (n.ch = t.text.length, n.sticky = 'before') : n.ch <= 0 && (n.ch = 0, n.sticky = 'after'); const o = ce(i, n.ch, n.sticky); const l = i[o]; if (e.doc.direction == 'ltr' && l.level % 2 == 0 && (r > 0 ? l.to > n.ch : l.from < n.ch)) { return $l(t, n, r) } let a; const s = function (e, n) { return Kl(t, e instanceof it ? e.ch : e, n) }; const u = function (n) { return e.options.lineWrapping ? (a = a || tr(e, t), kr(e, t, a, n)) : { begin: 0, end: t.text.length } }; const c = u(n.sticky == 'before' ? s(n, -1) : n.ch); if (e.doc.direction == 'rtl' || l.level == 1) { const f = l.level == 1 == r < 0; const h = s(n, f ? 1 : -1); if (h != null && (f ? h <= l.to && h <= c.end : h >= l.from && h >= c.begin)) { const d = f ? 'before' : 'after'; return new it(n.line, h, d) } } const p = function (e, t, r) { for (let o = function (e, t) { return t ? new it(n.line, s(e, 1), 'before') : new it(n.line, e, 'after') }; e >= 0 && e < i.length; e += t) { const l = i[e]; const a = t > 0 == (l.level != 1); let u = a ? r.begin : s(r.end, -1); if (l.from <= u && u < l.to) { return o(u, a) } if (u = a ? l.from : s(l.to, -1), r.begin <= u && u < r.end) { return o(u, a) } } }; let g = p(o + r, r, c); if (g) { return g } const m = r > 0 ? c.end : s(c.begin, -1); return m == null || r > 0 && m == t.text.length || (g = p(r > 0 ? 0 : i.length - 1, r, u(m)), !g) ? null : g }zl.basic = { Left: 'goCharLeft', Right: 'goCharRight', Up: 'goLineUp', Down: 'goLineDown', End: 'goLineEnd', Home: 'goLineStartSmart', PageUp: 'goPageUp', PageDown: 'goPageDown', Delete: 'delCharAfter', Backspace: 'delCharBefore', 'Shift-Backspace': 'delCharBefore', Tab: 'defaultTab', 'Shift-Tab': 'indentAuto', Enter: 'newlineAndIndent', Insert: 'toggleOverwrite', Esc: 'singleSelection' }, zl.pcDefault = { 'Ctrl-A': 'selectAll', 'Ctrl-D': 'deleteLine', 'Ctrl-Z': 'undo', 'Shift-Ctrl-Z': 'redo', 'Ctrl-Y': 'redo', 'Ctrl-Home': 'goDocStart', 'Ctrl-End': 'goDocEnd', 'Ctrl-Up': 'goLineUp', 'Ctrl-Down': 'goLineDown', 'Ctrl-Left': 'goGroupLeft', 'Ctrl-Right': 'goGroupRight', 'Alt-Left': 'goLineStart', 'Alt-Right': 'goLineEnd', 'Ctrl-Backspace': 'delGroupBefore', 'Ctrl-Delete': 'delGroupAfter', 'Ctrl-S': 'save', 'Ctrl-F': 'find', 'Ctrl-G': 'findNext', 'Shift-Ctrl-G': 'findPrev', 'Shift-Ctrl-F': 'replace', 'Shift-Ctrl-R': 'replaceAll', 'Ctrl-[': 'indentLess', 'Ctrl-]': 'indentMore', 'Ctrl-U': 'undoSelection', 'Shift-Ctrl-U': 'redoSelection', 'Alt-U': 'redoSelection', fallthrough: 'basic' }, zl.emacsy = { 'Ctrl-F': 'goCharRight', 'Ctrl-B': 'goCharLeft', 'Ctrl-P': 'goLineUp', 'Ctrl-N': 'goLineDown', 'Alt-F': 'goWordRight', 'Alt-B': 'goWordLeft', 'Ctrl-A': 'goLineStart', 'Ctrl-E': 'goLineEnd', 'Ctrl-V': 'goPageDown', 'Shift-Ctrl-V': 'goPageUp', 'Ctrl-D': 'delCharAfter', 'Ctrl-H': 'delCharBefore', 'Alt-D': 'delWordAfter', 'Alt-Backspace': 'delWordBefore', 'Ctrl-K': 'killLine', 'Ctrl-T': 'transposeChars', 'Ctrl-O': 'openLine' }, zl.macDefault = { 'Cmd-A': 'selectAll', 'Cmd-D': 'deleteLine', 'Cmd-Z': 'undo', 'Shift-Cmd-Z': 'redo', 'Cmd-Y': 'redo', 'Cmd-Home': 'goDocStart', 'Cmd-Up': 'goDocStart', 'Cmd-End': 'goDocEnd', 'Cmd-Down': 'goDocEnd', 'Alt-Left': 'goGroupLeft', 'Alt-Right': 'goGroupRight', 'Cmd-Left': 'goLineLeft', 'Cmd-Right': 'goLineRight', 'Alt-Backspace': 'delGroupBefore', 'Ctrl-Alt-Backspace': 'delGroupAfter', 'Alt-Delete': 'delGroupAfter', 'Cmd-S': 'save', 'Cmd-F': 'find', 'Cmd-G': 'findNext', 'Shift-Cmd-G': 'findPrev', 'Cmd-Alt-F': 'replace', 'Shift-Cmd-Alt-F': 'replaceAll', 'Cmd-[': 'indentLess', 'Cmd-]': 'indentMore', 'Cmd-Backspace': 'delWrappedLineLeft', 'Cmd-Delete': 'delWrappedLineRight', 'Cmd-U': 'undoSelection', 'Shift-Cmd-U': 'redoSelection', 'Ctrl-Up': 'goDocStart', 'Ctrl-Down': 'goDocEnd', fallthrough: ['basic', 'emacsy'] }, zl.default = y ? zl.macDefault : zl.pcDefault; const Yl = { selectAll: qo, singleSelection (e) { return e.setSelection(e.getCursor('anchor'), e.getCursor('head'), G) }, killLine (e) { return _l(e, function (t) { if (t.empty()) { const n = Ye(e.doc, t.head.line).text.length; return t.head.ch == n && t.head.line < e.lastLine() ? { from: t.head, to: it(t.head.line + 1, 0) } : { from: t.head, to: it(t.head.line, n) } } return { from: t.from(), to: t.to() } }) }, deleteLine (e) { return _l(e, function (t) { return { from: it(t.from().line, 0), to: ft(e.doc, it(t.to().line + 1, 0)) } }) }, delLineLeft (e) { return _l(e, function (e) { return { from: it(e.from().line, 0), to: e.from() } }) }, delWrappedLineLeft (e) { return _l(e, function (t) { const n = e.charCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: 0, top: n }, 'div'); return { from: r, to: t.from() } }) }, delWrappedLineRight (e) { return _l(e, function (t) { const n = e.charCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, 'div'); return { from: t.from(), to: r } }) }, undo (e) { return e.undo() }, redo (e) { return e.redo() }, undoSelection (e) { return e.undoSelection() }, redoSelection (e) { return e.redoSelection() }, goDocStart (e) { return e.extendSelection(it(e.firstLine(), 0)) }, goDocEnd (e) { return e.extendSelection(it(e.lastLine())) }, goLineStart (e) { return e.extendSelectionsBy(function (t) { return Zl(e, t.head.line) }, { origin: '+move', bias: 1 }) }, goLineStartSmart (e) { return e.extendSelectionsBy(function (t) { return Ql(e, t.head) }, { origin: '+move', bias: 1 }) }, goLineEnd (e) { return e.extendSelectionsBy(function (t) { return Jl(e, t.head.line) }, { origin: '+move', bias: -1 }) }, goLineRight (e) { return e.extendSelectionsBy(function (t) { const n = e.cursorCoords(t.head, 'div').top + 5; return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, 'div') }, _) }, goLineLeft (e) { return e.extendSelectionsBy(function (t) { const n = e.cursorCoords(t.head, 'div').top + 5; return e.coordsChar({ left: 0, top: n }, 'div') }, _) }, goLineLeftSmart (e) { return e.extendSelectionsBy(function (t) { const n = e.cursorCoords(t.head, 'div').top + 5; const r = e.coordsChar({ left: 0, top: n }, 'div'); return r.ch < e.getLine(r.line).search(/\S/) ? Ql(e, t.head) : r }, _) }, goLineUp (e) { return e.moveV(-1, 'line') }, goLineDown (e) { return e.moveV(1, 'line') }, goPageUp (e) { return e.moveV(-1, 'page') }, goPageDown (e) { return e.moveV(1, 'page') }, goCharLeft (e) { return e.moveH(-1, 'char') }, goCharRight (e) { return e.moveH(1, 'char') }, goColumnLeft (e) { return e.moveH(-1, 'column') }, goColumnRight (e) { return e.moveH(1, 'column') }, goWordLeft (e) { return e.moveH(-1, 'word') }, goGroupRight (e) { return e.moveH(1, 'group') }, goGroupLeft (e) { return e.moveH(-1, 'group') }, goWordRight (e) { return e.moveH(1, 'word') }, delCharBefore (e) { return e.deleteH(-1, 'char') }, delCharAfter (e) { return e.deleteH(1, 'char') }, delWordBefore (e) { return e.deleteH(-1, 'word') }, delWordAfter (e) { return e.deleteH(1, 'word') }, delGroupBefore (e) { return e.deleteH(-1, 'group') }, delGroupAfter (e) { return e.deleteH(1, 'group') }, indentAuto (e) { return e.indentSelection('smart') }, indentMore (e) { return e.indentSelection('add') }, indentLess (e) { return e.indentSelection('subtract') }, insertTab (e) { return e.replaceSelection('\t') }, insertSoftTab (e) { for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) { const o = n[i].from(); const l = I(e.getLine(o.line), o.ch, r); t.push(X(r - l % r)) }e.replaceSelections(t) }, defaultTab (e) { e.somethingSelected() ? e.indentSelection('add') : e.execCommand('insertTab') }, transposeChars (e) { return Ni(e, function () { for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) { if (t[r].empty()) { let i = t[r].head; const o = Ye(e.doc, i.line).text; if (o) { if (i.ch == o.length && (i = new it(i.line, i.ch - 1)), i.ch > 0) { i = new it(i.line, i.ch + 1), e.replaceRange(o.charAt(i.ch - 1) + o.charAt(i.ch - 2), it(i.line, i.ch - 2), i, '+transpose') } else if (i.line > e.doc.first) { const l = Ye(e.doc, i.line - 1).text; l && (i = new it(i.line, 1), e.replaceRange(o.charAt(0) + e.doc.lineSeparator() + l.charAt(l.length - 1), it(i.line - 1, l.length - 1), i, '+transpose')) } }n.push(new io(i, i)) } }e.setSelections(n) }) }, newlineAndIndent (e) { return Ni(e, function () { for (var t = e.listSelections(), n = t.length - 1; n >= 0; n--) { e.replaceRange(e.doc.lineSeparator(), t[n].anchor, t[n].head, '+input') }t = e.listSelections(); for (let r = 0; r < t.length; r++) { e.indentLine(t[r].from().line, null, !0) }li(e) }) }, openLine (e) { return e.replaceSelection('\n', 'start') }, toggleOverwrite (e) { return e.toggleOverwrite() } }; function Zl (e, t) { const n = Ye(e.doc, t); const r = Zt(n); return r != n && (t = et(r)), Xl(!0, e, r, t, 1) } function Jl (e, t) { const n = Ye(e.doc, t); const r = Jt(n); return r != n && (t = et(r)), Xl(!0, e, n, t, -1) } function Ql (e, t) { const n = Zl(e, t.line); const r = Ye(e.doc, n.line); const i = he(r, e.doc.direction); if (!i || i[0].level == 0) { const o = Math.max(0, r.text.search(/\S/)); const l = t.line == n.line && t.ch <= o && t.ch; return it(n.line, l ? 0 : o, n.sticky) } return n } function ea (e, t, n) { if (typeof t === 'string' && (t = Yl[t], !t)) { return !1 } e.display.input.ensurePolled(); const r = e.display.shift; let i = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != V } finally { e.display.shift = r, e.state.suppressEdits = !1 } return i } function ta (e, t, n) { for (let r = 0; r < e.state.keyMaps.length; r++) { const i = Bl(t, e.state.keyMaps[r], n, e); if (i) { return i } } return e.options.extraKeys && Bl(t, e.options.extraKeys, n, e) || Bl(t, e.options.keyMap, n, e) } const na = new R(); function ra (e, t, n, r) { const i = e.state.keySeq; if (i) { if (jl(t)) { return 'handled' } if (/\'$/.test(t) ? e.state.keySeq = null : na.set(50, function () { e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset()) }), ia(e, i + ' ' + t, n, r)) { return !0 } } return ia(e, t, n, r) } function ia (e, t, n, r) { const i = ta(e, t, r); return i == 'multi' && (e.state.keySeq = t), i == 'handled' && On(e, 'keyHandled', e, t, n), i != 'handled' && i != 'multi' || (Ce(n), $r(e)), !!i } function oa (e, t) { const n = Gl(t, !0); return !!n && (t.shiftKey && !e.state.keySeq ? ra(e, 'Shift-' + n, t, function (t) { return ea(e, t, !0) }) || ra(e, n, t, function (t) { if (typeof t === 'string' ? /^go[A-Z]/.test(t) : t.motion) { return ea(e, t) } }) : ra(e, n, t, function (t) { return ea(e, t) })) } function la (e, t, n) { return ra(e, "'" + n + "'", t, function (t) { return ea(e, t, !0) }) } let aa = null; function sa (e) { const t = this; if (t.curOp.focus = W(), !ye(t, e)) { l && a < 11 && e.keyCode == 27 && (e.returnValue = !1); const r = e.keyCode; t.display.shift = r == 16 || e.shiftKey; const i = oa(t, e); f && (aa = i ? r : null, !i && r == 88 && !Fe && (y ? e.metaKey : e.ctrlKey) && t.replaceSelection('', null, 'cut')), n && !y && !i && r == 46 && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand('cut'), r != 18 || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || ua(t) } } function ua (e) { const t = e.display.lineDiv; function n (e) { e.keyCode != 18 && e.altKey || (T(t, 'CodeMirror-crosshair'), me(document, 'keyup', n), me(document, 'mouseover', n)) }H(t, 'CodeMirror-crosshair'), pe(document, 'keyup', n), pe(document, 'mouseover', n) } function ca (e) { e.keyCode == 16 && (this.doc.sel.shift = !1), ye(this, e) } function fa (e) { const t = this; if (!(Gn(t.display, e) || ye(t, e) || e.ctrlKey && !e.altKey || y && e.metaKey)) { const n = e.keyCode; const r = e.charCode; if (f && n == aa) { return aa = null, void Ce(e) } if (!f || e.which && !(e.which < 10) || !oa(t, e)) { const i = String.fromCharCode(r == null ? n : r); i != '\b' && (la(t, e, i) || t.display.input.onKeyPress(e)) } } } let ha; let da; const pa = 400; const ga = function (e, t, n) { this.time = e, this.pos = t, this.button = n }; function ma (e, t) { const n = +new Date(); return da && da.compare(n, e, t) ? (ha = da = null, 'triple') : ha && ha.compare(n, e, t) ? (da = new ga(n, e, t), ha = null, 'double') : (ha = new ga(n, e, t), da = null, 'single') } function va (e) { const t = this; const n = t.display; if (!(ye(t, e) || n.activeTouch && n.input.supportsTouch())) { if (n.input.ensurePolled(), n.shift = e.shiftKey, Gn(n, e)) { s || (n.scroller.draggable = !1, setTimeout(function () { return n.scroller.draggable = !0 }, 100)) } else if (!Ta(t, e)) { const r = Er(t, e); const i = Me(e); const o = r ? ma(r, i) : 'single'; window.focus(), i == 1 && t.state.selectingText && t.state.selectingText(e), r && ya(t, i, r, o, e) || (i == 1 ? r ? wa(t, r, o, e) : Te(e) == n.scroller && Ce(e) : i == 2 ? (r && Fo(t.doc, r), setTimeout(function () { return n.input.focus() }, 20)) : i == 3 && (k ? t.display.input.onContextMenu(e) : qr(t))) } } } function ya (e, t, n, r, i) { let o = 'Click'; return r == 'double' ? o = 'Double' + o : r == 'triple' && (o = 'Triple' + o), o = (t == 1 ? 'Left' : t == 2 ? 'Middle' : 'Right') + o, ra(e, Vl(o, i), i, function (t) { if (typeof t === 'string' && (t = Yl[t]), !t) { return !1 } let r = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), r = t(e, n) != V } finally { e.state.suppressEdits = !1 } return r }) } function ba (e, t, n) { const r = e.getOption('configureMouse'); const i = r ? r(e, t, n) : {}; if (i.unit == null) { const o = b ? n.shiftKey && n.metaKey : n.altKey; i.unit = o ? 'rectangle' : t == 'single' ? 'char' : t == 'double' ? 'word' : 'line' } return (i.extend == null || e.doc.extend) && (i.extend = e.doc.extend || n.shiftKey), i.addNew == null && (i.addNew = y ? n.metaKey : n.ctrlKey), i.moveOnDrag == null && (i.moveOnDrag = !(y ? n.altKey : n.ctrlKey)), i } function wa (e, t, n, r) { l ? setTimeout(P(Xr, e), 0) : e.curOp.focus = W(); let i; const o = ba(e, n, r); const a = e.doc.sel; e.options.dragDrop && Ne && !e.isReadOnly() && n == 'single' && (i = a.contains(t)) > -1 && (ot((i = a.ranges[i]).from(), t) < 0 || t.xRel > 0) && (ot(i.to(), t) > 0 || t.xRel < 0) ? xa(e, r, t, o) : ka(e, r, t, o) } function xa (e, t, n, r) { const i = e.display; let o = !1; var u = Di(e, function (t) { s && (i.scroller.draggable = !1), e.state.draggingText = !1, me(i.wrapper.ownerDocument, 'mouseup', u), me(i.wrapper.ownerDocument, 'mousemove', c), me(i.scroller, 'dragstart', f), me(i.scroller, 'drop', u), o || (Ce(t), r.addNew || Fo(e.doc, n, null, null, r.extend), s || l && a == 9 ? setTimeout(function () { i.wrapper.ownerDocument.body.focus(), i.input.focus() }, 20) : i.input.focus()) }); var c = function (e) { o = o || Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) >= 10 }; var f = function () { return o = !0 }; s && (i.scroller.draggable = !0), e.state.draggingText = u, u.copy = !r.moveOnDrag, i.scroller.dragDrop && i.scroller.dragDrop(), pe(i.wrapper.ownerDocument, 'mouseup', u), pe(i.wrapper.ownerDocument, 'mousemove', c), pe(i.scroller, 'dragstart', f), pe(i.scroller, 'drop', u), qr(e), setTimeout(function () { return i.input.focus() }, 20) } function Ca (e, t, n) { if (n == 'char') { return new io(t, t) } if (n == 'word') { return e.findWordAt(t) } if (n == 'line') { return new io(it(t.line, 0), ft(e.doc, it(t.line + 1, 0))) } const r = n(e, t); return new io(r.from, r.to) } function ka (e, t, n, r) { const i = e.display; const o = e.doc; Ce(t); let l; let a; let s = o.sel; const u = s.ranges; if (r.addNew && !r.extend ? (a = o.sel.contains(n), l = a > -1 ? u[a] : new io(n, n)) : (l = o.sel.primary(), a = o.sel.primIndex), r.unit == 'rectangle') { r.addNew || (l = new io(n, n)), n = Er(e, t, !0, !0), a = -1 } else { const c = Ca(e, n, r.unit); l = r.extend ? Eo(l, c.anchor, c.head, r.extend) : c }r.addNew ? a == -1 ? (a = u.length, jo(o, oo(e, u.concat([l]), a), { scroll: !1, origin: '*mouse' })) : u.length > 1 && u[a].empty() && r.unit == 'char' && !r.extend ? (jo(o, oo(e, u.slice(0, a).concat(u.slice(a + 1)), 0), { scroll: !1, origin: '*mouse' }), s = o.sel) : zo(o, a, l, U) : (a = 0, jo(o, new ro([l], 0), U), s = o.sel); let f = n; function h (t) { if (ot(f, t) != 0) { if (f = t, r.unit == 'rectangle') { for (var i = [], u = e.options.tabSize, c = I(Ye(o, n.line).text, n.ch, u), h = I(Ye(o, t.line).text, t.ch, u), d = Math.min(c, h), p = Math.max(c, h), g = Math.min(n.line, t.line), m = Math.min(e.lastLine(), Math.max(n.line, t.line)); g <= m; g++) { const v = Ye(o, g).text; const y = K(v, d, u); d == p ? i.push(new io(it(g, y), it(g, y))) : v.length > y && i.push(new io(it(g, y), it(g, K(v, p, u)))) }i.length || i.push(new io(n, n)), jo(o, oo(e, s.ranges.slice(0, a).concat(i), a), { origin: '*mouse', scroll: !1 }), e.scrollIntoView(t) } else { let b; const w = l; const x = Ca(e, t, r.unit); let C = w.anchor; ot(x.anchor, C) > 0 ? (b = x.head, C = ut(w.from(), x.anchor)) : (b = x.anchor, C = st(w.to(), x.head)); const k = s.ranges.slice(0); k[a] = Sa(e, new io(ft(o, C), b)), jo(o, oo(e, k, a), U) } } } const d = i.wrapper.getBoundingClientRect(); let p = 0; function g (t) { const n = ++p; const l = Er(e, t, !0, r.unit == 'rectangle'); if (l) { if (ot(l, f) != 0) { e.curOp.focus = W(), h(l); const a = ei(i, o); (l.line >= a.to || l.line < a.from) && setTimeout(Di(e, function () { p == n && g(t) }), 150) } else { const s = t.clientY < d.top ? -20 : t.clientY > d.bottom ? 20 : 0; s && setTimeout(Di(e, function () { p == n && (i.scroller.scrollTop += s, g(t)) }), 50) } } } function m (t) { e.state.selectingText = !1, p = 1 / 0, t && (Ce(t), i.input.focus()), me(i.wrapper.ownerDocument, 'mousemove', v), me(i.wrapper.ownerDocument, 'mouseup', y), o.history.lastSelOrigin = null } var v = Di(e, function (e) { e.buttons !== 0 && Me(e) ? g(e) : m(e) }); var y = Di(e, m); e.state.selectingText = y, pe(i.wrapper.ownerDocument, 'mousemove', v), pe(i.wrapper.ownerDocument, 'mouseup', y) } function Sa (e, t) { const n = t.anchor; const r = t.head; const i = Ye(e.doc, n.line); if (ot(n, r) == 0 && n.sticky == r.sticky) { return t } const o = he(i); if (!o) { return t } const l = ce(o, n.ch, n.sticky); const a = o[l]; if (a.from != n.ch && a.to != n.ch) { return t } let s; const u = l + (a.from == n.ch == (a.level != 1) ? 0 : 1); if (u == 0 || u == o.length) { return t } if (r.line != n.line) { s = (r.line - n.line) * (e.doc.direction == 'ltr' ? 1 : -1) > 0 } else { const c = ce(o, r.ch, r.sticky); const f = c - l || (r.ch - n.ch) * (a.level == 1 ? -1 : 1); s = c == u - 1 || c == u ? f < 0 : f > 0 } const h = o[u + (s ? -1 : 0)]; const d = s == (h.level == 1); const p = d ? h.from : h.to; const g = d ? 'after' : 'before'; return n.ch == p && n.sticky == g ? t : new io(new it(n.line, p, g), r) } function La (e, t, n, r) { let i, o; if (t.touches) { i = t.touches[0].clientX, o = t.touches[0].clientY } else { try { i = t.clientX, o = t.clientY } catch (t) { return !1 } } if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) { return !1 } r && Ce(t); const l = e.display; const a = l.lineDiv.getBoundingClientRect(); if (o > a.bottom || !we(e, n)) { return Se(t) } o -= a.top - l.viewOffset; for (let s = 0; s < e.display.gutterSpecs.length; ++s) { const u = l.gutters.childNodes[s]; if (u && u.getBoundingClientRect().right >= i) { const c = tt(e.doc, o); const f = e.display.gutterSpecs[s]; return ve(e, n, e, c, f.className, t), Se(t) } } } function Ta (e, t) { return La(e, t, 'gutterClick', !0) } function Ma (e, t) { Gn(e.display, t) || Oa(e, t) || ye(e, t, 'contextmenu') || k || e.display.input.onContextMenu(t) } function Oa (e, t) { return !!we(e, 'gutterContextMenu') && La(e, t, 'gutterContextMenu', !1) } function Aa (e) { e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + e.options.theme.replace(/(^|\s)\s*/g, ' cm-s-'), fr(e) }ga.prototype.compare = function (e, t, n) { return this.time + pa > e && ot(t, this.pos) == 0 && n == this.button }; const Na = { toString () { return 'CodeMirror.Init' } }; const Da = {}; const Wa = {}; function Ha (e) { const t = e.optionHandlers; function n (n, r, i, o) { e.defaults[n] = r, i && (t[n] = o ? function (e, t, n) { n != Na && i(e, t, n) } : i) }e.defineOption = n, e.Init = Na, n('value', '', function (e, t) { return e.setValue(t) }, !0), n('mode', null, function (e, t) { e.doc.modeOption = t, ho(e) }, !0), n('indentUnit', 2, ho, !0), n('indentWithTabs', !1), n('smartIndent', !0), n('tabSize', 4, function (e) { po(e), fr(e), Pr(e) }, !0), n('lineSeparator', null, function (e, t) { if (e.doc.lineSep = t, t) { const n = []; let r = e.doc.first; e.doc.iter(function (e) { for (let i = 0; ;) { const o = e.text.indexOf(t, i); if (o == -1) { break } i = o + t.length, n.push(it(r, o)) }r++ }); for (let i = n.length - 1; i >= 0; i--) { rl(e.doc, t, n[i], it(n[i].line, n[i].ch + t.length)) } } }), n('specialChars', /[\u0000-\u001F\u007F-\u009F\u00AD\u061C\u200B-\u200F\u2028\u2029\uFEFF\uFFF9-\uFFFC]/g, function (e, t, n) { e.state.specialChars = new RegExp(t.source + (t.test('\t') ? '' : '|\t'), 'g'), n != Na && e.refresh() }), n('specialCharPlaceholder', gn, function (e) { return e.refresh() }, !0), n('electricChars', !0), n('inputStyle', v ? 'contenteditable' : 'textarea', function () { throw new Error('inputStyle can not (yet) be changed in a running editor') }, !0), n('spellcheck', !1, function (e, t) { return e.getInputField().spellcheck = t }, !0), n('autocorrect', !1, function (e, t) { return e.getInputField().autocorrect = t }, !0), n('autocapitalize', !1, function (e, t) { return e.getInputField().autocapitalize = t }, !0), n('rtlMoveVisually', !w), n('wholeLineUpdateBefore', !0), n('theme', 'default', function (e) { Aa(e), Yi(e) }, !0), n('keyMap', 'default', function (e, t, n) { const r = Ul(t); const i = n != Na && Ul(n); i && i.detach && i.detach(e, r), r.attach && r.attach(e, i || null) }), n('extraKeys', null), n('configureMouse', null), n('lineWrapping', !1, Fa, !0), n('gutters', [], function (e, t) { e.display.gutterSpecs = Xi(t, e.options.lineNumbers), Yi(e) }, !0), n('fixedGutter', !0, function (e, t) { e.display.gutters.style.left = t ? Dr(e.display) + 'px' : '0', e.refresh() }, !0), n('coverGutterNextToScrollbar', !1, function (e) { return vi(e) }, !0), n('scrollbarStyle', 'native', function (e) { wi(e), vi(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft) }, !0), n('lineNumbers', !1, function (e, t) { e.display.gutterSpecs = Xi(e.options.gutters, t), Yi(e) }, !0), n('firstLineNumber', 1, Yi, !0), n('lineNumberFormatter', function (e) { return e }, Yi, !0), n('showCursorWhenSelecting', !1, Vr, !0), n('resetSelectionOnContextMenu', !0), n('lineWiseCopyCut', !0), n('pasteLinesPerSelection', !0), n('selectionsMayTouch', !1), n('readOnly', !1, function (e, t) { t == 'nocursor' && (Zr(e), e.display.input.blur()), e.display.input.readOnlyChanged(t) }), n('disableInput', !1, function (e, t) { t || e.display.input.reset() }, !0), n('dragDrop', !0, Ea), n('allowDropFileTypes', null), n('cursorBlinkRate', 530), n('cursorScrollMargin', 0), n('cursorHeight', 1, Vr, !0), n('singleCursorHeightPerLine', !0, Vr, !0), n('workTime', 100), n('workDelay', 100), n('flattenSpans', !0, po, !0), n('addModeClass', !1, po, !0), n('pollInterval', 100), n('undoDepth', 200, function (e, t) { return e.doc.history.undoDepth = t }), n('historyEventDelay', 1250), n('viewportMargin', 10, function (e) { return e.refresh() }, !0), n('maxHighlightLength', 1e4, po, !0), n('moveInputWithCursor', !0, function (e, t) { t || e.display.input.resetPosition() }), n('tabindex', null, function (e, t) { return e.display.input.getField().tabIndex = t || '' }), n('autofocus', null), n('direction', 'ltr', function (e, t) { return e.doc.setDirection(t) }, !0), n('phrases', null) } function Ea (e, t, n) { const r = n && n != Na; if (!t != !r) { const i = e.display.dragFunctions; const o = t ? pe : me; o(e.display.scroller, 'dragstart', i.start), o(e.display.scroller, 'dragenter', i.enter), o(e.display.scroller, 'dragover', i.over), o(e.display.scroller, 'dragleave', i.leave), o(e.display.scroller, 'drop', i.drop) } } function Fa (e) { e.options.lineWrapping ? (H(e.display.wrapper, 'CodeMirror-wrap'), e.display.sizer.style.minWidth = '', e.display.sizerWidth = null) : (T(e.display.wrapper, 'CodeMirror-wrap'), an(e)), Hr(e), Pr(e), fr(e), setTimeout(function () { return vi(e) }, 100) } function Pa (e, t) { const n = this; if (!(this instanceof Pa)) { return new Pa(e, t) } this.options = t = t ? z(t) : {}, z(Da, t, !1); let r = t.value; typeof r === 'string' ? r = new Cl(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r; const i = new Pa.inputStyles[t.inputStyle](this); const o = this.display = new Zi(e, r, i, t); for (const u in o.wrapper.CodeMirror = this, Aa(this), t.lineWrapping && (this.display.wrapper.className += ' CodeMirror-wrap'), wi(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: -1, cutIncoming: -1, selectingText: !1, draggingText: !1, highlight: new R(), keySeq: null, specialChars: null }, t.autofocus && !v && o.input.focus(), l && a < 11 && setTimeout(function () { return n.display.input.reset(!0) }, 20), za(this), Nl(), Ci(this), this.curOp.forceUpdate = !0, yo(this, r), t.autofocus && !v || this.hasFocus() ? setTimeout(P(Yr, this), 20) : Zr(this), Wa) { Wa.hasOwnProperty(u) && Wa[u](this, t[u], Na) }$i(this), t.finishInit && t.finishInit(this); for (let c = 0; c < Ia.length; ++c) { Ia[c](this) }ki(this), s && t.lineWrapping && getComputedStyle(o.lineDiv).textRendering == 'optimizelegibility' && (o.lineDiv.style.textRendering = 'auto') } function za (e) { const t = e.display; pe(t.scroller, 'mousedown', Di(e, va)), pe(t.scroller, 'dblclick', l && a < 11 ? Di(e, function (t) { if (!ye(e, t)) { const n = Er(e, t); if (n && !Ta(e, t) && !Gn(e.display, t)) { Ce(t); const r = e.findWordAt(n); Fo(e.doc, r.anchor, r.head) } } }) : function (t) { return ye(e, t) || Ce(t) }), pe(t.scroller, 'contextmenu', function (t) { return Ma(e, t) }), pe(t.input.getField(), 'contextmenu', function (n) { t.scroller.contains(n.target) || Ma(e, n) }); let n; let r = { end: 0 }; function i () { t.activeTouch && (n = setTimeout(function () { return t.activeTouch = null }, 1e3), r = t.activeTouch, r.end = +new Date()) } function o (e) { if (e.touches.length != 1) { return !1 } const t = e.touches[0]; return t.radiusX <= 1 && t.radiusY <= 1 } function s (e, t) { if (t.left == null) { return !0 } const n = t.left - e.left; const r = t.top - e.top; return n * n + r * r > 400 }pe(t.scroller, 'touchstart', function (i) { if (!ye(e, i) && !o(i) && !Ta(e, i)) { t.input.ensurePolled(), clearTimeout(n); const l = +new Date(); t.activeTouch = { start: l, moved: !1, prev: l - r.end <= 300 ? r : null }, i.touches.length == 1 && (t.activeTouch.left = i.touches[0].pageX, t.activeTouch.top = i.touches[0].pageY) } }), pe(t.scroller, 'touchmove', function () { t.activeTouch && (t.activeTouch.moved = !0) }), pe(t.scroller, 'touchend', function (n) { const r = t.activeTouch; if (r && !Gn(t, n) && r.left != null && !r.moved && new Date() - r.start < 300) { let o; const l = e.coordsChar(t.activeTouch, 'page'); o = !r.prev || s(r, r.prev) ? new io(l, l) : !r.prev.prev || s(r, r.prev.prev) ? e.findWordAt(l) : new io(it(l.line, 0), ft(e.doc, it(l.line + 1, 0))), e.setSelection(o.anchor, o.head), e.focus(), Ce(n) }i() }), pe(t.scroller, 'touchcancel', i), pe(t.scroller, 'scroll', function () { t.scroller.clientHeight && (fi(e, t.scroller.scrollTop), di(e, t.scroller.scrollLeft, !0), ve(e, 'scroll', e)) }), pe(t.scroller, 'mousewheel', function (t) { return no(e, t) }), pe(t.scroller, 'DOMMouseScroll', function (t) { return no(e, t) }), pe(t.wrapper, 'scroll', function () { return t.wrapper.scrollTop = t.wrapper.scrollLeft = 0 }), t.dragFunctions = { enter (t) { ye(e, t) || Le(t) }, over (t) { ye(e, t) || (Tl(e, t), Le(t)) }, start (t) { return Ll(e, t) }, drop: Di(e, Sl), leave (t) { ye(e, t) || Ml(e) } }; const u = t.input.getField(); pe(u, 'keyup', function (t) { return ca.call(e, t) }), pe(u, 'keydown', Di(e, sa)), pe(u, 'keypress', Di(e, fa)), pe(u, 'focus', function (t) { return Yr(e, t) }), pe(u, 'blur', function (t) { return Zr(e, t) }) }Pa.defaults = Da, Pa.optionHandlers = Wa; var Ia = []; function Ra (e, t, n, r) { let i; const o = e.doc; n == null && (n = 'add'), n == 'smart' && (o.mode.indent ? i = yt(e, t).state : n = 'prev'); const l = e.options.tabSize; const a = Ye(o, t); const s = I(a.text, null, l); a.stateAfter && (a.stateAfter = null); let u; const c = a.text.match(/^\s*/)[0]; if (r || /\S/.test(a.text)) { if (n == 'smart' && (u = o.mode.indent(i, a.text.slice(c.length), a.text), u == V || u > 150)) { if (!r) { return } n = 'prev' } } else { u = 0, n = 'not' }n == 'prev' ? u = t > o.first ? I(Ye(o, t - 1).text, null, l) : 0 : n == 'add' ? u = s + e.options.indentUnit : n == 'subtract' ? u = s - e.options.indentUnit : typeof n === 'number' && (u = s + n), u = Math.max(0, u); let f = ''; let h = 0; if (e.options.indentWithTabs) { for (let d = Math.floor(u / l); d; --d) { h += l, f += '\t' } } if (h < u && (f += X(u - h)), f != c) { return rl(o, f, it(t, 0), it(t, c.length), '+input'), a.stateAfter = null, !0 } for (let p = 0; p < o.sel.ranges.length; p++) { const g = o.sel.ranges[p]; if (g.head.line == t && g.head.ch < c.length) { const m = it(t, c.length); zo(o, p, new io(m, m)); break } } }Pa.defineInitHook = function (e) { return Ia.push(e) }; let Ba = null; function ja (e) { Ba = e } function Va (e, t, n, r, i) { const o = e.doc; e.display.shift = !1, r || (r = o.sel); const l = +new Date() - 200; const a = i == 'paste' || e.state.pasteIncoming > l; const s = He(t); let u = null; if (a && r.ranges.length > 1) { if (Ba && Ba.text.join('\n') == t) { if (r.ranges.length % Ba.text.length == 0) { u = []; for (let c = 0; c < Ba.text.length; c++) { u.push(o.splitLines(Ba.text[c])) } } } else { s.length == r.ranges.length && e.options.pasteLinesPerSelection && (u = Y(s, function (e) { return [e] })) } } for (var f = e.curOp.updateInput, h = r.ranges.length - 1; h >= 0; h--) { const d = r.ranges[h]; let p = d.from(); let g = d.to(); d.empty() && (n && n > 0 ? p = it(p.line, p.ch - n) : e.state.overwrite && !a ? g = it(g.line, Math.min(Ye(o, g.line).text.length, g.ch + q(s).length)) : a && Ba && Ba.lineWise && Ba.text.join('\n') == t && (p = g = it(p.line, 0))); const m = { from: p, to: g, text: u ? u[h % u.length] : s, origin: i || (a ? 'paste' : e.state.cutIncoming > l ? 'cut' : '+input') }; Zo(e.doc, m), On(e, 'inputRead', e, m) }t && !a && Ua(e, t), li(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = f), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1 } function Ga (e, t) { const n = e.clipboardData && e.clipboardData.getData('Text'); if (n) { return e.preventDefault(), t.isReadOnly() || t.options.disableInput || Ni(t, function () { return Va(t, n, 0, null, 'paste') }), !0 } } function Ua (e, t) { if (e.options.electricChars && e.options.smartIndent) { for (let n = e.doc.sel, r = n.ranges.length - 1; r >= 0; r--) { const i = n.ranges[r]; if (!(i.head.ch > 100 || r && n.ranges[r - 1].head.line == i.head.line)) { const o = e.getModeAt(i.head); let l = !1; if (o.electricChars) { for (let a = 0; a < o.electricChars.length; a++) { if (t.includes(o.electricChars.charAt(a))) { l = Ra(e, i.head.line, 'smart'); break } } } else { o.electricInput && o.electricInput.test(Ye(e.doc, i.head.line).text.slice(0, i.head.ch)) && (l = Ra(e, i.head.line, 'smart')) }l && On(e, 'electricInput', e, i.head.line) } } } } function _a (e) { for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) { const i = e.doc.sel.ranges[r].head.line; const o = { anchor: it(i, 0), head: it(i + 1, 0) }; n.push(o), t.push(e.getRange(o.anchor, o.head)) } return { text: t, ranges: n } } function Ka (e, t, n, r) { e.setAttribute('autocorrect', n ? '' : 'off'), e.setAttribute('autocapitalize', r ? '' : 'off'), e.setAttribute('spellcheck', !!t) } function $a () { const e = A('textarea', null, null, 'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none'); const t = A('div', [e], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;'); return s ? e.style.width = '1000px' : e.setAttribute('wrap', 'off'), g && (e.style.border = '1px solid black'), Ka(e), t } function Xa (e) { const t = e.optionHandlers; const n = e.helpers = {}; e.prototype = { constructor: e, focus () { window.focus(), this.display.input.focus() }, setOption (e, n) { const r = this.options; const i = r[e]; r[e] == n && e != 'mode' || (r[e] = n, t.hasOwnProperty(e) && Di(this, t[e])(this, n, i), ve(this, 'optionChange', this, e)) }, getOption (e) { return this.options[e] }, getDoc () { return this.doc }, addKeyMap (e, t) { this.state.keyMaps[t ? 'push' : 'unshift'](Ul(e)) }, removeKeyMap (e) { for (let t = this.state.keyMaps, n = 0; n < t.length; ++n) { if (t[n] == e || t[n].name == e) { return t.splice(n, 1), !0 } } }, addOverlay: Wi(function (t, n) { const r = t.token ? t : e.getMode(this.options, t); if (r.startState) { throw new Error('Overlays may not be stateful.') } Z(this.state.overlays, { mode: r, modeSpec: t, opaque: n && n.opaque, priority: n && n.priority || 0 }, function (e) { return e.priority }), this.state.modeGen++, Pr(this) }), removeOverlay: Wi(function (e) { for (let t = this.state.overlays, n = 0; n < t.length; ++n) { const r = t[n].modeSpec; if (r == e || typeof e === 'string' && r.name == e) { return t.splice(n, 1), this.state.modeGen++, void Pr(this) } } }), indentLine: Wi(function (e, t, n) { typeof t !== 'string' && typeof t !== 'number' && (t = t == null ? this.options.smartIndent ? 'smart' : 'prev' : t ? 'add' : 'subtract'), nt(this.doc, e) && Ra(this, e, t, n) }), indentSelection: Wi(function (e) { for (let t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) { const i = t[r]; if (i.empty()) { i.head.line > n && (Ra(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && li(this)) } else { const o = i.from(); const l = i.to(); const a = Math.max(n, o.line); n = Math.min(this.lastLine(), l.line - (l.ch ? 0 : 1)) + 1; for (let s = a; s < n; ++s) { Ra(this, s, e) } const u = this.doc.sel.ranges; o.ch == 0 && t.length == u.length && u[r].from().ch > 0 && zo(this.doc, r, new io(o, u[r].to()), G) } } }), getTokenAt (e, t) { return kt(this, e, t) }, getLineTokens (e, t) { return kt(this, it(e), t, !0) }, getTokenTypeAt (e) { e = ft(this.doc, e); let t; const n = vt(this, Ye(this.doc, e.line)); let r = 0; let i = (n.length - 1) / 2; const o = e.ch; if (o == 0) { t = n[2] } else { for (;;) { const l = r + i >> 1; if ((l ? n[2 * l - 1] : 0) >= o) { i = l } else { if (!(n[2 * l + 1] < o)) { t = n[2 * l + 2]; break }r = l + 1 } } } const a = t ? t.indexOf('overlay ') : -1; return a < 0 ? t : a == 0 ? null : t.slice(0, a - 1) }, getModeAt (t) { const n = this.doc.mode; return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n }, getHelper (e, t) { return this.getHelpers(e, t)[0] }, getHelpers (e, t) { const r = []; if (!n.hasOwnProperty(t)) { return r } const i = n[t]; const o = this.getModeAt(e); if (typeof o[t] === 'string') { i[o[t]] && r.push(i[o[t]]) } else if (o[t]) { for (let l = 0; l < o[t].length; l++) { const a = i[o[t][l]]; a && r.push(a) } } else { o.helperType && i[o.helperType] ? r.push(i[o.helperType]) : i[o.name] && r.push(i[o.name]) } for (let s = 0; s < i._global.length; s++) { const u = i._global[s]; u.pred(o, this) && B(r, u.val) == -1 && r.push(u.val) } return r }, getStateAfter (e, t) { const n = this.doc; return e = ct(n, e == null ? n.first + n.size - 1 : e), yt(this, e + 1, t).state }, cursorCoords (e, t) { let n; const r = this.doc.sel.primary(); return n = e == null ? r.head : typeof e === 'object' ? ft(this.doc, e) : e ? r.from() : r.to(), yr(this, n, t || 'page') }, charCoords (e, t) { return vr(this, ft(this.doc, e), t || 'page') }, coordsChar (e, t) { return e = mr(this, e, t || 'page'), xr(this, e.left, e.top) }, lineAtHeight (e, t) { return e = mr(this, { top: e, left: 0 }, t || 'page').top, tt(this.doc, e + this.display.viewOffset) }, heightAtLine (e, t, n) { let r; let i = !1; if (typeof e === 'number') { const o = this.doc.first + this.doc.size - 1; e < this.doc.first ? e = this.doc.first : e > o && (e = o, i = !0), r = Ye(this.doc, e) } else { r = e } return gr(this, r, { top: 0, left: 0 }, t || 'page', n || i).top + (i ? this.doc.height - on(r) : 0) }, defaultTextHeight () { return Or(this.display) }, defaultCharWidth () { return Ar(this.display) }, getViewport () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget (e, t, n, r, i) { const o = this.display; e = yr(this, ft(this.doc, e)); let l = e.bottom; let a = e.left; if (t.style.position = 'absolute', t.setAttribute('cm-ignore-events', 'true'), this.display.input.setUneditable(t), o.sizer.appendChild(t), r == 'over') { l = e.top } else if (r == 'above' || r == 'near') { const s = Math.max(o.wrapper.clientHeight, this.doc.height); const u = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth); (r == 'above' || e.bottom + t.offsetHeight > s) && e.top > t.offsetHeight ? l = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= s && (l = e.bottom), a + t.offsetWidth > u && (a = u - t.offsetWidth) }t.style.top = l + 'px', t.style.left = t.style.right = '', i == 'right' ? (a = o.sizer.clientWidth - t.offsetWidth, t.style.right = '0px') : (i == 'left' ? a = 0 : i == 'middle' && (a = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = a + 'px'), n && ri(this, { left: a, top: l, right: a + t.offsetWidth, bottom: l + t.offsetHeight }) }, triggerOnKeyDown: Wi(sa), triggerOnKeyPress: Wi(fa), triggerOnKeyUp: ca, triggerOnMouseDown: Wi(va), execCommand (e) { if (Yl.hasOwnProperty(e)) { return Yl[e].call(null, this) } }, triggerElectric: Wi(function (e) { Ua(this, e) }), findPosH (e, t, n, r) { let i = 1; t < 0 && (i = -1, t = -t); for (var o = ft(this.doc, e), l = 0; l < t; ++l) { if (o = qa(this.doc, o, i, n, r), o.hitSide) { break } } return o }, moveH: Wi(function (e, t) { const n = this; this.extendSelectionsBy(function (r) { return n.display.shift || n.doc.extend || r.empty() ? qa(n.doc, r.head, e, t, n.options.rtlMoveVisually) : e < 0 ? r.from() : r.to() }, _) }), deleteH: Wi(function (e, t) { const n = this.doc.sel; const r = this.doc; n.somethingSelected() ? r.replaceSelection('', null, '+delete') : _l(this, function (n) { const i = qa(r, n.head, e, t, !1); return e < 0 ? { from: i, to: n.head } : { from: n.head, to: i } }) }), findPosV (e, t, n, r) { let i = 1; let o = r; t < 0 && (i = -1, t = -t); for (var l = ft(this.doc, e), a = 0; a < t; ++a) { const s = yr(this, l, 'div'); if (o == null ? o = s.left : s.left = o, l = Ya(this, s, i, n), l.hitSide) { break } } return l }, moveV: Wi(function (e, t) { const n = this; const r = this.doc; const i = []; const o = !this.display.shift && !r.extend && r.sel.somethingSelected(); if (r.extendSelectionsBy(function (l) { if (o) { return e < 0 ? l.from() : l.to() } const a = yr(n, l.head, 'div'); l.goalColumn != null && (a.left = l.goalColumn), i.push(a.left); const s = Ya(n, a, e, t); return t == 'page' && l == r.sel.primary() && oi(n, vr(n, s, 'div').top - a.top), s }, _), i.length) { for (let l = 0; l < r.sel.ranges.length; l++) { r.sel.ranges[l].goalColumn = i[l] } } }), findWordAt (e) { const t = this.doc; const n = Ye(t, e.line).text; let r = e.ch; let i = e.ch; if (n) { const o = this.getHelper(e, 'wordChars'); e.sticky != 'before' && i != n.length || !r ? ++i : --r; const l = n.charAt(r); const a = ne(l, o) ? function (e) { return ne(e, o) } : /\s/.test(l) ? function (e) { return /\s/.test(e) } : function (e) { return !/\s/.test(e) && !ne(e) }; while (r > 0 && a(n.charAt(r - 1))) { --r } while (i < n.length && a(n.charAt(i))) { ++i } } return new io(it(e.line, r), it(e.line, i)) }, toggleOverwrite (e) { e != null && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? H(this.display.cursorDiv, 'CodeMirror-overwrite') : T(this.display.cursorDiv, 'CodeMirror-overwrite'), ve(this, 'overwriteToggle', this, this.state.overwrite)) }, hasFocus () { return this.display.input.getField() == W() }, isReadOnly () { return !(!this.options.readOnly && !this.doc.cantEdit) }, scrollTo: Wi(function (e, t) { ai(this, e, t) }), getScrollInfo () { const e = this.display.scroller; return { left: e.scrollLeft, top: e.scrollTop, height: e.scrollHeight - $n(this) - this.display.barHeight, width: e.scrollWidth - $n(this) - this.display.barWidth, clientHeight: qn(this), clientWidth: Xn(this) } }, scrollIntoView: Wi(function (e, t) { e == null ? (e = { from: this.doc.sel.primary().head, to: null }, t == null && (t = this.options.cursorScrollMargin)) : typeof e === 'number' ? e = { from: it(e, 0), to: null } : e.from == null && (e = { from: e, to: null }), e.to || (e.to = e.from), e.margin = t || 0, e.from.line != null ? si(this, e) : ci(this, e.from, e.to, e.margin) }), setSize: Wi(function (e, t) { const n = this; const r = function (e) { return typeof e === 'number' || /^\d+$/.test(String(e)) ? e + 'px' : e }; e != null && (this.display.wrapper.style.width = r(e)), t != null && (this.display.wrapper.style.height = r(t)), this.options.lineWrapping && cr(this); let i = this.display.viewFrom; this.doc.iter(i, this.display.viewTo, function (e) { if (e.widgets) { for (let t = 0; t < e.widgets.length; t++) { if (e.widgets[t].noHScroll) { zr(n, i, 'widget'); break } } }++i }), this.curOp.forceUpdate = !0, ve(this, 'refresh', this) }), operation (e) { return Ni(this, e) }, startOperation () { return Ci(this) }, endOperation () { return ki(this) }, refresh: Wi(function () { const e = this.display.cachedTextHeight; Pr(this), this.curOp.forceUpdate = !0, fr(this), ai(this, this.doc.scrollLeft, this.doc.scrollTop), Ui(this.display), (e == null || Math.abs(e - Or(this.display)) > 0.5) && Hr(this), ve(this, 'refresh', this) }), swapDoc: Wi(function (e) { const t = this.doc; return t.cm = null, this.state.selectingText && this.state.selectingText(), yo(this, e), fr(this), this.display.input.reset(), ai(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, On(this, 'swapDoc', this, t), t }), phrase (e) { const t = this.options.phrases; return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e }, getInputField () { return this.display.input.getField() }, getWrapperElement () { return this.display.wrapper }, getScrollerElement () { return this.display.scroller }, getGutterElement () { return this.display.gutters } }, xe(e), e.registerHelper = function (t, r, i) { n.hasOwnProperty(t) || (n[t] = e[t] = { _global: [] }), n[t][r] = i }, e.registerGlobalHelper = function (t, r, i, o) { e.registerHelper(t, r, o), n[t]._global.push({ pred: i, val: o }) } } function qa (e, t, n, r, i) { const o = t; const l = n; let a = Ye(e, t.line); const s = i && e.cm && e.cm.getOption('direction') == 'rtl' ? -n : n; function u () { const n = t.line + s; return !(n < e.first || n >= e.first + e.size) && (t = new it(n, t.ch, t.sticky), a = Ye(e, n)) } function c (r) { let o; if (o = i ? ql(e.cm, a, t, n) : $l(a, t, n), o == null) { if (r || !u()) { return !1 } t = Xl(i, e.cm, a, t.line, s) } else { t = o } return !0 } if (r == 'char') { c() } else if (r == 'column') { c(!0) } else if (r == 'word' || r == 'group') { for (let f = null, h = r == 'group', d = e.cm && e.cm.getHelper(t, 'wordChars'), p = !0; ;p = !1) { if (n < 0 && !c(!p)) { break } const g = a.text.charAt(t.ch) || '\n'; let m = ne(g, d) ? 'w' : h && g == '\n' ? 'n' : !h || /\s/.test(g) ? null : 'p'; if (!h || p || m || (m = 's'), f && f != m) { n < 0 && (n = 1, c(), t.sticky = 'after'); break } if (m && (f = m), n > 0 && !c(!p)) { break } } } const v = $o(e, t, o, l, !0); return lt(o, v) && (v.hitSide = !0), v } function Ya (e, t, n, r) { let i; let o; const l = e.doc; const a = t.left; if (r == 'page') { const s = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight); const u = Math.max(s - 0.5 * Or(e.display), 3); i = (n > 0 ? t.bottom : t.top) + n * u } else { r == 'line' && (i = n > 0 ? t.bottom + 3 : t.top - 3) } for (;;) { if (o = xr(e, a, i), !o.outside) { break } if (n < 0 ? i <= 0 : i >= l.height) { o.hitSide = !0; break }i += 5 * n } return o } const Za = function (e) { this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new R(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null }; function Ja (e, t) { const n = er(e, t.line); if (!n || n.hidden) { return null } const r = Ye(e.doc, t.line); const i = Zn(n, r, t.line); const o = he(r, e.doc.direction); let l = 'left'; if (o) { const a = ce(o, t.ch); l = a % 2 ? 'right' : 'left' } const s = or(i.map, t.ch, l); return s.offset = s.collapse == 'right' ? s.end : s.start, s } function Qa (e) { for (let t = e; t; t = t.parentNode) { if (/CodeMirror-gutter-wrapper/.test(t.className)) { return !0 } } return !1 } function es (e, t) { return t && (e.bad = !0), e } function ts (e, t, n, r, i) { let o = ''; let l = !1; const a = e.doc.lineSeparator(); let s = !1; function u (e) { return function (t) { return t.id == e } } function c () { l && (o += a, s && (o += a), l = s = !1) } function f (e) { e && (c(), o += e) } function h (t) { if (t.nodeType == 1) { const n = t.getAttribute('cm-text'); if (n) { return void f(n) } let o; const d = t.getAttribute('cm-marker'); if (d) { const p = e.findMarks(it(r, 0), it(i + 1, 0), u(+d)); return void (p.length && (o = p[0].find(0)) && f(Ze(e.doc, o.from, o.to).join(a))) } if (t.getAttribute('contenteditable') == 'false') { return } const g = /^(pre|div|p|li|table|br)$/i.test(t.nodeName); if (!/^br$/i.test(t.nodeName) && t.textContent.length == 0) { return } g && c(); for (let m = 0; m < t.childNodes.length; m++) { h(t.childNodes[m]) }/^(pre|p)$/i.test(t.nodeName) && (s = !0), g && (l = !0) } else { t.nodeType == 3 && f(t.nodeValue.replace(/\u200B/g, '').replace(/\u00A0/g, ' ')) } } for (;;) { if (h(t), t == n) { break } t = t.nextSibling, s = !1 } return o } function ns (e, t, n) { let r; if (t == e.display.lineDiv) { if (r = e.display.lineDiv.childNodes[n], !r) { return es(e.clipPos(it(e.display.viewTo - 1)), !0) } t = null, n = 0 } else { for (r = t; ;r = r.parentNode) { if (!r || r == e.display.lineDiv) { return null } if (r.parentNode && r.parentNode == e.display.lineDiv) { break } } } for (let i = 0; i < e.display.view.length; i++) { const o = e.display.view[i]; if (o.node == r) { return rs(o, t, n) } } } function rs (e, t, n) { const r = e.text.firstChild; let i = !1; if (!t || !D(r, t)) { return es(it(et(e.line), 0), !0) } if (t == r && (i = !0, t = r.childNodes[n], n = 0, !t)) { const o = e.rest ? q(e.rest) : e.line; return es(it(et(o), o.text.length), i) } let l = t.nodeType == 3 ? t : null; let a = t; l || t.childNodes.length != 1 || t.firstChild.nodeType != 3 || (l = t.firstChild, n && (n = l.nodeValue.length)); while (a.parentNode != r) { a = a.parentNode } const s = e.measure; const u = s.maps; function c (t, n, r) { for (let i = -1; i < (u ? u.length : 0); i++) { for (let o = i < 0 ? s.map : u[i], l = 0; l < o.length; l += 3) { const a = o[l + 2]; if (a == t || a == n) { const c = et(i < 0 ? e.line : e.rest[i]); let f = o[l] + r; return (r < 0 || a != t) && (f = o[l + (r ? 1 : 0)]), it(c, f) } } } } let f = c(l, a, n); if (f) { return es(f, i) } for (let h = a.nextSibling, d = l ? l.nodeValue.length - n : 0; h; h = h.nextSibling) { if (f = c(h, h.firstChild, 0), f) { return es(it(f.line, f.ch - d), i) } d += h.textContent.length } for (let p = a.previousSibling, g = n; p; p = p.previousSibling) { if (f = c(p, p.firstChild, -1), f) { return es(it(f.line, f.ch + g), i) } g += p.textContent.length } }Za.prototype.init = function (e) { const t = this; const n = this; const r = n.cm; const i = n.div = e.lineDiv; function o (e) { if (!ye(r, e)) { if (r.somethingSelected()) { ja({ lineWise: !1, text: r.getSelections() }), e.type == 'cut' && r.replaceSelection('', null, 'cut') } else { if (!r.options.lineWiseCopyCut) { return } const t = _a(r); ja({ lineWise: !0, text: t.text }), e.type == 'cut' && r.operation(function () { r.setSelections(t.ranges, 0, G), r.replaceSelection('', null, 'cut') }) } if (e.clipboardData) { e.clipboardData.clearData(); const o = Ba.text.join('\n'); if (e.clipboardData.setData('Text', o), e.clipboardData.getData('Text') == o) { return void e.preventDefault() } } const l = $a(); const a = l.firstChild; r.display.lineSpace.insertBefore(l, r.display.lineSpace.firstChild), a.value = Ba.text.join('\n'); const s = document.activeElement; F(a), setTimeout(function () { r.display.lineSpace.removeChild(l), s.focus(), s == i && n.showPrimarySelection() }, 50) } }Ka(i, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize), pe(i, 'paste', function (e) { ye(r, e) || Ga(e, r) || a <= 11 && setTimeout(Di(r, function () { return t.updateFromDOM() }), 20) }), pe(i, 'compositionstart', function (e) { t.composing = { data: e.data, done: !1 } }), pe(i, 'compositionupdate', function (e) { t.composing || (t.composing = { data: e.data, done: !1 }) }), pe(i, 'compositionend', function (e) { t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0) }), pe(i, 'touchstart', function () { return n.forceCompositionEnd() }), pe(i, 'input', function () { t.composing || t.readFromDOMSoon() }), pe(i, 'copy', o), pe(i, 'cut', o) }, Za.prototype.prepareSelection = function () { const e = Gr(this.cm, !1); return e.focus = this.cm.state.focused, e }, Za.prototype.showSelection = function (e, t) { e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e)) }, Za.prototype.getSelection = function () { return this.cm.display.wrapper.ownerDocument.getSelection() }, Za.prototype.showPrimarySelection = function () { const e = this.getSelection(); const t = this.cm; const r = t.doc.sel.primary(); const i = r.from(); const o = r.to(); if (t.display.viewTo == t.display.viewFrom || i.line >= t.display.viewTo || o.line < t.display.viewFrom) { e.removeAllRanges() } else { const l = ns(t, e.anchorNode, e.anchorOffset); const a = ns(t, e.focusNode, e.focusOffset); if (!l || l.bad || !a || a.bad || ot(ut(l, a), i) != 0 || ot(st(l, a), o) != 0) { const s = t.display.view; const u = i.line >= t.display.viewFrom && Ja(t, i) || { node: s[0].measure.map[2], offset: 0 }; let c = o.line < t.display.viewTo && Ja(t, o); if (!c) { const f = s[s.length - 1].measure; const h = f.maps ? f.maps[f.maps.length - 1] : f.map; c = { node: h[h.length - 1], offset: h[h.length - 2] - h[h.length - 3] } } if (u && c) { let d; const p = e.rangeCount && e.getRangeAt(0); try { d = L(u.node, u.offset, c.offset, c.node) } catch (g) {}d && (!n && t.state.focused ? (e.collapse(u.node, u.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), p && e.anchorNode == null ? e.addRange(p) : n && this.startGracePeriod()), this.rememberSelection() } else { e.removeAllRanges() } } } }, Za.prototype.startGracePeriod = function () { const e = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () { e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function () { return e.cm.curOp.selectionChanged = !0 }) }, 20) }, Za.prototype.showMultipleSelections = function (e) { O(this.cm.display.cursorDiv, e.cursors), O(this.cm.display.selectionDiv, e.selection) }, Za.prototype.rememberSelection = function () { const e = this.getSelection(); this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset }, Za.prototype.selectionInEditor = function () { const e = this.getSelection(); if (!e.rangeCount) { return !1 } const t = e.getRangeAt(0).commonAncestorContainer; return D(this.div, t) }, Za.prototype.focus = function () { this.cm.options.readOnly != 'nocursor' && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), this.div.focus()) }, Za.prototype.blur = function () { this.div.blur() }, Za.prototype.getField = function () { return this.div }, Za.prototype.supportsTouch = function () { return !0 }, Za.prototype.receivedFocus = function () { const e = this; function t () { e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t)) } this.selectionInEditor() ? this.pollSelection() : Ni(this.cm, function () { return e.cm.curOp.selectionChanged = !0 }), this.polling.set(this.cm.options.pollInterval, t) }, Za.prototype.selectionChanged = function () { const e = this.getSelection(); return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset }, Za.prototype.pollSelection = function () { if (this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) { const e = this.getSelection(); const t = this.cm; if (m && c && this.cm.display.gutterSpecs.length && Qa(e.anchorNode)) { return this.cm.triggerOnKeyDown({ type: 'keydown', keyCode: 8, preventDefault: Math.abs }), this.blur(), void this.focus() } if (!this.composing) { this.rememberSelection(); const n = ns(t, e.anchorNode, e.anchorOffset); const r = ns(t, e.focusNode, e.focusOffset); n && r && Ni(t, function () { jo(t.doc, lo(n, r), G), (n.bad || r.bad) && (t.curOp.selectionChanged = !0) }) } } }, Za.prototype.pollContent = function () { this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); let e; let t; let n; const r = this.cm; const i = r.display; const o = r.doc.sel.primary(); let l = o.from(); let a = o.to(); if (l.ch == 0 && l.line > r.firstLine() && (l = it(l.line - 1, Ye(r.doc, l.line - 1).length)), a.ch == Ye(r.doc, a.line).text.length && a.line < r.lastLine() && (a = it(a.line + 1, 0)), l.line < i.viewFrom || a.line > i.viewTo - 1) { return !1 } l.line == i.viewFrom || (e = Fr(r, l.line)) == 0 ? (t = et(i.view[0].line), n = i.view[0].node) : (t = et(i.view[e].line), n = i.view[e - 1].node.nextSibling); let s; let u; const c = Fr(r, a.line); if (c == i.view.length - 1 ? (s = i.viewTo - 1, u = i.lineDiv.lastChild) : (s = et(i.view[c + 1].line) - 1, u = i.view[c + 1].node.previousSibling), !n) { return !1 } const f = r.doc.splitLines(ts(r, n, u, t, s)); const h = Ze(r.doc, it(t, 0), it(s, Ye(r.doc, s).text.length)); while (f.length > 1 && h.length > 1) { if (q(f) == q(h)) { f.pop(), h.pop(), s-- } else { if (f[0] != h[0]) { break } f.shift(), h.shift(), t++ } } let d = 0; let p = 0; const g = f[0]; const m = h[0]; const v = Math.min(g.length, m.length); while (d < v && g.charCodeAt(d) == m.charCodeAt(d)) { ++d } const y = q(f); const b = q(h); const w = Math.min(y.length - (f.length == 1 ? d : 0), b.length - (h.length == 1 ? d : 0)); while (p < w && y.charCodeAt(y.length - p - 1) == b.charCodeAt(b.length - p - 1)) { ++p } if (f.length == 1 && h.length == 1 && t == l.line) { while (d && d > l.ch && y.charCodeAt(y.length - p - 1) == b.charCodeAt(b.length - p - 1)) { d--, p++ } }f[f.length - 1] = y.slice(0, y.length - p).replace(/^\u200B+/, ''), f[0] = f[0].slice(d).replace(/\u200B+$/, ''); const x = it(t, d); const C = it(s, h.length ? q(h).length - p : 0); return f.length > 1 || f[0] || ot(x, C) ? (rl(r.doc, f, x, C, '+input'), !0) : void 0 }, Za.prototype.ensurePolled = function () { this.forceCompositionEnd() }, Za.prototype.reset = function () { this.forceCompositionEnd() }, Za.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()) }, Za.prototype.readFromDOMSoon = function () { const e = this; this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function () { if (e.readDOMTimeout = null, e.composing) { if (!e.composing.done) { return } e.composing = null }e.updateFromDOM() }, 80)) }, Za.prototype.updateFromDOM = function () { const e = this; !this.cm.isReadOnly() && this.pollContent() || Ni(this.cm, function () { return Pr(e.cm) }) }, Za.prototype.setUneditable = function (e) { e.contentEditable = 'false' }, Za.prototype.onKeyPress = function (e) { e.charCode == 0 || this.composing || (e.preventDefault(), this.cm.isReadOnly() || Di(this.cm, Va)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0)) }, Za.prototype.readOnlyChanged = function (e) { this.div.contentEditable = String(e != 'nocursor') }, Za.prototype.onContextMenu = function () {}, Za.prototype.resetPosition = function () {}, Za.prototype.needsContentAttribute = !0; const is = function (e) { this.cm = e, this.prevInput = '', this.pollingFast = !1, this.polling = new R(), this.hasSelection = !1, this.composing = null }; function os (e, t) { if (t = t ? z(t) : {}, t.value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), t.autofocus == null) { const n = W(); t.autofocus = n == e || e.getAttribute('autofocus') != null && n == document.body } function r () { e.value = a.getValue() } let i; if (e.form && (pe(e.form, 'submit', r), !t.leaveSubmitMethodAlone)) { const o = e.form; i = o.submit; try { var l = o.submit = function () { r(), o.submit = i, o.submit(), o.submit = l } } catch (s) {} }t.finishInit = function (n) { n.save = r, n.getTextArea = function () { return e }, n.toTextArea = function () { n.toTextArea = isNaN, r(), e.parentNode.removeChild(n.getWrapperElement()), e.style.display = '', e.form && (me(e.form, 'submit', r), t.leaveSubmitMethodAlone || typeof e.form.submit !== 'function' || (e.form.submit = i)) } }, e.style.display = 'none'; var a = Pa(function (t) { return e.parentNode.insertBefore(t, e.nextSibling) }, t); return a } function ls (e) { e.off = me, e.on = pe, e.wheelEventPixels = to, e.Doc = Cl, e.splitLines = He, e.countColumn = I, e.findColumn = K, e.isWordChar = te, e.Pass = V, e.signal = ve, e.Line = sn, e.changeEnd = ao, e.scrollbarModel = bi, e.Pos = it, e.cmpPos = ot, e.modes = Ie, e.mimeModes = Re, e.resolveMode = Ve, e.getMode = Ge, e.modeExtensions = Ue, e.extendMode = _e, e.copyState = Ke, e.startState = Xe, e.innerMode = $e, e.commands = Yl, e.keyMap = zl, e.keyName = Gl, e.isModifierKey = jl, e.lookupKey = Bl, e.normalizeKeyMap = Rl, e.StringStream = qe, e.SharedTextMarker = ml, e.TextMarker = pl, e.LineWidget = cl, e.e_preventDefault = Ce, e.e_stopPropagation = ke, e.e_stop = Le, e.addClass = H, e.contains = D, e.rmClass = T, e.keyNames = Hl }is.prototype.init = function (e) { const t = this; const n = this; const r = this.cm; this.createField(e); const i = this.textarea; function o (e) { if (!ye(r, e)) { if (r.somethingSelected()) { ja({ lineWise: !1, text: r.getSelections() }) } else { if (!r.options.lineWiseCopyCut) { return } const t = _a(r); ja({ lineWise: !0, text: t.text }), e.type == 'cut' ? r.setSelections(t.ranges, null, G) : (n.prevInput = '', i.value = t.text.join('\n'), F(i)) }e.type == 'cut' && (r.state.cutIncoming = +new Date()) } }e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), g && (i.style.width = '0px'), pe(i, 'input', function () { l && a >= 9 && t.hasSelection && (t.hasSelection = null), n.poll() }), pe(i, 'paste', function (e) { ye(r, e) || Ga(e, r) || (r.state.pasteIncoming = +new Date(), n.fastPoll()) }), pe(i, 'cut', o), pe(i, 'copy', o), pe(e.scroller, 'paste', function (t) { if (!Gn(e, t) && !ye(r, t)) { if (!i.dispatchEvent) { return r.state.pasteIncoming = +new Date(), void n.focus() } const o = new Event('paste'); o.clipboardData = t.clipboardData, i.dispatchEvent(o) } }), pe(e.lineSpace, 'selectstart', function (t) { Gn(e, t) || Ce(t) }), pe(i, 'compositionstart', function () { const e = r.getCursor('from'); n.composing && n.composing.range.clear(), n.composing = { start: e, range: r.markText(e, r.getCursor('to'), { className: 'CodeMirror-composing' }) } }), pe(i, 'compositionend', function () { n.composing && (n.poll(), n.composing.range.clear(), n.composing = null) }) }, is.prototype.createField = function (e) { this.wrapper = $a(), this.textarea = this.wrapper.firstChild }, is.prototype.prepareSelection = function () { const e = this.cm; const t = e.display; const n = e.doc; const r = Gr(e); if (e.options.moveInputWithCursor) { const i = yr(e, n.sel.primary().head, 'div'); const o = t.wrapper.getBoundingClientRect(); const l = t.lineDiv.getBoundingClientRect(); r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + l.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + l.left - o.left)) } return r }, is.prototype.showSelection = function (e) { const t = this.cm; const n = t.display; O(n.cursorDiv, e.cursors), O(n.selectionDiv, e.selection), e.teTop != null && (this.wrapper.style.top = e.teTop + 'px', this.wrapper.style.left = e.teLeft + 'px') }, is.prototype.reset = function (e) { if (!this.contextMenuPending && !this.composing) { const t = this.cm; if (t.somethingSelected()) { this.prevInput = ''; const n = t.getSelection(); this.textarea.value = n, t.state.focused && F(this.textarea), l && a >= 9 && (this.hasSelection = n) } else { e || (this.prevInput = this.textarea.value = '', l && a >= 9 && (this.hasSelection = null)) } } }, is.prototype.getField = function () { return this.textarea }, is.prototype.supportsTouch = function () { return !1 }, is.prototype.focus = function () { if (this.cm.options.readOnly != 'nocursor' && (!v || W() != this.textarea)) { try { this.textarea.focus() } catch (e) {} } }, is.prototype.blur = function () { this.textarea.blur() }, is.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0 }, is.prototype.receivedFocus = function () { this.slowPoll() }, is.prototype.slowPoll = function () { const e = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, function () { e.poll(), e.cm.state.focused && e.slowPoll() }) }, is.prototype.fastPoll = function () { let e = !1; const t = this; function n () { const r = t.poll(); r || e ? (t.pollingFast = !1, t.slowPoll()) : (e = !0, t.polling.set(60, n)) }t.pollingFast = !0, t.polling.set(20, n) }, is.prototype.poll = function () { const e = this; const t = this.cm; const n = this.textarea; let r = this.prevInput; if (this.contextMenuPending || !t.state.focused || Ee(n) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) { return !1 } const i = n.value; if (i == r && !t.somethingSelected()) { return !1 } if (l && a >= 9 && this.hasSelection === i || y && /[\uF700-\uF7FF]/.test(i)) { return t.display.input.reset(), !1 } if (t.doc.sel == t.display.selForContextMenu) { const o = i.charCodeAt(0); if (o != 8203 || r || (r = '​'), o == 8666) { return this.reset(), this.cm.execCommand('undo') } } let s = 0; const u = Math.min(r.length, i.length); while (s < u && r.charCodeAt(s) == i.charCodeAt(s)) { ++s } return Ni(t, function () { Va(t, i.slice(s), r.length - s, null, e.composing ? '*compose' : null), i.length > 1e3 || i.includes('\n') ? n.value = e.prevInput = '' : e.prevInput = i, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor('to'), { className: 'CodeMirror-composing' })) }), !0 }, is.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, is.prototype.onKeyPress = function () { l && a >= 9 && (this.hasSelection = null), this.fastPoll() }, is.prototype.onContextMenu = function (e) { const t = this; const n = t.cm; const r = n.display; const i = t.textarea; t.contextMenuPending && t.contextMenuPending(); const o = Er(n, e); const u = r.scroller.scrollTop; if (o && !f) { const c = n.options.resetSelectionOnContextMenu; c && n.doc.sel.contains(o) == -1 && Di(n, jo)(n.doc, lo(o), G); let h; var d = i.style.cssText; var p = t.wrapper.style.cssText; const g = t.wrapper.offsetParent.getBoundingClientRect(); if (t.wrapper.style.cssText = 'position: static', i.style.cssText = 'position: absolute; width: 30px; height: 30px;\n      top: ' + (e.clientY - g.top - 5) + 'px; left: ' + (e.clientX - g.left - 5) + 'px;\n      z-index: 1000; background: ' + (l ? 'rgba(255, 255, 255, .05)' : 'transparent') + ';\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);', s && (h = window.scrollY), r.input.focus(), s && window.scrollTo(null, h), r.input.reset(), n.somethingSelected() || (i.value = t.prevInput = ' '), t.contextMenuPending = y, r.selForContextMenu = n.doc.sel, clearTimeout(r.detectingSelectAll), l && a >= 9 && v(), k) { Le(e); var m = function () { me(window, 'mouseup', m), setTimeout(y, 20) }; pe(window, 'mouseup', m) } else { setTimeout(y, 50) } } function v () { if (i.selectionStart != null) { const e = n.somethingSelected(); const o = '​' + (e ? i.value : ''); i.value = '⇚', i.value = o, t.prevInput = e ? '' : '​', i.selectionStart = 1, i.selectionEnd = o.length, r.selForContextMenu = n.doc.sel } } function y () { if (t.contextMenuPending == y && (t.contextMenuPending = !1, t.wrapper.style.cssText = p, i.style.cssText = d, l && a < 9 && r.scrollbars.setScrollTop(r.scroller.scrollTop = u), i.selectionStart != null)) { (!l || l && a < 9) && v(); let e = 0; var o = function () { r.selForContextMenu == n.doc.sel && i.selectionStart == 0 && i.selectionEnd > 0 && t.prevInput == '​' ? Di(n, qo)(n) : e++ < 10 ? r.detectingSelectAll = setTimeout(o, 500) : (r.selForContextMenu = null, r.input.reset()) }; r.detectingSelectAll = setTimeout(o, 200) } } }, is.prototype.readOnlyChanged = function (e) { e || this.reset(), this.textarea.disabled = e == 'nocursor' }, is.prototype.setUneditable = function () {}, is.prototype.needsContentAttribute = !1, Ha(Pa), Xa(Pa); const as = 'iter insert remove copy getEditor constructor'.split(' '); for (const ss in Cl.prototype) { Cl.prototype.hasOwnProperty(ss) && B(as, ss) < 0 && (Pa.prototype[ss] = (function (e) { return function () { return e.apply(this.doc, arguments) } }(Cl.prototype[ss]))) } return xe(Cl), Pa.inputStyles = { textarea: is, contenteditable: Za }, Pa.defineMode = function (e) { Pa.defaults.mode || e == 'null' || (Pa.defaults.mode = e), Be.apply(this, arguments) }, Pa.defineMIME = je, Pa.defineMode('null', function () { return { token (e) { return e.skipToEnd() } } }), Pa.defineMIME('text/plain', 'null'), Pa.defineExtension = function (e, t) { Pa.prototype[e] = t }, Pa.defineDocExtension = function (e, t) { Cl.prototype[e] = t }, Pa.fromTextArea = os, ls(Pa), Pa.version = '5.51.0', Pa }) }, '8c33' (e, t, n) { (function (e) { e(n('56b3')) })(function (e) { const t = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8); const n = e.Pos; const r = { '(': ')>', ')': '(<', '[': ']>', ']': '[<', '{': '}>', '}': '{<', '<': '>>', '>': '<<' }; function i (e) { return e && e.bracketRegex || /[(){}[\]]/ } function o (e, t, o) { const a = e.getLineHandle(t.line); let s = t.ch - 1; let u = o && o.afterCursor; u == null && (u = /(^| )cm-fat-cursor($| )/.test(e.getWrapperElement().className)); const c = i(o); const f = !u && s >= 0 && c.test(a.text.charAt(s)) && r[a.text.charAt(s)] || c.test(a.text.charAt(s + 1)) && r[a.text.charAt(++s)]; if (!f) { return null } const h = f.charAt(1) == '>' ? 1 : -1; if (o && o.strict && h > 0 != (s == t.ch)) { return null } const d = e.getTokenTypeAt(n(t.line, s + 1)); const p = l(e, n(t.line, s + (h > 0 ? 1 : 0)), h, d || null, o); return p == null ? null : { from: n(t.line, s), to: p && p.pos, match: p && p.ch == f.charAt(0), forward: h > 0 } } function l (e, t, o, l, a) { for (var s = a && a.maxScanLineLength || 1e4, u = a && a.maxScanLines || 1e3, c = [], f = i(a), h = o > 0 ? Math.min(t.line + u, e.lastLine() + 1) : Math.max(e.firstLine() - 1, t.line - u), d = t.line; d != h; d += o) { const p = e.getLine(d); if (p) { let g = o > 0 ? 0 : p.length - 1; const m = o > 0 ? p.length : -1; if (!(p.length > s)) { for (d == t.line && (g = t.ch - (o < 0 ? 1 : 0)); g != m; g += o) { const v = p.charAt(g); if (f.test(v) && (void 0 === l || e.getTokenTypeAt(n(d, g + 1)) == l)) { const y = r[v]; if (y && y.charAt(1) == '>' == o > 0) { c.push(v) } else { if (!c.length) { return { pos: n(d, g), ch: v } } c.pop() } } } } } } return d - o != (o > 0 ? e.lastLine() : e.firstLine()) && null } function a (e, r, i) { for (var l = e.state.matchBrackets.maxHighlightLineLength || 1e3, a = [], s = e.listSelections(), u = 0; u < s.length; u++) { const c = s[u].empty() && o(e, s[u].head, i); if (c && e.getLine(c.from.line).length <= l) { const f = c.match ? 'CodeMirror-matchingbracket' : 'CodeMirror-nonmatchingbracket'; a.push(e.markText(c.from, n(c.from.line, c.from.ch + 1), { className: f })), c.to && e.getLine(c.to.line).length <= l && a.push(e.markText(c.to, n(c.to.line, c.to.ch + 1), { className: f })) } } if (a.length) { t && e.state.focused && e.focus(); const h = function () { e.operation(function () { for (let e = 0; e < a.length; e++) { a[e].clear() } }) }; if (!r) { return h } setTimeout(h, 800) } } function s (e) { e.operation(function () { e.state.matchBrackets.currentlyHighlighted && (e.state.matchBrackets.currentlyHighlighted(), e.state.matchBrackets.currentlyHighlighted = null), e.state.matchBrackets.currentlyHighlighted = a(e, !1, e.state.matchBrackets) }) }e.defineOption('matchBrackets', !1, function (t, n, r) { r && r != e.Init && (t.off('cursorActivity', s), t.state.matchBrackets && t.state.matchBrackets.currentlyHighlighted && (t.state.matchBrackets.currentlyHighlighted(), t.state.matchBrackets.currentlyHighlighted = null)), n && (t.state.matchBrackets = typeof n === 'object' ? n : {}, t.on('cursorActivity', s)) }), e.defineExtension('matchBrackets', function () { a(this, !0) }), e.defineExtension('findMatchingBracket', function (e, t, n) { return (n || typeof t === 'boolean') && (n ? (n.strict = t, t = n) : t = t ? { strict: !0 } : null), o(this, e, t) }), e.defineExtension('scanForBracket', function (e, t, n, r) { return l(this, e, t, n, r) }) }) }, '8db2' (e, t) { e.exports = { props: { id: { type: String, required: !0 }, name: { type: String, required: !0 }, value: { type: null, default: null }, type: { type: String, required: !0 }, length: { type: [String, Number], default: null }, readonly: { type: Boolean, default: !1 }, collection: { type: String, default: null }, primaryKey: { type: [Number, String], default: null }, required: { type: Boolean, default: !1 }, options: { type: Object, default: () => ({}) }, newItem: { type: Boolean, default: !1 }, relation: { type: Object, default: null }, fields: { type: Object, default: null }, values: { type: Object, default: null }, width: { type: String, default: null, validator (e) { return ['half', 'half-left', 'half-right', 'full', 'fill'].includes(e) } } } } }, '8f94' (e, t, n) { !(function (t, r) { e.exports = r(n('56b3')) }(0, function (e) { return (function (e) { function t (r) { if (n[r]) { return n[r].exports } const i = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports } var n = {}; return t.m = e, t.c = n, t.i = function (e) { return e }, t.d = function (e, n, r) { t.o(e, n) || Object.defineProperty(e, n, { configurable: !1, enumerable: !0, get: r }) }, t.n = function (e) { const n = e && e.__esModule ? function () { return e.default } : function () { return e }; return t.d(n, 'a', n), n }, t.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, t.p = '/', t(t.s = 3) }([function (t, n) { t.exports = e }, function (e, t, n) { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(0); const i = (function (e) { return e && e.__esModule ? e : { default: e } }(r)); const o = window.CodeMirror || i.default; typeof Object.assign !== 'function' && Object.defineProperty(Object, 'assign', { value (e, t) { if (e == null) { throw new TypeError('Cannot convert undefined or null to object') } for (var n = Object(e), r = 1; r < arguments.length; r++) { const i = arguments[r]; if (i != null) { for (const o in i) { Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]) } } } return n }, writable: !0, configurable: !0 }), t.default = { name: 'codemirror', data () { return { content: '', codemirror: null, cminstance: null } }, props: { code: String, value: String, marker: Function, unseenLines: Array, name: { type: String, default: 'codemirror' }, placeholder: { type: String, default: '' }, merge: { type: Boolean, default: !1 }, options: { type: Object, default () { return {} } }, events: { type: Array, default () { return [] } }, globalOptions: { type: Object, default () { return {} } }, globalEvents: { type: Array, default () { return [] } } }, watch: { options: { deep: !0, handler (e) { for (const t in e) { this.cminstance.setOption(t, e[t]) } } }, merge () { this.$nextTick(this.switchMerge) }, code (e) { this.handerCodeChange(e) }, value (e) { this.handerCodeChange(e) } }, methods: { initialize () { const e = this; const t = Object.assign({}, this.globalOptions, this.options); this.merge ? (this.codemirror = o.MergeView(this.$refs.mergeview, t), this.cminstance = this.codemirror.edit) : (this.codemirror = o.fromTextArea(this.$refs.textarea, t), this.cminstance = this.codemirror, this.cminstance.setValue(this.code || this.value || this.content)), this.cminstance.on('change', function (t) { e.content = t.getValue(), e.$emit && e.$emit('input', e.content) }); const n = {}; ['scroll', 'changes', 'beforeChange', 'cursorActivity', 'keyHandled', 'inputRead', 'electricInput', 'beforeSelectionChange', 'viewportChange', 'swapDoc', 'gutterClick', 'gutterContextMenu', 'focus', 'blur', 'refresh', 'optionChange', 'scrollCursorIntoView', 'update'].concat(this.events).concat(this.globalEvents).filter(function (e) { return !n[e] && (n[e] = !0) }).forEach(function (t) { e.cminstance.on(t, function () { for (var n = arguments.length, r = Array(n), i = 0; i < n; i++) { r[i] = arguments[i] }e.$emit.apply(e, [t].concat(r)); const o = t.replace(/([A-Z])/g, '-$1').toLowerCase(); o !== t && e.$emit.apply(e, [o].concat(r)) }) }), this.$emit('ready', this.codemirror), this.unseenLineMarkers(), this.refresh() }, refresh () { const e = this; this.$nextTick(function () { e.cminstance.refresh() }) }, destroy () { const e = this.cminstance.doc.cm.getWrapperElement(); e && e.remove && e.remove() }, handerCodeChange (e) { if (e !== this.cminstance.getValue()) { const t = this.cminstance.getScrollInfo(); this.cminstance.setValue(e), this.content = e, this.cminstance.scrollTo(t.left, t.top) } this.unseenLineMarkers() }, unseenLineMarkers () { const e = this; void 0 !== this.unseenLines && void 0 !== this.marker && this.unseenLines.forEach(function (t) { const n = e.cminstance.lineInfo(t); e.cminstance.setGutterMarker(t, 'breakpoints', n.gutterMarkers ? null : e.marker()) }) }, switchMerge () { const e = this.cminstance.doc.history; const t = this.cminstance.doc.cleanGeneration; this.options.value = this.cminstance.getValue(), this.destroy(), this.initialize(), this.cminstance.doc.history = e, this.cminstance.doc.cleanGeneration = t } }, mounted () { this.initialize() }, beforeDestroy () { this.destroy() } } }, function (e, t, n) { 'use strict'; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(1); const i = n.n(r); for (const o in r) { !['default', 'default'].includes(o) && (function (e) { n.d(t, e, function () { return r[e] }) }(o)) } const l = n(5); const a = n(4); const s = a(i.a, l.a, !1, null, null, null); t.default = s.exports }, function (e, t, n) { 'use strict'; function r (e) { return e && e.__esModule ? e : { default: e } }Object.defineProperty(t, '__esModule', { value: !0 }), t.install = t.codemirror = t.CodeMirror = void 0; const i = n(0); const o = r(i); const l = n(2); const a = r(l); const s = window.CodeMirror || o.default; const u = function (e, t) { t && (t.options && (a.default.props.globalOptions.default = function () { return t.options }), t.events && (a.default.props.globalEvents.default = function () { return t.events })), e.component(a.default.name, a.default) }; const c = { CodeMirror: s, codemirror: a.default, install: u }; t.default = c, t.CodeMirror = s, t.codemirror = a.default, t.install = u }, function (e, t) { e.exports = function (e, t, n, r, i, o) { let l; let a = e = e || {}; const s = typeof e.default; s !== 'object' && s !== 'function' || (l = e, a = e.default); let u; const c = typeof a === 'function' ? a.options : a; if (t && (c.render = t.render, c.staticRenderFns = t.staticRenderFns, c._compiled = !0), n && (c.functional = !0), i && (c._scopeId = i), o ? (u = function (e) { e = e || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, e || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (e = __VUE_SSR_CONTEXT__), r && r.call(this, e), e && e._registeredComponents && e._registeredComponents.add(o) }, c._ssrRegister = u) : r && (u = r), u) { const f = c.functional; const h = f ? c.render : c.beforeCreate; f ? (c._injectStyles = u, c.render = function (e, t) { return u.call(t), h(e, t) }) : c.beforeCreate = h ? [].concat(h, u) : [u] } return { esModule: l, exports: a, options: c } } }, function (e, t, n) { 'use strict'; const r = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'vue-codemirror', class: { merge: e.merge } }, [e.merge ? n('div', { ref: 'mergeview' }) : n('textarea', { ref: 'textarea', attrs: { name: e.name, placeholder: e.placeholder } })]) }; const i = []; const o = { render: r, staticRenderFns: i }; t.a = o }])) })) }, '9c7b' (e, t, n) { (function (e) { e(n('56b3')) })(function (e) { 'use strict'; function t (e, t) { function n (e) { clearTimeout(r.doRedraw), r.doRedraw = setTimeout(function () { r.redraw() }, e) } this.cm = e, this.options = t, this.buttonHeight = t.scrollButtonHeight || e.getOption('scrollButtonHeight'), this.annotations = [], this.doRedraw = this.doUpdate = null, this.div = e.getWrapperElement().appendChild(document.createElement('div')), this.div.style.cssText = 'position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none', this.computeScale(); var r = this; e.on('refresh', this.resizeHandler = function () { clearTimeout(r.doUpdate), r.doUpdate = setTimeout(function () { r.computeScale() && n(20) }, 100) }), e.on('markerAdded', this.resizeHandler), e.on('markerCleared', this.resizeHandler), !1 !== t.listenForChanges && e.on('changes', this.changeHandler = function () { n(250) }) }e.defineExtension('annotateScrollbar', function (e) { return typeof e === 'string' && (e = { className: e }), new t(this, e) }), e.defineOption('scrollButtonHeight', 0), t.prototype.computeScale = function () { const e = this.cm; const t = (e.getWrapperElement().clientHeight - e.display.barHeight - 2 * this.buttonHeight) / e.getScrollerElement().scrollHeight; if (t != this.hScale) { return this.hScale = t, !0 } }, t.prototype.update = function (e) { this.annotations = e, this.redraw() }, t.prototype.redraw = function (e) { !1 !== e && this.computeScale(); const t = this.cm; const n = this.hScale; const r = document.createDocumentFragment(); const i = this.annotations; const o = t.getOption('lineWrapping'); const l = o && 1.5 * t.defaultTextHeight(); let a = null; let s = null; function u (e, n) { if (a != e.line && (a = e.line, s = t.getLineHandle(a)), s.widgets && s.widgets.length || o && s.height > l) { return t.charCoords(e, 'local')[n ? 'top' : 'bottom'] } const r = t.heightAtLine(s, 'local'); return r + (n ? 0 : s.height) } const c = t.lastLine(); if (t.display.barWidth) { for (var f, h = 0; h < i.length; h++) { let d = i[h]; if (!(d.to.line > c)) { const p = f || u(d.from, !0) * n; let g = u(d.to, !1) * n; while (h < i.length - 1) { if (i[h + 1].to.line > c) { break } if (f = u(i[h + 1].from, !0) * n, f > g + 0.9) { break } d = i[++h], g = u(d.to, !1) * n } if (g != p) { const m = Math.max(g - p, 3); const v = r.appendChild(document.createElement('div')); v.style.cssText = 'position: absolute; right: 0px; width: ' + Math.max(t.display.barWidth - 1, 2) + 'px; top: ' + (p + this.buttonHeight) + 'px; height: ' + m + 'px', v.className = this.options.className, d.id && v.setAttribute('annotation-id', d.id) } } } } this.div.textContent = '', this.div.appendChild(r) }, t.prototype.clear = function () { this.cm.off('refresh', this.resizeHandler), this.cm.off('markerAdded', this.resizeHandler), this.cm.off('markerCleared', this.resizeHandler), this.changeHandler && this.cm.off('changes', this.changeHandler), this.div.parentNode.removeChild(this.div) } }) }, a7be (e, t, n) {}, f4ba (e, t, n) { (function (e) { e(n('56b3')) })(function (e) { 'use strict'; function t (t, r) { function i () { t.display.wrapper.offsetHeight ? (n(t, r), t.display.lastWrapHeight != t.display.wrapper.clientHeight && t.refresh()) : r.timeout = setTimeout(i, r.delay) }r.timeout = setTimeout(i, r.delay), r.hurry = function () { clearTimeout(r.timeout), r.timeout = setTimeout(i, 50) }, e.on(window, 'mouseup', r.hurry), e.on(window, 'keyup', r.hurry) } function n (t, n) { clearTimeout(n.timeout), e.off(window, 'mouseup', n.hurry), e.off(window, 'keyup', n.hurry) }e.defineOption('autoRefresh', !1, function (e, r) { e.state.autoRefresh && (n(e, e.state.autoRefresh), e.state.autoRefresh = null), r && e.display.wrapper.offsetHeight == 0 && t(e, e.state.autoRefresh = { delay: r.delay || 250 }) }) }) }, f9d4 (e, t, n) { (function (e) { e(n('56b3')) })(function (e) { 'use strict'; e.defineMode('javascript', function (t, n) { let r; let i; const o = t.indentUnit; const l = n.statementIndent; const a = n.jsonld; const s = n.json || a; const u = n.typescript; const c = n.wordCharacters || /[\w$\xA1-\uFFFF]/; const f = (function () { function e (e) { return { type: e, style: 'keyword' } } const t = e('keyword a'); const n = e('keyword b'); const r = e('keyword c'); const i = e('keyword d'); const o = e('operator'); const l = { type: 'atom', style: 'atom' }; return { if: e('if'), while: t, with: t, else: n, do: n, try: n, finally: n, return: i, break: i, continue: i, new: e('new'), delete: r, void: r, throw: r, debugger: e('debugger'), var: e('var'), const: e('var'), let: e('var'), function: e('function'), catch: e('catch'), for: e('for'), switch: e('switch'), case: e('case'), default: e('default'), in: o, typeof: o, instanceof: o, true: l, false: l, null: l, undefined: l, NaN: l, Infinity: l, this: e('this'), class: e('class'), super: e('atom'), yield: r, export: e('export'), import: e('import'), extends: r, await: r } }()); const h = /[+\-*&%=<>!?|~^@]/; const d = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function p (e) { let t; let n = !1; let r = !1; while ((t = e.next()) != null) { if (!n) { if (t == '/' && !r) { return } t == '[' ? r = !0 : r && t == ']' && (r = !1) }n = !n && t == '\\' } } function g (e, t, n) { return r = e, i = n, t } function m (e, t) { const n = e.next(); if (n == '"' || n == "'") { return t.tokenize = v(n), t.tokenize(e, t) } if (n == '.' && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) { return g('number', 'number') } if (n == '.' && e.match('..')) { return g('spread', 'meta') } if (/[\[\]{}\(\),;\:\.]/.test(n)) { return g(n) } if (n == '=' && e.eat('>')) { return g('=>', 'operator') } if (n == '0' && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) { return g('number', 'number') } if (/\d/.test(n)) { return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), g('number', 'number') } if (n == '/') { return e.eat('*') ? (t.tokenize = y, y(e, t)) : e.eat('/') ? (e.skipToEnd(), g('comment', 'comment')) : et(e, t, 1) ? (p(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), g('regexp', 'string-2')) : (e.eat('='), g('operator', 'operator', e.current())) } if (n == '`') { return t.tokenize = b, b(e, t) } if (n == '#') { return e.skipToEnd(), g('error', 'error') } if (n == '<' && e.match('!--') || n == '-' && e.match('->')) { return e.skipToEnd(), g('comment', 'comment') } if (h.test(n)) { return n == '>' && t.lexical && t.lexical.type == '>' || (e.eat('=') ? n != '!' && n != '=' || e.eat('=') : /[<>*+\-]/.test(n) && (e.eat(n), n == '>' && e.eat(n))), g('operator', 'operator', e.current()) } if (c.test(n)) { e.eatWhile(c); const r = e.current(); if (t.lastType != '.') { if (f.propertyIsEnumerable(r)) { const i = f[r]; return g(i.type, i.style, r) } if (r == 'async' && e.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1)) { return g('async', 'keyword', r) } } return g('variable', 'variable', r) } } function v (e) { return function (t, n) { let r; let i = !1; if (a && t.peek() == '@' && t.match(d)) { return n.tokenize = m, g('jsonld-keyword', 'meta') } while ((r = t.next()) != null) { if (r == e && !i) { break } i = !i && r == '\\' } return i || (n.tokenize = m), g('string', 'string') } } function y (e, t) { let n; let r = !1; while (n = e.next()) { if (n == '/' && r) { t.tokenize = m; break }r = n == '*' } return g('comment', 'comment') } function b (e, t) { let n; let r = !1; while ((n = e.next()) != null) { if (!r && (n == '`' || n == '$' && e.eat('{'))) { t.tokenize = m; break }r = !r && n == '\\' } return g('quasi', 'string-2', e.current()) } const w = '([{}])'; function x (e, t) { t.fatArrowAt && (t.fatArrowAt = null); let n = e.string.indexOf('=>', e.start); if (!(n < 0)) { if (u) { const r = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n)); r && (n = r.index) } for (var i = 0, o = !1, l = n - 1; l >= 0; --l) { const a = e.string.charAt(l); const s = w.indexOf(a); if (s >= 0 && s < 3) { if (!i) { ++l; break } if (--i == 0) { a == '(' && (o = !0); break } } else if (s >= 3 && s < 6) { ++i } else if (c.test(a)) { o = !0 } else if (/["'\/`]/.test(a)) { for (;;--l) { if (l == 0) { return } const f = e.string.charAt(l - 1); if (f == a && e.string.charAt(l - 2) != '\\') { l--; break } } } else if (o && !i) { ++l; break } }o && !i && (t.fatArrowAt = l) } } const C = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, 'jsonld-keyword': !0 }; function k (e, t, n, r, i, o) { this.indented = e, this.column = t, this.type = n, this.prev = i, this.info = o, r != null && (this.align = r) } function S (e, t) { for (var n = e.localVars; n; n = n.next) { if (n.name == t) { return !0 } } for (let r = e.context; r; r = r.prev) { for (n = r.vars; n; n = n.next) { if (n.name == t) { return !0 } } } } function L (e, t, n, r, i) { const o = e.cc; T.state = e, T.stream = i, T.marked = null, T.cc = o, T.style = t, e.lexical.hasOwnProperty('align') || (e.lexical.align = !0); while (1) { const l = o.length ? o.pop() : s ? U : V; if (l(n, r)) { while (o.length && o[o.length - 1].lex) { o.pop()() } return T.marked ? T.marked : n == 'variable' && S(e, r) ? 'variable-2' : t } } } var T = { state: null, column: null, marked: null, cc: null }; function M () { for (let e = arguments.length - 1; e >= 0; e--) { T.cc.push(arguments[e]) } } function O () { return M.apply(null, arguments), !0 } function A (e, t) { for (let n = t; n; n = n.next) { if (n.name == e) { return !0 } } return !1 } function N (e) { const t = T.state; if (T.marked = 'def', t.context) { if (t.lexical.info == 'var' && t.context && t.context.block) { const r = D(e, t.context); if (r != null) { return void (t.context = r) } } else if (!A(e, t.localVars)) { return void (t.localVars = new E(e, t.localVars)) } } n.globalVars && !A(e, t.globalVars) && (t.globalVars = new E(e, t.globalVars)) } function D (e, t) { if (t) { if (t.block) { const n = D(e, t.prev); return n ? n == t.prev ? t : new H(n, t.vars, !0) : null } return A(e, t.vars) ? t : new H(t.prev, new E(e, t.vars), !1) } return null } function W (e) { return e == 'public' || e == 'private' || e == 'protected' || e == 'abstract' || e == 'readonly' } function H (e, t, n) { this.prev = e, this.vars = t, this.block = n } function E (e, t) { this.name = e, this.next = t } const F = new E('this', new E('arguments', null)); function P () { T.state.context = new H(T.state.context, T.state.localVars, !1), T.state.localVars = F } function z () { T.state.context = new H(T.state.context, T.state.localVars, !0), T.state.localVars = null } function I () { T.state.localVars = T.state.context.vars, T.state.context = T.state.context.prev } function R (e, t) { const n = function () { const n = T.state; let r = n.indented; if (n.lexical.type == 'stat') { r = n.lexical.indented } else { for (let i = n.lexical; i && i.type == ')' && i.align; i = i.prev) { r = i.indented } }n.lexical = new k(r, T.stream.column(), e, null, n.lexical, t) }; return n.lex = !0, n } function B () { const e = T.state; e.lexical.prev && (e.lexical.type == ')' && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev) } function j (e) { function t (n) { return n == e ? O() : e == ';' || n == '}' || n == ')' || n == ']' ? M() : O(t) } return t } function V (e, t) { return e == 'var' ? O(R('vardef', t), Se, j(';'), B) : e == 'keyword a' ? O(R('form'), K, V, B) : e == 'keyword b' ? O(R('form'), V, B) : e == 'keyword d' ? T.stream.match(/^\s*$/, !1) ? O() : O(R('stat'), X, j(';'), B) : e == 'debugger' ? O(j(';')) : e == '{' ? O(R('}'), z, fe, B, I) : e == ';' ? O() : e == 'if' ? (T.state.lexical.info == 'else' && T.state.cc[T.state.cc.length - 1] == B && T.state.cc.pop()(), O(R('form'), K, V, B, Ne)) : e == 'function' ? O(Ee) : e == 'for' ? O(R('form'), De, V, B) : e == 'class' || u && t == 'interface' ? (T.marked = 'keyword', O(R('form', e == 'class' ? e : t), Re, B)) : e == 'variable' ? u && t == 'declare' ? (T.marked = 'keyword', O(V)) : u && (t == 'module' || t == 'enum' || t == 'type') && T.stream.match(/^\s*\w/, !1) ? (T.marked = 'keyword', t == 'enum' ? O(Ze) : t == 'type' ? O(Pe, j('operator'), me, j(';')) : O(R('form'), Le, j('{'), R('}'), fe, B, B)) : u && t == 'namespace' ? (T.marked = 'keyword', O(R('form'), U, V, B)) : u && t == 'abstract' ? (T.marked = 'keyword', O(V)) : O(R('stat'), ie) : e == 'switch' ? O(R('form'), K, j('{'), R('}', 'switch'), z, fe, B, B, I) : e == 'case' ? O(U, j(':')) : e == 'default' ? O(j(':')) : e == 'catch' ? O(R('form'), P, G, V, B, I) : e == 'export' ? O(R('stat'), Ge, B) : e == 'import' ? O(R('stat'), _e, B) : e == 'async' ? O(V) : t == '@' ? O(U, V) : M(R('stat'), U, j(';'), B) } function G (e) { if (e == '(') { return O(ze, j(')')) } } function U (e, t) { return $(e, t, !1) } function _ (e, t) { return $(e, t, !0) } function K (e) { return e != '(' ? M() : O(R(')'), U, j(')'), B) } function $ (e, t, n) { if (T.state.fatArrowAt == T.stream.start) { const r = n ? ee : Q; if (e == '(') { return O(P, R(')'), ue(ze, ')'), B, j('=>'), r, I) } if (e == 'variable') { return M(P, Le, j('=>'), r, I) } } const i = n ? Y : q; return C.hasOwnProperty(e) ? O(i) : e == 'function' ? O(Ee, i) : e == 'class' || u && t == 'interface' ? (T.marked = 'keyword', O(R('form'), Ie, B)) : e == 'keyword c' || e == 'async' ? O(n ? _ : U) : e == '(' ? O(R(')'), X, j(')'), B, i) : e == 'operator' || e == 'spread' ? O(n ? _ : U) : e == '[' ? O(R(']'), Ye, B, i) : e == '{' ? ce(le, '}', null, i) : e == 'quasi' ? M(Z, i) : e == 'new' ? O(te(n)) : e == 'import' ? O(U) : O() } function X (e) { return e.match(/[;\}\)\],]/) ? M() : M(U) } function q (e, t) { return e == ',' ? O(U) : Y(e, t, !1) } function Y (e, t, n) { const r = n == 0 ? q : Y; const i = n == 0 ? U : _; return e == '=>' ? O(P, n ? ee : Q, I) : e == 'operator' ? /\+\+|--/.test(t) || u && t == '!' ? O(r) : u && t == '<' && T.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? O(R('>'), ue(me, '>'), B, r) : t == '?' ? O(U, j(':'), i) : O(i) : e == 'quasi' ? M(Z, r) : e != ';' ? e == '(' ? ce(_, ')', 'call', r) : e == '.' ? O(oe, r) : e == '[' ? O(R(']'), X, j(']'), B, r) : u && t == 'as' ? (T.marked = 'keyword', O(me, r)) : e == 'regexp' ? (T.state.lastType = T.marked = 'operator', T.stream.backUp(T.stream.pos - T.stream.start - 1), O(i)) : void 0 : void 0 } function Z (e, t) { return e != 'quasi' ? M() : t.slice(t.length - 2) != '${' ? O(Z) : O(U, J) } function J (e) { if (e == '}') { return T.marked = 'string-2', T.state.tokenize = b, O(Z) } } function Q (e) { return x(T.stream, T.state), M(e == '{' ? V : U) } function ee (e) { return x(T.stream, T.state), M(e == '{' ? V : _) } function te (e) { return function (t) { return t == '.' ? O(e ? re : ne) : t == 'variable' && u ? O(xe, e ? Y : q) : M(e ? _ : U) } } function ne (e, t) { if (t == 'target') { return T.marked = 'keyword', O(q) } } function re (e, t) { if (t == 'target') { return T.marked = 'keyword', O(Y) } } function ie (e) { return e == ':' ? O(B, V) : M(q, j(';'), B) } function oe (e) { if (e == 'variable') { return T.marked = 'property', O() } } function le (e, t) { return e == 'async' ? (T.marked = 'property', O(le)) : e == 'variable' || T.style == 'keyword' ? (T.marked = 'property', t == 'get' || t == 'set' ? O(ae) : (u && T.state.fatArrowAt == T.stream.start && (n = T.stream.match(/^\s*:\s*/, !1)) && (T.state.fatArrowAt = T.stream.pos + n[0].length), O(se))) : e == 'number' || e == 'string' ? (T.marked = a ? 'property' : T.style + ' property', O(se)) : e == 'jsonld-keyword' ? O(se) : u && W(t) ? (T.marked = 'keyword', O(le)) : e == '[' ? O(U, he, j(']'), se) : e == 'spread' ? O(_, se) : t == '*' ? (T.marked = 'keyword', O(le)) : e == ':' ? M(se) : void 0; let n } function ae (e) { return e != 'variable' ? M(se) : (T.marked = 'property', O(Ee)) } function se (e) { return e == ':' ? O(_) : e == '(' ? M(Ee) : void 0 } function ue (e, t, n) { function r (i, o) { if (n ? n.includes(i) : i == ',') { const l = T.state.lexical; return l.info == 'call' && (l.pos = (l.pos || 0) + 1), O(function (n, r) { return n == t || r == t ? M() : M(e) }, r) } return i == t || o == t ? O() : n && n.includes(';') ? M(e) : O(j(t)) } return function (n, i) { return n == t || i == t ? O() : M(e, r) } } function ce (e, t, n) { for (let r = 3; r < arguments.length; r++) { T.cc.push(arguments[r]) } return O(R(t, n), ue(e, t), B) } function fe (e) { return e == '}' ? O() : M(V, fe) } function he (e, t) { if (u) { if (e == ':') { return O(me) } if (t == '?') { return O(he) } } } function de (e, t) { if (u && (e == ':' || t == 'in')) { return O(me) } } function pe (e) { if (u && e == ':') { return T.stream.match(/^\s*\w+\s+is\b/, !1) ? O(U, ge, me) : O(me) } } function ge (e, t) { if (t == 'is') { return T.marked = 'keyword', O() } } function me (e, t) { return t == 'keyof' || t == 'typeof' || t == 'infer' ? (T.marked = 'keyword', O(t == 'typeof' ? _ : me)) : e == 'variable' || t == 'void' ? (T.marked = 'type', O(we)) : t == '|' || t == '&' ? O(me) : e == 'string' || e == 'number' || e == 'atom' ? O(we) : e == '[' ? O(R(']'), ue(me, ']', ','), B, we) : e == '{' ? O(R('}'), ue(ye, '}', ',;'), B, we) : e == '(' ? O(ue(be, ')'), ve, we) : e == '<' ? O(ue(me, '>'), me) : void 0 } function ve (e) { if (e == '=>') { return O(me) } } function ye (e, t) { return e == 'variable' || T.style == 'keyword' ? (T.marked = 'property', O(ye)) : t == '?' || e == 'number' || e == 'string' ? O(ye) : e == ':' ? O(me) : e == '[' ? O(j('variable'), de, j(']'), ye) : e == '(' ? M(Fe, ye) : void 0 } function be (e, t) { return e == 'variable' && T.stream.match(/^\s*[?:]/, !1) || t == '?' ? O(be) : e == ':' ? O(me) : e == 'spread' ? O(be) : M(me) } function we (e, t) { return t == '<' ? O(R('>'), ue(me, '>'), B, we) : t == '|' || e == '.' || t == '&' ? O(me) : e == '[' ? O(me, j(']'), we) : t == 'extends' || t == 'implements' ? (T.marked = 'keyword', O(me)) : t == '?' ? O(me, j(':'), me) : void 0 } function xe (e, t) { if (t == '<') { return O(R('>'), ue(me, '>'), B, we) } } function Ce () { return M(me, ke) } function ke (e, t) { if (t == '=') { return O(me) } } function Se (e, t) { return t == 'enum' ? (T.marked = 'keyword', O(Ze)) : M(Le, he, Oe, Ae) } function Le (e, t) { return u && W(t) ? (T.marked = 'keyword', O(Le)) : e == 'variable' ? (N(t), O()) : e == 'spread' ? O(Le) : e == '[' ? ce(Me, ']') : e == '{' ? ce(Te, '}') : void 0 } function Te (e, t) { return e != 'variable' || T.stream.match(/^\s*:/, !1) ? (e == 'variable' && (T.marked = 'property'), e == 'spread' ? O(Le) : e == '}' ? M() : e == '[' ? O(U, j(']'), j(':'), Te) : O(j(':'), Le, Oe)) : (N(t), O(Oe)) } function Me () { return M(Le, Oe) } function Oe (e, t) { if (t == '=') { return O(_) } } function Ae (e) { if (e == ',') { return O(Se) } } function Ne (e, t) { if (e == 'keyword b' && t == 'else') { return O(R('form', 'else'), V, B) } } function De (e, t) { return t == 'await' ? O(De) : e == '(' ? O(R(')'), We, B) : void 0 } function We (e) { return e == 'var' ? O(Se, He) : e == 'variable' ? O(He) : M(He) } function He (e, t) { return e == ')' ? O() : e == ';' ? O(He) : t == 'in' || t == 'of' ? (T.marked = 'keyword', O(U, He)) : M(U, He) } function Ee (e, t) { return t == '*' ? (T.marked = 'keyword', O(Ee)) : e == 'variable' ? (N(t), O(Ee)) : e == '(' ? O(P, R(')'), ue(ze, ')'), B, pe, V, I) : u && t == '<' ? O(R('>'), ue(Ce, '>'), B, Ee) : void 0 } function Fe (e, t) { return t == '*' ? (T.marked = 'keyword', O(Fe)) : e == 'variable' ? (N(t), O(Fe)) : e == '(' ? O(P, R(')'), ue(ze, ')'), B, pe, I) : u && t == '<' ? O(R('>'), ue(Ce, '>'), B, Fe) : void 0 } function Pe (e, t) { return e == 'keyword' || e == 'variable' ? (T.marked = 'type', O(Pe)) : t == '<' ? O(R('>'), ue(Ce, '>'), B) : void 0 } function ze (e, t) { return t == '@' && O(U, ze), e == 'spread' ? O(ze) : u && W(t) ? (T.marked = 'keyword', O(ze)) : u && e == 'this' ? O(he, Oe) : M(Le, he, Oe) } function Ie (e, t) { return e == 'variable' ? Re(e, t) : Be(e, t) } function Re (e, t) { if (e == 'variable') { return N(t), O(Be) } } function Be (e, t) { return t == '<' ? O(R('>'), ue(Ce, '>'), B, Be) : t == 'extends' || t == 'implements' || u && e == ',' ? (t == 'implements' && (T.marked = 'keyword'), O(u ? me : U, Be)) : e == '{' ? O(R('}'), je, B) : void 0 } function je (e, t) { return e == 'async' || e == 'variable' && (t == 'static' || t == 'get' || t == 'set' || u && W(t)) && T.stream.match(/^\s+[\w$\xA1-\uFFFF]/, !1) ? (T.marked = 'keyword', O(je)) : e == 'variable' || T.style == 'keyword' ? (T.marked = 'property', O(u ? Ve : Ee, je)) : e == 'number' || e == 'string' ? O(u ? Ve : Ee, je) : e == '[' ? O(U, he, j(']'), u ? Ve : Ee, je) : t == '*' ? (T.marked = 'keyword', O(je)) : u && e == '(' ? M(Fe, je) : e == ';' || e == ',' ? O(je) : e == '}' ? O() : t == '@' ? O(U, je) : void 0 } function Ve (e, t) { if (t == '?') { return O(Ve) } if (e == ':') { return O(me, Oe) } if (t == '=') { return O(_) } const n = T.state.lexical.prev; const r = n && n.info == 'interface'; return M(r ? Fe : Ee) } function Ge (e, t) { return t == '*' ? (T.marked = 'keyword', O(qe, j(';'))) : t == 'default' ? (T.marked = 'keyword', O(U, j(';'))) : e == '{' ? O(ue(Ue, '}'), qe, j(';')) : M(V) } function Ue (e, t) { return t == 'as' ? (T.marked = 'keyword', O(j('variable'))) : e == 'variable' ? M(_, Ue) : void 0 } function _e (e) { return e == 'string' ? O() : e == '(' ? M(U) : M(Ke, $e, qe) } function Ke (e, t) { return e == '{' ? ce(Ke, '}') : (e == 'variable' && N(t), t == '*' && (T.marked = 'keyword'), O(Xe)) } function $e (e) { if (e == ',') { return O(Ke, $e) } } function Xe (e, t) { if (t == 'as') { return T.marked = 'keyword', O(Ke) } } function qe (e, t) { if (t == 'from') { return T.marked = 'keyword', O(U) } } function Ye (e) { return e == ']' ? O() : M(ue(_, ']')) } function Ze () { return M(R('form'), Le, j('{'), R('}'), ue(Je, '}'), B, B) } function Je () { return M(Le, Oe) } function Qe (e, t) { return e.lastType == 'operator' || e.lastType == ',' || h.test(t.charAt(0)) || /[,.]/.test(t.charAt(0)) } function et (e, t, n) { return t.tokenize == m && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || t.lastType == 'quasi' && /\{\s*$/.test(e.string.slice(0, e.pos - (n || 0))) } return I.lex = !0, B.lex = !0, { startState (e) { const t = { tokenize: m, lastType: 'sof', cc: [], lexical: new k((e || 0) - o, 0, 'block', !1), localVars: n.localVars, context: n.localVars && new H(null, null, !1), indented: e || 0 }; return n.globalVars && typeof n.globalVars === 'object' && (t.globalVars = n.globalVars), t }, token (e, t) { if (e.sol() && (t.lexical.hasOwnProperty('align') || (t.lexical.align = !1), t.indented = e.indentation(), x(e, t)), t.tokenize != y && e.eatSpace()) { return null } const n = t.tokenize(e, t); return r == 'comment' ? n : (t.lastType = r != 'operator' || i != '++' && i != '--' ? r : 'incdec', L(t, n, r, i, e)) }, indent (t, r) { if (t.tokenize == y) { return e.Pass } if (t.tokenize != m) { return 0 } let i; const a = r && r.charAt(0); let s = t.lexical; if (!/^\s*else\b/.test(r)) { for (let u = t.cc.length - 1; u >= 0; --u) { const c = t.cc[u]; if (c == B) { s = s.prev } else if (c != Ne) { break } } } while ((s.type == 'stat' || s.type == 'form') && (a == '}' || (i = t.cc[t.cc.length - 1]) && (i == q || i == Y) && !/^[,\.=+\-*:?[\(]/.test(r))) { s = s.prev }l && s.type == ')' && s.prev.type == 'stat' && (s = s.prev); const f = s.type; const h = a == f; return f == 'vardef' ? s.indented + (t.lastType == 'operator' || t.lastType == ',' ? s.info.length + 1 : 0) : f == 'form' && a == '{' ? s.indented : f == 'form' ? s.indented + o : f == 'stat' ? s.indented + (Qe(t, r) ? l || o : 0) : s.info != 'switch' || h || n.doubleIndentSwitch == 0 ? s.align ? s.column + (h ? 0 : 1) : s.indented + (h ? 0 : o) : s.indented + (/^(?:case|default)\b/.test(r) ? o : 2 * o) }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: s ? null : '/*', blockCommentEnd: s ? null : '*/', blockCommentContinue: s ? null : ' * ', lineComment: s ? null : '//', fold: 'brace', closeBrackets: "()[]{}''\"\"``", helperType: s ? 'json' : 'javascript', jsonldMode: a, jsonMode: s, expressionAllowed: et, skipExpression (e) { const t = e.cc[e.cc.length - 1]; t != U && t != _ || e.cc.pop() } } }), e.registerHelper('wordChars', 'javascript', /[\w$]/), e.defineMIME('text/javascript', 'javascript'), e.defineMIME('text/ecmascript', 'javascript'), e.defineMIME('application/javascript', 'javascript'), e.defineMIME('application/x-javascript', 'javascript'), e.defineMIME('application/ecmascript', 'javascript'), e.defineMIME('application/json', { name: 'javascript', json: !0 }), e.defineMIME('application/x-json', { name: 'javascript', json: !0 }), e.defineMIME('application/ld+json', { name: 'javascript', jsonld: !0 }), e.defineMIME('text/typescript', { name: 'javascript', typescript: !0 }), e.defineMIME('application/typescript', { name: 'javascript', typescript: !0 }) }) } }])
// # sourceMappingURL=chunk-49328605.06faeeb4.js.map
