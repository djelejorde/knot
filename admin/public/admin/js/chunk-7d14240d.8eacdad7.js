(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-7d14240d'], { '030f' (e, t, n) { (function (e) { (function (t) { 'use strict'; const n = function () {}; const r = function (e) { return function () { return e() } }; const o = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return e(t.apply(null, n)) } }; const i = function (e) { return function () { return e } }; const u = function (e) { return e }; function a (e) { for (var t = [], n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } const o = t.concat(n); return e.apply(null, o) } } const c = function (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } return !e.apply(null, t) } }; const s = function (e) { return function () { throw new Error(e) } }; const l = i(!1); const f = i(!0); const d = tinymce.util.Tools.resolve('tinymce.ThemeManager'); var m = function () { return m = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, m.apply(this, arguments) }; function g (e, t) { const n = {}; for (var r in e) { Object.prototype.hasOwnProperty.call(e, r) && !t.includes(r) && (n[r] = e[r]) } if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let o = 0; for (r = Object.getOwnPropertySymbols(e); o < r.length; o++) { !t.includes(r[o]) && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]) } } return n } function h () { for (var e = 0, t = 0, n = arguments.length; t < n; t++) { e += arguments[t].length } const r = Array(e); let o = 0; for (t = 0; t < n; t++) { for (let i = arguments[t], u = 0, a = i.length; u < a; u++, o++) { r[o] = i[u] } } return r } let p; const v = function () { return b }; var b = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const r = function (e) { return e }; const o = { fold (e, t) { return e() }, is: l, isSome: l, isNone: f, getOr: r, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: i(null), getOrUndefined: i(void 0), or: r, orThunk: t, map: v, each: n, bind: v, exists: l, forall: f, filter: v, equals: e, equals_: e, toArray () { return [] }, toString: i('none()') }; return Object.freeze && Object.freeze(o), o }()); var y = function (e) { const t = i(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: f, isNone: l, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return y(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : b }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(l, function (t) { return n(e, t) }) } }; return o }; const w = function (e) { return e === null || void 0 === e ? b : y(e) }; const x = { some: y, none: v, from: w }; var C = function (e) { const t = function (t) { return e === t }; const n = function (t) { return C(e) }; const r = function (t) { return C(e) }; const o = function (t) { return C(t(e)) }; const u = function (t) { return C(e) }; const a = function (t) { t(e) }; const c = function (t) { return t(e) }; const s = function (t, n) { return n(e) }; const d = function (t) { return t(e) }; const m = function (t) { return t(e) }; const g = function () { return x.some(e) }; return { is: t, isValue: f, isError: l, getOr: i(e), getOrThunk: i(e), getOrDie: i(e), or: n, orThunk: r, fold: s, map: o, mapError: u, each: a, bind: c, exists: d, forall: m, toOption: g } }; var S = function (e) { const t = function (e) { return e() }; const r = function () { return s(String(e))() }; const o = function (e) { return e }; const i = function (e) { return e() }; const a = function (t) { return S(e) }; const c = function (t) { return S(t(e)) }; const d = function (t) { return S(e) }; const m = function (t, n) { return t(e) }; return { is: l, isValue: l, isError: f, getOr: u, getOrThunk: t, getOrDie: r, or: o, orThunk: i, fold: m, map: a, mapError: c, each: n, bind: d, exists: l, forall: f, toOption: x.none } }; const k = function (e, t) { return e.fold(function () { return S(t) }, C) }; const T = { value: C, error: S, fromOption: k }; const E = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const O = function (e) { return function (t) { return E(t) === e } }; const N = O('string'); const _ = O('object'); const D = O('array'); const A = O('boolean'); const R = O('function'); const B = O('number'); const M = function (e, t) { if (D(e)) { for (let n = 0, r = e.length; n < r; ++n) { if (!0 !== t(e[n])) { return !1 } } return !0 } return !1 }; const P = Array.prototype.slice; const z = Array.prototype.indexOf; const I = Array.prototype.push; const L = function (e, t) { return z.call(e, t) }; const H = function (e, t) { const n = L(e, t); return n === -1 ? x.none() : x.some(n) }; const F = function (e, t) { return L(e, t) > -1 }; const V = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return !0 } } return !1 }; const U = function (e, t) { for (var n = [], r = 0; r < e; r++) { n.push(t(r)) } return n }; const j = function (e, t) { for (var n = [], r = 0; r < e.length; r += t) { const o = P.call(e, r, r + t); n.push(o) } return n }; const W = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const q = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const $ = function (e, t) { for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; t(r, n) } }; const G = function (e, t) { for (var n = [], r = [], o = 0, i = e.length; o < i; o++) { const u = e[o]; const a = t(u, o) ? n : r; a.push(u) } return { pass: n, fail: r } }; const X = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const Y = function (e, t, n) { return $(e, function (e) { n = t(n, e) }), n }; const K = function (e, t, n) { return q(e, function (e) { n = t(n, e) }), n }; const J = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return x.some(o) } } return x.none() }; const Z = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return x.some(n) } } return x.none() }; const Q = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!D(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } I.apply(t, e[n]) } return t }; const ee = function (e, t) { return Q(W(e, t)) }; const te = function (e, t) { for (let n = 0, r = e.length; n < r; ++n) { const o = e[n]; if (!0 !== t(o, n)) { return !1 } } return !0 }; const ne = function (e) { const t = P.call(e, 0); return t.reverse(), t }; const re = function (e, t) { return X(e, function (e) { return !F(t, e) }) }; const oe = function (e, t) { for (var n = {}, r = 0, o = e.length; r < o; r++) { const i = e[r]; n[String(i)] = t(i, r) } return n }; const ie = function (e) { return [e] }; const ue = function (e, t) { const n = P.call(e, 0); return n.sort(t), n }; const ae = function (e) { return e.length === 0 ? x.none() : x.some(e[0]) }; const ce = function (e) { return e.length === 0 ? x.none() : x.some(e[e.length - 1]) }; const se = R(Array.from) ? Array.from : function (e) { return P.call(e) }; const le = function (e, t) { for (let n = 0; n < e.length; n++) { const r = t(e[n], n); if (r.isSome()) { return r } } return x.none() }; const fe = Object.keys; const de = Object.hasOwnProperty; const me = function (e, t) { for (let n = fe(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; t(u, i) } }; const ge = function (e, t) { return he(e, function (e, n) { return { k: n, v: t(e, n) } }) }; var he = function (e, t) { const n = {}; return me(e, function (e, r) { const o = t(e, r); n[o.k] = o.v }), n }; const pe = function (e, t) { const n = []; return me(e, function (e, r) { n.push(t(e, r)) }), n }; const ve = function (e, t) { for (let n = fe(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; if (t(u, i, e)) { return x.some(u) } } return x.none() }; const be = function (e) { return pe(e, function (e) { return e }) }; const ye = function (e, t) { return we(e, t) ? x.from(e[t]) : x.none() }; var we = function (e, t) { return de.call(e, t) }; const xe = function (e, t) { return we(e, t) && void 0 !== e[t] && e[t] !== null }; const Ce = function (e) { if (!D(e)) { throw new Error('cases must be an array') } if (e.length === 0) { throw new Error('there must be at least one case') } const n = []; const r = {}; return q(e, function (o, i) { const u = fe(o); if (u.length !== 1) { throw new Error('one and only one name per case') } const a = u[0]; const c = o[a]; if (void 0 !== r[a]) { throw new Error('duplicate key detected:' + a) } if (a === 'cata') { throw new Error('cannot have a case named cata (sorry)') } if (!D(c)) { throw new Error('case arguments must be an array') } n.push(a), r[a] = function () { const r = arguments.length; if (r !== c.length) { throw new Error('Wrong number of arguments to case ' + a + '. Expected ' + c.length + ' (' + c + '), got ' + r) } for (var o = new Array(r), u = 0; u < o.length; u++) { o[u] = arguments[u] } const s = function (e) { const t = fe(e); if (n.length !== t.length) { throw new Error('Wrong number of arguments to match. Expected: ' + n.join(',') + '\nActual: ' + t.join(',')) } const r = te(n, function (e) { return F(t, e) }); if (!r) { throw new Error('Not all branches were specified when using match. Specified: ' + t.join(', ') + '\nRequired: ' + n.join(', ')) } return e[a].apply(null, o) }; return { fold () { if (arguments.length !== e.length) { throw new Error('Wrong number of arguments to fold. Expected ' + e.length + ', got ' + arguments.length) } const t = arguments[i]; return t.apply(null, o) }, match: s, log (e) { t.console.log(e, { constructors: n, constructor: a, params: o }) } } } }), r }; const Se = { generate: Ce }; const ke = Object.prototype.hasOwnProperty; const Te = function (e, t) { return t }; const Ee = function (e, t) { const n = _(e) && _(t); return n ? Ne(e, t) : t }; const Oe = function (e) { return function () { for (var t = new Array(arguments.length), n = 0; n < t.length; n++) { t[n] = arguments[n] } if (t.length === 0) { throw new Error("Can't merge zero objects") } for (var r = {}, o = 0; o < t.length; o++) { const i = t[o]; for (const u in i) { ke.call(i, u) && (r[u] = e(r[u], i[u])) } } return r } }; var Ne = Oe(Ee); const _e = Oe(Te); const De = function (e) { let t; let n = !1; return function () { for (var r = [], o = 0; o < arguments.length; o++) { r[o] = arguments[o] } return n || (n = !0, t = e.apply(null, r)), t } }; (function (e) { e[e.Error = 0] = 'Error', e[e.Value = 1] = 'Value' })(p || (p = {})); const Ae = function (e, t, n) { return e.stype === p.Error ? t(e.serror) : n(e.svalue) }; const Re = function (e) { const t = []; const n = []; return q(e, function (e) { Ae(e, function (e) { return n.push(e) }, function (e) { return t.push(e) }) }), { values: t, errors: n } }; const Be = function (e, t) { return e.stype === p.Error ? { stype: p.Error, serror: t(e.serror) } : e }; const Me = function (e, t) { return e.stype === p.Value ? { stype: p.Value, svalue: t(e.svalue) } : e }; const Pe = function (e, t) { return e.stype === p.Value ? t(e.svalue) : e }; const ze = function (e, t) { return e.stype === p.Error ? t(e.serror) : e }; const Ie = function (e) { return { stype: p.Value, svalue: e } }; const Le = function (e) { return { stype: p.Error, serror: e } }; const He = function (e) { return Ae(e, T.error, T.value) }; const Fe = function (e) { return e.fold(Le, Ie) }; const Ve = { fromResult: Fe, toResult: He, svalue: Ie, partition: Re, serror: Le, bind: Pe, bindError: ze, map: Me, mapError: Be, fold: Ae }; const Ue = Se.generate([{ strict: [] }, { defaultedThunk: ['fallbackThunk'] }, { asOption: [] }, { asDefaultedOptionThunk: ['fallbackThunk'] }, { mergeWithThunk: ['baseThunk'] }]); const je = function (e) { return Ue.defaultedThunk(i(e)) }; const We = function (e) { return Ue.mergeWithThunk(i(e)) }; const qe = Ue.strict; const $e = Ue.asOption; const Ge = Ue.defaultedThunk; const Xe = (Ue.asDefaultedOptionThunk, Ue.mergeWithThunk); const Ye = function (e, t) { const n = {}; return me(e, function (e, r) { F(t, r) || (n[r] = e) }), n }; const Ke = function (e, t) { let n; return n = {}, n[e] = t, n }; const Je = function (e) { const t = {}; return q(e, function (e) { t[e.key] = e.value }), t }; const Ze = (Se.generate([{ bothErrors: ['error1', 'error2'] }, { firstError: ['error1', 'value2'] }, { secondError: ['value1', 'error2'] }, { bothValues: ['value1', 'value2'] }]), function (e) { const t = []; const n = []; return q(e, function (e) { e.fold(function (e) { t.push(e) }, function (e) { n.push(e) }) }), { errors: t, values: n } }); const Qe = function (e, t) { return Ye(e, t) }; const et = function (e, t) { return Ke(e, t) }; const tt = function (e) { return Je(e) }; const nt = function (e, t) { return e.length === 0 ? T.value(t) : T.value(Ne(t, _e.apply(void 0, e))) }; const rt = function (e) { return T.error(Q(e)) }; const ot = function (e, t) { const n = Ze(e); return n.errors.length > 0 ? rt(n.errors) : nt(n.values, t) }; const it = function (e, t) { return e.length > 0 ? Ve.svalue(Ne(t, _e.apply(void 0, e))) : Ve.svalue(t) }; const ut = function (e) { return o(Ve.serror, Q)(e) }; const at = function (e, t) { const n = Ve.partition(e); return n.errors.length > 0 ? ut(n.errors) : it(n.values, t) }; const ct = function (e) { const t = Ve.partition(e); return t.errors.length > 0 ? ut(t.errors) : Ve.svalue(t.values) }; const st = { consolidateObj: at, consolidateArr: ct }; const lt = function (e) { return _(e) && fe(e).length > 100 ? ' removed due to size' : JSON.stringify(e, null, 2) }; const ft = function (e) { const t = e.length > 10 ? e.slice(0, 10).concat([{ path: [], getErrorInfo () { return '... (only showing first ten failures)' } }]) : e; return W(t, function (e) { return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo() }) }; const dt = function (e, t) { return Ve.serror([{ path: e, getErrorInfo: t }]) }; const mt = function (e, t, n) { return dt(e, function () { return 'Could not find valid *strict* value for "' + t + '" in ' + lt(n) }) }; const gt = function (e, t) { return dt(e, function () { return 'Choice schema did not contain choice key: "' + t + '"' }) }; const ht = function (e, t, n) { return dt(e, function () { return 'The chosen schema: "' + n + '" did not exist in branches: ' + lt(t) }) }; const pt = function (e, t) { return dt(e, function () { return 'There are unsupported fields: [' + t.join(', ') + '] specified' }) }; const vt = function (e, t) { return dt(e, function () { return t }) }; const bt = Se.generate([{ field: ['key', 'okey', 'presence', 'prop'] }, { state: ['okey', 'instantiator'] }]); const yt = function (e, t, n) { return ye(t, n).fold(function () { return mt(e, n, t) }, Ve.svalue) }; const wt = function (e, t, n) { const r = ye(e, t).fold(function () { return n(e) }, u); return Ve.svalue(r) }; const xt = function (e, t) { return Ve.svalue(ye(e, t)) }; const Ct = function (e, t, n) { const r = ye(e, t).map(function (t) { return !0 === t ? n(e) : t }); return Ve.svalue(r) }; const St = function (e, t, n, r) { return n.fold(function (n, o, u, a) { const c = function (t) { const i = a.extract(e.concat([n]), r, t); return Ve.map(i, function (e) { return Ke(o, r(e)) }) }; const s = function (t) { return t.fold(function () { const e = Ke(o, r(x.none())); return Ve.svalue(e) }, function (t) { const i = a.extract(e.concat([n]), r, t); return Ve.map(i, function (e) { return Ke(o, r(x.some(e))) }) }) }; return (function () { return u.fold(function () { return Ve.bind(yt(e, t, n), c) }, function (e) { return Ve.bind(wt(t, n, e), c) }, function () { return Ve.bind(xt(t, n), s) }, function (e) { return Ve.bind(Ct(t, n, e), s) }, function (e) { const r = e(t); const o = Ve.map(wt(t, n, i({})), function (e) { return Ne(r, e) }); return Ve.bind(o, c) }) }()) }, function (e, n) { const o = n(t); return Ve.svalue(Ke(e, r(o))) }) }; const kt = function (e, t, n, r) { const o = W(n, function (n) { return St(e, t, n, r) }); return st.consolidateObj(o, {}) }; const Tt = function (e) { const t = function (t, n, r) { return e().extract(t, n, r) }; const n = function () { return e().toString() }; return { extract: t, toString: n } }; const Et = function (e) { const t = function (t, n, r) { return Ve.bindError(e(r, n), function (e) { return vt(t, e) }) }; const n = function () { return 'val' }; return { extract: t, toString: n } }; const Ot = function (e) { const t = fe(e); return X(t, function (t) { return xe(e, t) }) }; const Nt = function (e) { const t = _t(e); const n = Y(e, function (e, t) { return t.fold(function (t) { return Ne(e, et(t, !0)) }, i(e)) }, {}); const r = function (e, r, o) { const i = A(o) ? [] : Ot(o); const u = X(i, function (e) { return !xe(n, e) }); return u.length === 0 ? t.extract(e, r, o) : pt(e, u) }; return { extract: r, toString: t.toString } }; var _t = function (e) { const t = function (t, n, r) { return kt(t, r, e, n) }; const n = function () { const t = W(e, function (e) { return e.fold(function (e, t, n, r) { return e + ' -> ' + r.toString() }, function (e, t) { return 'state(' + e + ')' }) }); return 'obj{\n' + t.join('\n') + '}' }; return { extract: t, toString: n } }; const Dt = function (e) { const t = function (t, n, r) { const o = W(r, function (r, o) { return e.extract(t.concat(['[' + o + ']']), n, r) }); return st.consolidateArr(o) }; const n = function () { return 'array(' + e.toString() + ')' }; return { extract: t, toString: n } }; const At = function (e) { const t = function (t, n, r) { for (var o = [], i = 0, u = e; i < u.length; i++) { const a = u[i]; const c = a.extract(t, n, r); if (c.stype === p.Value) { return c } o.push(c) } return st.consolidateArr(o) }; const n = function () { return 'oneOf(' + W(e, function (e) { return e.toString() }).join(', ') + ')' }; return { extract: t, toString: n } }; const Rt = function (e, t) { const n = function (t, n) { return Dt(Et(e)).extract(t, u, n) }; const r = function (e, r, o) { const i = fe(o); const u = n(e, i); return Ve.bind(u, function (n) { const i = W(n, function (e) { return bt.field(e, e, qe(), t) }); return _t(i).extract(e, r, o) }) }; const o = function () { return 'setOf(' + t.toString() + ')' }; return { extract: r, toString: o } }; const Bt = i(Et(Ve.svalue)); const Mt = o(Dt, _t); const Pt = bt.state; const zt = bt.field; const It = function (e, t, n, r, o) { const i = ye(r, o); return i.fold(function () { return ht(e, r, o) }, function (r) { return r.extract(e.concat(['branch: ' + o]), t, n) }) }; const Lt = function (e, t) { const n = function (n, r, o) { const i = ye(o, e); return i.fold(function () { return gt(n, e) }, function (e) { return It(n, r, o, t, e) }) }; const r = function () { return 'chooseOn(' + e + '). Possible values: ' + fe(t) }; return { extract: n, toString: r } }; const Ht = Et(Ve.svalue); const Ft = function (e) { return Mt(e) }; const Vt = function () { return Dt(Ht) }; const Ut = Tt; const jt = function (e) { return Et(function (t) { return e(t).fold(Ve.serror, Ve.svalue) }) }; const Wt = function (e, t) { return Rt(function (t) { return Ve.fromResult(e(t)) }, t) }; const qt = function (e, t, n, r) { const o = t.extract([e], n, r); return Ve.mapError(o, function (e) { return { input: r, errors: e } }) }; const $t = function (e, t, n) { return Ve.toResult(qt(e, t, u, n)) }; const Gt = function (e) { return e.fold(function (e) { throw new Error(Yt(e)) }, u) }; const Xt = function (e, t, n) { return Gt($t(e, t, n)) }; var Yt = function (e) { return 'Errors: \n' + ft(e.errors).join('\n') + '\n\nInput object: ' + lt(e.input) }; const Kt = function (e, t) { return Lt(e, t) }; const Jt = function (e, t) { return Lt(e, ge(t, _t)) }; const Zt = i(Ht); const Qt = function (e, t) { return Et(function (n) { const r = typeof n; return e(n) ? Ve.svalue(n) : Ve.serror('Expected type: ' + t + ' but got: ' + r) }) }; const en = Qt(B, 'number'); const tn = Qt(N, 'string'); const nn = Qt(A, 'boolean'); const rn = Qt(R, 'function'); var on = function (e) { const t = function (e, t) { let n = e.next(); while (!n.done) { if (!t(n.value)) { return !1 } n = e.next() } return !0 }; if (Object(e) !== e) { return !0 } switch ({}.toString.call(e).slice(8, -1)) { case 'Boolean':case 'Number':case 'String':case 'Date':case 'RegExp':case 'Blob':case 'FileList':case 'ImageData':case 'ImageBitmap':case 'ArrayBuffer':return !0; case 'Array':case 'Object':return Object.keys(e).every(function (t) { return on(e[t]) }); case 'Map':return t(e.keys(), on) && t(e.values(), on); case 'Set':return t(e.keys(), on); default:return !1 } }; const un = Et(function (e) { return on(e) ? Ve.svalue(e) : Ve.serror('Expected value to be acceptable for sending via postMessage') }); const an = function (e) { return jt(function (t) { return F(e, t) ? T.value(t) : T.error('Unsupported value: "' + t + '", choose one of "' + e.join(', ') + '".') }) }; const cn = function (e) { return zt(e, e, qe(), Bt()) }; const sn = function (e, t) { return zt(e, e, qe(), t) }; const ln = function (e) { return sn(e, en) }; const fn = function (e) { return sn(e, tn) }; const dn = function (e, t) { return zt(e, e, qe(), an(t)) }; const mn = function (e) { return sn(e, nn) }; const gn = function (e) { return sn(e, rn) }; const hn = function (e, t) { return zt(e, e, $e(), Et(function (n) { return Ve.serror('The field: ' + e + ' is forbidden. ' + t) })) }; const pn = function (e, t) { return zt(e, e, qe(), _t(t)) }; const vn = function (e, t) { return zt(e, e, qe(), Mt(t)) }; const bn = function (e, t) { return zt(e, e, qe(), Dt(t)) }; const yn = function (e) { return zt(e, e, $e(), Bt()) }; const wn = function (e, t) { return zt(e, e, $e(), t) }; const xn = function (e) { return wn(e, en) }; const Cn = function (e) { return wn(e, tn) }; const Sn = function (e) { return wn(e, rn) }; const kn = function (e, t) { return wn(e, Dt(t)) }; const Tn = function (e, t) { return wn(e, _t(t)) }; const En = function (e, t) { return wn(e, Nt(t)) }; const On = function (e, t) { return zt(e, e, je(t), Bt()) }; const Nn = function (e, t, n) { return zt(e, e, je(t), n) }; const _n = function (e, t) { return Nn(e, t, en) }; const Dn = function (e, t) { return Nn(e, t, tn) }; const An = function (e, t, n) { return Nn(e, t, an(n)) }; const Rn = function (e, t) { return Nn(e, t, nn) }; const Bn = function (e, t) { return Nn(e, t, rn) }; const Mn = function (e, t) { return Nn(e, t, un) }; const Pn = function (e, t, n) { return Nn(e, t, Dt(n)) }; const zn = function (e, t, n) { return Nn(e, t, _t(n)) }; const In = function (e, t) { return Pt(e, t) }; var Ln = function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return Ln(n()) }; return { get: n, set: r, clone: o } }; const Hn = function (e, n) { const r = n || t.document; const o = r.createElement('div'); if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) { throw t.console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node') } return Un(o.childNodes[0]) }; const Fn = function (e, n) { const r = n || t.document; const o = r.createElement(e); return Un(o) }; const Vn = function (e, n) { const r = n || t.document; const o = r.createTextNode(e); return Un(o) }; var Un = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: i(e) } }; const jn = function (e, t, n) { const r = e.dom(); return x.from(r.elementFromPoint(t, n)).map(Un) }; const Wn = { fromHtml: Hn, fromTag: Fn, fromText: Vn, fromDom: Un, fromPoint: jn }; const qn = function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }; const $n = function (e, n) { return qn(e, n, t.Node.DOCUMENT_POSITION_PRECEDING) }; const Gn = function (e, n) { return qn(e, n, t.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const Xn = { documentPositionPreceding: $n, documentPositionContainedBy: Gn }; const Yn = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const Kn = function (e, t) { const n = Yn(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return Qn(r(1), r(2)) }; const Jn = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? Zn() : Kn(e, n) }; var Zn = function () { return Qn(0, 0) }; var Qn = function (e, t) { return { major: e, minor: t } }; const er = { nu: Qn, detect: Jn, unknown: Zn }; const tr = 'Edge'; const nr = 'Chrome'; const rr = 'IE'; const or = 'Opera'; const ir = 'Firefox'; const ur = 'Safari'; const ar = function (e, t) { return function () { return t === e } }; const cr = function () { return sr({ current: void 0, version: er.unknown() }) }; var sr = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: ar(tr, t), isChrome: ar(nr, t), isIE: ar(rr, t), isOpera: ar(or, t), isFirefox: ar(ir, t), isSafari: ar(ur, t) } }; const lr = { unknown: cr, nu: sr, edge: i(tr), chrome: i(nr), ie: i(rr), opera: i(or), firefox: i(ir), safari: i(ur) }; const fr = 'Windows'; const dr = 'iOS'; const mr = 'Android'; const gr = 'Linux'; const hr = 'OSX'; const pr = 'Solaris'; const vr = 'FreeBSD'; const br = 'ChromeOS'; const yr = function (e, t) { return function () { return t === e } }; const wr = function () { return xr({ current: void 0, version: er.unknown() }) }; var xr = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: yr(fr, t), isiOS: yr(dr, t), isAndroid: yr(mr, t), isOSX: yr(hr, t), isLinux: yr(gr, t), isSolaris: yr(pr, t), isFreeBSD: yr(vr, t), isChromeOS: yr(br, t) } }; const Cr = { unknown: wr, nu: xr, windows: i(fr), ios: i(dr), android: i(mr), linux: i(gr), osx: i(hr), solaris: i(pr), freebsd: i(vr), chromeos: i(br) }; const Sr = function (e, t, n, r) { const o = e.isiOS() && !0 === /ipad/i.test(n); const u = e.isiOS() && !o; const a = e.isiOS() || e.isAndroid(); const c = a || r('(pointer:coarse)'); const s = o || !u && a && r('(min-device-width:768px)'); const l = u || a && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: i(o), isiPhone: i(u), isTablet: i(s), isPhone: i(l), isTouch: i(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: i(f), isDesktop: i(d) } }; const kr = function (e, t) { const n = String(t).toLowerCase(); return J(e, function (e) { return e.search(n) }) }; const Tr = function (e, t) { return kr(e, t).map(function (e) { const n = er.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Er = function (e, t) { return kr(e, t).map(function (e) { const n = er.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Or = { detectBrowser: Tr, detectOs: Er }; const Nr = function (e, t, n) { if (t === '') { return !0 } if (e.length < t.length) { return !1 } const r = e.substr(n, n + t.length); return r === t }; const _r = function (e, t) { return e.includes(t) }; const Dr = function (e, t) { return Nr(e, t, e.length - t.length) }; const Ar = function (e) { return e.replace(/^\s+|\s+$/g, '') }; const Rr = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const Br = function (e) { return function (t) { return _r(t, e) } }; const Mr = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return _r(e, 'edge/') && _r(e, 'chrome') && _r(e, 'safari') && _r(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Rr], search (e) { return _r(e, 'chrome') && !_r(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return _r(e, 'msie') || _r(e, 'trident') } }, { name: 'Opera', versionRegexes: [Rr, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Br('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Br('firefox') }, { name: 'Safari', versionRegexes: [Rr, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (_r(e, 'safari') || _r(e, 'mobile/')) && _r(e, 'applewebkit') } }]; const Pr = [{ name: 'Windows', search: Br('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return _r(e, 'iphone') || _r(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: Br('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: Br('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: Br('linux'), versionRegexes: [] }, { name: 'Solaris', search: Br('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: Br('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: Br('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const zr = { browsers: i(Mr), oses: i(Pr) }; const Ir = function (e, t) { const n = zr.browsers(); const r = zr.oses(); const o = Or.detectBrowser(n, e).fold(lr.unknown, lr.nu); const i = Or.detectOs(r, e).fold(Cr.unknown, Cr.nu); const u = Sr(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const Lr = { detect: Ir }; const Hr = function (e) { return t.window.matchMedia(e).matches }; const Fr = Ln(Lr.detect(t.navigator.userAgent, Hr)); const Vr = function () { return Fr.get() }; const Ur = (t.Node.ATTRIBUTE_NODE, t.Node.CDATA_SECTION_NODE, t.Node.COMMENT_NODE, t.Node.DOCUMENT_NODE); const jr = (t.Node.DOCUMENT_TYPE_NODE, t.Node.DOCUMENT_FRAGMENT_NODE, t.Node.ELEMENT_NODE); const Wr = t.Node.TEXT_NODE; const qr = (t.Node.PROCESSING_INSTRUCTION_NODE, t.Node.ENTITY_REFERENCE_NODE, t.Node.ENTITY_NODE, t.Node.NOTATION_NODE, jr); const $r = Ur; const Gr = function (e, t) { const n = e.dom(); if (n.nodeType !== qr) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const Xr = function (e) { return e.nodeType !== qr && e.nodeType !== $r || e.childElementCount === 0 }; const Yr = function (e, n) { const r = void 0 === n ? t.document : n.dom(); return Xr(r) ? [] : W(r.querySelectorAll(e), Wn.fromDom) }; const Kr = function (e, n) { const r = void 0 === n ? t.document : n.dom(); return Xr(r) ? x.none() : x.from(r.querySelector(e)).map(Wn.fromDom) }; const Jr = function (e, t) { return e.dom() === t.dom() }; const Zr = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const Qr = function (e, t) { return Xn.documentPositionContainedBy(e.dom(), t.dom()) }; const eo = Vr().browser; const to = eo.isIE() ? Qr : Zr; const no = function (e, t, n) { let r = e.dom(); const o = R(n) ? n : i(!1); while (r.parentNode) { r = r.parentNode; const u = Wn.fromDom(r); const a = t(u); if (a.isSome()) { return a } if (o(u)) { break } } return x.none() }; const ro = function (e, t, n) { const r = t(e); return r.orThunk(function () { return n(e) ? x.none() : no(e, t, n) }) }; const oo = function (e, t) { return Jr(e.element(), t.event().target()) }; const io = function (e) { if (!xe(e, 'can') && !xe(e, 'abort') && !xe(e, 'run')) { throw new Error('EventHandler defined by: ' + JSON.stringify(e, null, 2) + ' does not have can, abort, or run!') } return Xt('Extracting event.handler', Nt([On('can', i(!0)), On('abort', i(!1)), On('run', n)]), e) }; const uo = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return K(e, function (e, r) { return e && t(r).apply(void 0, n) }, !0) } }; const ao = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return K(e, function (e, r) { return e || t(r).apply(void 0, n) }, !1) } }; const co = function (e) { return R(e) ? { can: i(!0), abort: i(!1), run: e } : e }; const so = function (e) { const t = uo(e, function (e) { return e.can }); const n = ao(e, function (e) { return e.abort }); const r = function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] }q(e, function (e) { e.run.apply(void 0, t) }) }; return io({ can: t, abort: n, run: r }) }; const lo = i('touchstart'); const fo = i('touchmove'); const mo = i('touchend'); const go = i('touchcancel'); const ho = i('mousedown'); const po = i('mousemove'); const vo = i('mouseout'); const bo = i('mouseup'); const yo = i('mouseover'); const wo = i('focusin'); const xo = i('focusout'); const Co = i('keydown'); const So = i('keyup'); const ko = i('input'); const To = i('change'); const Eo = i('click'); const Oo = i('transitionend'); const No = i('selectstart'); const _o = { tap: i('alloy.tap') }; const Do = i('alloy.focus'); const Ao = i('alloy.blur.post'); const Ro = i('alloy.paste.post'); const Bo = i('alloy.receive'); const Mo = i('alloy.execute'); const Po = i('alloy.focus.item'); const zo = _o.tap; const Io = i('alloy.longpress'); const Lo = i('alloy.sandbox.close'); const Ho = i('alloy.typeahead.cancel'); const Fo = i('alloy.system.init'); const Vo = i('alloy.system.touchmove'); const Uo = i('alloy.system.touchend'); const jo = i('alloy.system.scroll'); const Wo = i('alloy.system.resize'); const qo = i('alloy.system.attached'); const $o = i('alloy.system.detached'); const Go = i('alloy.system.dismissRequested'); const Xo = i('alloy.system.repositionRequested'); const Yo = i('alloy.focusmanager.shifted'); const Ko = i('alloy.slotcontainer.visibility'); const Jo = i('alloy.change.tab'); const Zo = i('alloy.dismiss.tab'); const Qo = i('alloy.highlight'); const ei = i('alloy.dehighlight'); const ti = function (e, t) { ii(e, e.element(), t, {}) }; const ni = function (e, t, n) { ii(e, e.element(), t, n) }; const ri = function (e) { ti(e, Mo()) }; const oi = function (e, t, n) { ii(e, t, n, {}) }; var ii = function (e, t, n, r) { const o = m({ target: t }, r); e.getSystem().triggerEvent(n, t, ge(o, i)) }; const ui = function (e, t, n, r) { e.getSystem().triggerEvent(n, t, r.event()) }; const ai = function (e) { return tt(e) }; const ci = function (e, t) { return { key: e, value: io({ abort: t }) } }; const si = function (e, t) { return { key: e, value: io({ can: t }) } }; const li = function (e) { return { key: e, value: io({ run (e, t) { t.event().prevent() } }) } }; const fi = function (e, t) { return { key: e, value: io({ run: t }) } }; const di = function (e, t, n) { return { key: e, value: io({ run (e, r) { t.apply(void 0, [e, r].concat(n)) } }) } }; const mi = function (e) { return function (t) { return fi(e, t) } }; const gi = function (e) { return function (t) { return { key: e, value: io({ run (e, n) { oo(e, n) && t(e, n) } }) } } }; const hi = function (e, t) { return fi(e, function (n, r) { n.getSystem().getByUid(t).each(function (t) { ui(t, t.element(), e, r) }) }) }; const pi = function (e, t, n) { const r = t.partUids[n]; return hi(e, r) }; const vi = function (e, t) { return fi(e, function (e, n) { const r = n.event(); const o = e.getSystem().getByDom(r.target()).fold(function () { const t = ro(r.target(), function (t) { return e.getSystem().getByDom(t).toOption() }, i(!1)); return t.getOr(e) }, function (e) { return e }); t(e, o, n) }) }; const bi = function (e) { return fi(e, function (e, t) { t.cut() }) }; const yi = function (e) { return fi(e, function (e, t) { t.stop() }) }; const wi = function (e, t) { return gi(e)(t) }; const xi = gi(qo()); const Ci = gi($o()); const Si = gi(Fo()); const ki = mi(Mo()); const Ti = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } if (e.length !== t.length) { throw new Error('Wrong number of arguments to struct. Expected "[' + e.length + ']", got ' + t.length + ' arguments') } const r = {}; return q(e, function (e, n) { r[e] = i(t[n]) }), r } }; const Ei = function (e) { return e.slice(0).sort() }; const Oi = function (e, t) { throw new Error('All required keys (' + Ei(e).join(', ') + ') were not specified. Specified keys were: ' + Ei(t).join(', ') + '.') }; const Ni = function (e) { throw new Error('Unsupported keys for object: ' + Ei(e).join(', ')) }; const _i = function (e, t) { if (!D(t)) { throw new Error('The ' + e + ' fields must be an array. Was: ' + t + '.') } q(t, function (t) { if (!N(t)) { throw new Error('The value ' + t + ' in the ' + e + ' fields was not a string.') } }) }; const Di = function (e) { const t = Ei(e); const n = J(t, function (e, n) { return n < t.length - 1 && e === t[n + 1] }); n.each(function (e) { throw new Error('The field: ' + e + ' occurs more than once in the combined fields: [' + t.join(', ') + '].') }) }; const Ai = function (e, t) { const n = e.concat(t); if (n.length === 0) { throw new Error('You must specify at least one required or optional field.') } return _i('required', e), _i('optional', t), Di(n), function (r) { const o = fe(r); const u = te(e, function (e) { return F(o, e) }); u || Oi(e, o); const a = X(o, function (e) { return !F(n, e) }); a.length > 0 && Ni(a); const c = {}; return q(e, function (e) { c[e] = i(r[e]) }), q(t, function (e) { c[e] = i(Object.prototype.hasOwnProperty.call(r, e) ? x.some(r[e]) : x.none()) }), c } }; const Ri = function (e) { return Wn.fromDom(e.dom().ownerDocument) }; const Bi = function (e) { return Wn.fromDom(e.dom().ownerDocument.documentElement) }; const Mi = function (e) { return Wn.fromDom(e.dom().ownerDocument.defaultView) }; const Pi = function (e) { return x.from(e.dom().parentNode).map(Wn.fromDom) }; const zi = function (e) { return x.from(e.dom().offsetParent).map(Wn.fromDom) }; const Ii = function (e) { return x.from(e.dom().nextSibling).map(Wn.fromDom) }; const Li = function (e) { return W(e.dom().childNodes, Wn.fromDom) }; const Hi = function (e, t) { const n = e.dom().childNodes; return x.from(n[t]).map(Wn.fromDom) }; const Fi = function (e) { return Hi(e, 0) }; const Vi = (Ti('element', 'offset'), function (e, n) { const r = n || t.document; const o = r.createElement('div'); return o.innerHTML = e, Li(Wn.fromDom(o)) }); const Ui = function (e, t) { const n = Pi(e); n.each(function (n) { n.dom().insertBefore(t.dom(), e.dom()) }) }; const ji = function (e, t) { const n = Ii(e); n.fold(function () { const n = Pi(e); n.each(function (e) { qi(e, t) }) }, function (e) { Ui(e, t) }) }; const Wi = function (e, t) { const n = Fi(e); n.fold(function () { qi(e, t) }, function (n) { e.dom().insertBefore(t.dom(), n.dom()) }) }; var qi = function (e, t) { e.dom().appendChild(t.dom()) }; const $i = function (e, t, n) { Hi(e, n).fold(function () { qi(e, t) }, function (e) { Ui(e, t) }) }; const Gi = function (e, t) { q(t, function (t) { Ui(e, t) }) }; const Xi = function (e, t) { q(t, function (t) { qi(e, t) }) }; const Yi = function (e) { e.dom().textContent = '', q(Li(e), function (e) { Ki(e) }) }; var Ki = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const Ji = function (e) { const t = Li(e); t.length > 0 && Gi(e, t), Ki(e) }; const Zi = function (e) { return e.dom().innerHTML }; const Qi = function (e, t) { const n = Ri(e); const r = n.dom(); const o = Wn.fromDom(r.createDocumentFragment()); const i = Vi(t, r); Xi(o, i), Yi(e), qi(e, o) }; const eu = function (e) { const t = Wn.fromTag('div'); const n = Wn.fromDom(e.dom().cloneNode(!0)); return qi(t, n), Zi(t) }; const tu = (typeof t.window !== 'undefined' ? t.window : Function('return this;')(), function (e) { const t = e.dom().nodeName; return t.toLowerCase() }); const nu = function (e) { return e.dom().nodeType }; const ru = function (e) { return function (t) { return nu(t) === e } }; const ou = ru(jr); const iu = ru(Wr); const uu = function (e, n, r) { if (!(N(r) || A(r) || B(r))) { throw t.console.error('Invalid call to Attr.set. Key ', n, ':: Value ', r, ':: Element ', e), new Error('Attribute value was not simple') } e.setAttribute(n, r + '') }; const au = function (e, t, n) { uu(e.dom(), t, n) }; const cu = function (e, t) { const n = e.dom(); me(t, function (e, t) { uu(n, t, e) }) }; const su = function (e, t) { const n = e.dom().getAttribute(t); return n === null ? void 0 : n }; const lu = function (e, t) { return x.from(su(e, t)) }; const fu = function (e, t) { const n = e.dom(); return !(!n || !n.hasAttribute) && n.hasAttribute(t) }; const du = function (e, t) { e.dom().removeAttribute(t) }; const mu = function (e, t) { return Wn.fromDom(e.dom().cloneNode(t)) }; const gu = function (e) { return mu(e, !1) }; const hu = function (e) { const t = gu(e); return eu(t) }; const pu = function (e) { return hu(e) }; const vu = function (e, t, n) { return Jr(t, e.element()) && !Jr(t, n) }; const bu = ai([si(Do(), function (e, n) { const r = n.event().originator(); const o = n.event().target(); return !vu(e, r, o) || (t.console.warn(Do() + ' did not get interpreted by the desired target. \nOriginator: ' + pu(r) + '\nTarget: ' + pu(o) + '\nCheck the ' + Do() + ' event handlers'), !1) })]); const yu = Object.freeze({ __proto__: null, events: bu }); let wu = 0; const xu = function (e) { const t = new Date(); const n = t.getTime(); const r = Math.floor(1e9 * Math.random()); return wu++, e + '_' + r + wu + String(n) }; const Cu = i('alloy-id-'); const Su = i('data-alloy-id'); const ku = Cu(); const Tu = Su(); const Eu = function (e, t) { const n = xu(ku + e); return Ou(t, n), n }; var Ou = function (e, t) { Object.defineProperty(e.dom(), Tu, { value: t, writable: !0 }) }; const Nu = function (e) { const t = ou(e) ? e.dom()[Tu] : null; return x.from(t) }; const _u = function (e) { return xu(e) }; const Du = u; const Au = function (e) { const t = function (t) { return function () { throw new Error('The component must be in a context to send: ' + t + (e ? '\n' + pu(e().element()) + ' is not in context.' : '')) } }; return { debugInfo: i('fake'), triggerEvent: t('triggerEvent'), triggerFocus: t('triggerFocus'), triggerEscape: t('triggerEscape'), build: t('build'), addToWorld: t('addToWorld'), removeFromWorld: t('removeFromWorld'), addToGui: t('addToGui'), removeFromGui: t('removeFromGui'), getByUid: t('getByUid'), getByDom: t('getByDom'), broadcast: t('broadcast'), broadcastOn: t('broadcastOn'), broadcastEvent: t('broadcastEvent'), isConnected: i(!1) } }; const Ru = Au(); const Bu = function (e, t, n) { const r = n.toString(); const o = r.indexOf(')') + 1; const i = r.indexOf('('); const u = r.substring(i + 1, o - 1).split(/,\s*/); return e.toFunctionAnnotation = function () { return { name: t, parameters: Mu(u.slice(0, 1).concat(u.slice(3))) } }, e }; var Mu = function (e) { return W(e, function (e) { return Dr(e, '/*') ? e.substring(0, e.length - '/*'.length) : e }) }; const Pu = function (e, t) { const n = e.toString(); const r = n.indexOf(')') + 1; const o = n.indexOf('('); const i = n.substring(o + 1, r - 1).split(/,\s*/); return e.toFunctionAnnotation = function () { return { name: t, parameters: Mu(i) } }, e }; const zu = function (e, t) { const n = t.toString(); const r = n.indexOf(')') + 1; const o = n.indexOf('('); const i = n.substring(o + 1, r - 1).split(/,\s*/); return e.toFunctionAnnotation = function () { return { name: 'OVERRIDE', parameters: Mu(i.slice(1)) } }, e }; const Iu = xu('alloy-premade'); const Lu = function (e) { return et(Iu, e) }; const Hu = function (e) { return ye(e, Iu) }; const Fu = function (e) { return zu(function (t) { for (var n = [], r = 1; r < arguments.length; r++) { n[r - 1] = arguments[r] } return e.apply(void 0, [t.getApis()].concat([t].concat(n))) }, e) }; const Vu = { init () { return Uu({ readState () { return 'No State required' } }) } }; var Uu = function (e) { return e }; const ju = function (e, t) { const n = W(t, function (e) { return Tn(e.name(), [cn('config'), On('state', Vu)]) }); const r = $t('component.behaviours', _t(n), e.behaviours).fold(function (t) { throw new Error(Yt(t) + '\nComplete spec:\n' + JSON.stringify(e, null, 2)) }, function (e) { return e }); return { list: t, data: ge(r, function (e) { const t = e.map(function (e) { return { config: e.config, state: e.state.init(e.config) } }); return function () { return t } }) } }; const Wu = function (e) { return e.list }; const qu = function (e) { return e.data }; const $u = function (e, t) { const n = {}; return me(e, function (e, r) { me(e, function (e, o) { const i = ye(n, o).getOr([]); n[o] = i.concat([t(r, e)]) }) }), n }; const Gu = function (e) { return { classes: void 0 !== e.classes ? e.classes : [], attributes: void 0 !== e.attributes ? e.attributes : {}, styles: void 0 !== e.styles ? e.styles : {} } }; const Xu = function (e, t) { return m(m({}, e), { attributes: m(m({}, e.attributes), t.attributes), styles: m(m({}, e.styles), t.styles), classes: e.classes.concat(t.classes) }) }; const Yu = function (e, t, n, r) { const o = m({}, t); q(n, function (t) { o[t.name()] = t.exhibit(e, r) }); const i = $u(o, function (e, t) { return { name: e, modification: t } }); const u = function (e) { return Y(e, function (e, t) { return m(m({}, t.modification), e) }, {}) }; const a = Y(i.classes, function (e, t) { return t.modification.concat(e) }, []); const c = u(i.attributes); const s = u(i.styles); return Gu({ classes: a, attributes: c, styles: s }) }; const Ku = function (e, t, n, r) { try { const o = ue(n, function (n, o) { const i = n[t](); const u = o[t](); const a = r.indexOf(i); const c = r.indexOf(u); if (a === -1) { throw new Error('The ordering for ' + e + ' does not have an entry for ' + i + '.\nOrder specified: ' + JSON.stringify(r, null, 2)) } if (c === -1) { throw new Error('The ordering for ' + e + ' does not have an entry for ' + u + '.\nOrder specified: ' + JSON.stringify(r, null, 2)) } return a < c ? -1 : c < a ? 1 : 0 }); return T.value(o) } catch (i) { return T.error([i]) } }; const Ju = function (e, t) { return { handler: e, purpose: i(t) } }; const Zu = function (e, t) { return { cHandler: e, purpose: i(t) } }; const Qu = function (e, t) { return Zu(a.apply(void 0, [e.handler].concat(t)), e.purpose()) }; const ea = function (e) { return e.cHandler }; const ta = function (e, t) { return { name: i(e), handler: i(t) } }; const na = function (e, t) { const n = {}; return q(e, function (e) { n[e.name()] = e.handlers(t) }), n }; const ra = function (e, t, n) { const r = m(m({}, n), na(t, e)); return $u(r, ta) }; const oa = function (e, t, n, r) { const o = ra(e, n, r); return ca(o, t) }; const ia = function (e) { const t = co(e); return function (e, n) { for (var r = [], o = 2; o < arguments.length; o++) { r[o - 2] = arguments[o] } const i = [e, n].concat(r); t.abort.apply(void 0, i) ? n.stop() : t.can.apply(void 0, i) && t.run.apply(void 0, i) } }; const ua = function (e, t) { return T.error(['The event (' + e + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(W(t, function (e) { return e.name() }), null, 2)]) }; const aa = function (e, t, n) { const r = t[n]; return r ? Ku('Event: ' + n, 'name', e, r).map(function (e) { const t = W(e, function (e) { return e.handler() }); return so(t) }) : ua(n, e) }; var ca = function (e, t) { const n = pe(e, function (e, n) { const r = e.length === 1 ? T.value(e[0].handler()) : aa(e, t, n); return r.map(function (r) { const o = ia(r); const i = e.length > 1 ? X(t[n], function (t) { return V(e, function (e) { return e.name() === t }) }).join(' > ') : e[0].name(); return et(n, Ju(o, i)) }) }); return ot(n, {}) }; const sa = function (e) { return $t('custom.definition', _t([zt('dom', 'dom', qe(), _t([cn('tag'), On('styles', {}), On('classes', []), On('attributes', {}), yn('value'), yn('innerHtml')])), cn('components'), cn('uid'), On('events', {}), On('apis', {}), zt('eventOrder', 'eventOrder', We({ 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'typeaheadevents'], 'alloy.focus': ['alloy.base.behaviour', 'focusing', 'keying'], 'alloy.system.init': ['alloy.base.behaviour', 'disabling', 'toggling', 'representing'], input: ['alloy.base.behaviour', 'representing', 'streaming', 'invalidating'], 'alloy.system.detached': ['alloy.base.behaviour', 'representing', 'item-events', 'tooltipping'], mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events'], touchstart: ['focusing', 'alloy.base.behaviour', 'item-type-events'], mouseover: ['item-type-events', 'tooltipping'] }), Zt()), yn('domModification')]), e) }; const la = function (e) { return m(m({}, e.dom), { uid: e.uid, domChildren: W(e.components, function (e) { return e.element() }) }) }; const fa = function (e) { return e.domModification.fold(function () { return Gu({}) }, Gu) }; const da = function (e) { return e.events }; const ma = function (e, t) { const n = su(e, t); return void 0 === n || n === '' ? [] : n.split(' ') }; const ga = function (e, t, n) { const r = ma(e, t); const o = r.concat([n]); return au(e, t, o.join(' ')), !0 }; const ha = function (e, t, n) { const r = X(ma(e, t), function (e) { return e !== n }); return r.length > 0 ? au(e, t, r.join(' ')) : du(e, t), !1 }; const pa = function (e) { return void 0 !== e.dom().classList }; const va = function (e) { return ma(e, 'class') }; const ba = function (e, t) { return ga(e, 'class', t) }; const ya = function (e, t) { return ha(e, 'class', t) }; const wa = function (e, t) { pa(e) ? e.dom().classList.add(t) : ba(e, t) }; const xa = function (e) { const t = pa(e) ? e.dom().classList : va(e); t.length === 0 && du(e, 'class') }; const Ca = function (e, t) { if (pa(e)) { const n = e.dom().classList; n.remove(t) } else { ya(e, t) }xa(e) }; const Sa = function (e, t) { return pa(e) && e.dom().classList.contains(t) }; const ka = function (e, t) { q(t, function (t) { wa(e, t) }) }; const Ta = function (e, t) { q(t, function (t) { Ca(e, t) }) }; const Ea = function (e) { return void 0 !== e.style && R(e.style.getPropertyValue) }; const Oa = function (e) { const t = iu(e) ? e.dom().parentNode : e.dom(); return void 0 !== t && t !== null && t.ownerDocument.body.contains(t) }; const Na = De(function () { return _a(Wn.fromDom(t.document)) }); var _a = function (e) { const t = e.dom().body; if (t === null || void 0 === t) { throw new Error('Body is not available yet') } return Wn.fromDom(t) }; const Da = function (e, n, r) { if (!N(r)) { throw t.console.error('Invalid call to CSS.set. Property ', n, ':: Value ', r, ':: Element ', e), new Error('CSS value must be a string: ' + r) } Ea(e) && e.style.setProperty(n, r) }; const Aa = function (e, t) { Ea(e) && e.style.removeProperty(t) }; const Ra = function (e, t, n) { const r = e.dom(); Da(r, t, n) }; const Ba = function (e, t) { const n = e.dom(); me(t, function (e, t) { Da(n, t, e) }) }; const Ma = function (e, t) { const n = e.dom(); me(t, function (e, t) { e.fold(function () { Aa(n, t) }, function (e) { Da(n, t, e) }) }) }; const Pa = function (e, n) { const r = e.dom(); const o = t.window.getComputedStyle(r); const i = o.getPropertyValue(n); const u = i !== '' || Oa(e) ? i : za(r, n); return u === null ? void 0 : u }; var za = function (e, t) { return Ea(e) ? e.style.getPropertyValue(t) : '' }; const Ia = function (e, t) { const n = e.dom(); const r = za(n, t); return x.from(r).filter(function (e) { return e.length > 0 }) }; const La = function (e) { const t = {}; const n = e.dom(); if (Ea(n)) { for (let r = 0; r < n.style.length; r++) { const o = n.style.item(r); t[o] = n.style[o] } } return t }; const Ha = function (e, t, n) { const r = Wn.fromTag(e); Ra(r, t, n); const o = Ia(r, t); return o.isSome() }; const Fa = function (e, t) { const n = e.dom(); Aa(n, t), fu(e, 'style') && Ar(su(e, 'style')) === '' && du(e, 'style') }; const Va = function (e) { return e.dom().offsetWidth }; const Ua = function (e) { return e.dom().value }; const ja = function (e, t) { if (void 0 === t) { throw new Error('Value.set was undefined') } e.dom().value = t }; const Wa = function (e) { const t = Wn.fromTag(e.tag); cu(t, e.attributes), ka(t, e.classes), Ba(t, e.styles), e.innerHtml.each(function (e) { return Qi(t, e) }); const n = e.domChildren; return Xi(t, n), e.value.each(function (e) { ja(t, e) }), e.uid, Ou(t, e.uid), t }; const qa = function (e) { const t = ye(e, 'behaviours').getOr({}); const n = X(fe(t), function (e) { return void 0 !== t[e] }); return W(n, function (e) { return t[e].me }) }; const $a = function (e, t) { return ju(e, t) }; const Ga = function (e) { const t = qa(e); return $a(e, t) }; const Xa = function (e, t, n) { const r = la(e); const o = fa(e); const i = { 'alloy.base.modification': o }; const u = t.length > 0 ? Yu(n, i, t, r) : o; return Xu(r, u) }; const Ya = function (e, t, n) { const r = { 'alloy.base.behaviour': da(e) }; return oa(n, e.eventOrder, t, r).getOrDie() }; const Ka = function (e) { const t = function () { return y }; const n = Ln(Ru); const r = Gt(sa(e)); const o = Ga(e); const u = Wu(o); const a = qu(o); const c = Xa(r, u, a); const s = Wa(c); const l = Ya(r, u, a); const f = Ln(r.components); const d = function (e) { n.set(e) }; const m = function () { n.set(Au(t)) }; const g = function () { const e = Li(s); const t = ee(e, function (e) { return n.get().getByDom(e).fold(function () { return [] }, function (e) { return [e] }) }); f.set(t) }; const h = function (t) { const n = a; const r = R(n[t.name()]) ? n[t.name()] : function () { throw new Error('Could not find ' + t.name() + ' in ' + JSON.stringify(e, null, 2)) }; return r() }; const p = function (e) { return R(a[e.name()]) }; const v = function () { return r.apis }; const b = function (e) { return a[e]().map(function (e) { return e.state.readState() }).getOr('not enabled') }; var y = { getSystem: n.get, config: h, hasConfigured: p, spec: i(e), readState: b, getApis: v, connect: d, disconnect: m, element: i(s), syncComponents: g, components: f.get, events: i(l) }; return y }; const Ja = function (e) { const t = ye(e, 'components').getOr([]); return W(t, nc) }; const Za = function (e) { const t = Du(e); const n = t.events; const r = g(t, ['events']); const o = Ja(r); const i = m(m({}, r), { events: m(m({}, yu), n), components: o }); return T.value(Ka(i)) }; const Qa = function (e) { const t = Wn.fromText(e); return ec({ element: t }) }; var ec = function (e) { const t = Xt('external.component', Nt([cn('element'), yn('uid')]), e); const r = Ln(Au()); const o = function (e) { r.set(e) }; const u = function () { r.set(Au(function () { return a })) }; t.uid.each(function (e) { Ou(t.element, e) }); var a = { getSystem: r.get, config: x.none, hasConfigured: i(!1), connect: o, disconnect: u, getApis () { return {} }, element: i(t.element), spec: i(e), readState: i('No state'), syncComponents: n, components: i([]), events: i({}) }; return Lu(a) }; const tc = _u; var nc = function (e) { return Hu(e).fold(function () { const t = e.hasOwnProperty('uid') ? e : m({ uid: tc('') }, e); return Za(t).getOrDie() }, function (e) { return e }) }; const rc = Lu; function oc (e, t) { const n = function (t, n) { if (!B(n) && !n.match(/^[0-9]+$/)) { throw new Error(e + '.set accepts only positive integer values. Value was ' + n) } const r = t.dom(); Ea(r) && (r.style[e] = n + 'px') }; const r = function (n) { const r = t(n); if (r <= 0 || r === null) { const o = Pa(n, e); return parseFloat(o) || 0 } return r }; const o = r; const i = function (e, t) { return K(t, function (t, n) { const r = Pa(e, n); const o = void 0 === r ? 0 : parseInt(r, 10); return isNaN(o) ? t : t + o }, 0) }; const u = function (e, t, n) { const r = i(e, n); const o = t > r ? t - r : 0; return o }; return { set: n, get: r, getOuter: o, aggregate: i, max: u } } const ic = oc('height', function (e) { const t = e.dom(); return Oa(e) ? t.getBoundingClientRect().height : t.offsetHeight }); const uc = function (e) { return ic.get(e) }; const ac = function (e) { return ic.getOuter(e) }; const cc = function (e, t) { const n = ['margin-top', 'border-top-width', 'padding-top', 'padding-bottom', 'border-bottom-width', 'margin-bottom']; const r = ic.max(e, t, n); Ra(e, 'max-height', r + 'px') }; var sc = function (e, t) { const n = function (n, r) { return sc(e + n, t + r) }; return { left: i(e), top: i(t), translate: n } }; const lc = sc; const fc = function (e) { const t = e.getBoundingClientRect(); return lc(t.left, t.top) }; const dc = function (e, t) { return void 0 !== e ? e : void 0 !== t ? t : 0 }; const mc = function (e) { const t = e.dom().ownerDocument; const n = t.body; const r = t.defaultView; const o = t.documentElement; if (n === e.dom()) { return lc(n.offsetLeft, n.offsetTop) } const i = dc(r.pageYOffset, o.scrollTop); const u = dc(r.pageXOffset, o.scrollLeft); const a = dc(o.clientTop, n.clientTop); const c = dc(o.clientLeft, n.clientLeft); return gc(e).translate(u - c, i - a) }; var gc = function (e) { const t = e.dom(); const n = t.ownerDocument; const r = n.body; return r === t ? lc(r.offsetLeft, r.offsetTop) : Oa(e) ? fc(t) : lc(0, 0) }; const hc = oc('width', function (e) { return e.dom().offsetWidth }); const pc = function (e, t) { hc.set(e, t) }; const vc = function (e) { return hc.get(e) }; const bc = function (e) { return hc.getOuter(e) }; const yc = function (e, t) { const n = ['margin-left', 'border-left-width', 'padding-left', 'padding-right', 'border-right-width', 'margin-right']; const r = hc.max(e, t, n); Ra(e, 'max-width', r + 'px') }; const wc = function (e, t, n, r, o, u, a) { return { target: i(e), x: i(t), y: i(n), stop: r, prevent: o, kill: u, raw: i(a) } }; const xc = function (e) { const t = Wn.fromDom(e.target); const n = function () { e.stopPropagation() }; const r = function () { e.preventDefault() }; const i = o(r, n); return wc(t, e.clientX, e.clientY, n, r, i, e) }; const Cc = function (e, t) { return function (n) { e(n) && t(xc(n)) } }; const Sc = function (e, t, n, r, o) { const i = Cc(n, r); return e.dom().addEventListener(t, i, o), { unbind: a(Ec, e, t, i, o) } }; const kc = function (e, t, n, r) { return Sc(e, t, n, r, !1) }; const Tc = function (e, t, n, r) { return Sc(e, t, n, r, !0) }; var Ec = function (e, t, n, r) { e.dom().removeEventListener(t, n, r) }; const Oc = (Vr().browser.isSafari(), function (e) { const n = void 0 !== e ? e.dom() : t.document; const r = n.body.scrollLeft || n.documentElement.scrollLeft; const o = n.body.scrollTop || n.documentElement.scrollTop; return lc(r, o) }); const Nc = function (e, n, r) { const o = void 0 !== r ? r.dom() : t.document; const i = o.defaultView; i.scrollTo(e, n) }; const _c = function (e) { const n = void 0 === e ? t.window : e; return x.from(n.visualViewport) }; const Dc = function (e, t, n, r) { return { x: i(e), y: i(t), width: i(n), height: i(r), right: i(e + n), bottom: i(t + r) } }; const Ac = function (e) { const n = void 0 === e ? t.window : e; const r = n.document; const o = Oc(Wn.fromDom(r)); return _c(n).fold(function () { const e = n.document.documentElement; const t = e.clientWidth; const r = e.clientHeight; return Dc(o.left(), o.top(), t, r) }, function (e) { return Dc(Math.max(e.pageLeft, o.left()), Math.max(e.pageTop, o.top()), e.width, e.height) }) }; var Rc = function (e, t) { const n = e.view(t); return n.fold(i([]), function (t) { const n = e.owner(t); const r = Rc(e, n); return [t].concat(r) }) }; const Bc = function (e, t) { const n = t.owner(e); const r = Rc(t, n); return x.some(r) }; const Mc = function (e) { const n = e.dom() === t.document ? x.none() : x.from(e.dom().defaultView.frameElement); return n.map(Wn.fromDom) }; const Pc = function (e) { return Ri(e) }; const zc = Object.freeze({ __proto__: null, view: Mc, owner: Pc }); const Ic = function (e) { const n = Wn.fromDom(t.document); const r = Oc(n); const o = Bc(e, zc); return o.fold(a(mc, e), function (t) { const n = gc(e); const o = Y(t, function (e, t) { const n = gc(t); return { left: e.left + n.left(), top: e.top + n.top() } }, { left: 0, top: 0 }); return lc(o.left + n.left() + r.left(), o.top + n.top() + r.top()) }) }; const Lc = Ti('point', 'width', 'height'); const Hc = Ti('x', 'y', 'width', 'height'); const Fc = function (e, t, n, r) { return { x: i(e), y: i(t), width: i(n), height: i(r), right: i(e + n), bottom: i(t + r) } }; const Vc = function (e) { const t = mc(e); const n = bc(e); const r = ac(e); return Fc(t.left(), t.top(), n, r) }; const Uc = function (e) { const t = Ic(e); const n = bc(e); const r = ac(e); return Fc(t.left(), t.top(), n, r) }; const jc = function () { return Ac(t.window) }; function Wc (e, t, n, r, o) { return e(n, r) ? x.some(n) : R(o) && o(n) ? x.none() : t(n, r, o) } let qc; const $c = function (e, t, n) { let r = e.dom(); const o = R(n) ? n : i(!1); while (r.parentNode) { r = r.parentNode; const u = Wn.fromDom(r); if (t(u)) { return x.some(u) } if (o(u)) { break } } return x.none() }; const Gc = function (e, t, n) { const r = function (e, t) { return t(e) }; return Wc(r, $c, e, t, n) }; const Xc = function (e, t) { var n = function (e) { for (let r = 0; r < e.childNodes.length; r++) { const o = Wn.fromDom(e.childNodes[r]); if (t(o)) { return x.some(o) } const i = n(e.childNodes[r]); if (i.isSome()) { return i } } return x.none() }; return n(e.dom()) }; const Yc = function (e, t, n) { return Gc(e, t, n).isSome() }; const Kc = function (e, t, n) { return $c(e, function (e) { return Gr(e, t) }, n) }; const Jc = function (e, t) { return Kr(t, e) }; const Zc = function (e, t, n) { return Wc(Gr, Kc, e, t, n) }; const Qc = function (e) { const t = Gc(e, function (e) { if (!ou(e)) { return !1 } const t = su(e, 'id'); return void 0 !== t && t.includes('aria-owns') }); return t.bind(function (e) { const t = su(e, 'id'); const n = Ri(e); return Jc(n, '[aria-owns="' + t + '"]') }) }; const es = function () { const e = xu('aria-owns'); const t = function (t) { au(t, 'aria-owns', e) }; const n = function (e) { du(e, 'aria-owns') }; return { id: i(e), link: t, unlink: n } }; const ts = function (e, t) { return Qc(t).exists(function (t) { return ns(e, t) }) }; var ns = function (e, t) { return Yc(t, function (t) { return Jr(t, e.element()) }, i(!1)) || ts(e, t) }; const rs = 'unknown'; (function (e) { e[e.STOP = 0] = 'STOP', e[e.NORMAL = 1] = 'NORMAL', e[e.LOGGING = 2] = 'LOGGING' })(qc || (qc = {})); let os; const is = Ln({}); const us = function (e, n) { const r = []; const o = (new Date()).getTime(); return { logEventCut (e, t, n) { r.push({ outcome: 'cut', target: t, purpose: n }) }, logEventStopped (e, t, n) { r.push({ outcome: 'stopped', target: t, purpose: n }) }, logNoParent (e, t, n) { r.push({ outcome: 'no-parent', target: t, purpose: n }) }, logEventNoHandlers (e, t) { r.push({ outcome: 'no-handlers-left', target: t }) }, logEventResponse (e, t, n) { r.push({ outcome: 'response', purpose: n, target: t }) }, write () { const i = (new Date()).getTime(); F(['mousemove', 'mouseover', 'mouseout', Fo()], e) || t.console.log(e, { event: e, time: i - o, target: n.dom(), sequence: W(r, function (e) { return F(['cut', 'stopped', 'response'], e.outcome) ? '{' + e.purpose + '} ' + e.outcome + ' at (' + pu(e.target) + ')' : e.outcome }) }) } } }; const as = function (e, t, n) { const r = ye(is.get(), e).orThunk(function () { const t = fe(is.get()); return le(t, function (t) { return e.includes(t) ? x.some(is.get()[t]) : x.none() }) }).getOr(qc.NORMAL); switch (r) { case qc.NORMAL:return n(ds()); case qc.LOGGING:var o = us(e, t); var i = n(o); return o.write(), i; case qc.STOP:return !0 } }; const cs = ['alloy/data/Fields', 'alloy/debugging/Debugging']; const ss = function () { const e = new Error(); if (void 0 !== e.stack) { const t = e.stack.split('\n'); return J(t, function (e) { return e.indexOf('alloy') > 0 && !V(cs, function (t) { return e.includes(t) }) }).getOr(rs) } return rs }; const ls = { logEventCut: n, logEventStopped: n, logNoParent: n, logEventNoHandlers: n, logEventResponse: n, write: n }; const fs = function (e, t, n) { return as(e, t, n) }; var ds = i(ls); const ms = i([cn('menu'), cn('selectedMenu')]); const gs = i([cn('item'), cn('selectedItem')]); const hs = (i(_t(gs().concat(ms()))), i(_t(gs()))); const ps = pn('initSize', [cn('numColumns'), cn('numRows')]); const vs = function () { return sn('markers', hs()) }; const bs = function () { return pn('markers', [cn('backgroundMenu')].concat(ms()).concat(gs())) }; const ys = function (e) { return pn('markers', W(e, cn)) }; const ws = function (e, t, n) { ss(); return zt(t, t, n, jt(function (e) { return T.value(function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } return e.apply(void 0, t) }) })) }; const xs = function (e) { return ws('onHandler', e, je(n)) }; const Cs = function (e) { return ws('onKeyboardHandler', e, je(x.none)) }; const Ss = function (e) { return ws('onHandler', e, qe()) }; const ks = function (e) { return ws('onKeyboardHandler', e, qe()) }; const Ts = function (e, t) { return In(e, i(t)) }; const Es = function (e) { return In(e, u) }; const Os = i(ps); const Ns = Ti('x', 'y', 'bubble', 'direction', 'boundsRestriction', 'label'); const _s = Se.generate([{ southeast: [] }, { southwest: [] }, { northeast: [] }, { northwest: [] }, { south: [] }, { north: [] }, { east: [] }, { west: [] }]); const Ds = function (e, t, n, r, o, i, u, a, c) { return e.fold(t, n, r, o, i, u, a, c) }; const As = function (e, t, n, r) { return e.fold(t, t, r, r, t, r, n, n) }; const Rs = function (e, t, n, r) { return e.fold(t, r, t, r, n, n, t, r) }; const Bs = _s.southeast; const Ms = _s.southwest; const Ps = _s.northeast; const zs = _s.northwest; const Is = _s.south; const Ls = _s.north; const Hs = _s.east; const Fs = _s.west; const Vs = function (e, t) { switch (t) { case 1:return e.x(); case 0:return e.x() + e.width(); case 2:return e.y(); case 3:return e.y() + e.height() } }; const Us = function (e, t) { return oe(['left', 'right', 'top', 'bottom'], function (n) { return ye(t, n).map(function (t) { return Vs(e, t) }) }) }; const js = function (e, t, n) { const r = function (e, r) { const o = e === 'top' || e === 'bottom' ? n.top() : n.left(); return ye(t, e).bind(u).bind(function (t) { return e === 'left' || e === 'top' ? t >= r ? x.some(t) : x.none() : t <= r ? x.some(t) : x.none() }).map(function (e) { return e + o }).getOr(r) }; const o = r('left', e.x()); const i = r('top', e.y()); const a = r('right', e.right()); const c = r('bottom', e.bottom()); return Fc(o, i, a - o, c - i) }; const Ws = function (e) { return e.x() }; const qs = function (e, t) { return e.x() + e.width() / 2 - t.width() / 2 }; const $s = function (e, t) { return e.x() + e.width() - t.width() }; const Gs = function (e, t) { return e.y() - t.height() }; const Xs = function (e) { return e.y() + e.height() }; const Ys = function (e, t) { return e.y() + e.height() / 2 - t.height() / 2 }; const Ks = function (e) { return e.x() + e.width() }; const Js = function (e, t) { return e.x() - t.width() }; const Zs = function (e, t, n) { return Ns(Ws(e), Xs(e), n.southeast(), Bs(), Us(e, { left: 1, top: 3 }), 'layout-se') }; const Qs = function (e, t, n) { return Ns($s(e, t), Xs(e), n.southwest(), Ms(), Us(e, { right: 0, top: 3 }), 'layout-sw') }; const el = function (e, t, n) { return Ns(Ws(e), Gs(e, t), n.northeast(), Ps(), Us(e, { left: 1, bottom: 2 }), 'layout-ne') }; const tl = function (e, t, n) { return Ns($s(e, t), Gs(e, t), n.northwest(), zs(), Us(e, { right: 0, bottom: 2 }), 'layout-nw') }; const nl = function (e, t, n) { return Ns(qs(e, t), Gs(e, t), n.north(), Ls(), Us(e, { bottom: 2 }), 'layout-n') }; const rl = function (e, t, n) { return Ns(qs(e, t), Xs(e), n.south(), Is(), Us(e, { top: 3 }), 'layout-s') }; const ol = function (e, t, n) { return Ns(Ks(e), Ys(e, t), n.east(), Hs(), Us(e, { left: 0 }), 'layout-e') }; const il = function (e, t, n) { return Ns(Js(e, t), Ys(e, t), n.west(), Fs(), Us(e, { right: 1 }), 'layout-w') }; const ul = function () { return [Zs, Qs, el, tl, rl, nl, ol, il] }; const al = function () { return [Qs, Zs, tl, el, rl, nl, ol, il] }; const cl = function () { return [el, tl, Zs, Qs, nl, rl] }; const sl = function () { return [tl, el, Qs, Zs, nl, rl] }; const ll = function () { return [Zs, Qs, el, tl, rl, nl] }; const fl = function () { return [Qs, Zs, tl, el, rl, nl] }; const dl = function (e, t, n) { return ki(function (r) { n(r, e, t) }) }; const ml = function (e, t, n) { return Si(function (r, o) { n(r, e, t) }) }; const gl = function (e, t, n, r, o, i) { const u = Nt(e); const a = Tn(t, [En('config', e)]); return bl(u, a, t, n, r, o, i) }; const hl = function (e, t, n, r, o, i) { const u = e; const a = Tn(t, [wn('config', e)]); return bl(u, a, t, n, r, o, i) }; const pl = function (e, t, n) { const r = function (r) { for (var o = [], u = 1; u < arguments.length; u++) { o[u - 1] = arguments[u] } const a = [r].concat(o); return r.config({ name: i(e) }).fold(function () { throw new Error('We could not find any behaviour configuration for: ' + e + '. Using API: ' + n) }, function (e) { const n = Array.prototype.slice.call(a, 1); return t.apply(void 0, [r, e.config, e.state].concat(n)) }) }; return Bu(r, n, t) }; const vl = function (e) { return { key: e, value: void 0 } }; var bl = function (e, t, n, r, o, i, u) { const c = function (e) { return xe(e, n) ? e[n]() : x.none() }; const s = ge(o, function (e, t) { return pl(n, e, t) }); const l = ge(i, function (e, t) { return Pu(e, t) }); var f = m(m(m({}, l), s), { revoke: a(vl, n), config (t) { const r = Xt(n + '-config', e, t); return { key: n, value: { config: r, me: f, configAsRaw: De(function () { return Xt(n + '-config', e, t) }), initialConfig: t, state: u } } }, schema () { return t }, exhibit (e, t) { return c(e).bind(function (e) { return ye(r, 'exhibit').map(function (n) { return n(t, e.config, e.state) }) }).getOr(Gu({})) }, name () { return n }, handlers (e) { return c(e).map(function (e) { const t = ye(r, 'events').getOr(function () { return {} }); return t(e.config, e.state) }).getOr({}) } }); return f }; const yl = function (e) { return tt(e) }; const wl = Nt([cn('fields'), cn('name'), On('active', {}), On('apis', {}), On('state', Vu), On('extra', {})]); const xl = function (e) { const t = Xt('Creating behaviour: ' + e.name, wl, e); return gl(t.fields, t.name, t.active, t.apis, t.extra, t.state) }; const Cl = Nt([cn('branchKey'), cn('branches'), cn('name'), On('active', {}), On('apis', {}), On('state', Vu), On('extra', {})]); const Sl = function (e) { const t = Xt('Creating behaviour: ' + e.name, Cl, e); return hl(Jt(t.branchKey, t.branches), t.name, t.active, t.apis, t.extra, t.state) }; const kl = i(void 0); const Tl = function (e, t) { return t.universal() ? e : X(e, function (e) { return F(t.channels(), e) }) }; const El = function (e) { return ai([fi(Bo(), function (t, n) { const r = e.channels; const o = fe(r); const i = n; const u = Tl(o, i); q(u, function (e) { const n = r[e]; const o = n.schema; const u = Xt('channel[' + e + '] data\nReceiver: ' + pu(t.element()), o, i.data()); n.onReceive(t, u) }) })]) }; const Ol = Object.freeze({ __proto__: null, events: El }); const Nl = [sn('channels', Wt(T.value, Nt([Ss('onReceive'), On('schema', Zt())])))]; const _l = xl({ fields: Nl, name: 'receiving', active: Ol }); const Dl = function (e, t) { return Gu({ classes: [], styles: t.useFixed() ? {} : { position: 'relative' } }) }; const Al = Object.freeze({ __proto__: null, exhibit: Dl }); const Rl = function (e) { e.dom().focus() }; const Bl = function (e) { e.dom().blur() }; const Ml = function (e) { const t = Ri(e).dom(); return e.dom() === t.activeElement }; const Pl = function (e) { const n = void 0 !== e ? e.dom() : t.document; return x.from(n.activeElement).map(Wn.fromDom) }; const zl = function (e) { return Pl(Ri(e)).filter(function (t) { return e.dom().contains(t.dom()) }) }; const Il = function (e, t) { const r = Ri(t); const o = Pl(r).bind(function (e) { const n = function (t) { return Jr(e, t) }; return n(t) ? x.some(t) : Xc(t, n) }); const i = e(t); return o.each(function (e) { Pl(r).filter(function (t) { return Jr(t, e) }).fold(function () { Rl(e) }, n) }), i }; const Ll = Ti('position', 'left', 'top', 'right', 'bottom'); const Hl = function (e, t) { const n = function (e) { return e + 'px' }; Ma(e, { position: x.some(t.position()), left: t.left().map(n), top: t.top().map(n), right: t.right().map(n), bottom: t.bottom().map(n) }) }; const Fl = Se.generate([{ none: [] }, { relative: ['x', 'y', 'width', 'height'] }, { fixed: ['x', 'y', 'width', 'height'] }]); const Vl = function (e, t, n, r, o, i) { const u = t.x() - n; const a = t.y() - r; const c = t.width(); const s = t.height(); const l = o - (u + c); const f = i - (a + s); const d = x.some(u); const m = x.some(a); const g = x.some(l); const h = x.some(f); const p = x.none(); return Ds(t.direction(), function () { return Ll(e, d, m, p, p) }, function () { return Ll(e, p, m, g, p) }, function () { return Ll(e, d, p, p, h) }, function () { return Ll(e, p, p, g, h) }, function () { return Ll(e, d, m, p, p) }, function () { return Ll(e, d, p, p, h) }, function () { return Ll(e, d, m, p, p) }, function () { return Ll(e, p, m, g, p) }) }; const Ul = function (e, t) { return e.fold(function () { return Ll('absolute', x.some(t.x()), x.some(t.y()), x.none(), x.none()) }, function (e, n, r, o) { return Vl('absolute', t, e, n, r, o) }, function (e, n, r, o) { return Vl('fixed', t, e, n, r, o) }) }; const jl = function (e, t) { const n = a(Ic, t); const r = e.fold(n, n, function () { const e = Oc(); return Ic(t).translate(-e.left(), -e.top()) }); const o = bc(t); const i = ac(t); return Fc(r.left(), r.top(), o, i) }; const Wl = function (e, t) { return t.fold(function () { return e.fold(jc, jc, Fc) }, function (t) { return e.fold(t, t, function () { const n = t(); const r = ql(e, n.x(), n.y()); return Fc(r.left(), r.top(), n.width(), n.height()) }) }) }; var ql = function (e, t, n) { const r = lc(t, n); const o = function () { const e = Oc(); return r.translate(-e.left(), -e.top()) }; return e.fold(i(r), i(r), o) }; const $l = function (e, t, n, r) { return e.fold(t, n, r) }; const Gl = (Fl.none, Fl.relative); const Xl = Fl.fixed; const Yl = Ti('anchorBox', 'origin'); const Kl = function (e, t) { return Yl(e, t) }; const Jl = function (e, t, n, r) { const o = e + t; return o > r ? n : o < n ? r : o }; const Zl = function (e, t, n) { return Math.min(Math.max(e, t), n) }; const Ql = Ai(['x', 'y', 'width', 'height', 'maxHeight', 'maxWidth', 'direction', 'classes', 'label', 'candidateYforTest'], []); const ef = Se.generate([{ fit: ['reposition'] }, { nofit: ['reposition', 'deltaW', 'deltaH'] }]); const tf = function (e, t, n, r, o) { const i = o.x(); const u = o.y(); const a = o.width(); const c = o.height(); const s = e >= i; const l = t >= u; const f = s && l; const d = e + n <= i + a; const m = t + r <= u + c; const g = d && m; const h = Math.abs(Math.min(n, s ? i + a - e : i - (e + n))); const p = Math.abs(Math.min(r, l ? u + c - t : u - (t + r))); const v = Math.max(o.x(), o.right() - n); const b = Math.max(o.y(), o.bottom() - r); const y = Zl(e, o.x(), v); const w = Zl(t, o.y(), b); return { originInBounds: f, sizeInBounds: g, limitX: y, limitY: w, deltaW: h, deltaH: p } }; const nf = function (e, t, n, r) { const o = e.x(); const u = e.y(); const a = e.bubble().offset(); const c = a.left(); const s = a.top(); const l = js(r, e.boundsRestriction(), a); const f = l.y(); const d = l.bottom(); const m = l.x(); const g = l.right(); const h = o + c; const p = u + s; const v = tf(h, p, t, n, l); const b = v.originInBounds; const y = v.sizeInBounds; const w = v.limitX; const x = v.limitY; const C = v.deltaW; const S = v.deltaH; const k = i(x + S - f); const T = i(d - x); const E = As(e.direction(), T, T, k); const O = i(w + C - m); const N = i(g - w); const _ = Rs(e.direction(), N, N, O); const D = Ql({ x: w, y: x, width: C, height: S, maxHeight: E, maxWidth: _, direction: e.direction(), classes: { on: e.bubble().classesOn(), off: e.bubble().classesOff() }, label: e.label(), candidateYforTest: p }); return b && y ? ef.fit(D) : ef.nofit(D, C, S) }; const rf = function (e, t, n, r, o) { const i = n.width(); const c = n.height(); const s = function (e, u, a, s) { const l = e(t, n, r); const f = nf(l, i, c, o); return f.fold(ef.fit, function (e, t, n) { const r = n > s || t > a; return r ? ef.nofit(e, t, n) : ef.nofit(u, a, s) }) }; const l = K(e, function (e, t) { const n = a(s, t); return e.fold(ef.fit, n) }, ef.nofit(Ql({ x: t.x(), y: t.y(), width: n.width(), height: n.height(), maxHeight: n.height(), maxWidth: n.width(), direction: Bs(), classes: { on: [], off: [] }, label: 'none', candidateYforTest: t.y() }), -1, -1)); return l.fold(u, u) }; const of = function (e) { return { width: i(bc(e)), height: i(ac(e)) } }; const uf = function (e, t, n, r) { Fa(t, 'max-height'), Fa(t, 'max-width'); const o = of(t); return rf(r.preference(), e, o, n, r.bounds()) }; const af = function (e, t) { const n = t.classes(); Ta(e, n.off), ka(e, n.on) }; const cf = function (e, t, n) { const r = n.maxHeightFunction(); r(e, t.maxHeight()) }; const sf = function (e, t, n) { const r = n.maxWidthFunction(); r(e, t.maxWidth()) }; const lf = function (e, t, n) { Hl(e, Ul(n.origin(), t)) }; const ff = function (e, t) { cc(e, Math.floor(t)) }; const df = i(function (e, t) { ff(e, t), Ba(e, { 'overflow-x': 'hidden', 'overflow-y': 'auto' }) }); const mf = i(function (e, t) { ff(e, t) }); const gf = Ai(['bounds', 'origin', 'preference', 'maxHeightFunction', 'maxWidthFunction'], []); const hf = function (e, t, n) { return void 0 === e[t] ? n : e[t] }; const pf = function (e, t, r, o, i, u) { const a = hf(u, 'maxHeightFunction', df()); const c = hf(u, 'maxWidthFunction', n); const s = e.anchorBox(); const l = e.origin(); const f = gf({ bounds: Wl(l, i), origin: l, preference: o, maxHeightFunction: a, maxWidthFunction: c }); vf(s, t, r, f) }; var vf = function (e, t, n, r) { const o = uf(e, t, n, r); lf(t, o, r), af(t, o), cf(t, o, r), sf(t, o, r) }; const bf = ['valignCentre', 'alignLeft', 'alignRight', 'alignCentre', 'top', 'bottom', 'left', 'right']; const yf = function (e, t, n) { const r = function (e) { return ye(n, e).getOr([]) }; const o = function (e, t, n) { const o = re(bf, n); return { offset () { return lc(e, t) }, classesOn () { return ee(n, r) }, classesOff () { return ee(o, r) } } }; return { southeast () { return o(-e, t, ['top', 'alignLeft']) }, southwest () { return o(e, t, ['top', 'alignRight']) }, south () { return o(-e / 2, t, ['top', 'alignCentre']) }, northeast () { return o(-e, -t, ['bottom', 'alignLeft']) }, northwest () { return o(e, -t, ['bottom', 'alignRight']) }, north () { return o(-e / 2, -t, ['bottom', 'alignCentre']) }, east () { return o(e, -t / 2, ['valignCentre', 'left']) }, west () { return o(-e, -t / 2, ['valignCentre', 'right']) }, innerNorthwest () { return o(-e, t, ['top', 'alignRight']) }, innerNortheast () { return o(e, t, ['top', 'alignLeft']) }, innerNorth () { return o(-e / 2, t, ['top', 'alignCentre']) }, innerSouthwest () { return o(-e, -t, ['bottom', 'alignRight']) }, innerSoutheast () { return o(e, -t, ['bottom', 'alignLeft']) }, innerSouth () { return o(-e / 2, -t, ['bottom', 'alignCentre']) }, innerWest () { return o(e, -t / 2, ['valignCentre', 'right']) }, innerEast () { return o(-e, -t / 2, ['valignCentre', 'left']) } } }; const wf = function () { return yf(0, 0, {}) }; const xf = function (e) { return e }; const Cf = function (e, t) { return function (n) { return Sf(n) === 'rtl' ? t : e } }; var Sf = function (e) { return Pa(e, 'direction') === 'rtl' ? 'rtl' : 'ltr' }; (function (e) { e.TopToBottom = 'toptobottom', e.BottomToTop = 'bottomtotop' })(os || (os = {})); const kf = 'data-alloy-vertical-dir'; const Tf = function (e) { return Yc(e, function (e) { return ou(e) && su(e, kf) === os.BottomToTop }) }; const Ef = function () { return Tn('layouts', [cn('onLtr'), cn('onRtl'), yn('onBottomLtr'), yn('onBottomRtl')]) }; const Of = function (e, t, n, r, o, i, u) { const a = u.map(Tf).getOr(!1); const c = t.layouts.map(function (t) { return t.onLtr(e) }); const s = t.layouts.map(function (t) { return t.onRtl(e) }); const l = a ? t.layouts.bind(function (t) { return t.onBottomLtr.map(function (t) { return t(e) }) }).or(c).getOr(o) : c.getOr(n); const f = a ? t.layouts.bind(function (t) { return t.onBottomRtl.map(function (t) { return t(e) }) }).or(s).getOr(i) : s.getOr(r); const d = Cf(l, f); return d(e) }; const Nf = function (e, t, n) { const r = t.hotspot; const o = jl(n, r.element()); const i = Of(e.element(), t, ll(), fl(), cl(), sl(), x.some(t.hotspot.element())); return x.some(xf({ anchorBox: o, bubble: t.bubble.getOr(wf()), overrides: t.overrides, layouts: i, placer: x.none() })) }; const _f = [cn('hotspot'), yn('bubble'), On('overrides', {}), Ef(), Ts('placement', Nf)]; const Df = function (e, t, n) { const r = ql(n, t.x, t.y); const o = Fc(r.left(), r.top(), t.width, t.height); const i = Of(e.element(), t, ul(), al(), ul(), al(), x.none()); return x.some(xf({ anchorBox: o, bubble: t.bubble, overrides: t.overrides, layouts: i, placer: x.none() })) }; const Af = [cn('x'), cn('y'), On('height', 0), On('width', 0), On('bubble', wf()), On('overrides', {}), Ef(), Ts('placement', Df)]; const Rf = '\uFEFF'; const Bf = ' '; const Mf = Ti('start', 'soffset', 'finish', 'foffset'); const Pf = { create: Mf }; const zf = Se.generate([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]); const If = function (e, t, n, r) { return e.fold(t, n, r) }; const Lf = function (e) { return e.fold(u, u, u) }; const Hf = zf.before; const Ff = zf.on; const Vf = zf.after; const Uf = { before: Hf, on: Ff, after: Vf, cata: If, getStart: Lf }; const jf = Se.generate([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }]); const Wf = function (e) { return jf.exact(e.start(), e.soffset(), e.finish(), e.foffset()) }; const qf = function (e) { return e.match({ domRange (e) { return Wn.fromDom(e.startContainer) }, relative (e, t) { return Uf.getStart(e) }, exact (e, t, n, r) { return e } }) }; const $f = jf.domRange; const Gf = jf.relative; const Xf = jf.exact; const Yf = function (e) { const t = qf(e); return Mi(t) }; const Kf = Pf.create; const Jf = { domRange: $f, relative: Gf, exact: Xf, exactFromRange: Wf, getWin: Yf, range: Kf }; const Zf = function (e, t) { t.fold(function (t) { e.setStartBefore(t.dom()) }, function (t, n) { e.setStart(t.dom(), n) }, function (t) { e.setStartAfter(t.dom()) }) }; const Qf = function (e, t) { t.fold(function (t) { e.setEndBefore(t.dom()) }, function (t, n) { e.setEnd(t.dom(), n) }, function (t) { e.setEndAfter(t.dom()) }) }; const ed = function (e, t, n) { const r = e.document.createRange(); return Zf(r, t), Qf(r, n), r }; const td = function (e, t, n, r, o) { const i = e.document.createRange(); return i.setStart(t.dom(), n), i.setEnd(r.dom(), o), i }; const nd = function (e) { return { left: i(e.left), top: i(e.top), right: i(e.right), bottom: i(e.bottom), width: i(e.width), height: i(e.height) } }; const rd = function (e) { const t = e.getClientRects(); const n = t.length > 0 ? t[0] : e.getBoundingClientRect(); return n.width > 0 || n.height > 0 ? x.some(n).map(nd) : x.none() }; const od = Se.generate([{ ltr: ['start', 'soffset', 'finish', 'foffset'] }, { rtl: ['start', 'soffset', 'finish', 'foffset'] }]); const id = function (e, t, n) { return t(Wn.fromDom(n.startContainer), n.startOffset, Wn.fromDom(n.endContainer), n.endOffset) }; const ud = function (e, t) { return t.match({ domRange (e) { return { ltr: i(e), rtl: x.none } }, relative (t, n) { return { ltr: De(function () { return ed(e, t, n) }), rtl: De(function () { return x.some(ed(e, n, t)) }) } }, exact (t, n, r, o) { return { ltr: De(function () { return td(e, t, n, r, o) }), rtl: De(function () { return x.some(td(e, r, o, t, n)) }) } } }) }; const ad = function (e, t) { const n = t.ltr(); if (n.collapsed) { const r = t.rtl().filter(function (e) { return !1 === e.collapsed }); return r.map(function (e) { return od.rtl(Wn.fromDom(e.endContainer), e.endOffset, Wn.fromDom(e.startContainer), e.startOffset) }).getOrThunk(function () { return id(e, od.ltr, n) }) } return id(e, od.ltr, n) }; const cd = function (e, t) { const n = ud(e, t); return ad(e, n) }; const sd = function (e, t) { const n = cd(e, t); return n.match({ ltr (t, n, r, o) { const i = e.document.createRange(); return i.setStart(t.dom(), n), i.setEnd(r.dom(), o), i }, rtl (t, n, r, o) { const i = e.document.createRange(); return i.setStart(r.dom(), o), i.setEnd(t.dom(), n), i } }) }; od.ltr, od.rtl; function ld (e, t) { const n = function (n) { if (!e(n)) { throw new Error('Can only get ' + t + ' value of a ' + t + ' node') } return r(n).getOr('') }; var r = function (t) { return e(t) ? x.from(t.dom().nodeValue) : x.none() }; const o = function (n, r) { if (!e(n)) { throw new Error('Can only set raw ' + t + ' value of a ' + t + ' node') } n.dom().nodeValue = r }; return { get: n, getOption: r, set: o } } const fd = ld(iu, 'text'); const dd = function (e) { return fd.get(e) }; const md = function (e) { return fd.getOption(e) }; const gd = function (e) { return tu(e) === 'img' ? 1 : md(e).fold(function () { return Li(e).length }, function (e) { return e.length }) }; const hd = function (e) { return md(e).filter(function (e) { return e.trim().length !== 0 || e.includes(Bf) }).isSome() }; const pd = ['img', 'br']; const vd = function (e) { const t = hd(e); return t || F(pd, tu(e)) }; const bd = function (e) { return yd(e, vd) }; var yd = function (e, t) { var n = function (e) { for (let r = Li(e), o = r.length - 1; o >= 0; o--) { const i = r[o]; if (t(i)) { return x.some(i) } const u = n(i); if (u.isSome()) { return u } } return x.none() }; return n(e) }; const wd = function (e, t) { return Yr(t, e) }; const xd = function (e, t, n, r) { const o = Ri(e); const i = o.dom().createRange(); return i.setStart(e.dom(), t), i.setEnd(n.dom(), r), i }; const Cd = function (e, t, n, r) { const o = xd(e, t, n, r); const i = Jr(e, n) && t === r; return o.collapsed && !i }; const Sd = function (e) { if (e.rangeCount > 0) { const t = e.getRangeAt(0); const n = e.getRangeAt(e.rangeCount - 1); return x.some(Pf.create(Wn.fromDom(t.startContainer), t.startOffset, Wn.fromDom(n.endContainer), n.endOffset)) } return x.none() }; const kd = function (e) { const t = Wn.fromDom(e.anchorNode); const n = Wn.fromDom(e.focusNode); return Cd(t, e.anchorOffset, n, e.focusOffset) ? x.some(Pf.create(t, e.anchorOffset, n, e.focusOffset)) : Sd(e) }; const Td = function (e) { return x.from(e.getSelection()).filter(function (e) { return e.rangeCount > 0 }).bind(kd) }; const Ed = function (e, t) { const n = sd(e, t); return rd(n) }; const Od = Ti('element', 'offset'); const Nd = function (e, t) { const n = Li(e); if (n.length === 0) { return Od(e, t) } if (t < n.length) { return Od(n[t], 0) } const r = n[n.length - 1]; const o = iu(r) ? dd(r).length : Li(r).length; return Od(r, o) }; const _d = Se.generate([{ screen: ['point'] }, { absolute: ['point', 'scrollLeft', 'scrollTop'] }]); const Dd = function (e) { return e.fold(u, function (e, t, n) { return e.translate(-t, -n) }) }; const Ad = function (e) { return e.fold(u, u) }; const Rd = function (e) { return K(e, function (e, t) { return e.translate(t.left(), t.top()) }, lc(0, 0)) }; const Bd = function (e) { const t = W(e, Dd); return Rd(t) }; const Md = function (e) { const t = W(e, Ad); return Rd(t) }; const Pd = _d.screen; const zd = _d.absolute; const Id = function (e, t, n) { const r = Mi(n.root).dom(); const o = function (t) { const n = Ri(t); const r = Ri(e.element()); return Jr(n, r) }; return x.from(r.frameElement).map(Wn.fromDom).filter(o).map(mc) }; const Ld = function (e, t, n) { const r = Ri(e.element()); const o = Oc(r); const i = Id(e, t, n).getOr(o); return zd(i, o.left(), o.top()) }; const Hd = function (e, t, n, r) { let o = e; let i = t; let u = n; let a = r; e < 0 && (o = 0, u = n + e), t < 0 && (i = 0, a = r + t); const c = Pd(lc(o, i)); return x.some(Lc(c, u, a)) }; const Fd = function (e, t, n, r, o) { return e.map(function (e) { const i = [t, e.point()]; const u = $l(r, function () { return Md(i) }, function () { return Md(i) }, function () { return Bd(i) }); const a = Hc(u.left(), u.top(), e.width(), e.height()); const c = n.showAbove ? cl() : ll(); const s = (n.showAbove, fl()); const l = Of(o, n, c, s, c, s, x.none()); return xf({ anchorBox: a, bubble: n.bubble.getOr(wf()), overrides: n.overrides, layouts: l, placer: x.none() }) }) }; const Vd = { capRect: Hd, calcNewAnchor: Fd }; const Ud = Ti('element', 'offset'); const jd = function (e, t) { return iu(e) ? Ud(e, t) : Nd(e, t) }; const Wd = function (e, t) { const n = t.getSelection.getOrThunk(function () { return function () { return Td(e) } }); return n().map(function (e) { const t = jd(e.start(), e.soffset()); const n = jd(e.finish(), e.foffset()); return Jf.range(t.element(), t.offset(), n.element(), n.offset()) }) }; const qd = function (e, t, n) { const r = Mi(t.root).dom(); const o = Ld(e, n, t); const i = Wd(r, t).bind(function (e) { const t = Ed(r, Jf.exactFromRange(e)).orThunk(function () { const t = Wn.fromText(Rf); return Ui(e.start(), t), Ed(r, Jf.exact(t, 0, t, 1)).map(function (e) { return Ki(t), e }) }); return t.bind(function (e) { return Vd.capRect(e.left(), e.top(), e.width(), e.height()) }) }); const u = Wd(r, t).bind(function (e) { return ou(e.start()) ? x.some(e.start()) : Pi(e.start()) }); const a = u.getOr(e.element()); return Vd.calcNewAnchor(i, o, t, n, a) }; const $d = [yn('getSelection'), cn('root'), yn('bubble'), Ef(), On('overrides', {}), On('showAbove', !1), Ts('placement', qd)]; const Gd = function (e, t, n) { const r = Ld(e, n, t); return t.node.bind(function (o) { const i = o.dom().getBoundingClientRect(); const u = Vd.capRect(i.left, i.top, i.width, i.height); const a = t.node.getOr(e.element()); return Vd.calcNewAnchor(u, r, t, n, a) }) }; const Xd = [cn('node'), cn('root'), yn('bubble'), Ef(), On('overrides', {}), On('showAbove', !1), Ts('placement', Gd)]; const Yd = function (e) { return e.x() + e.width() }; const Kd = function (e, t) { return e.x() - t.width() }; const Jd = function (e, t) { return e.y() - t.height() + e.height() }; const Zd = function (e) { return e.y() }; const Qd = function (e, t, n) { return Ns(Yd(e), Zd(e), n.southeast(), Bs(), Us(e, { left: 0, top: 2 }), 'link-layout-se') }; const em = function (e, t, n) { return Ns(Kd(e, t), Zd(e), n.southwest(), Ms(), Us(e, { right: 1, top: 2 }), 'link-layout-sw') }; const tm = function (e, t, n) { return Ns(Yd(e), Jd(e, t), n.northeast(), Ps(), Us(e, { left: 0, bottom: 3 }), 'link-layout-ne') }; const nm = function (e, t, n) { return Ns(Kd(e, t), Jd(e, t), n.northwest(), zs(), Us(e, { right: 1, bottom: 3 }), 'link-layout-nw') }; const rm = function () { return [Qd, em, tm, nm] }; const om = function () { return [em, Qd, nm, tm] }; const im = function (e, t, n) { const r = jl(n, t.item.element()); const o = Of(e.element(), t, rm(), om(), rm(), om(), x.none()); return x.some(xf({ anchorBox: r, bubble: wf(), overrides: t.overrides, layouts: o, placer: x.none() })) }; const um = [cn('item'), Ef(), On('overrides', {}), Ts('placement', im)]; const am = Jt('anchor', { selection: $d, node: Xd, hotspot: _f, submenu: um, makeshift: Af }); const cm = function () { const e = t.document.documentElement; return Xl(0, 0, e.clientWidth, e.clientHeight) }; const sm = function (e) { const t = mc(e.element()); const n = e.element().dom().getBoundingClientRect(); return Gl(t.left(), t.top(), n.width, n.height) }; const lm = function (e, t, n, r, o) { const i = Kl(n.anchorBox, t); pf(i, o.element(), n.bubble, n.layouts, r, n.overrides) }; const fm = function (e, t, n, r, o) { dm(e, t, n, r, o, x.none()) }; var dm = function (e, t, n, r, o, i) { const u = i.map(Vc); return mm(e, t, n, r, o, u) }; var mm = function (e, t, n, r, o, u) { const a = Xt('positioning anchor.info', am, r); Il(function () { Ra(o.element(), 'position', 'fixed'); const n = Ia(o.element(), 'visibility'); Ra(o.element(), 'visibility', 'hidden'); const r = t.useFixed() ? cm() : sm(e); const c = a.placement; const s = u.map(i).or(t.getBounds); c(e, a, r).each(function (t) { const n = t.placer.getOr(lm); n(e, r, t, s, o) }), n.fold(function () { Fa(o.element(), 'visibility') }, function (e) { Ra(o.element(), 'visibility', e) }), Ia(o.element(), 'left').isNone() && Ia(o.element(), 'top').isNone() && Ia(o.element(), 'right').isNone() && Ia(o.element(), 'bottom').isNone() && Ia(o.element(), 'position').is('fixed') && Fa(o.element(), 'position') }, o.element()) }; const gm = function (e, t, n) { return t.useFixed() ? 'fixed' : 'absolute' }; const hm = Object.freeze({ __proto__: null, position: fm, positionWithin: dm, positionWithinBounds: mm, getMode: gm }); const pm = [On('useFixed', l), yn('getBounds')]; const vm = xl({ fields: pm, name: 'positioning', active: Al, apis: hm }); var bm = function (e) { ti(e, $o()); const t = e.components(); q(t, bm) }; var ym = function (e) { const t = e.components(); q(t, ym), ti(e, qo()) }; const wm = function (e, t) { qi(e.element(), t.element()) }; const xm = function (e) { q(e.components(), function (e) { return Ki(e.element()) }), Yi(e.element()), e.syncComponents() }; const Cm = function (e, t) { const n = e.components(); xm(e); const r = re(n, t); q(r, function (t) { bm(t), e.getSystem().removeFromWorld(t) }), q(t, function (t) { t.getSystem().isConnected() ? wm(e, t) : (e.getSystem().addToWorld(t), wm(e, t), Oa(e.element()) && ym(t)), e.syncComponents() }) }; const Sm = function (e, t) { km(e, t, qi) }; var km = function (e, t, n) { e.getSystem().addToWorld(t), n(e.element(), t.element()), Oa(e.element()) && ym(t), e.syncComponents() }; const Tm = function (e) { bm(e), Ki(e.element()), e.getSystem().removeFromWorld(e) }; const Em = function (e) { const t = Pi(e.element()).bind(function (t) { return e.getSystem().getByDom(t).toOption() }); Tm(e), t.each(function (e) { e.syncComponents() }) }; const Om = function (e) { const t = e.components(); q(t, Tm), Yi(e.element()), e.syncComponents() }; const Nm = function (e, t) { Dm(e, t, qi) }; const _m = function (e, t) { Dm(e, t, ji) }; var Dm = function (e, t, n) { n(e, t.element()); const r = Li(t.element()); q(r, function (e) { t.getByDom(e).each(ym) }) }; const Am = function (e) { const t = Li(e.element()); q(t, function (t) { e.getByDom(t).each(bm) }), Ki(e.element()) }; const Rm = function (e, t, n, r) { n.get().each(function (t) { Om(e) }); const o = t.getAttachPoint(e); Sm(o, e); const i = e.getSystem().build(r); return Sm(e, i), n.set(i), i }; const Bm = function (e, t, n, r) { const o = Rm(e, t, n, r); return t.onOpen(e, o), o }; const Mm = function (e, t, n, r) { return n.get().map(function () { return Rm(e, t, n, r) }) }; const Pm = function (e, t, n, r, o) { Um(e, t), Bm(e, t, n, r), o(), Wm(e, t) }; const zm = function (e, t, n) { n.get().each(function (r) { Om(e), Em(e), t.onClose(e, r), n.clear() }) }; const Im = function (e, t, n) { return n.isOpen() }; const Lm = function (e, t, n, r) { return Im(e, t, n) && n.get().exists(function (n) { return t.isPartOf(e, n, r) }) }; const Hm = function (e, t, n) { return n.get() }; const Fm = function (e, t, n, r) { Ia(e.element(), t).fold(function () { du(e.element(), n) }, function (t) { au(e.element(), n, t) }), Ra(e.element(), t, r) }; const Vm = function (e, t, n) { if (fu(e.element(), n)) { const r = su(e.element(), n); Ra(e.element(), t, r) } else { Fa(e.element(), t) } }; var Um = function (e, t, n) { const r = t.getAttachPoint(e); Ra(e.element(), 'position', vm.getMode(r)), Fm(e, 'visibility', t.cloakVisibilityAttr, 'hidden') }; const jm = function (e) { return V(['top', 'left', 'right', 'bottom'], function (t) { return Ia(e, t).isSome() }) }; var Wm = function (e, t, n) { jm(e.element()) || Fa(e.element(), 'position'), Vm(e, 'visibility', t.cloakVisibilityAttr) }; const qm = Object.freeze({ __proto__: null, cloak: Um, decloak: Wm, open: Bm, openWhileCloaked: Pm, close: zm, isOpen: Im, isPartOf: Lm, getState: Hm, setContent: Mm }); const $m = function (e, t) { return ai([fi(Lo(), function (n, r) { zm(n, e, t) })]) }; const Gm = Object.freeze({ __proto__: null, events: $m }); const Xm = [xs('onOpen'), xs('onClose'), cn('isPartOf'), cn('getAttachPoint'), On('cloakVisibilityAttr', 'data-precloak-visibility')]; const Ym = function () { const e = Ln(x.none()); const t = i('not-implemented'); const n = function () { return e.get().isSome() }; const r = function (t) { e.set(x.some(t)) }; const o = function () { return e.get() }; const u = function () { e.set(x.none()) }; return Uu({ readState: t, isOpen: n, clear: u, set: r, get: o }) }; const Km = Object.freeze({ __proto__: null, init: Ym }); const Jm = xl({ fields: Xm, name: 'sandboxing', active: Gm, apis: qm, state: Km }); const Zm = i('dismiss.popups'); const Qm = i('reposition.popups'); const eg = i('mouse.released'); const tg = Nt([On('isExtraPart', i(!1)), Tn('fireEventInstead', [On('event', Go())])]); const ng = function (e) { let t; const n = Xt('Dismissal', tg, e); return t = {}, t[Zm()] = { schema: Nt([cn('target')]), onReceive (e, t) { if (Jm.isOpen(e)) { const r = Jm.isPartOf(e, t.target) || n.isExtraPart(e, t.target); r || n.fireEventInstead.fold(function () { return Jm.close(e) }, function (t) { return ti(e, t.event) }) } } }, t }; const rg = Nt([Tn('fireEventInstead', [On('event', Xo())]), gn('doReposition')]); const og = function (e) { let t; const n = Xt('Reposition', rg, e); return t = {}, t[Qm()] = { onReceive (e) { Jm.isOpen(e) && n.fireEventInstead.fold(function () { return n.doReposition(e) }, function (t) { return ti(e, t.event) }) } }, t }; const ig = function (e, t, n) { t.store.manager.onLoad(e, t, n) }; const ug = function (e, t, n) { t.store.manager.onUnload(e, t, n) }; const ag = function (e, t, n, r) { t.store.manager.setValue(e, t, n, r) }; const cg = function (e, t, n) { return t.store.manager.getValue(e, t, n) }; const sg = function (e, t, n) { return n }; const lg = Object.freeze({ __proto__: null, onLoad: ig, onUnload: ug, setValue: ag, getValue: cg, getState: sg }); const fg = function (e, t) { const n = e.resetOnDom ? [xi(function (n, r) { ig(n, e, t) }), Ci(function (n, r) { ug(n, e, t) })] : [ml(e, t, ig)]; return ai(n) }; const dg = Object.freeze({ __proto__: null, events: fg }); const mg = function () { const e = Ln(null); const t = function () { return { mode: 'memory', value: e.get() } }; const n = function () { return e.get() === null }; const r = function () { e.set(null) }; return Uu({ set: e.set, get: e.get, isNotSet: n, clear: r, readState: t }) }; const gg = function () { const e = function () {}; return Uu({ readState: e }) }; const hg = function () { const e = Ln({}); const t = Ln({}); const n = function () { return { mode: 'dataset', dataByValue: e.get(), dataByText: t.get() } }; const r = function () { e.set({}), t.set({}) }; const o = function (n) { return ye(e.get(), n).orThunk(function () { return ye(t.get(), n) }) }; const i = function (n) { const r = e.get(); const o = t.get(); const i = {}; const u = {}; q(n, function (e) { i[e.value] = e, ye(e, 'meta').each(function (t) { ye(t, 'text').each(function (t) { u[t] = e }) }) }), e.set(m(m({}, r), i)), t.set(m(m({}, o), u)) }; return Uu({ readState: n, lookup: o, update: i, clear: r }) }; const pg = function (e) { return e.store.manager.state(e) }; const vg = Object.freeze({ __proto__: null, memory: mg, dataset: hg, manual: gg, init: pg }); const bg = function (e, t, n, r) { const o = t.store; n.update([r]), o.setValue(e, r), t.onSetValue(e, r) }; const yg = function (e, t, n) { const r = t.store; const o = r.getDataKey(e); return n.lookup(o).fold(function () { return r.getFallbackEntry(o) }, function (e) { return e }) }; const wg = function (e, t, n) { const r = t.store; r.initialValue.each(function (r) { bg(e, t, n, r) }) }; const xg = function (e, t, n) { n.clear() }; const Cg = [yn('initialValue'), cn('getFallbackEntry'), cn('getDataKey'), cn('setValue'), Ts('manager', { setValue: bg, getValue: yg, onLoad: wg, onUnload: xg, state: hg })]; const Sg = function (e, t, n) { return t.store.getValue(e) }; const kg = function (e, t, n, r) { t.store.setValue(e, r), t.onSetValue(e, r) }; const Tg = function (e, t, n) { t.store.initialValue.each(function (n) { t.store.setValue(e, n) }) }; const Eg = [cn('getValue'), On('setValue', n), yn('initialValue'), Ts('manager', { setValue: kg, getValue: Sg, onLoad: Tg, onUnload: n, state: Vu.init })]; const Og = function (e, t, n, r) { n.set(r), t.onSetValue(e, r) }; const Ng = function (e, t, n) { return n.get() }; const _g = function (e, t, n) { t.store.initialValue.each(function (e) { n.isNotSet() && n.set(e) }) }; const Dg = function (e, t, n) { n.clear() }; const Ag = [yn('initialValue'), Ts('manager', { setValue: Og, getValue: Ng, onLoad: _g, onUnload: Dg, state: mg })]; const Rg = [Nn('store', { mode: 'memory' }, Jt('mode', { memory: Ag, manual: Eg, dataset: Cg })), xs('onSetValue'), On('resetOnDom', !1)]; var Bg = xl({ fields: Rg, name: 'representing', active: dg, apis: lg, extra: { setValueFrom (e, t) { const n = Bg.getValue(t); Bg.setValue(e, n) } }, state: vg }); const Mg = function (e, t) { return zn(e, {}, W(t, function (t) { return hn(t.name(), 'Cannot configure ' + t.name() + ' for ' + e) }).concat([In('dump', u)])) }; const Pg = function (e) { return e.dump }; const zg = function (e, t) { return m(m({}, e.dump), yl(t)) }; const Ig = { field: Mg, augment: zg, get: Pg }; const Lg = 'placeholder'; const Hg = Se.generate([{ single: ['required', 'valueThunk'] }, { multiple: ['required', 'valueThunks'] }]); const Fg = function (e) { return we(e, 'uiType') }; const Vg = function (e, t, n, r) { return e.exists(function (e) { return e !== n.owner }) ? Hg.single(!0, i(n)) : ye(r, n.name).fold(function () { throw new Error('Unknown placeholder component: ' + n.name + '\nKnown: [' + fe(r) + ']\nNamespace: ' + e.getOr('none') + '\nSpec: ' + JSON.stringify(n, null, 2)) }, function (e) { return e.replace() }) }; const Ug = function (e, t, n, r) { return Fg(n) && n.uiType === Lg ? Vg(e, t, n, r) : Hg.single(!1, i(n)) }; var jg = function (e, t, n, r) { const o = Ug(e, t, n, r); return o.fold(function (o, i) { const u = Fg(n) ? i(t, n.config, n.validated) : i(t); const a = ye(u, 'components').getOr([]); const c = ee(a, function (n) { return jg(e, t, n, r) }); return [m(m({}, u), { components: c })] }, function (e, r) { if (Fg(n)) { const o = r(t, n.config, n.validated); const i = n.validated.preprocess.getOr(u); return i(o) } return r(t) }) }; const Wg = function (e, t, n, r) { return ee(n, function (n) { return jg(e, t, n, r) }) }; const qg = function (e, t) { let n = !1; const r = function () { return n }; const o = function () { if (n) { throw new Error('Trying to use the same placeholder more than once: ' + e) } return n = !0, t }; const u = function () { return t.fold(function (e, t) { return e }, function (e, t) { return e }) }; return { name: i(e), required: u, used: r, replace: o } }; const $g = function (e, t, n, r) { const o = ge(r, function (e, t) { return qg(t, e) }); const i = Wg(e, t, n, o); return me(o, function (n) { if (!1 === n.used() && n.required()) { throw new Error('Placeholder: ' + n.name() + ' was not found in components list\nNamespace: ' + e.getOr('none') + '\nComponents: ' + JSON.stringify(t.components, null, 2)) } }), i }; const Gg = Hg.single; const Xg = Hg.multiple; const Yg = i(Lg); const Kg = Se.generate([{ required: ['data'] }, { external: ['data'] }, { optional: ['data'] }, { group: ['data'] }]); const Jg = On('factory', { sketch: u }); const Zg = On('schema', []); const Qg = cn('name'); const eh = zt('pname', 'pname', Ge(function (e) { return '<alloy.' + xu(e.name) + '>' }), Zt()); const th = In('schema', function () { return [yn('preprocess')] }); const nh = On('defaults', i({})); const rh = On('overrides', i({})); const oh = _t([Jg, Zg, Qg, eh, nh, rh]); const ih = _t([Jg, Zg, Qg, nh, rh]); const uh = _t([Jg, Zg, Qg, eh, nh, rh]); const ah = _t([Jg, th, Qg, cn('unit'), eh, nh, rh]); const ch = function (e) { return e.fold(x.some, x.none, x.some, x.some) }; const sh = function (e) { const t = function (e) { return e.name }; return e.fold(t, t, t, t) }; const lh = function (e) { return e.fold(u, u, u, u) }; const fh = function (e, t) { return function (n) { const r = Xt('Converting part type', t, n); return e(r) } }; const dh = fh(Kg.required, oh); const mh = fh(Kg.external, ih); const gh = fh(Kg.optional, uh); const hh = fh(Kg.group, ah); const ph = i('entirety'); const vh = Object.freeze({ __proto__: null, required: dh, external: mh, optional: gh, group: hh, asNamedPart: ch, name: sh, asCommon: lh, original: ph }); const bh = function (e, t, n, r) { return Ne(t.defaults(e, n, r), n, { uid: e.partUids[t.name] }, t.overrides(e, n, r)) }; const yh = function (e, t, n) { const r = {}; const o = {}; return q(n, function (e) { e.fold(function (e) { r[e.pname] = Gg(!0, function (t, n, r) { return e.factory.sketch(bh(t, e, n, r)) }) }, function (e) { const n = t.parts[e.name]; o[e.name] = i(e.factory.sketch(bh(t, e, n[ph()]), n)) }, function (e) { r[e.pname] = Gg(!1, function (t, n, r) { return e.factory.sketch(bh(t, e, n, r)) }) }, function (e) { r[e.pname] = Xg(!0, function (t, n, r) { const o = t[e.name]; return W(o, function (n) { return e.factory.sketch(Ne(e.defaults(t, n, r), n, e.overrides(t, n))) }) }) }) }), { internals: i(r), externals: i(o) } }; const wh = function (e, t) { const n = {}; return q(t, function (t) { ch(t).each(function (t) { const r = xh(e, t.pname); n[t.name] = function (n) { const o = Xt('Part: ' + t.name + ' in ' + e, _t(t.schema), n); return m(m({}, r), { config: n, validated: o }) } }) }), n }; var xh = function (e, t) { return { uiType: Yg(), owner: e, name: t } }; const Ch = function (e, t, n) { return { uiType: Yg(), owner: e, name: t, config: n, validated: {} } }; const Sh = function (e) { return ee(e, function (e) { return e.fold(x.none, x.some, x.none, x.none).map(function (e) { return pn(e.name, e.schema.concat([Es(ph())])) }).toArray() }) }; const kh = function (e) { return W(e, sh) }; const Th = function (e, t, n) { return yh(e, t, n) }; const Eh = function (e, t, n) { return $g(x.some(e), t, t.components, n) }; const Oh = function (e, t, n) { const r = t.partUids[n]; return e.getSystem().getByUid(r).toOption() }; const Nh = function (e, t, n) { return Oh(e, t, n).getOrDie('Could not find part: ' + n) }; const _h = function (e, t, n) { const r = {}; const o = t.partUids; const u = e.getSystem(); return q(n, function (e) { r[e] = i(u.getByUid(o[e])) }), r }; const Dh = function (e, t) { const n = e.getSystem(); return ge(t.partUids, function (e, t) { return i(n.getByUid(e)) }) }; const Ah = function (e) { return fe(e.partUids) }; const Rh = function (e, t, n) { const r = {}; const o = t.partUids; const u = e.getSystem(); return q(n, function (e) { r[e] = i(u.getByUid(o[e]).getOrDie()) }), r }; const Bh = function (e, t) { const n = kh(t); return tt(W(n, function (t) { return { key: t, value: e + '-' + t } })) }; const Mh = function (e) { return zt('partUids', 'partUids', Xe(function (t) { return Bh(t.uid, e) }), Zt()) }; const Ph = Object.freeze({ __proto__: null, generate: wh, generateOne: Ch, schemas: Sh, names: kh, substitutes: Th, components: Eh, defaultUids: Bh, defaultUidsSchema: Mh, getAllParts: Dh, getAllPartNames: Ah, getPart: Oh, getPartOrDie: Nh, getParts: _h, getPartsOrDie: Rh }); const zh = function (e, t) { const n = e.length > 0 ? [pn('parts', e)] : []; return n.concat([cn('uid'), On('dom', {}), On('components', []), Es('originalSpec'), On('debug.sketcher', {})]).concat(t) }; const Ih = function (e, t, n, r, o) { const i = zh(r, o); return Xt(e + ' [SpecSchema]', Nt(i.concat(t)), n) }; const Lh = function (e, t, n, r) { const o = Vh(r); const i = Ih(e, t, o, [], []); return n(i, o) }; const Hh = function (e, t, n, r, o) { const i = Vh(o); const u = Sh(n); const a = Mh(n); const c = Ih(e, t, i, u, [a]); const s = Th(e, c, n); const l = Eh(e, c, s.internals()); return r(c, l, i, s.externals()) }; const Fh = function (e) { return we(e, 'uid') }; var Vh = function (e) { return Fh(e) ? e : m(m({}, e), { uid: _u('uid') }) }; function Uh (e) { return void 0 !== e.uid } let jh; const Wh = Nt([cn('name'), cn('factory'), cn('configFields'), On('apis', {}), On('extraApis', {})]); const qh = Nt([cn('name'), cn('factory'), cn('configFields'), cn('partFields'), On('apis', {}), On('extraApis', {})]); const $h = function (e) { const t = Xt('Sketcher for ' + e.name, Wh, e); const n = function (e) { return Lh(t.name, t.configFields, t.factory, e) }; const r = ge(t.apis, Fu); const o = ge(t.extraApis, function (e, t) { return Pu(e, t) }); return m(m({ name: i(t.name), configFields: i(t.configFields), sketch: n }, r), o) }; const Gh = function (e) { const t = Xt('Sketcher for ' + e.name, qh, e); const n = function (e) { return Hh(t.name, t.configFields, t.partFields, t.factory, e) }; const r = wh(t.name, t.partFields); const o = ge(t.apis, Fu); const u = ge(t.extraApis, function (e, t) { return Pu(e, t) }); return m(m({ name: i(t.name), partFields: i(t.partFields), configFields: i(t.configFields), sketch: n, parts: i(r) }, o), u) }; const Xh = function (e) { for (var t = [], n = function (e) { t.push(e) }, r = 0; r < e.length; r++) { e[r].each(n) } return t }; const Yh = function (e) { for (var t = [], n = 0; n < e.length; n++) { const r = e[n]; if (!r.isSome()) { return x.none() } t.push(r.getOrDie()) } return x.some(t) }; const Kh = function (e, t, n) { return e.isSome() && t.isSome() ? x.some(n(e.getOrDie(), t.getOrDie())) : x.none() }; const Jh = function (e, t, n, r) { return e.isSome() && t.isSome() && n.isSome() ? x.some(r(e.getOrDie(), t.getOrDie(), n.getOrDie())) : x.none() }; const Zh = function (e) { return tu(e) === 'input' && su(e, 'type') !== 'radio' || tu(e) === 'textarea' }; const Qh = function (e, t, n) { return t.find(e) }; const ep = Object.freeze({ __proto__: null, getCurrent: Qh }); const tp = [cn('find')]; const np = xl({ fields: tp, name: 'composing', apis: ep }); const rp = function (e, t, n, r) { const o = wd(e.element(), '.' + t.highlightClass); q(o, function (n) { V(r, function (e) { return e.element() === n }) || (Ca(n, t.highlightClass), e.getSystem().getByDom(n).each(function (n) { t.onDehighlight(e, n), ti(n, ei()) })) }) }; const op = function (e, t, n) { return rp(e, t, n, []) }; const ip = function (e, t, n, r) { fp(e, t, n, r) && (Ca(r.element(), t.highlightClass), t.onDehighlight(e, r), ti(r, ei())) }; const up = function (e, t, n, r) { rp(e, t, n, [r]), fp(e, t, n, r) || (wa(r.element(), t.highlightClass), t.onHighlight(e, r), ti(r, Qo())) }; const ap = function (e, t, n) { gp(e, t).each(function (r) { up(e, t, n, r) }) }; const cp = function (e, t, n) { hp(e, t).each(function (r) { up(e, t, n, r) }) }; const sp = function (e, t, n, r) { mp(e, t, n, r).fold(function (e) { throw new Error(e) }, function (r) { up(e, t, n, r) }) }; const lp = function (e, t, n, r) { const o = yp(e, t); const i = J(o, r); i.each(function (r) { up(e, t, n, r) }) }; var fp = function (e, t, n, r) { return Sa(r.element(), t.highlightClass) }; const dp = function (e, t, n) { return Jc(e.element(), '.' + t.highlightClass).bind(function (t) { return e.getSystem().getByDom(t).toOption() }) }; var mp = function (e, t, n, r) { const o = wd(e.element(), '.' + t.itemClass); return x.from(o[r]).fold(function () { return T.error('No element found with index ' + r) }, e.getSystem().getByDom) }; var gp = function (e, t, n) { return Jc(e.element(), '.' + t.itemClass).bind(function (t) { return e.getSystem().getByDom(t).toOption() }) }; var hp = function (e, t, n) { const r = wd(e.element(), '.' + t.itemClass); const o = r.length > 0 ? x.some(r[r.length - 1]) : x.none(); return o.bind(function (t) { return e.getSystem().getByDom(t).toOption() }) }; const pp = function (e, t, n, r) { const o = wd(e.element(), '.' + t.itemClass); const i = Z(o, function (e) { return Sa(e, t.highlightClass) }); return i.bind(function (t) { const n = Jl(t, r, 0, o.length - 1); return e.getSystem().getByDom(o[n]).toOption() }) }; const vp = function (e, t, n) { return pp(e, t, n, -1) }; const bp = function (e, t, n) { return pp(e, t, n, 1) }; var yp = function (e, t, n) { const r = wd(e.element(), '.' + t.itemClass); return Xh(W(r, function (t) { return e.getSystem().getByDom(t).toOption() })) }; const wp = Object.freeze({ __proto__: null, dehighlightAll: op, dehighlight: ip, highlight: up, highlightFirst: ap, highlightLast: cp, highlightAt: sp, highlightBy: lp, isHighlighted: fp, getHighlighted: dp, getFirst: gp, getLast: hp, getPrevious: vp, getNext: bp, getCandidates: yp }); const xp = [cn('highlightClass'), cn('itemClass'), xs('onHighlight'), xs('onDehighlight')]; const Cp = xl({ fields: xp, name: 'highlighting', apis: wp }); const Sp = function () { return [8] }; const kp = function () { return [9] }; const Tp = function () { return [13] }; const Ep = function () { return [27] }; const Op = function () { return [32] }; const Np = function () { return [37] }; const _p = function () { return [38] }; const Dp = function () { return [39] }; const Ap = function () { return [40] }; const Rp = function (e, t, n) { const r = ne(e.slice(0, t)); const o = ne(e.slice(t + 1)); return J(r.concat(o), n) }; const Bp = function (e, t, n) { const r = ne(e.slice(0, t)); return J(r, n) }; const Mp = function (e, t, n) { const r = e.slice(0, t); const o = e.slice(t + 1); return J(o.concat(r), n) }; const Pp = function (e, t, n) { const r = e.slice(t + 1); return J(r, n) }; const zp = function (e) { return function (t) { const n = t.raw(); return F(e, n.which) } }; const Ip = function (e) { return function (t) { return te(e, function (e) { return e(t) }) } }; const Lp = function (e) { const t = e.raw(); return !0 === t.shiftKey }; const Hp = function (e) { const t = e.raw(); return !0 === t.ctrlKey }; const Fp = c(Lp); const Vp = function (e, t) { return { matches: e, classification: t } }; const Up = function (e, t) { const n = J(e, function (e) { return e.matches(t) }); return n.map(function (e) { return e.classification }) }; const jp = function (e, t, n) { const r = t.exists(function (e) { return n.exists(function (t) { return Jr(t, e) }) }); r || ni(e, Yo(), { prevFocus: t, newFocus: n }) }; const Wp = function () { const e = function (e) { return zl(e.element()) }; const t = function (t, n) { const r = e(t); t.getSystem().triggerFocus(n, t.element()); const o = e(t); jp(t, r, o) }; return { get: e, set: t } }; const qp = function () { const e = function (e) { return Cp.getHighlighted(e).map(function (e) { return e.element() }) }; const t = function (t, r) { const o = e(t); t.getSystem().getByDom(r).fold(n, function (e) { Cp.highlight(t, e) }); const i = e(t); jp(t, o, i) }; return { get: e, set: t } }; (function (e) { e.OnFocusMode = 'onFocus', e.OnEnterOrSpaceMode = 'onEnterOrSpace', e.OnApiMode = 'onApi' })(jh || (jh = {})); let $p; const Gp = function (e, t, n, r, o) { const i = function () { return e.concat([On('focusManager', Wp()), Nn('focusInside', 'onFocus', jt(function (e) { return F(['onFocus', 'onEnterOrSpace', 'onApi'], e) ? T.value(e) : T.error('Invalid value for focusInside') })), Ts('handler', c), Ts('state', t), Ts('sendFocusIn', o)]) }; const u = function (e, t, n, r, o) { const i = n(e, t, r, o); return Up(i, t.event()).bind(function (n) { return n(e, t, r, o) }) }; const a = function (e, t) { const i = e.focusInside !== jh.OnFocusMode ? x.none() : o(e).map(function (n) { return fi(Do(), function (r, o) { n(r, e, t), o.stop() }) }); const a = function (n, r) { const i = zp(Op().concat(Tp()))(r.event()); e.focusInside === jh.OnEnterOrSpaceMode && i && oo(n, r) && o(e).each(function (o) { o(n, e, t), r.stop() }) }; return ai(i.toArray().concat([fi(Co(), function (r, o) { u(r, o, n, e, t).fold(function () { a(r, o) }, function (e) { o.stop() }) }), fi(So(), function (n, o) { u(n, o, r, e, t).each(function (e) { o.stop() }) })])) }; var c = { schema: i, processKey: u, toEvents: a }; return c }; const Xp = function (e) { const t = [yn('onEscape'), yn('onEnter'), On('selector', '[data-alloy-tabstop="true"]:not(:disabled)'), On('firstTabstop', 0), On('useTabstopAt', i(!0)), yn('visibilitySelector')].concat([e]); const n = function (e, t) { const n = e.visibilitySelector.bind(function (e) { return Zc(t, e) }).getOr(t); return uc(n) > 0 }; const r = function (e, t) { const r = wd(e.element(), t.selector); const o = X(r, function (e) { return n(t, e) }); return x.from(o[t.firstTabstop]) }; const o = function (e, t) { return t.focusManager.get(e).bind(function (e) { return Zc(e, t.selector) }) }; const u = function (e, t) { return n(e, t) && e.useTabstopAt(t) }; const c = function (e, t, n) { r(e, t).each(function (n) { t.focusManager.set(e, n) }) }; const s = function (e, t, n, r, o) { return o(t, n, function (e) { return u(r, e) }).fold(function () { return r.cyclic ? x.some(!0) : x.none() }, function (t) { return r.focusManager.set(e, t), x.some(!0) }) }; const l = function (e, t, n, r) { const i = wd(e.element(), n.selector); return o(e, n).bind(function (t) { const o = Z(i, a(Jr, t)); return o.bind(function (t) { return s(e, i, t, n, r) }) }) }; const f = function (e, t, n) { const r = n.cyclic ? Rp : Bp; return l(e, t, n, r) }; const d = function (e, t, n) { const r = n.cyclic ? Mp : Pp; return l(e, t, n, r) }; const m = function (e, t, n) { return n.onEnter.bind(function (n) { return n(e, t) }) }; const g = function (e, t, n) { return n.onEscape.bind(function (n) { return n(e, t) }) }; const h = i([Vp(Ip([Lp, zp(kp())]), f), Vp(zp(kp()), d), Vp(zp(Ep()), g), Vp(Ip([Fp, zp(Tp())]), m)]); const p = i([]); return Gp(t, Vu.init, h, p, function () { return x.some(c) }) }; const Yp = Xp(In('cyclic', i(!1))); const Kp = Xp(In('cyclic', i(!0))); const Jp = function (e, t, n) { return oi(e, n, Mo()), x.some(!0) }; const Zp = function (e, t, n) { return Zh(n) && zp(Op())(t.event()) ? x.none() : Jp(e, t, n) }; const Qp = function (e, t) { return x.some(!0) }; const ev = [On('execute', Zp), On('useSpace', !1), On('useEnter', !0), On('useControlEnter', !1), On('useDown', !1)]; const tv = function (e, t, n) { return n.execute(e, t, e.element()) }; const nv = function (e, t, n, r) { const o = n.useSpace && !Zh(e.element()) ? Op() : []; const i = n.useEnter ? Tp() : []; const u = n.useDown ? Ap() : []; const a = o.concat(i).concat(u); return [Vp(zp(a), tv)].concat(n.useControlEnter ? [Vp(Ip([Hp, zp(Tp())]), tv)] : []) }; const rv = function (e, t, n, r) { return n.useSpace && !Zh(e.element()) ? [Vp(zp(Op()), Qp)] : [] }; const ov = Gp(ev, Vu.init, nv, rv, function () { return x.none() }); const iv = function () { const e = Ln(x.none()); const t = function (t, n) { e.set(x.some({ numRows: i(t), numColumns: i(n) })) }; const n = function () { return e.get().map(function (e) { return e.numRows() }) }; const r = function () { return e.get().map(function (e) { return e.numColumns() }) }; return Uu({ readState () { return e.get().map(function (e) { return { numRows: String(e.numRows()), numColumns: String(e.numColumns()) } }).getOr({ numRows: '?', numColumns: '?' }) }, setGridSize: t, getNumRows: n, getNumColumns: r }) }; const uv = function (e) { return e.state(e) }; const av = Object.freeze({ __proto__: null, flatgrid: iv, init: uv }); const cv = function (e) { return function (t, n, r, o) { const i = e(t.element()); return dv(i, t, n, r, o) } }; const sv = function (e, t) { const n = Cf(e, t); return cv(n) }; const lv = function (e, t) { const n = Cf(t, e); return cv(n) }; const fv = function (e) { return function (t, n, r, o) { return dv(e, t, n, r, o) } }; var dv = function (e, t, n, r, o) { const i = r.focusManager.get(t).bind(function (n) { return e(t.element(), n, r, o) }); return i.map(function (e) { return r.focusManager.set(t, e), !0 }) }; const mv = fv; const gv = fv; const hv = fv; const pv = function (e) { return e.offsetWidth <= 0 && e.offsetHeight <= 0 }; const vv = function (e) { const t = e.dom(); return !pv(t) }; const bv = function (e, t) { return Z(e, t).map(function (t) { return { index: i(t), candidates: i(e) } }) }; const yv = function (e, t, n) { const r = function (e) { return Jr(e, t) }; const o = wd(e, n); const i = X(o, vv); return bv(i, r) }; const wv = function (e, t) { return Z(e, function (e) { return Jr(t, e) }) }; const xv = function (e, t, n, r) { const o = Math.floor(t / n); const i = t % n; return r(o, i).bind(function (t) { const r = t.row() * n + t.column(); return r >= 0 && r < e.length ? x.some(e[r]) : x.none() }) }; const Cv = function (e, t, n, r, o) { return xv(e, t, r, function (t, u) { const a = t === n - 1; const c = a ? e.length - t * r : r; const s = Jl(u, o, 0, c - 1); return x.some({ row: i(t), column: i(s) }) }) }; const Sv = function (e, t, n, r, o) { return xv(e, t, r, function (t, u) { const a = Jl(t, o, 0, n - 1); const c = a === n - 1; const s = c ? e.length - a * r : r; const l = Zl(u, 0, s - 1); return x.some({ row: i(a), column: i(l) }) }) }; const kv = function (e, t, n, r) { return Cv(e, t, n, r, 1) }; const Tv = function (e, t, n, r) { return Cv(e, t, n, r, -1) }; const Ev = function (e, t, n, r) { return Sv(e, t, n, r, -1) }; const Ov = function (e, t, n, r) { return Sv(e, t, n, r, 1) }; const Nv = [cn('selector'), On('execute', Zp), Cs('onEscape'), On('captureTab', !1), Os()]; const _v = function (e, t, n) { Jc(e.element(), t.selector).each(function (n) { t.focusManager.set(e, n) }) }; const Dv = function (e, t) { return t.focusManager.get(e).bind(function (e) { return Zc(e, t.selector) }) }; const Av = function (e, t, n, r) { return Dv(e, n).bind(function (r) { return n.execute(e, t, r) }) }; const Rv = function (e) { return function (t, n, r, o) { return yv(t, n, r.selector).bind(function (t) { return e(t.candidates(), t.index(), o.getNumRows().getOr(r.initSize.numRows), o.getNumColumns().getOr(r.initSize.numColumns)) }) } }; const Bv = function (e, t, n) { return n.captureTab ? x.some(!0) : x.none() }; const Mv = function (e, t, n) { return n.onEscape(e, t) }; const Pv = Rv(Tv); const zv = Rv(kv); const Iv = Rv(Ev); const Lv = Rv(Ov); const Hv = i([Vp(zp(Np()), sv(Pv, zv)), Vp(zp(Dp()), lv(Pv, zv)), Vp(zp(_p()), mv(Iv)), Vp(zp(Ap()), gv(Lv)), Vp(Ip([Lp, zp(kp())]), Bv), Vp(Ip([Fp, zp(kp())]), Bv), Vp(zp(Ep()), Mv), Vp(zp(Op().concat(Tp())), Av)]); const Fv = i([Vp(zp(Op()), Qp)]); const Vv = Gp(Nv, iv, Hv, Fv, function () { return x.some(_v) }); const Uv = function (e, t, n, r) { const o = function (e) { return tu(e) === 'button' && su(e, 'disabled') === 'disabled' }; var i = function (e, t, n) { const u = Jl(t, r, 0, n.length - 1); return u === e ? x.none() : o(n[u]) ? i(e, u, n) : x.from(n[u]) }; return yv(e, n, t).bind(function (e) { const t = e.index(); const n = e.candidates(); return i(t, t, n) }) }; const jv = [cn('selector'), On('getInitial', x.none), On('execute', Zp), Cs('onEscape'), On('executeOnMove', !1), On('allowVertical', !0)]; const Wv = function (e, t) { return t.focusManager.get(e).bind(function (e) { return Zc(e, t.selector) }) }; const qv = function (e, t, n) { return Wv(e, n).bind(function (r) { return n.execute(e, t, r) }) }; const $v = function (e, t, n) { t.getInitial(e).orThunk(function () { return Jc(e.element(), t.selector) }).each(function (n) { t.focusManager.set(e, n) }) }; const Gv = function (e, t, n) { return Uv(e, n.selector, t, -1) }; const Xv = function (e, t, n) { return Uv(e, n.selector, t, 1) }; const Yv = function (e) { return function (t, n, r, o) { return e(t, n, r, o).bind(function () { return r.executeOnMove ? qv(t, n, r) : x.some(!0) }) } }; const Kv = function (e, t, n) { return n.onEscape(e, t) }; const Jv = function (e, t, n, r) { const o = Np().concat(n.allowVertical ? _p() : []); const i = Dp().concat(n.allowVertical ? Ap() : []); return [Vp(zp(o), Yv(sv(Gv, Xv))), Vp(zp(i), Yv(lv(Gv, Xv))), Vp(zp(Tp()), qv), Vp(zp(Op()), qv), Vp(zp(Ep()), Kv)] }; const Zv = i([Vp(zp(Op()), Qp)]); const Qv = Gp(jv, Vu.init, Jv, Zv, function () { return x.some($v) }); const eb = Ai(['rowIndex', 'columnIndex', 'cell'], []); const tb = function (e, t, n) { return x.from(e[t]).bind(function (e) { return x.from(e[n]).map(function (e) { return eb({ rowIndex: t, columnIndex: n, cell: e }) }) }) }; const nb = function (e, t, n, r) { const o = e[t]; const i = o.length; const u = Jl(n, r, 0, i - 1); return tb(e, t, u) }; const rb = function (e, t, n, r) { const o = Jl(n, r, 0, e.length - 1); const i = e[o].length; const u = Zl(t, 0, i - 1); return tb(e, o, u) }; const ob = function (e, t, n, r) { const o = e[t]; const i = o.length; const u = Zl(n + r, 0, i - 1); return tb(e, t, u) }; const ib = function (e, t, n, r) { const o = Zl(n + r, 0, e.length - 1); const i = e[o].length; const u = Zl(t, 0, i - 1); return tb(e, o, u) }; const ub = function (e, t, n) { return nb(e, t, n, 1) }; const ab = function (e, t, n) { return nb(e, t, n, -1) }; const cb = function (e, t, n) { return rb(e, n, t, -1) }; const sb = function (e, t, n) { return rb(e, n, t, 1) }; const lb = function (e, t, n) { return ob(e, t, n, -1) }; const fb = function (e, t, n) { return ob(e, t, n, 1) }; const db = function (e, t, n) { return ib(e, n, t, -1) }; const mb = function (e, t, n) { return ib(e, n, t, 1) }; const gb = [pn('selectors', [cn('row'), cn('cell')]), On('cycles', !0), On('previousSelector', x.none), On('execute', Zp)]; const hb = function (e, t, n) { const r = t.previousSelector(e).orThunk(function () { const n = t.selectors; return Jc(e.element(), n.cell) }); r.each(function (n) { t.focusManager.set(e, n) }) }; const pb = function (e, t, n) { return zl(e.element()).bind(function (r) { return n.execute(e, t, r) }) }; const vb = function (e, t) { return W(e, function (e) { return wd(e, t.selectors.cell) }) }; const bb = function (e, t) { return function (n, r, o) { const i = o.cycles ? e : t; return Zc(r, o.selectors.row).bind(function (e) { const t = wd(e, o.selectors.cell); return wv(t, r).bind(function (t) { const r = wd(n, o.selectors.row); return wv(r, e).bind(function (e) { const n = vb(r, o); return i(n, e, t).map(function (e) { return e.cell() }) }) }) }) } }; const yb = bb(ab, lb); const wb = bb(ub, fb); const xb = bb(cb, db); const Cb = bb(sb, mb); const Sb = i([Vp(zp(Np()), sv(yb, wb)), Vp(zp(Dp()), lv(yb, wb)), Vp(zp(_p()), mv(xb)), Vp(zp(Ap()), gv(Cb)), Vp(zp(Op().concat(Tp())), pb)]); const kb = i([Vp(zp(Op()), Qp)]); const Tb = Gp(gb, Vu.init, Sb, kb, function () { return x.some(hb) }); const Eb = [cn('selector'), On('execute', Zp), On('moveOnTab', !1)]; const Ob = function (e, t, n) { return n.focusManager.get(e).bind(function (r) { return n.execute(e, t, r) }) }; const Nb = function (e, t, n) { Jc(e.element(), t.selector).each(function (n) { t.focusManager.set(e, n) }) }; const _b = function (e, t, n) { return Uv(e, n.selector, t, -1) }; const Db = function (e, t, n) { return Uv(e, n.selector, t, 1) }; const Ab = function (e, t, n, r) { return n.moveOnTab ? hv(_b)(e, t, n, r) : x.none() }; const Rb = function (e, t, n, r) { return n.moveOnTab ? hv(Db)(e, t, n, r) : x.none() }; const Bb = i([Vp(zp(_p()), hv(_b)), Vp(zp(Ap()), hv(Db)), Vp(Ip([Lp, zp(kp())]), Ab), Vp(Ip([Fp, zp(kp())]), Rb), Vp(zp(Tp()), Ob), Vp(zp(Op()), Ob)]); const Mb = i([Vp(zp(Op()), Qp)]); const Pb = Gp(Eb, Vu.init, Bb, Mb, function () { return x.some(Nb) }); const zb = [Cs('onSpace'), Cs('onEnter'), Cs('onShiftEnter'), Cs('onLeft'), Cs('onRight'), Cs('onTab'), Cs('onShiftTab'), Cs('onUp'), Cs('onDown'), Cs('onEscape'), On('stopSpaceKeyup', !1), yn('focusIn')]; const Ib = function (e, t, n) { return [Vp(zp(Op()), n.onSpace), Vp(Ip([Fp, zp(Tp())]), n.onEnter), Vp(Ip([Lp, zp(Tp())]), n.onShiftEnter), Vp(Ip([Lp, zp(kp())]), n.onShiftTab), Vp(Ip([Fp, zp(kp())]), n.onTab), Vp(zp(_p()), n.onUp), Vp(zp(Ap()), n.onDown), Vp(zp(Np()), n.onLeft), Vp(zp(Dp()), n.onRight), Vp(zp(Op()), n.onSpace), Vp(zp(Ep()), n.onEscape)] }; const Lb = function (e, t, n) { return n.stopSpaceKeyup ? [Vp(zp(Op()), Qp)] : [] }; const Hb = Gp(zb, Vu.init, Ib, Lb, function (e) { return e.focusIn }); const Fb = Yp.schema(); const Vb = Kp.schema(); const Ub = Qv.schema(); const jb = Vv.schema(); const Wb = Tb.schema(); const qb = ov.schema(); const $b = Pb.schema(); const Gb = Hb.schema(); const Xb = Object.freeze({ __proto__: null, acyclic: Fb, cyclic: Vb, flow: Ub, flatgrid: jb, matrix: Wb, execution: qb, menu: $b, special: Gb }); const Yb = function (e) { return xe(e, 'setGridSize') }; const Kb = Sl({ branchKey: 'mode', branches: Xb, name: 'keying', active: { events (e, t) { const n = e.handler; return n.toEvents(e, t) } }, apis: { focusIn (e, t, n) { t.sendFocusIn(t).fold(function () { e.getSystem().triggerFocus(e.element(), e.element()) }, function (r) { r(e, t, n) }) }, setGridSize (e, n, r, o, i) { Yb(r) ? r.setGridSize(o, i) : t.console.error('Layout does not support setGridSize') } }, state: av }); const Jb = function (e, t, n, r) { Il(function () { const t = W(r, e.getSystem().build); Cm(e, t) }, e.element()) }; const Zb = function (e, t, n, r) { const o = e.getSystem().build(r); km(e, o, n) }; const Qb = function (e, t, n, r) { Zb(e, t, qi, r) }; const ey = function (e, t, n, r) { Zb(e, t, Wi, r) }; const ty = function (e, t, n, r) { const o = ny(e); const i = J(o, function (e) { return Jr(r.element(), e.element()) }); i.each(Em) }; var ny = function (e, t) { return e.components() }; const ry = function (e, t, n, r, o) { const i = ny(e); return x.from(i[r]).map(function (i) { return ty(e, t, n, i), o.each(function (n) { Zb(e, t, function (e, t) { $i(e, t, r) }, n) }), i }) }; const oy = function (e, t, n, r, o) { const i = ny(e); return Z(i, r).bind(function (r) { return ry(e, t, n, r, o) }) }; const iy = Object.freeze({ __proto__: null, append: Qb, prepend: ey, remove: ty, replaceAt: ry, replaceBy: oy, set: Jb, contents: ny }); const uy = xl({ fields: [], name: 'replacing', apis: iy }); const ay = function (e, t) { const n = ai(t); return xl({ fields: [cn('enabled')], name: e, active: { events: i(n) } }) }; const cy = function (e, t) { const n = ay(e, t); return { key: e, value: { config: {}, me: n, configAsRaw: i({}), initialConfig: {}, state: Vu } } }; const sy = function (e, t) { t.ignore || (Rl(e.element()), t.onFocus(e)) }; const ly = function (e, t) { t.ignore || Bl(e.element()) }; const fy = function (e) { return Ml(e.element()) }; const dy = Object.freeze({ __proto__: null, focus: sy, blur: ly, isFocused: fy }); const my = function (e, t) { const n = t.ignore ? {} : { attributes: { tabindex: '-1' } }; return Gu(n) }; const gy = function (e) { return ai([fi(Do(), function (t, n) { sy(t, e), n.stop() })].concat(e.stopMousedown ? [fi(ho(), function (e, t) { t.event().prevent() })] : [])) }; const hy = Object.freeze({ __proto__: null, exhibit: my, events: gy }); const py = [xs('onFocus'), On('stopMousedown', !1), On('ignore', !1)]; const vy = xl({ fields: py, name: 'focusing', active: hy, apis: dy }); const by = function (e, t, n) { const r = t.aria; r.update(e, r, n.get()) }; const yy = function (e, t, n) { t.toggleClass.each(function (t) { n.get() ? wa(e.element(), t) : Ca(e.element(), t) }) }; const wy = function (e, t, n) { Sy(e, t, n, !n.get()) }; const xy = function (e, t, n) { n.set(!0), yy(e, t, n), by(e, t, n) }; const Cy = function (e, t, n) { n.set(!1), yy(e, t, n), by(e, t, n) }; var Sy = function (e, t, n, r) { const o = r ? xy : Cy; o(e, t, n) }; const ky = function (e, t, n) { return n.get() }; const Ty = function (e, t, n) { Sy(e, t, n, t.selected) }; const Ey = Object.freeze({ __proto__: null, onLoad: Ty, toggle: wy, isOn: ky, on: xy, off: Cy, set: Sy }); const Oy = function () { return Gu({}) }; const Ny = function (e, t) { const n = dl(e, t, wy); const r = ml(e, t, Ty); return ai(Q([e.toggleOnExecute ? [n] : [], [r]])) }; const _y = Object.freeze({ __proto__: null, exhibit: Oy, events: Ny }); const Dy = function (e) { const t = function () { const t = Ln(e); const n = function () { return t.get() }; const r = function (e) { return t.set(e) }; const o = function () { return t.set(e) }; const i = function () { return t.get() }; return { get: n, set: r, clear: o, readState: i } }; return { init: t } }; const Ay = function (e, t, n) { au(e.element(), 'aria-pressed', n), t.syncWithExpanded && My(e, t, n) }; const Ry = function (e, t, n) { au(e.element(), 'aria-selected', n) }; const By = function (e, t, n) { au(e.element(), 'aria-checked', n) }; var My = function (e, t, n) { au(e.element(), 'aria-expanded', n) }; const Py = [On('selected', !1), yn('toggleClass'), On('toggleOnExecute', !0), Nn('aria', { mode: 'none' }, Jt('mode', { pressed: [On('syncWithExpanded', !1), Ts('update', Ay)], checked: [Ts('update', By)], expanded: [Ts('update', My)], selected: [Ts('update', Ry)], none: [Ts('update', n)] }))]; const zy = xl({ fields: Py, name: 'toggling', active: _y, apis: Ey, state: Dy(!1) }); const Iy = function () { const e = function (e, t) { t.stop(), ri(e) }; return [fi(Eo(), e), fi(zo(), e), bi(lo()), bi(ho())] }; const Ly = function (e) { const t = function (e) { return ki(function (t, n) { e(t), n.stop() }) }; return ai(Q([e.map(t).toArray(), Iy()])) }; const Hy = 'alloy.item-hover'; const Fy = 'alloy.item-focus'; const Vy = function (e) { (zl(e.element()).isNone() || vy.isFocused(e)) && (vy.isFocused(e) || vy.focus(e), ni(e, Hy, { item: e })) }; const Uy = function (e) { ni(e, Fy, { item: e }) }; const jy = i(Hy); const Wy = i(Fy); const qy = function (e) { return { dom: e.dom, domModification: m(m({}, e.domModification), { attributes: m(m(m({ role: e.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem' }, e.domModification.attributes), { 'aria-haspopup': e.hasSubmenu }), e.hasSubmenu ? { 'aria-expanded': !1 } : {}) }), behaviours: Ig.augment(e.itemBehaviours, [e.toggling.fold(zy.revoke, function (e) { return zy.config(m({ aria: { mode: 'checked' } }, e)) }), vy.config({ ignore: e.ignoreFocus, stopMousedown: e.ignoreFocus, onFocus (e) { Uy(e) } }), Kb.config({ mode: 'execution' }), Bg.config({ store: { mode: 'memory', initialValue: e.data } }), cy('item-type-events', h(Iy(), [fi(yo(), Vy), fi(Po(), vy.focus)]))]), components: e.components, eventOrder: e.eventOrder } }; const $y = [cn('data'), cn('components'), cn('dom'), On('hasSubmenu', !1), yn('toggling'), Ig.field('itemBehaviours', [zy, vy, Kb, Bg]), On('ignoreFocus', !1), On('domModification', {}), Ts('builder', qy), On('eventOrder', {})]; const Gy = function (e) { return { dom: e.dom, components: e.components, events: ai([yi(Po())]) } }; const Xy = [cn('dom'), cn('components'), Ts('builder', Gy)]; const Yy = function () { return 'item-widget' }; const Ky = i([dh({ name: 'widget', overrides (e) { return { behaviours: yl([Bg.config({ store: { mode: 'manual', getValue (t) { return e.data }, setValue () {} } })]) } } })]); const Jy = function (e) { const t = Th(Yy(), e, Ky()); const n = Eh(Yy(), e, t.internals()); const r = function (t) { return Oh(t, e, 'widget').map(function (e) { return Kb.focusIn(e), e }) }; const o = function (t, n) { return Zh(n.event().target()) ? x.none() : (function () { return e.autofocus ? (n.setSource(t.element()), x.none()) : x.none() }()) }; return { dom: e.dom, components: n, domModification: e.domModification, events: ai([ki(function (e, t) { r(e).each(function (e) { t.stop() }) }), fi(yo(), Vy), fi(Po(), function (t, n) { e.autofocus ? r(t) : vy.focus(t) })]), behaviours: Ig.augment(e.widgetBehaviours, [Bg.config({ store: { mode: 'memory', initialValue: e.data } }), vy.config({ ignore: e.ignoreFocus, onFocus (e) { Uy(e) } }), Kb.config({ mode: 'special', focusIn: e.autofocus ? function (e) { r(e) } : kl(), onLeft: o, onRight: o, onEscape (t, n) { return vy.isFocused(t) || e.autofocus ? e.autofocus ? (n.setSource(t.element()), x.none()) : x.none() : (vy.focus(t), x.some(!0)) } })]) } }; const Zy = [cn('uid'), cn('data'), cn('components'), cn('dom'), On('autofocus', !1), On('ignoreFocus', !1), Ig.field('widgetBehaviours', [Bg, vy, Kb]), On('domModification', {}), Mh(Ky()), Ts('builder', Jy)]; const Qy = Jt('type', { widget: Zy, item: $y, separator: Xy }); const ew = function (e, t) { return { mode: 'flatgrid', selector: '.' + e.markers.item, initSize: { numColumns: t.initSize.numColumns, numRows: t.initSize.numRows }, focusManager: e.focusManager } }; const tw = function (e, t) { return { mode: 'matrix', selectors: { row: t.rowSelector, cell: '.' + e.markers.item }, focusManager: e.focusManager } }; const nw = function (e, t) { return { mode: 'menu', selector: '.' + e.markers.item, moveOnTab: t.moveOnTab, focusManager: e.focusManager } }; const rw = i([hh({ factory: { sketch (e) { const t = Xt('menu.spec item', Qy, e); return t.builder(t) } }, name: 'items', unit: 'item', defaults (e, t) { return t.hasOwnProperty('uid') ? t : m(m({}, t), { uid: _u('item') }) }, overrides (e, t) { return { type: t.type, ignoreFocus: e.fakeFocus, domModification: { classes: [e.markers.item] } } } })]); const ow = i([cn('value'), cn('items'), cn('dom'), cn('components'), On('eventOrder', {}), Mg('menuBehaviours', [Cp, Bg, np, Kb]), Nn('movement', { mode: 'menu', moveOnTab: !0 }, Jt('mode', { grid: [Os(), Ts('config', ew)], matrix: [Ts('config', tw), cn('rowSelector')], menu: [On('moveOnTab', !0), Ts('config', nw)] })), vs(), On('fakeFocus', !1), On('focusManager', Wp()), xs('onHighlight')]); const iw = i('alloy.menu-focus'); const uw = function (e, t, n, r) { return { uid: e.uid, dom: e.dom, markers: e.markers, behaviours: zg(e.menuBehaviours, [Cp.config({ highlightClass: e.markers.selectedItem, itemClass: e.markers.item, onHighlight: e.onHighlight }), Bg.config({ store: { mode: 'memory', initialValue: e.value } }), np.config({ find: x.some }), Kb.config(e.movement.config(e, e.movement))]), events: ai([fi(Wy(), function (e, t) { const n = t.event(); e.getSystem().getByDom(n.target()).each(function (n) { Cp.highlight(e, n), t.stop(), ni(e, iw(), { menu: e, item: n }) }) }), fi(jy(), function (e, t) { const n = t.event().item(); Cp.highlight(e, n) })]), components: t, eventOrder: e.eventOrder, domModification: { attributes: { role: 'menu' } } } }; const aw = Gh({ name: 'Menu', configFields: ow(), partFields: rw(), factory: uw }); const cw = function (e) { return he(e, function (e, t) { return { k: e, v: t } }) }; var sw = function (e, t, n, r) { return ye(n, r).bind(function (r) { return ye(e, r).bind(function (r) { const o = sw(e, t, n, r); return x.some([r].concat(o)) }) }).getOr([]) }; const lw = function (e, t) { const n = {}; me(e, function (e, t) { q(e, function (e) { n[e] = t }) }); const r = t; const o = cw(t); const i = ge(o, function (e, t) { return [t].concat(sw(n, r, o, t)) }); return ge(n, function (e) { return ye(i, e).getOr([e]) }) }; const fw = function () { const e = Ln({}); const t = Ln({}); const n = Ln({}); const r = Ln(x.none()); const o = Ln({}); const i = function () { e.set({}), t.set({}), n.set({}), r.set(x.none()) }; const u = function () { return r.get().isNone() }; const a = function (e, n) { let r; t.set(m(m({}, t.get()), (r = {}, r[e] = { type: 'prepared', menu: n }, r))) }; const c = function (i, u, a, c) { r.set(x.some(i)), e.set(a), t.set(u), o.set(c); const s = lw(c, a); n.set(s) }; const s = function (t) { return ve(e.get(), function (e, n) { return e === t }) }; const l = function (e, t, n) { return p(e).bind(function (r) { return s(e).bind(function (e) { return t(e).map(function (e) { return { triggeredMenu: r, triggeringItem: e, triggeringPath: n } }) }) }) }; const f = function (e, t) { const o = X(b(e).toArray(), function (e) { return p(e).isSome() }); return ye(n.get(), e).bind(function (e) { const n = ne(o.concat(e)); const i = ee(n, function (e, o) { return l(e, t, n.slice(0, o + 1)).fold(function () { return r.get().is(e) ? [] : [x.none()] }, function (e) { return [x.some(e)] }) }); return Yh(i) }) }; const d = function (t) { return ye(e.get(), t).map(function (e) { const r = ye(n.get(), t).getOr([]); return [e].concat(r) }) }; const g = function (e) { return ye(n.get(), e).bind(function (e) { return e.length > 1 ? x.some(e.slice(1)) : x.none() }) }; const h = function (e) { return ye(n.get(), e) }; var p = function (e) { return v(e).bind(dw) }; var v = function (e) { return ye(t.get(), e) }; var b = function (t) { return ye(e.get(), t) }; const y = function (e) { const t = o.get(); return re(fe(t), e) }; const w = function () { return r.get().bind(p) }; const C = function () { return t.get() }; return { setMenuBuilt: a, setContents: c, expand: d, refresh: h, collapse: g, lookupMenu: v, lookupItem: b, otherMenus: y, getPrimary: w, getMenus: C, clear: i, isClear: u, getTriggeringPath: f } }; var dw = function (e) { return e.type === 'prepared' ? x.some(e.menu) : x.none() }; const mw = { init: fw, extractPreparedMenu: dw }; const gw = function (e, t) { let n; const r = Ln(x.none()); const o = function (t, n, r) { return ge(r, function (r, o) { const i = function () { return aw.sketch(m(m({ dom: r.dom }, r), { value: o, items: r.items, markers: e.markers, fakeFocus: e.fakeFocus, onHighlight: e.onHighlight, focusManager: e.fakeFocus ? qp() : Wp() })) }; return o === n ? { type: 'prepared', menu: t.getSystem().build(i()) } : { type: 'notbuilt', nbMenu: i } }) }; const i = mw.init(); const u = function (t) { const n = o(t, e.data.primary, e.data.menus); const r = s(); return i.setContents(e.data.primary, n, e.data.expansions, r), i.getPrimary() }; const a = function (e) { return Bg.getValue(e).value }; const c = function (e, t, n) { return le(t, function (e) { if (!e.getSystem().isConnected()) { return x.none() } const t = Cp.getCandidates(e); return J(t, function (e) { return a(e) === n }) }) }; var s = function (t) { return ge(e.data.menus, function (e, t) { return ee(e.items, function (e) { return e.type === 'separator' ? [] : [e.data.value] }) }) }; const l = function (e, t) { Cp.highlight(e, t), Cp.getHighlighted(t).orThunk(function () { return Cp.getFirst(t) }).each(function (t) { oi(e, t.element(), Po()) }) }; const f = function (e, t) { return Xh(W(t, function (t) { return e.lookupMenu(t).bind(function (e) { return e.type === 'prepared' ? x.some(e.menu) : x.none() }) })) }; const d = function (t, n, r) { const o = f(n, n.otherMenus(r)); q(o, function (n) { Ta(n.element(), [e.markers.backgroundMenu]), e.stayInDom || uy.remove(t, n) }) }; const g = function (t) { return r.get().getOrThunk(function () { const n = {}; const o = wd(t.element(), '.' + e.markers.item); const i = X(o, function (e) { return su(e, 'aria-haspopup') === 'true' }); return q(i, function (e) { t.getSystem().getByDom(e).each(function (e) { const t = a(e); n[t] = e }) }), r.set(x.some(n)), n }) }; const h = function (e, t) { const n = g(e); me(n, function (e, n) { const r = F(t, n); au(e.element(), 'aria-expanded', r) }) }; const p = function (t, n, r) { return x.from(r[0]).bind(function (o) { return n.lookupMenu(o).bind(function (o) { if (o.type === 'notbuilt') { return x.none() } const i = o.menu; const u = f(n, r.slice(1)); return q(u, function (t) { wa(t.element(), e.markers.backgroundMenu) }), Oa(i.element()) || uy.append(t, rc(i)), Ta(i.element(), [e.markers.backgroundMenu]), l(t, i), d(t, n, r), x.some(i) }) }) }; (function (e) { e[e.HighlightSubmenu = 0] = 'HighlightSubmenu', e[e.HighlightParent = 1] = 'HighlightParent' })(n || (n = {})); const v = function (e, t, n) { if (n.type === 'notbuilt') { const r = e.getSystem().build(n.nbMenu()); return i.setMenuBuilt(t, r), r } return n.menu }; const b = function (t, r, o) { void 0 === o && (o = n.HighlightSubmenu); const u = a(r); return i.expand(u).bind(function (u) { return h(t, u), x.from(u[0]).bind(function (a) { return i.lookupMenu(a).bind(function (c) { const s = v(t, a, c); return Oa(s.element()) || uy.append(t, rc(s)), e.onOpenSubmenu(t, r, s, ne(u)), o === n.HighlightSubmenu ? (Cp.highlightFirst(s), p(t, i, u)) : (Cp.dehighlightAll(s), x.some(r)) }) }) }) }; const y = function (t, n) { const r = a(n); return i.collapse(r).bind(function (r) { return h(t, r), p(t, i, r).map(function (r) { return e.onCollapseMenu(t, n, r), r }) }) }; const w = function (e, t) { const n = a(t); return i.refresh(n).bind(function (t) { return h(e, t), p(e, i, t) }) }; const C = function (e, t) { return Zh(t.element()) ? x.none() : b(e, t, n.HighlightSubmenu) }; const S = function (e, t) { return Zh(t.element()) ? x.none() : y(e, t) }; const k = function (t, n) { return y(t, n).orThunk(function () { return e.onEscape(t, n).map(function () { return t }) }) }; const T = function (t) { return function (n, r) { return Zc(r.getSource(), '.' + e.markers.item).bind(function (e) { return n.getSystem().getByDom(e).toOption().bind(function (e) { return t(n, e).map(function () { return !0 }) }) }) } }; const E = ai([fi(iw(), function (e, t) { const n = t.event().item(); i.lookupItem(a(n)).each(function () { const n = t.event().menu(); Cp.highlight(e, n); const r = a(t.event().item()); i.refresh(r).each(function (t) { return d(e, i, t) }) }) }), ki(function (t, r) { const o = r.event().target(); t.getSystem().getByDom(o).each(function (r) { const o = a(r); o.indexOf('collapse-item') === 0 && y(t, r), b(t, r, n.HighlightSubmenu).fold(function () { e.onExecute(t, r) }, function () {}) }) }), xi(function (t, n) { u(t).each(function (n) { uy.append(t, rc(n)), e.onOpenMenu(t, n), e.highlightImmediately && l(t, n) }) })].concat(e.navigateOnHover ? [fi(jy(), function (t, r) { const o = r.event().item(); w(t, o), b(t, o, n.HighlightParent), e.onHover(t, o) })] : [])); const O = function (e) { return Cp.getHighlighted(e).bind(Cp.getHighlighted) }; const N = function (e) { O(e).each(function (t) { y(e, t) }) }; const _ = function (e) { i.getPrimary().each(function (t) { l(e, t) }) }; const D = function (e) { return x.from(e.components()[0]).filter(function (e) { return su(e.element(), 'role') === 'menu' }) }; const A = function (t) { const n = i.getPrimary().bind(function (e) { return O(t).bind(function (e) { const n = a(e); const r = be(i.getMenus()); const o = Xh(W(r, mw.extractPreparedMenu)); return i.getTriggeringPath(n, function (e) { return c(t, o, e) }) }).map(function (t) { return { primary: e, triggeringPath: t } }) }); n.fold(function () { D(t).each(function (n) { e.onRepositionMenu(t, n, []) }) }, function (n) { const r = n.primary; const o = n.triggeringPath; e.onRepositionMenu(t, r, o) }) }; const R = { collapseMenu: N, highlightPrimary: _, repositionMenus: A }; return { uid: e.uid, dom: e.dom, markers: e.markers, behaviours: zg(e.tmenuBehaviours, [Kb.config({ mode: 'special', onRight: T(C), onLeft: T(S), onEscape: T(k), focusIn (e, t) { i.getPrimary().each(function (t) { oi(e, t.element(), Po()) }) } }), Cp.config({ highlightClass: e.markers.selectedMenu, itemClass: e.markers.menu }), np.config({ find (e) { return Cp.getHighlighted(e) } }), uy.config({})]), eventOrder: e.eventOrder, apis: R, events: E } }; const hw = i('collapse-item'); const pw = function (e, t, n) { return { primary: e, menus: t, expansions: n } }; const vw = function (e, t) { return { primary: e, menus: et(e, t), expansions: {} } }; const bw = function (e) { return { value: xu(hw()), meta: { text: e } } }; const yw = $h({ name: 'TieredMenu', configFields: [ks('onExecute'), ks('onEscape'), Ss('onOpenMenu'), Ss('onOpenSubmenu'), xs('onRepositionMenu'), xs('onCollapseMenu'), On('highlightImmediately', !0), pn('data', [cn('primary'), cn('menus'), cn('expansions')]), On('fakeFocus', !1), xs('onHighlight'), xs('onHover'), bs(), cn('dom'), On('navigateOnHover', !0), On('stayInDom', !1), Mg('tmenuBehaviours', [Kb, Cp, np, uy]), On('eventOrder', {})], apis: { collapseMenu (e, t) { e.collapseMenu(t) }, highlightPrimary (e, t) { e.highlightPrimary(t) }, repositionMenus (e, t) { e.repositionMenus(t) } }, factory: gw, extraApis: { tieredData: pw, singleData: vw, collapseItem: bw } }); const ww = function (e, t, n, r, o) { const i = function () { return e.lazySink(t) }; const u = r.type === 'horizontal' ? { layouts: { onLtr () { return ll() }, onRtl () { return fl() } } } : {}; const a = function (e) { return e.length === 2 }; const c = function (e) { return a(e) ? u : {} }; return yw.sketch({ dom: { tag: 'div' }, data: r.data, markers: r.menu.markers, highlightImmediately: r.menu.highlightImmediately, onEscape () { return Jm.close(t), e.onEscape.map(function (e) { return e(t) }), x.some(!0) }, onExecute () { return x.some(!0) }, onOpenMenu (e, t) { vm.positionWithinBounds(i().getOrDie(), n, t, o()) }, onOpenSubmenu (e, t, n, r) { const o = i().getOrDie(); vm.position(o, m({ anchor: 'submenu', item: t }, c(r)), n) }, onRepositionMenu (e, t, r) { const u = i().getOrDie(); vm.positionWithinBounds(u, n, t, o()), q(r, function (e) { const t = c(e.triggeringPath); vm.position(u, m({ anchor: 'submenu', item: e.triggeringItem }, t), e.triggeredMenu) }) } }) }; const xw = function (e, t) { const n = function (t, n) { const r = e.getRelated(t); return r.exists(function (e) { return ns(e, n) }) }; const r = function (e, t) { Jm.setContent(e, t) }; const o = function (e, t, n) { i(e, t, n, x.none()) }; var i = function (e, t, n, r) { u(e, t, n, function () { return r.map(function (e) { return Vc(e) }) }) }; var u = function (t, n, r, o) { const i = e.lazySink(t).getOrDie(); Jm.openWhileCloaked(t, r, function () { return vm.positionWithinBounds(i, n, t, o()) }), Bg.setValue(t, x.some({ mode: 'position', anchor: n, getBounds: o })) }; const a = function (e, t, n) { c(e, t, n, function () { return x.none() }) }; var c = function (t, n, r, o) { const i = ww(e, t, n, r, o); Jm.open(t, i), Bg.setValue(t, x.some({ mode: 'menu', menu: i })) }; const s = function (e) { Jm.isOpen(e) && (Bg.setValue(e, x.none()), Jm.close(e)) }; const l = function (e) { return Jm.getState(e) }; const f = function (t) { Jm.isOpen(t) && Bg.getValue(t).each(function (n) { switch (n.mode) { case 'menu':Jm.getState(t).each(function (e) { yw.repositionMenus(e) }); break; case 'position':var r = e.lazySink(t).getOrDie(); vm.positionWithinBounds(r, n.anchor, t, n.getBounds()); break } }) }; const d = { setContent: r, showAt: o, showWithin: i, showWithinBounds: u, showMenuAt: a, showMenuWithinBounds: c, hide: s, getContent: l, reposition: f, isOpen: Jm.isOpen }; return { uid: e.uid, dom: e.dom, behaviours: zg(e.inlineBehaviours, [Jm.config({ isPartOf (e, t, r) { return ns(t, r) || n(e, r) }, getAttachPoint (t) { return e.lazySink(t).getOrDie() }, onOpen (t) { e.onShow(t) }, onClose (t) { e.onHide(t) } }), Bg.config({ store: { mode: 'memory', initialValue: x.none() } }), _l.config({ channels: m(m({}, ng(m({ isExtraPart: t.isExtraPart }, e.fireDismissalEventInstead.map(function (e) { return { fireEventInstead: { event: e.event } } }).getOr({})))), og(m(m({}, e.fireRepositionEventInstead.map(function (e) { return { fireEventInstead: { event: e.event } } }).getOr({})), { doReposition: f }))) })]), eventOrder: e.eventOrder, apis: d } }; const Cw = $h({ name: 'InlineView', configFields: [cn('lazySink'), xs('onShow'), xs('onHide'), Sn('onEscape'), Mg('inlineBehaviours', [Jm, Bg, _l]), Tn('fireDismissalEventInstead', [On('event', Go())]), Tn('fireRepositionEventInstead', [On('event', Xo())]), On('getRelated', x.none), On('isExtraPart', l), On('eventOrder', x.none)], factory: xw, apis: { showAt (e, t, n, r) { e.showAt(t, n, r) }, showWithin (e, t, n, r, o) { e.showWithin(t, n, r, o) }, showWithinBounds (e, t, n, r, o) { e.showWithinBounds(t, n, r, o) }, showMenuAt (e, t, n, r) { e.showMenuAt(t, n, r) }, showMenuWithinBounds (e, t, n, r, o) { e.showMenuWithinBounds(t, n, r, o) }, hide (e, t) { e.hide(t) }, isOpen (e, t) { return e.isOpen(t) }, getContent (e, t) { return e.getContent(t) }, setContent (e, t, n) { e.setContent(t, n) }, reposition (e, t) { e.reposition(t) } } }); const Sw = function (e) { return e.x() }; const kw = function (e, t) { return e.x() + e.width() / 2 - t.width() / 2 }; const Tw = function (e, t) { return e.x() + e.width() - t.width() }; const Ew = function (e) { return e.y() }; const Ow = function (e, t) { return e.y() + e.height() - t.height() }; const Nw = function (e, t, n) { return Ns(Tw(e, t), Ow(e, t), n.innerSoutheast(), zs(), Us(e, { right: 0, bottom: 3 }), 'layout-inner-se') }; const _w = function (e, t, n) { return Ns(Sw(e), Ow(e, t), n.innerSouthwest(), Ps(), Us(e, { left: 1, bottom: 3 }), 'layout-inner-sw') }; const Dw = function (e, t, n) { return Ns(Tw(e, t), Ew(e), n.innerNortheast(), Ms(), Us(e, { right: 0, top: 2 }), 'layout-inner-ne') }; const Aw = function (e, t, n) { return Ns(Sw(e), Ew(e), n.innerNorthwest(), Bs(), Us(e, { left: 1, top: 2 }), 'layout-inner-nw') }; const Rw = function (e, t, n) { return Ns(kw(e, t), Ew(e), n.innerNorth(), Is(), Us(e, { top: 2 }), 'layout-inner-n') }; const Bw = function (e, t, n) { return Ns(kw(e, t), Ow(e, t), n.innerSouth(), Ls(), Us(e, { bottom: 3 }), 'layout-inner-s') }; const Mw = tinymce.util.Tools.resolve('tinymce.util.Delay'); const Pw = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const zw = tinymce.util.Tools.resolve('tinymce.EditorManager'); const Iw = function (e) { const t = e.settings; const n = t.skin; let r = t.skin_url; if (!1 !== n) { const o = n || 'oxide'; r = r ? e.documentBaseURI.toAbsolute(r) : zw.baseURL + '/skins/ui/' + o } return r }; const Lw = function (e) { return e.getParam('readonly', !1, 'boolean') }; const Hw = function (e) { return !1 === e.getParam('skin') }; const Fw = function (e) { return e.getParam('height', Math.max(e.getElement().offsetHeight, 200)) }; const Vw = function (e) { return e.getParam('width', Pw.DOM.getStyle(e.getElement(), 'width')) }; const Uw = function (e) { return x.from(e.settings.min_width).filter(B) }; const jw = function (e) { return x.from(e.settings.min_height).filter(B) }; const Ww = function (e) { return x.from(e.getParam('max_width')).filter(B) }; const qw = function (e) { return x.from(e.getParam('max_height')).filter(B) }; const $w = function (e) { return x.from(e.getParam('style_formats')).filter(D) }; const Gw = function (e) { return e.getParam('style_formats_merge', !1, 'boolean') }; const Xw = function (e) { return e.getParam('removed_menuitems', '') }; const Yw = function (e) { return !1 !== e.getParam('menubar', !0, 'boolean') }; const Kw = function (e) { const t = e.getParam('toolbar', !0); const n = !0 === t; const r = N(t); const o = D(t) && t.length > 0; return !Zw(e) && (o || r || n) }; const Jw = function (e) { const t = fe(e.settings); const n = X(t, function (e) { return /^toolbar([1-9])$/.test(e) }); const r = W(n, function (t) { return e.getParam(t, !1, 'string') }); const o = X(r, function (e) { return typeof e === 'string' }); return o.length > 0 ? x.some(o) : x.none() }; var Zw = function (e) { return Jw(e).fold(function () { const t = e.getParam('toolbar', [], 'string[]'); return t.length > 0 }, function () { return !0 }) }; (function (e) { e.default = 'wrap', e.floating = 'floating', e.sliding = 'sliding', e.scrolling = 'scrolling' })($p || ($p = {})); let Qw; const ex = function (e) { return e.getParam('toolbar_mode', '', 'string') }; (function (e) { e.top = 'top', e.bottom = 'bottom' })(Qw || (Qw = {})); const tx = function (e) { return e.getParam('toolbar_groups', {}, 'object') }; const nx = function (e) { return e.getParam('toolbar_location', Qw.top, 'string') !== Qw.bottom }; const rx = function (e) { return e.getParam('fixed_toolbar_container', '', 'string') }; const ox = function (e) { const t = rx(e); return t.length > 0 && e.inline ? Jc(Na(), t) : x.none() }; const ix = function (e) { return e.inline && ox(e).isSome() }; const ux = function (e) { const t = ox(e); return t.getOr(Na()) }; const ax = function (e) { return e.inline && !Yw(e) && !Kw(e) && !Zw(e) }; const cx = function (e) { const t = e.getParam('toolbar_sticky', !1, 'boolean'); return (t || e.inline) && !ix(e) && !ax(e) }; const sx = function (e) { return e.getParam('draggable_modal', !1, 'boolean') }; const lx = function (e) { const t = Ly(e.action); const n = e.dom.tag; const r = function (t) { return ye(e.dom, 'attributes').bind(function (e) { return ye(e, t) }) }; const o = function () { if (n === 'button') { const e = r('type').getOr('button'); const t = r('role').map(function (e) { return { role: e } }).getOr({}); return m({ type: e }, t) } const o = r('role').getOr('button'); return { role: o } }; return { uid: e.uid, dom: e.dom, components: e.components, events: t, behaviours: Ig.augment(e.buttonBehaviours, [vy.config({}), Kb.config({ mode: 'execution', useSpace: !0, useEnter: !0 })]), domModification: { attributes: o() }, eventOrder: e.eventOrder } }; const fx = $h({ name: 'Button', factory: lx, configFields: [On('uid', void 0), cn('dom'), On('components', []), Ig.field('buttonBehaviours', [vy, Kb]), yn('action'), yn('role'), On('eventOrder', {})] }); const dx = function (e) { const t = Uh(e) && xe(e, 'uid') ? e.uid : _u('memento'); const n = function (e) { return e.getSystem().getByUid(t).getOrDie() }; const r = function (e) { return e.getSystem().getByUid(t).toOption() }; const o = function () { return m(m({}, e), { uid: t }) }; return { get: n, getOpt: r, asSpec: o } }; const mx = function (e) { return x.from(e()['temporary-placeholder']).getOr('!not found!') }; const gx = function (e, t) { return x.from(t()[e]).getOrThunk(function () { return mx(t) }) }; const hx = function (e, t, n) { return x.from(t()[e]).or(n).getOrThunk(function () { return mx(t) }) }; const px = function (e, t) { return le(e, function (e) { return x.from(t()[e]) }).getOrThunk(function () { return mx(t) }) }; const vx = { success: 'checkmark', error: 'warning', err: 'error', warning: 'warning', warn: 'warning', info: 'info' }; const bx = function (e) { const t = dx({ dom: { tag: 'p', innerHtml: e.translationProvider(e.text) }, behaviours: yl([uy.config({})]) }); const n = function (e) { return { dom: { tag: 'div', classes: ['tox-bar'], attributes: { style: 'width: ' + e + '%' } } } }; const r = function (e) { return { dom: { tag: 'div', classes: ['tox-text'], innerHtml: e + '%' } } }; const o = dx({ dom: { tag: 'div', classes: e.progress ? ['tox-progress-bar', 'tox-progress-indicator'] : ['tox-progress-bar'] }, components: [{ dom: { tag: 'div', classes: ['tox-bar-container'] }, components: [n(0)] }, r(0)], behaviours: yl([uy.config({})]) }); const i = function (e, t) { e.getSystem().isConnected() && o.getOpt(e).each(function (e) { uy.set(e, [{ dom: { tag: 'div', classes: ['tox-bar-container'] }, components: [n(t)] }, r(t)]) }) }; const u = function (e, n) { if (e.getSystem().isConnected()) { const r = t.get(e); uy.set(r, [Qa(n)]) } }; const a = { updateProgress: i, updateText: u }; const c = Q([e.icon.toArray(), e.level.toArray(), e.level.bind(function (e) { return x.from(vx[e]) }).toArray()]); return { uid: e.uid, dom: { tag: 'div', attributes: { role: 'alert' }, classes: e.level.map(function (e) { return ['tox-notification', 'tox-notification--in', 'tox-notification--' + e] }).getOr(['tox-notification', 'tox-notification--in']) }, components: [{ dom: { tag: 'div', classes: ['tox-notification__icon'], innerHtml: px(c, e.iconProvider) } }, { dom: { tag: 'div', classes: ['tox-notification__body'] }, components: [t.asSpec()], behaviours: yl([uy.config({})]) }].concat(e.progress ? [o.asSpec()] : []).concat(e.closeButton ? [fx.sketch({ dom: { tag: 'button', classes: ['tox-notification__dismiss', 'tox-button', 'tox-button--naked', 'tox-button--icon'] }, components: [{ dom: { tag: 'div', classes: ['tox-icon'], innerHtml: gx('close', e.iconProvider), attributes: { 'aria-label': e.translationProvider('Close') } } }], action (t) { e.onAction(t) } })] : []), apis: a } }; const yx = $h({ name: 'Notification', factory: bx, configFields: [yn('level'), cn('progress'), cn('icon'), cn('onAction'), cn('text'), cn('iconProvider'), cn('translationProvider'), Rn('closeButton', !0)], apis: { updateProgress (e, t, n) { e.updateProgress(t, n) }, updateText (e, t, n) { e.updateText(t, n) } } }); function wx (e, t, n) { const r = t.backstage; const o = nx(e); const i = function (e) { switch (e) { case 'bc-bc':return Bw; case 'tc-tc':return Rw; case 'tc-bc':return nl; case 'bc-tc':default:return rl } }; const u = function (e) { q(e, function (e) { return e.moveTo(0, 0) }) }; const a = function (e) { e.length > 0 && (ae(e).each(function (e) { return e.moveRel(null, 'banner') }), q(e, function (t, n) { n > 0 && t.moveRel(e[n - 1].getEl(), 'bc-tc') })) }; const c = function (e) { u(e), a(e) }; const s = function (e, u) { const a = !e.closeButton && e.timeout && (e.timeout > 0 || e.timeout < 0); const c = function () { u(), Cw.hide(l) }; const s = nc(yx.sketch({ text: e.text, level: F(['success', 'error', 'warning', 'warn', 'info'], e.type) ? e.type : void 0, progress: !0 === e.progressBar, icon: x.from(e.icon), closeButton: !a, onAction: c, iconProvider: r.shared.providers.icons, translationProvider: r.shared.providers.translate })); var l = nc(Cw.sketch(m({ dom: { tag: 'div', classes: ['tox-notifications-container'] }, lazySink: t.backstage.shared.getSink, fireDismissalEventInstead: {} }, o ? {} : { fireRepositionEventInstead: {} }))); return n.add(l), e.timeout > 0 && Mw.setTimeout(function () { c() }, e.timeout), { close: c, moveTo (e, t) { Cw.showAt(l, { anchor: 'makeshift', x: e, y: t }, rc(s)) }, moveRel (e, n) { if (n !== 'banner') { const r = i(n); const o = { anchor: 'node', root: Na(), node: x.some(Wn.fromDom(e)), layouts: { onRtl () { return [r] }, onLtr () { return [r] } } }; Cw.showAt(l, o, rc(s)) } else { Cw.showAt(l, t.backstage.shared.anchors.banner(), rc(s)) } }, text (e) { yx.updateText(s, e) }, settings: e, getEl () { return s.element().dom() }, progressBar: { value (e) { yx.updateProgress(s, e) } } } }; const l = function (e) { e.close() }; const f = function (e) { return e.settings }; return { open: s, close: l, reposition: c, getArgs: f } } let xx; const Cx = function (e, n) { let r = null; const o = function () { r !== null && (t.clearTimeout(r), r = null) }; const i = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r === null && (r = t.setTimeout(function () { e.apply(null, o), r = null }, n)) }; return { cancel: o, throttle: i } }; const Sx = function (e, n) { let r = null; const o = function () { r !== null && (t.clearTimeout(r), r = null) }; const i = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r !== null && t.clearTimeout(r), r = t.setTimeout(function () { e.apply(null, o), r = null }, n) }; return { cancel: o, throttle: i } }; const kx = tinymce.util.Tools.resolve('tinymce.dom.TextSeeker'); const Tx = function (e, t) { return e.isBlock(t) || F(['BR', 'IMG', 'HR', 'INPUT'], t.nodeName) || e.getContentEditable(t) === 'false' }; const Ex = function (e, t, n, r, o) { const i = kx(e, function (t) { return Tx(e, t) }); return x.from(i.backwards(t, n, r, o)) }; const Ox = '[data-mce-autocompleter]'; const Nx = function (e, t) { return _x(Wn.fromDom(e.selection.getNode())).getOrThunk(function () { const n = Wn.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc()); return qi(n, Wn.fromDom(t.extractContents())), t.insertNode(n.dom()), Pi(n).each(function (e) { return e.dom().normalize() }), bd(n).map(function (t) { e.selection.setCursorLocation(t.dom(), gd(t)) }), n }) }; var _x = function (e) { return Zc(e, Ox) }; const Dx = function (e) { return e.collapsed && e.startContainer.nodeType === 3 }; const Ax = function (e) { return e.toString().replace(/\u00A0/g, ' ').replace(/\uFEFF/g, '') }; const Rx = function (e) { return e !== '' && '  \f\n\r\t\v'.includes(e) }; const Bx = function (e, t) { return e.substring(t.length) }; const Mx = function (e, t, n) { let r; for (r = t - 1; r >= 0; r--) { const o = e.charAt(r); if (Rx(o)) { return x.none() } if (o === n) { break } } return x.some(r) }; const Px = function (e, t, n, r) { if (void 0 === r && (r = 0), !Dx(t)) { return x.none() } const o = function (e, t, r) { return Mx(r, t, n).getOr(t) }; const i = e.getParent(t.startContainer, e.isBlock) || e.getRoot(); return Ex(e, t.startContainer, t.startOffset, o, i).bind(function (e) { const o = t.cloneRange(); if (o.setStart(e.container, e.offset), o.setEnd(t.endContainer, t.endOffset), o.collapsed) { return x.none() } const i = Ax(o); const u = i.lastIndexOf(n); return u !== 0 || Bx(i, n).length < r ? x.none() : x.some({ text: Bx(i, n), range: o, triggerChar: n }) }) }; const zx = function (e, t, n, r) { return void 0 === r && (r = 0), _x(Wn.fromDom(t.startContainer)).fold(function () { return Px(e, t, n, r) }, function (t) { const r = e.createRng(); r.selectNode(t.dom()); const o = Ax(r); return x.some({ range: r, text: Bx(o, n), triggerChar: n }) }) }; const Ix = function (e, t) { t.on('keypress compositionend', e.onKeypress.throttle), t.on('remove', e.onKeypress.cancel); const n = function (e, t) { ni(e, Co(), { raw: t }) }; t.on('keydown', function (t) { const r = function () { return e.getView().bind(Cp.getHighlighted) }; t.which === 8 && e.onKeypress.throttle(t), e.isActive() && (t.which === 27 && e.cancelIfNecessary(), e.isMenuOpen() ? t.which === 13 ? (r().each(ri), t.preventDefault()) : t.which === 40 ? (r().fold(function () { e.getView().each(Cp.highlightFirst) }, function (e) { n(e, t) }), t.preventDefault(), t.stopImmediatePropagation()) : t.which !== 37 && t.which !== 38 && t.which !== 39 || r().each(function (e) { n(e, t), t.preventDefault(), t.stopImmediatePropagation() }) : t.which !== 13 && t.which !== 38 && t.which !== 40 || e.cancelIfNecessary()) }), t.on('NodeChange', function (t) { e.isActive() && !e.isProcessingAction() && _x(Wn.fromDom(t.element)).isNone() && e.cancelIfNecessary() }) }; const Lx = { setup: Ix }; const Hx = tinymce.util.Tools.resolve('tinymce.util.Promise'); const Fx = function (e, t) { return { container: e, offset: t } }; const Vx = function (e) { return e.nodeType === t.Node.TEXT_NODE }; const Ux = function (e) { return e.nodeType === t.Node.ELEMENT_NODE }; var jx = function (e) { if (Vx(e)) { return Fx(e, e.data.length) } const t = e.childNodes; return t.length > 0 ? jx(t[t.length - 1]) : Fx(e, t.length) }; var Wx = function (e, t) { const n = e.childNodes; return n.length > 0 && t < n.length ? Wx(n[t], 0) : n.length > 0 && Ux(e) && n.length === t ? jx(n[n.length - 1]) : Fx(e, t) }; const qx = function (e, t) { return Ex(e, t.container, t.offset, function (e, t) { return t === 0 ? -1 : t }, e.getRoot()).filter(function (e) { const t = e.container.data.charAt(e.offset - 1); return !Rx(t) }).isSome() }; const $x = function (e) { return function (t) { const n = Wx(t.startContainer, t.startOffset); return !qx(e, n) } }; const Gx = function (e, t, n) { return le(n.triggerChars, function (n) { return zx(e, t, n) }) }; const Xx = function (e, t) { const n = t(); const r = e.selection.getRng(); return Gx(e.dom, r, n).bind(function (n) { return Yx(e, t, n) }) }; var Yx = function (e, t, n, r) { void 0 === r && (r = {}); const o = t(); const i = e.selection.getRng(); const u = i.startContainer.nodeValue; const a = X(o.lookupByChar(n.triggerChar), function (t) { return n.text.length >= t.minChars && t.matches.getOrThunk(function () { return $x(e.dom) })(n.range, u, n.text) }); if (a.length === 0) { return x.none() } const c = Hx.all(W(a, function (e) { const t = e.fetch(n.text, e.maxResults, r); return t.then(function (t) { return { matchText: n.text, items: t, columns: e.columns, onAction: e.onAction } }) })); return x.some({ lookupData: c, context: n }) }; const Kx = _t([fn('type'), Cn('text')]); const Jx = function (e) { return $t('separatormenuitem', Kx, e) }; const Zx = _t([In('type', function () { return 'autocompleteitem' }), In('active', function () { return !1 }), In('disabled', function () { return !1 }), On('meta', {}), fn('value'), Cn('text'), Cn('icon')]); const Qx = _t([fn('type'), fn('ch'), _n('minChars', 1), On('columns', 1), _n('maxResults', 10), Sn('matches'), gn('fetch'), gn('onAction')]); const eC = function (e) { return $t('Autocompleter.Separator', Kx, e) }; const tC = function (e) { return $t('Autocompleter.Item', Zx, e) }; const nC = function (e) { return $t('Autocompleter', Qx, e) }; const rC = function (e) { const t = {}; return q(e, function (e) { t[e] = {} }), fe(t) }; const oC = function (e) { const t = e.ui.registry.getAll().popups; const n = ge(t, function (e) { return nC(e).fold(function (e) { throw new Error(Yt(e)) }, function (e) { return e }) }); const r = rC(pe(n, function (e) { return e.ch })); const o = be(n); const i = function (e) { return X(o, function (t) { return t.ch === e }) }; return { dataset: n, triggerChars: r, lookupByChar: i } }; const iC = [Rn('disabled', !1), Cn('text'), Cn('shortcut'), zt('value', 'value', Ge(function () { return xu('menuitem-value') }), Zt()), On('meta', {})]; const uC = _t([fn('type'), Bn('onSetup', function () { return n }), Bn('onAction', n), Cn('icon')].concat(iC)); const aC = function (e) { return $t('menuitem', uC, e) }; const cC = _t([fn('type'), gn('getSubmenuItems'), Bn('onSetup', function () { return n }), Cn('icon')].concat(iC)); const sC = function (e) { return $t('nestedmenuitem', cC, e) }; const lC = _t([fn('type'), Rn('active', !1), Bn('onSetup', function () { return n }), gn('onAction')].concat(iC)); const fC = function (e) { return $t('togglemenuitem', lC, e) }; const dC = _t([fn('type'), Rn('active', !1), Cn('icon')].concat(iC)); const mC = function (e) { return $t('choicemenuitem', dC, e) }; const gC = ['inserttable', 'colorswatch']; const hC = _t([fn('type'), dn('fancytype', gC), Bn('onAction', n)]); const pC = function (e) { return $t('fancymenuitem', hC, e) }; const vC = function (e, t, n) { const r = wd(e.element(), '.' + n); if (r.length > 0) { const o = Z(r, function (e) { const n = e.dom().getBoundingClientRect().top; const o = r[0].dom().getBoundingClientRect().top; return Math.abs(n - o) > t }).getOr(r.length); return x.some({ numColumns: o, numRows: Math.ceil(r.length / o) }) } return x.none() }; const bC = function (e, t) { return yl([cy(e, t)]) }; const yC = function (e) { return bC(xu('unnamed-events'), e) }; const wC = { namedEvents: bC, unnamedEvents: yC }; const xC = [cn('lazySink'), cn('tooltipDom'), On('exclusive', !0), On('tooltipComponents', []), On('delay', 300), An('mode', 'normal', ['normal', 'follow-highlight']), On('anchor', function (e) { return { anchor: 'hotspot', hotspot: e, layouts: { onLtr: i([rl, nl, Zs, el, Qs, tl]), onRtl: i([rl, nl, Zs, el, Qs, tl]) } } }), xs('onHide'), xs('onShow')]; const CC = function () { const e = Ln(x.none()); const n = Ln(x.none()); const r = function () { return n.get() }; const o = function (e) { n.set(x.some(e)) }; const u = function () { n.set(x.none()) }; const a = function () { e.get().each(function (e) { t.clearTimeout(e) }) }; const c = function (n, r) { a(), e.set(x.some(t.setTimeout(function () { n() }, r))) }; const s = function () { return n.get().isSome() }; const l = i('not-implemented'); return Uu({ getTooltip: r, isShowing: s, setTooltip: o, clearTooltip: u, clearTimer: a, resetTimer: c, readState: l }) }; const SC = Object.freeze({ __proto__: null, init: CC }); const kC = xu('tooltip.exclusive'); const TC = xu('tooltip.show'); const EC = xu('tooltip.hide'); const OC = function (e, t, n) { e.getSystem().broadcastOn([kC], {}) }; const NC = function (e, t, n, r) { n.getTooltip().each(function (e) { e.getSystem().isConnected() && uy.set(e, r) }) }; const _C = Object.freeze({ __proto__: null, hideAllExclusive: OC, setComponents: NC }); const DC = function (e, t) { const n = function (n) { t.getTooltip().each(function (r) { Em(r), e.onHide(n, r), t.clearTooltip() }), t.clearTimer() }; const r = function (n) { if (!t.isShowing()) { OC(n); const r = e.lazySink(n).getOrDie(); const o = n.getSystem().build({ dom: e.tooltipDom, components: e.tooltipComponents, events: ai(e.mode === 'normal' ? [fi(yo(), function (e) { ti(n, TC) }), fi(vo(), function (e) { ti(n, EC) })] : []), behaviours: yl([uy.config({})]) }); t.setTooltip(o), Sm(r, o), e.onShow(n, o), vm.position(r, e.anchor(n), o) } }; return ai(Q([[fi(TC, function (n) { t.resetTimer(function () { r(n) }, e.delay) }), fi(EC, function (r) { t.resetTimer(function () { n(r) }, e.delay) }), fi(Bo(), function (e, t) { const r = t; F(r.channels(), kC) && n(e) }), Ci(function (e) { n(e) })], e.mode === 'normal' ? [fi(wo(), function (e) { ti(e, TC) }), fi(Ao(), function (e) { ti(e, EC) }), fi(yo(), function (e) { ti(e, TC) }), fi(vo(), function (e) { ti(e, EC) })] : [fi(Qo(), function (e, t) { ti(e, TC) }), fi(ei(), function (e) { ti(e, EC) })]])) }; const AC = Object.freeze({ __proto__: null, events: DC }); const RC = xl({ fields: xC, name: 'tooltipping', active: AC, state: SC, apis: _C }); const BC = tinymce.util.Tools.resolve('tinymce.util.I18n'); const MC = 'tox-menu-nav__js'; const PC = 'tox-collection__item'; const zC = 'tox-swatch'; const IC = { normal: MC, color: zC }; const LC = 'tox-collection__item--enabled'; const HC = 'tox-collection__group-heading'; const FC = 'tox-collection__item-icon'; const VC = 'tox-collection__item-label'; const UC = 'tox-collection__item-accessory'; const jC = 'tox-collection__item-caret'; const WC = 'tox-collection__item-checkmark'; const qC = 'tox-collection__item--active'; const $C = 'tox-collection__item-icon-rtl'; const GC = function (e) { return ye(IC, e).getOr(MC) }; const XC = tinymce.util.Tools.resolve('tinymce.Env'); const YC = function (e) { const t = { alt: '&#x2325;', ctrl: '&#x2303;', shift: '&#x21E7;', meta: '&#x2318;', access: '&#x2303;&#x2325;' }; const n = { meta: 'Ctrl', access: 'Shift+Alt' }; const r = XC.mac ? t : n; const o = e.split('+'); const i = W(o, function (e) { const t = e.toLowerCase().trim(); return we(r, t) ? r[t] : e }); return XC.mac ? i.join('') : i.join('+') }; const KC = { convertText: YC }; const JC = function (e) { return { dom: { tag: 'div', classes: [FC], innerHtml: e } } }; const ZC = function (e) { return { dom: { tag: 'div', classes: [VC] }, components: [Qa(BC.translate(e))] } }; const QC = function (e) { return { dom: { tag: 'div', classes: [VC], innerHtml: e } } }; const eS = function (e, t) { return { dom: { tag: 'div', classes: [VC] }, components: [{ dom: { tag: e.tag, styles: e.styles }, components: [Qa(BC.translate(t))] }] } }; const tS = function (e) { return { dom: { tag: 'div', classes: [UC], innerHtml: KC.convertText(e) } } }; const nS = function (e) { return { dom: { tag: 'div', classes: [FC, WC], innerHtml: gx('checkmark', e) } } }; const rS = function (e) { return { dom: { tag: 'div', classes: [jC], innerHtml: gx('chevron-right', e) } } }; const oS = function (e) { return { dom: { tag: 'div', classes: [jC], innerHtml: gx('chevron-down', e) } } }; const iS = function (e, t, n, r) { const o = 'custom'; const i = 'remove'; const u = function () { const u = zC; const a = n.getOr(''); const c = e.map(function (e) { return { title: r.translate(e) } }).getOr({}); const s = { tag: 'div', attributes: c, classes: [u] }; return m(m({}, s), t === o ? { tag: 'button', classes: h(s.classes, ['tox-swatches__picker-btn']), innerHtml: a } : t === i ? { classes: h(s.classes, ['tox-swatch--remove']), innerHtml: a } : { attributes: m(m({}, s.attributes), { 'data-mce-color': t }), styles: { 'background-color': t } }) }; return { dom: u(), optComponents: [] } }; const uS = function (e, t, n, r, o) { const i = n ? e.checkMark.orThunk(function () { return t.or(x.some('')).map(JC) }) : x.none(); const u = e.ariaLabel.map(function (e) { return { attributes: { title: BC.translate(e) } } }).getOr({}); const a = m({ tag: 'div', classes: [MC, PC].concat(o ? [$C] : []) }, u); const c = e.htmlContent.fold(function () { return e.textContent.map(r) }, function (e) { return x.some(QC(e)) }); const s = { dom: a, optComponents: [i, c, e.shortcutContent.map(tS), e.caret] }; return s }; const aS = ['list-num-default', 'list-num-lower-alpha', 'list-num-lower-greek', 'list-num-lower-roman', 'list-num-upper-alpha', 'list-num-upper-roman']; const cS = ['list-bull-circle', 'list-bull-default', 'list-bull-square']; const sS = function (e, t, n, r) { void 0 === r && (r = x.none()); const o = function (e) { return e.map(function (e) { return BC.isRtl() && F(aS, e) ? e + '-rtl' : e }) }; const i = BC.isRtl() && e.iconContent.exists(function (e) { return F(cS, e) }); const u = o(e.iconContent).map(function (e) { return hx(e, t.icons, r) }); const c = x.from(e.meta).fold(function () { return ZC }, function (e) { return we(e, 'style') ? a(eS, e.style) : ZC }); return e.presets === 'color' ? iS(e.ariaLabel, e.value, u, t) : uS(e, u, n, c, i) }; const lS = ['input', 'button', 'textarea', 'select']; const fS = function (e, t, n) { t.disabled && yS(e, t) }; const dS = function (e, t) { return !0 === t.useNative && F(lS, tu(e.element())) }; const mS = function (e) { return fu(e.element(), 'disabled') }; const gS = function (e) { au(e.element(), 'disabled', 'disabled') }; const hS = function (e) { du(e.element(), 'disabled') }; const pS = function (e) { return su(e.element(), 'aria-disabled') === 'true' }; const vS = function (e) { au(e.element(), 'aria-disabled', 'true') }; const bS = function (e) { au(e.element(), 'aria-disabled', 'false') }; var yS = function (e, t, n) { t.disableClass.each(function (t) { wa(e.element(), t) }); const r = dS(e, t) ? gS : vS; r(e), t.onDisabled(e) }; const wS = function (e, t, n) { t.disableClass.each(function (t) { Ca(e.element(), t) }); const r = dS(e, t) ? hS : bS; r(e), t.onEnabled(e) }; const xS = function (e, t) { return dS(e, t) ? mS(e) : pS(e) }; const CS = function (e, t, n, r) { const o = r ? yS : wS; o(e, t, n) }; const SS = Object.freeze({ __proto__: null, enable: wS, disable: yS, isDisabled: xS, onLoad: fS, set: CS }); const kS = function (e, t) { return Gu({ classes: t.disabled ? t.disableClass.map(ie).getOr([]) : [] }) }; const TS = function (e, t) { return ai([ci(Mo(), function (t, n) { return xS(t, e) }), ml(e, t, fS)]) }; const ES = Object.freeze({ __proto__: null, exhibit: kS, events: TS }); const OS = [On('disabled', !1), On('useNative', !0), yn('disableClass'), xs('onDisabled'), xs('onEnabled')]; const NS = xl({ fields: OS, name: 'disabling', active: ES, apis: SS }); const _S = function (e) { return NS.config({ disabled: e, disableClass: 'tox-collection__item--state-disabled' }) }; const DS = function (e) { return NS.config({ disabled: e }) }; const AS = function (e) { return NS.config({ disabled: e, disableClass: 'tox-tbtn--disabled' }) }; const RS = function (e) { return NS.config({ disabled: e, disableClass: 'tox-tbtn--disabled', useNative: !1 }) }; const BS = { item: _S, button: DS, splitButton: AS, toolbarButton: RS }; const MS = function (e, t) { const n = e.getApi(t); return function (e) { e(n) } }; const PS = function (e, t) { return xi(function (n) { const r = MS(e, n); r(function (n) { const r = e.onSetup(n); r !== null && void 0 !== r && t.set(r) }) }) }; const zS = function (e, t) { return Ci(function (n) { return MS(e, n)(t.get()) }) }; (function (e) { e[e.CLOSE_ON_EXECUTE = 0] = 'CLOSE_ON_EXECUTE', e[e.BUBBLE_TO_SANDBOX = 1] = 'BUBBLE_TO_SANDBOX' })(xx || (xx = {})); const IS = xx; const LS = function (e, t) { return ki(function (n, r) { MS(e, n)(e.onAction), e.triggersSubmenu || t !== IS.CLOSE_ON_EXECUTE || (ti(n, Lo()), r.stop()) }) }; const HS = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'item-events'] }; const FS = function (e) { return ee(e, function (e) { return e.toArray() }) }; const VS = function (e, t, r) { const o = Ln(n); return { type: 'item', dom: t.dom, components: FS(t.optComponents), data: e.data, eventOrder: HS, hasSubmenu: e.triggersSubmenu, itemBehaviours: yl([cy('item-events', [LS(e, r), PS(e, o), zS(e, o)]), BS.item(e.disabled), uy.config({})].concat(e.itemBehaviours)) } }; const US = function (e) { return { value: e.value, meta: m({ text: e.text.getOr('') }, e.meta) } }; const jS = function (e, t) { return ye(e, 'tooltipWorker').map(function (e) { return [RC.config({ lazySink: t.getSink, tooltipDom: { tag: 'div', classes: ['tox-tooltip-worker-container'] }, tooltipComponents: [], anchor (e) { return { anchor: 'submenu', item: e, overrides: { maxHeightFunction: mf } } }, mode: 'follow-highlight', onShow (t, n) { e(function (e) { RC.setComponents(t, [ec({ element: Wn.fromDom(e) })]) }) } })] }).getOr([]) }; const WS = function (e) { return e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') }; const qS = function (e) { return Pw.DOM.encode(e) }; const $S = function (e, t) { const n = BC.translate(e); const r = qS(n); if (t.length > 0) { const o = new RegExp(WS(t), 'gi'); return r.replace(o, function (e) { return '<span class="tox-autocompleter-highlight">' + e + '</span>' }) } return r }; const GS = function (e, t, n, r, o, i, u, a) { void 0 === a && (a = !0); const c = sS({ presets: r, textContent: x.none(), htmlContent: n ? e.text.map(function (e) { return $S(e, t) }) : x.none(), ariaLabel: e.text, iconContent: e.icon, shortcutContent: x.none(), checkMark: x.none(), caret: x.none(), value: e.value }, u.providers, a, e.icon); return VS({ data: US(e), disabled: e.disabled, getApi () { return {} }, onAction (t) { return o(e.value, e.meta) }, onSetup () { return function () {} }, triggersSubmenu: !1, itemBehaviours: jS(e.meta, u) }, c, i) }; const XS = function (e, t, n, r, o, i, u) { const a = function (e) { return { setActive (t) { zy.set(e, t) }, isActive () { return zy.isOn(e) }, isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const c = sS({ presets: n, textContent: t ? e.text : x.none(), htmlContent: x.none(), ariaLabel: e.text, iconContent: e.icon, shortcutContent: t ? e.shortcut : x.none(), checkMark: t ? x.some(nS(u.icons)) : x.none(), caret: x.none(), value: e.value }, u, !0); return Ne(VS({ data: US(e), disabled: e.disabled, getApi: a, onAction (t) { return r(e.value) }, onSetup (e) { return e.setActive(o), function () {} }, triggersSubmenu: !1, itemBehaviours: [] }, c, i), { toggling: { toggleClass: LC, toggleOnExecute: !1, selected: e.active } }) }; const YS = i(wh(Yy(), Ky())); const KS = xu('cell-over'); const JS = xu('cell-execute'); const ZS = function (e, t, n) { let r; const o = function (n) { return ni(n, KS, { row: e, col: t }) }; const i = function (n) { return ni(n, JS, { row: e, col: t }) }; const u = function (e, t) { t.stop(), i(e) }; return nc({ dom: { tag: 'div', attributes: (r = { role: 'button' }, r['aria-labelledby'] = n, r) }, behaviours: yl([cy('insert-table-picker-cell', [fi(yo(), vy.focus), fi(Mo(), i), fi(Eo(), u), fi(zo(), u)]), zy.config({ toggleClass: 'tox-insert-table-picker__selected', toggleOnExecute: !1 }), vy.config({ onFocus: o })]) }) }; const QS = function (e, t, n) { for (var r = [], o = 0; o < t; o++) { for (var i = [], u = 0; u < n; u++) { i.push(ZS(o, u, e)) }r.push(i) } return r }; const ek = function (e, t, n, r, o) { for (let i = 0; i < r; i++) { for (let u = 0; u < o; u++) { zy.set(e[i][u], i <= t && u <= n) } } }; const tk = function (e) { return ee(e, function (e) { return W(e, rc) }) }; const nk = function (e, t) { return Qa(t + 1 + 'x' + (e + 1)) }; function rk (e) { const t = 10; const n = 10; const r = xu('size-label'); const o = QS(r, t, n); const i = dx({ dom: { tag: 'span', classes: ['tox-insert-table-picker__label'], attributes: { id: r } }, components: [Qa('0x0')], behaviours: yl([uy.config({})]) }); return { type: 'widget', data: { value: xu('widget-id') }, dom: { tag: 'div', classes: ['tox-fancymenuitem'] }, autofocus: !0, components: [YS().widget({ dom: { tag: 'div', classes: ['tox-insert-table-picker'] }, components: tk(o).concat(i.asSpec()), behaviours: yl([cy('insert-table-picker', [vi(KS, function (e, r, u) { const a = u.event().row(); const c = u.event().col(); ek(o, a, c, t, n), uy.set(i.get(e), [nk(a, c)]) }), vi(JS, function (t, n, r) { e.onAction({ numRows: r.event().row() + 1, numColumns: r.event().col() + 1 }), ti(t, Lo()) })]), Kb.config({ initSize: { numRows: t, numColumns: n }, mode: 'flatgrid', selector: '[role="button"]' })]) })] } } const ok = function (e) { return { value: i(e) } }; const ik = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; const uk = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; const ak = function (e) { return ik.test(e) || uk.test(e) }; const ck = function (e) { const t = e.value().replace(ik, function (e, t, n, r) { return t + t + n + n + r + r }); return { value: i(t) } }; const sk = function (e) { const t = ck(e); const n = uk.exec(t.value()); return n === null ? ['FFFFFF', 'FF', 'FF', 'FF'] : n }; const lk = function (e) { const t = e.toString(16); return t.length === 1 ? '0' + t : t }; const fk = function (e) { const t = lk(e.red()) + lk(e.green()) + lk(e.blue()); return ok(t) }; const dk = Math.min; const mk = Math.max; const gk = Math.round; const hk = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/; const pk = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/; const vk = function (e, t, n, r) { return { red: i(e), green: i(t), blue: i(n), alpha: i(r) } }; const bk = function (e) { const t = parseInt(e, 10); return t.toString() === e && t >= 0 && t <= 255 }; const yk = function (e) { let t; let n; let r; const o = (e.hue() || 0) % 360; let i = e.saturation() / 100; let u = e.value() / 100; if (i = mk(0, dk(i, 1)), u = mk(0, dk(u, 1)), i === 0) { return t = n = r = gk(255 * u), vk(t, n, r, 1) } const a = o / 60; const c = u * i; const s = c * (1 - Math.abs(a % 2 - 1)); const l = u - c; switch (Math.floor(a)) { case 0:t = c, n = s, r = 0; break; case 1:t = s, n = c, r = 0; break; case 2:t = 0, n = c, r = s; break; case 3:t = 0, n = s, r = c; break; case 4:t = s, n = 0, r = c; break; case 5:t = c, n = 0, r = s; break; default:t = n = r = 0 } return t = gk(255 * (t + l)), n = gk(255 * (n + l)), r = gk(255 * (r + l)), vk(t, n, r, 1) }; const wk = function (e) { const t = sk(e); const n = parseInt(t[1], 16); const r = parseInt(t[2], 16); const o = parseInt(t[3], 16); return vk(n, r, o, 1) }; const xk = function (e, t, n, r) { const o = parseInt(e, 10); const i = parseInt(t, 10); const u = parseInt(n, 10); const a = parseFloat(r); return vk(o, i, u, a) }; const Ck = function (e) { if (e === 'transparent') { return x.some(vk(0, 0, 0, 0)) } const t = hk.exec(e); if (t !== null) { return x.some(xk(t[1], t[2], t[3], '1')) } const n = pk.exec(e); return n !== null ? x.some(xk(n[1], n[2], n[3], n[4])) : x.none() }; const Sk = function (e) { return 'rgba(' + e.red() + ',' + e.green() + ',' + e.blue() + ',' + e.alpha() + ')' }; const kk = i(vk(255, 0, 0, 1)); const Tk = tinymce.util.Tools.resolve('tinymce.util.LocalStorage'); const Ek = 'tinymce-custom-colors'; function Ok (e) { void 0 === e && (e = 10); const t = Tk.getItem(Ek); const n = N(t) ? JSON.parse(t) : []; const r = function (t) { const n = e - t.length; return n < 0 ? t.slice(0, e) : t }; const o = r(n); const i = function (t) { H(o, t).each(u), o.unshift(t), o.length > e && o.pop(), Tk.setItem(Ek, JSON.stringify(o)) }; var u = function (e) { o.splice(e, 1) }; const a = function () { return o.slice(0) }; return { add: i, state: a } } const Nk = 'choiceitem'; const _k = [{ type: Nk, text: 'Light Green', value: '#BFEDD2' }, { type: Nk, text: 'Light Yellow', value: '#FBEEB8' }, { type: Nk, text: 'Light Red', value: '#F8CAC6' }, { type: Nk, text: 'Light Purple', value: '#ECCAFA' }, { type: Nk, text: 'Light Blue', value: '#C2E0F4' }, { type: Nk, text: 'Green', value: '#2DC26B' }, { type: Nk, text: 'Yellow', value: '#F1C40F' }, { type: Nk, text: 'Red', value: '#E03E2D' }, { type: Nk, text: 'Purple', value: '#B96AD9' }, { type: Nk, text: 'Blue', value: '#3598DB' }, { type: Nk, text: 'Dark Turquoise', value: '#169179' }, { type: Nk, text: 'Orange', value: '#E67E23' }, { type: Nk, text: 'Dark Red', value: '#BA372A' }, { type: Nk, text: 'Dark Purple', value: '#843FA1' }, { type: Nk, text: 'Dark Blue', value: '#236FA1' }, { type: Nk, text: 'Light Gray', value: '#ECF0F1' }, { type: Nk, text: 'Medium Gray', value: '#CED4D9' }, { type: Nk, text: 'Gray', value: '#95A5A6' }, { type: Nk, text: 'Dark Gray', value: '#7E8C8D' }, { type: Nk, text: 'Navy Blue', value: '#34495E' }, { type: Nk, text: 'Black', value: '#000000' }, { type: Nk, text: 'White', value: '#ffffff' }]; const Dk = Ok(10); const Ak = function (e) { const n = []; const r = t.document.createElement('canvas'); r.height = 1, r.width = 1; for (var o = r.getContext('2d'), i = function (e, t) { const n = 255; const r = t / 255; const o = Math.round(e * r + n * (1 - r)); return ('0' + o.toString(16)).slice(-2).toUpperCase() }, u = function (e) { if (/^[0-9A-Fa-f]{6}$/.test(e)) { return '#' + e.toUpperCase() } o.clearRect(0, 0, r.width, r.height), o.fillStyle = '#FFFFFF', o.fillStyle = e, o.fillRect(0, 0, 1, 1); const t = o.getImageData(0, 0, 1, 1).data; const n = t[0]; const u = t[1]; const a = t[2]; const c = t[3]; return '#' + i(n, c) + i(u, c) + i(a, c) }, a = 0; a < e.length; a += 2) { n.push({ text: e[a + 1], value: u(e[a]), type: 'choiceitem' }) } return n }; const Rk = function (e, t) { return e.getParam('color_cols', t, 'number') }; const Bk = function (e) { return !1 !== e.getParam('custom_colors') }; const Mk = function (e) { return e.getParam('color_map') }; const Pk = function (e) { const t = Mk(e); return void 0 !== t ? Ak(t) : _k }; const zk = function () { return W(Dk.state(), function (e) { return { type: Nk, text: e, value: e } }) }; const Ik = function (e) { Dk.add(e) }; const Lk = { mapColors: Ak, getColorCols: Rk, hasCustomColors: Bk, getColorMap: Mk, getColors: Pk, getCurrentColors: zk, addColor: Ik }; const Hk = function (e) { return e.fire('SkinLoaded') }; const Fk = function (e, t) { return e.fire('SkinLoadError', t) }; const Vk = function (e) { return e.fire('ResizeEditor') }; const Uk = function (e) { return e.fire('BeforeRenderUI') }; const jk = function (e, t) { return e.fire('ResizeContent', t) }; const Wk = function (e, t) { return e.fire('ScrollContent', t) }; const qk = function (e, t) { return e.fire('TextColorChange', t) }; const $k = { fireSkinLoaded: Hk, fireSkinLoadError: Fk, fireResizeEditor: Vk, fireScrollContent: Wk, fireBeforeRenderUI: Uk, fireResizeContent: jk, fireTextColorChange: qk }; const Gk = function (e, t) { let n; return e.dom.getParents(e.selection.getStart(), function (e) { let r; (r = e.style[t === 'forecolor' ? 'color' : 'background-color']) && (n = n || r) }), n }; const Xk = function (e, t, n) { e.undoManager.transact(function () { e.focus(), e.formatter.apply(t, { value: n }), e.nodeChanged() }) }; const Yk = function (e, t) { e.undoManager.transact(function () { e.focus(), e.formatter.remove(t, { value: null }, null, !0), e.nodeChanged() }) }; const Kk = function (e) { e.addCommand('mceApplyTextcolor', function (t, n) { Xk(e, t, n) }), e.addCommand('mceRemoveTextcolor', function (t) { Yk(e, t) }) }; const Jk = function (e) { return Math.max(5, Math.ceil(Math.sqrt(e))) }; const Zk = function (e) { const t = Lk.getColors(e); const n = Jk(t.length); return Lk.getColorCols(e, n) }; const Qk = function (e) { const t = 'choiceitem'; const n = { type: t, text: 'Remove color', icon: 'color-swatch-remove-color', value: 'remove' }; const r = { type: t, text: 'Custom color', icon: 'color-picker', value: 'custom' }; return e ? [n, r] : [n] }; const eT = function (e, t, n, r) { if (n === 'custom') { const o = uT(e); o(function (n) { n.each(function (n) { Lk.addColor(n), e.execCommand('mceApplyTextcolor', t, n), r(n) }) }, '#000000') } else { n === 'remove' ? (r(''), e.execCommand('mceRemoveTextcolor', t)) : (r(n), e.execCommand('mceApplyTextcolor', t, n)) } }; const tT = function (e, t) { return e.concat(Lk.getCurrentColors().concat(Qk(t))) }; const nT = function (e, t) { return function (n) { n(tT(e, t)) } }; const rT = function (e, t, n) { const r = function (t, n) { e.setIconFill(t, n), e.setIconStroke(t, n) }; const o = t === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color'; r(o, n) }; const oT = function (e, t, n, r, o) { e.ui.registry.addSplitButton(t, { tooltip: r, presets: 'color', icon: t === 'forecolor' ? 'text-color' : 'highlight-bg-color', select (t) { const r = x.from(Gk(e, n)); return r.bind(function (e) { return Ck(e).map(function (e) { const n = fk(e).value(); return _r(t.toLowerCase(), n) }) }).getOr(!1) }, columns: Zk(e), fetch: nT(Lk.getColors(e), Lk.hasCustomColors(e)), onAction (t) { o.get() !== null && eT(e, n, o.get(), function () {}) }, onItemAction (r, i) { eT(e, n, i, function (n) { o.set(n), $k.fireTextColorChange(e, { name: t, color: n }) }) }, onSetup (n) { o.get() !== null && rT(n, t, o.get()); const r = function (e) { e.name === t && rT(n, e.name, e.color) }; return e.on('TextColorChange', r), function () { e.off('TextColorChange', r) } } }) }; const iT = function (e, t, r, o) { e.ui.registry.addNestedMenuItem(t, { text: o, icon: t === 'forecolor' ? 'text-color' : 'highlight-bg-color', getSubmenuItems () { return [{ type: 'fancymenuitem', fancytype: 'colorswatch', onAction (t) { eT(e, r, t.value, n) } }] } }) }; var uT = function (e) { return function (t, n) { const r = function (e) { return function (t) { const n = t.getData(); e(x.from(n.colorpicker)), t.close() } }; const o = function (e, t) { t.name === 'hex-valid' && (t.value ? e.enable('ok') : e.disable('ok')) }; const i = { colorpicker: n }; const u = r(t); e.windowManager.open({ title: 'Color Picker', size: 'normal', body: { type: 'panel', items: [{ type: 'colorpicker', name: 'colorpicker', label: 'Color' }] }, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: i, onAction: o, onSubmit: u, onClose () {}, onCancel () { t(x.none()) } }) } }; const aT = function (e) { Kk(e); const t = Ln(null); const n = Ln(null); oT(e, 'forecolor', 'forecolor', 'Text color', t), oT(e, 'backcolor', 'hilitecolor', 'Background color', n), iT(e, 'forecolor', 'forecolor', 'Text color'), iT(e, 'backcolor', 'hilitecolor', 'Background color') }; const cT = { register: aT, getColors: tT, getFetch: nT, colorPickerDialog: uT, getCurrentColor: Gk, getColorCols: Zk, calcCols: Jk }; const sT = function (e) { return e === 'color' ? 'tox-swatches' : 'tox-menu' }; const lT = function (e) { return { backgroundMenu: 'tox-background-menu', selectedMenu: 'tox-selected-menu', selectedItem: 'tox-collection__item--active', hasIcons: 'tox-menu--has-icons', menu: sT(e), tieredMenu: 'tox-tiered-menu' } }; const fT = function (e) { const t = lT(e); return { backgroundMenu: t.backgroundMenu, selectedMenu: t.selectedMenu, menu: t.menu, selectedItem: t.selectedItem, item: GC(e) } }; const dT = function (e, t, n) { const r = lT(n); return { tag: 'div', classes: Q([[r.menu, 'tox-menu-' + t + '-column'], e ? [r.hasIcons] : []]) } }; const mT = [aw.parts().items({})]; const gT = function (e, t, n) { const r = lT(n); const o = { tag: 'div', classes: Q([[r.tieredMenu]]) }; return { dom: o, markers: fT(n) } }; const hT = function (e, t) { return function (n) { const r = j(n, t); return W(r, function (t) { return { dom: e, components: t } }) } }; const pT = function (e) { return { dom: { tag: 'div', classes: ['tox-menu', 'tox-swatches-menu'] }, components: [{ dom: { tag: 'div', classes: ['tox-swatches'] }, components: [aw.parts().items({ preprocess: e !== 'auto' ? hT({ tag: 'div', classes: ['tox-swatches__row'] }, e) : u })] }] } }; const vT = function (e) { return { dom: { tag: 'div', classes: ['tox-menu', 'tox-collection', 'tox-collection--toolbar', 'tox-collection--toolbar-lg'] }, components: [aw.parts().items({ preprocess: hT({ tag: 'div', classes: ['tox-collection__group'] }, e) })] } }; const bT = function (e, t) { const n = []; let r = []; return q(e, function (e, o) { t(e, o) ? (r.length > 0 && n.push(r), r = [], we(e.dom, 'innerHtml') && r.push(e)) : r.push(e) }), r.length > 0 && n.push(r), W(n, function (e) { return { dom: { tag: 'div', classes: ['tox-collection__group'] }, components: e } }) }; const yT = function (e, t, n) { return { dom: { tag: 'div', classes: ['tox-menu', 'tox-collection'].concat(e === 1 ? ['tox-collection--list'] : ['tox-collection--grid']) }, components: [aw.parts().items({ preprocess (n) { return e !== 'auto' && e > 1 ? hT({ tag: 'div', classes: ['tox-collection__group'] }, e)(n) : bT(n, function (e, n) { return t[n].type === 'separator' }) } })] } }; const wT = function (e, t) { return { dom: { tag: 'div', classes: ['tox-collection', 'tox-collection--horizontal'] }, components: [aw.parts().items({ preprocess (t) { return bT(t, function (t, n) { return e[n].type === 'separator' }) } })] } }; const xT = function (e) { return void 0 !== e.icon || e.type === 'togglemenuitem' || e.type === 'choicemenuitem' }; const CT = function (e) { return V(e, xT) }; const ST = function (e) { return t.console.error(Yt(e)), t.console.log(e), x.none() }; const kT = function (e, t, n, r, o) { const i = wT(n); return { value: e, dom: i.dom, components: i.components, items: n } }; const TT = function (e, t, n, r, o) { if (o === 'color') { var i = pT(r); return { value: e, dom: i.dom, components: i.components, items: n } } if (o === 'normal' && r === 'auto') { i = yT(r, n); return { value: e, dom: i.dom, components: i.components, items: n } } if (o === 'normal' && r === 1) { i = yT(1, n); return { value: e, dom: i.dom, components: i.components, items: n } } if (o === 'normal') { i = yT(r, n); return { value: e, dom: i.dom, components: i.components, items: n } } if (o === 'listpreview' && r !== 'auto') { i = vT(r); return { value: e, dom: i.dom, components: i.components, items: n } } return { value: e, dom: dT(t, r, o), components: mT, items: n } }; const ET = function (e, t, n, r, o, i, u, a) { const c = CT(t); const s = o !== 'color' ? 'normal' : 'color'; const l = OT(t, n, r, s, i, u, a); return TT(e, c, l, r, o) }; var OT = function (e, t, n, r, o, i, u) { return Xh(W(e, function (e) { return e.type === 'choiceitem' ? mC(e).fold(ST, function (a) { return x.some(XS(a, n === 1, r, t, i(e.value), o, u)) }) : x.none() })) }; const NT = function (e, t) { const n = fT(t); if (e === 1) { return { mode: 'menu', moveOnTab: !0 } } if (e === 'auto') { return { mode: 'grid', selector: '.' + n.item, initSize: { numColumns: 1, numRows: 1 } } } const r = t === 'color' ? 'tox-swatches__row' : 'tox-collection__group'; return { mode: 'matrix', rowSelector: '.' + r } }; const _T = function (e, t) { return e === 1 ? { mode: 'menu', moveOnTab: !1, selector: '.tox-collection__item' } : e === 'auto' ? { mode: 'flatgrid', selector: '.tox-collection__item', initSize: { numColumns: 1, numRows: 1 } } : { mode: 'matrix', selectors: { row: t === 'color' ? '.tox-swatches__row' : '.tox-collection__group', cell: t === 'color' ? '.' + zC : '.' + PC } } }; function DT (e, t) { const n = cT.getColors(t.colorinput.getColors(), t.colorinput.hasCustomColors()); const r = t.colorinput.getColorCols(); const o = 'color'; const i = ET(xu('menu-value'), n, function (t) { e.onAction({ value: t }) }, r, o, IS.CLOSE_ON_EXECUTE, function () { return !1 }, t.shared.providers); const u = m(m({}, i), { markers: fT(o), movement: NT(r, o) }); return { type: 'widget', data: { value: xu('widget-id') }, dom: { tag: 'div', classes: ['tox-fancymenuitem'] }, autofocus: !0, components: [YS().widget(aw.sketch(u))] } } let AT; const RT = { inserttable: rk, colorswatch: DT }; const BT = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) ? x.some(e[t]) : x.none() }; const MT = function (e, t) { return BT(RT, e.fancytype).map(function (n) { return n(e, t) }) }; const PT = function (e, t, n, r) { void 0 === r && (r = !0); const o = function (e) { return { isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const i = sS({ presets: 'normal', iconContent: e.icon, textContent: e.text, htmlContent: x.none(), ariaLabel: e.text, caret: x.none(), checkMark: x.none(), shortcutContent: e.shortcut }, n, r); return VS({ data: US(e), getApi: o, disabled: e.disabled, onAction: e.onAction, onSetup: e.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, i, t) }; const zT = function (e, t, r, o, i) { void 0 === o && (o = !0), void 0 === i && (i = !1); const u = i ? oS(r.icons) : rS(r.icons); const a = function (e) { return { isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const c = sS({ presets: 'normal', iconContent: e.icon, textContent: e.text, htmlContent: x.none(), ariaLabel: e.text, caret: x.some(u), checkMark: x.none(), shortcutContent: e.shortcut }, r, o); return VS({ data: US(e), getApi: a, disabled: e.disabled, onAction: n, onSetup: e.onSetup, triggersSubmenu: !0, itemBehaviours: [] }, c, t) }; const IT = function (e) { const t = e.text.fold(function () { return {} }, function (e) { return { innerHtml: e } }); return { type: 'separator', dom: m({ tag: 'div', classes: [PC, HC] }, t), components: [] } }; const LT = function (e, t, n) { const r = function (e) { return { setActive (t) { zy.set(e, t) }, isActive () { return zy.isOn(e) }, isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const o = sS({ iconContent: x.none(), textContent: e.text, htmlContent: x.none(), ariaLabel: e.text, checkMark: x.some(nS(n.icons)), caret: x.none(), shortcutContent: e.shortcut, presets: 'normal', meta: e.meta }, n, !0); return Ne(VS({ data: US(e), disabled: e.disabled, getApi: r, onAction: e.onAction, onSetup: e.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, o, t), { toggling: { toggleClass: LC, toggleOnExecute: !1, selected: e.active } }) }; const HT = GS; const FT = IT; const VT = PT; const UT = zT; const jT = LT; const WT = MT; (function (e) { e[e.ContentFocus = 0] = 'ContentFocus', e[e.UiFocus = 1] = 'UiFocus' })(AT || (AT = {})); const qT = function (e) { return void 0 !== e.icon || e.type === 'togglemenuitem' || e.type === 'choicemenuitem' }; const $T = function (e) { return V(e, qT) }; const GT = function (e, n, r, o, i) { const u = r.shared.providers; const a = function (e) { return i ? m(m({}, e), { shortcut: x.none(), icon: e.text.isSome() ? x.none() : e.icon }) : e }; switch (e.type) { case 'menuitem':return aC(e).fold(ST, function (e) { return x.some(VT(a(e), n, u, o)) }); case 'nestedmenuitem':return sC(e).fold(ST, function (e) { return x.some(UT(a(e), n, u, o, i)) }); case 'togglemenuitem':return fC(e).fold(ST, function (e) { return x.some(jT(a(e), n, u)) }); case 'separator':return Jx(e).fold(ST, function (e) { return x.some(FT(e)) }); case 'fancymenuitem':return pC(e).fold(ST, function (e) { return WT(a(e), r) }); default:return t.console.error('Unknown item in general menu', e), x.none() } }; const XT = function (e, t, n, r, o, i) { const u = r === 1; const a = !u || $T(e); return Xh(W(e, function (e) { return e.type === 'separator' ? eC(e).fold(ST, function (e) { return x.some(FT(e)) }) : tC(e).fold(ST, function (e) { return x.some(HT(e, t, u, 'normal', n, o, i, a)) }) })) }; const YT = function (e, t, n, r, o) { const i = $T(t); const u = Xh(W(t, function (e) { const t = function (e) { return o ? !e.hasOwnProperty('text') : i }; const u = function (e) { return GT(e, n, r, t(e), o) }; return e.type === 'nestedmenuitem' && e.getSubmenuItems().length <= 0 ? u(m(m({}, e), { disabled: !0 })) : u(e) })); const a = o ? kT : TT; return a(e, i, u, 1, 'normal') }; const KT = function (e) { return yw.singleData(e.value, e) }; const JT = function (e, t, n, r) { const o = n === AT.ContentFocus ? qp() : Wp(); const i = NT(t, r); const u = fT(r); return { dom: e.dom, components: e.components, items: e.items, value: e.value, markers: { selectedItem: u.selectedItem, item: u.item }, movement: i, fakeFocus: n === AT.ContentFocus, focusManager: o, menuBehaviours: wC.unnamedEvents(t !== 'auto' ? [] : [xi(function (e, t) { vC(e, 4, u.item).each(function (t) { const n = t.numColumns; const r = t.numRows; Kb.setGridSize(e, r, n) }) })]) } }; const ZT = function (e, n) { const r = Ln(x.none()); const o = Ln(!1); const i = nc(Cw.sketch({ dom: { tag: 'div', classes: ['tox-autocompleter'] }, components: [], fireDismissalEventInstead: {}, inlineBehaviours: yl([cy('dismissAutocompleter', [fi(Go(), function () { return s() })])]), lazySink: n.getSink })); const u = function () { return Cw.isOpen(i) }; const a = function () { return r.get().isSome() }; const c = function () { a() && Cw.hide(i) }; var s = function () { if (a()) { const t = r.get().map(function (e) { return e.element }); _x(t.getOr(Wn.fromDom(e.selection.getNode()))).each(Ji), c(), r.set(x.none()), o.set(!1) } }; const l = De(function () { return oC(e) }); const f = function (r, i) { const u = le(i, function (e) { return x.from(e.columns) }).getOr(1); return ee(i, function (i) { const a = i.items; return XT(a, i.matchText, function (n, u) { const a = e.selection.getRng(); zx(e.dom, a, r).fold(function () { return t.console.error('Lost context. Cursor probably moved') }, function (e) { const t = e.range; const r = { hide () { s() }, reload (e) { c(), h(e) } }; o.set(!0), i.onAction(r, t, n, u), o.set(!1) }) }, u, IS.BUBBLE_TO_SANDBOX, n) }) }; const d = function (t) { if (!a()) { const n = Nx(e, t.range); r.set(x.some({ triggerChar: t.triggerChar, element: n, matchLength: t.text.length })), o.set(!1) } }; const m = function (t, n, r, o) { t.matchLength = n.text.length; const u = le(r, function (e) { return x.from(e.columns) }).getOr(1); Cw.showAt(i, { anchor: 'node', root: Wn.fromDom(e.getBody()), node: x.from(t.element) }, aw.sketch(JT(TT('autocompleter-value', !0, o, u, 'normal'), u, AT.ContentFocus, 'normal'))), Cw.getContent(i).each(Cp.highlightFirst) }; const g = function (t) { return r.get().map(function (n) { return zx(e.dom, e.selection.getRng(), n.triggerChar).bind(function (n) { return Yx(e, l, n, t) }) }).getOrThunk(function () { return Xx(e, l) }) }; var h = function (e) { g(e).fold(s, function (e) { d(e.context), e.lookupData.then(function (t) { r.get().map(function (n) { const r = e.context; if (n.triggerChar === r.triggerChar) { const o = f(r.triggerChar, t); o.length > 0 ? m(n, r, t, o) : r.text.length - n.matchLength >= 10 ? s() : c() } }) }) }) }; const p = Sx(function (e) { e.which !== 27 && h() }, 50); const v = { onKeypress: p, cancelIfNecessary: s, isMenuOpen: u, isActive: a, isProcessingAction: o.get, getView () { return Cw.getContent(i) } }; Lx.setup(v, e) }; const QT = { register: ZT }; const eE = i(!0); const tE = function (e, t, n) { return kc(e, t, eE, n) }; const nE = function (e, t, n) { return Tc(e, t, eE, n) }; const rE = xc; const oE = function (e, t, n) { return Zc(e, t, n).isSome() }; function iE (e, n) { let r = null; const o = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r = t.setTimeout(function () { e.apply(null, o), r = null }, n) }; const i = function () { r !== null && (t.clearTimeout(r), r = null) }; return { cancel: i, schedule: o } } const uE = 5; const aE = 400; const cE = function (e) { const t = e.raw(); return void 0 === t.touches || t.touches.length !== 1 ? x.none() : x.some(t.touches[0]) }; const sE = function (e, t) { const n = Math.abs(e.clientX - t.x()); const r = Math.abs(e.clientY - t.y()); return n > uE || r > uE }; const lE = function (e) { const t = Ln(x.none()); const n = Ln(!1); const r = iE(function (t) { e.triggerEvent(Io(), t), n.set(!0) }, aE); const o = function (e) { return cE(e).each(function (o) { r.cancel(); const u = { x: i(o.clientX), y: i(o.clientY), target: e.target }; r.schedule(e), n.set(!1), t.set(x.some(u)) }), x.none() }; const u = function (e) { return r.cancel(), cE(e).each(function (e) { t.get().each(function (n) { sE(e, n) && t.set(x.none()) }) }), x.none() }; const a = function (o) { r.cancel(); const i = function (e) { return Jr(e.target(), o.target()) }; return t.get().filter(i).map(function (t) { return n.get() ? (o.prevent(), !1) : e.triggerEvent(zo(), o) }) }; const c = tt([{ key: lo(), value: o }, { key: fo(), value: u }, { key: mo(), value: a }]); const s = function (e, t) { return ye(c, t).bind(function (t) { return t(e) }) }; return { fireIfReady: s } }; const fE = function (e) { const t = e.raw(); return t.which === Sp()[0] && !F(['input', 'textarea'], tu(e.target())) && !oE(e.target(), '[contenteditable="true"]') }; const dE = Vr().browser.isFirefox(); const mE = Nt([gn('triggerEvent'), On('stopBackspace', !0)]); const gE = function (e, t) { return dE ? nE(e, 'focus', t) : tE(e, 'focusin', t) }; const hE = function (e, t) { return dE ? nE(e, 'blur', t) : tE(e, 'focusout', t) }; const pE = function (e, n) { const r = Xt('Getting GUI events settings', mE, n); const o = ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'gesturestart', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout', 'click']; const i = lE(r); const u = W(o.concat(['selectstart', 'input', 'contextmenu', 'change', 'transitionend', 'drag', 'dragstart', 'dragend', 'dragenter', 'dragleave', 'dragover', 'drop', 'keyup']), function (t) { return tE(e, t, function (e) { i.fireIfReady(e, t).each(function (t) { t && e.kill() }); const n = r.triggerEvent(t, e); n && e.kill() }) }); const a = Ln(x.none()); const c = tE(e, 'paste', function (e) { i.fireIfReady(e, 'paste').each(function (t) { t && e.kill() }); const n = r.triggerEvent('paste', e); n && e.kill(), a.set(x.some(t.setTimeout(function () { r.triggerEvent(Ro(), e) }, 0))) }); const s = tE(e, 'keydown', function (e) { const t = r.triggerEvent('keydown', e); t ? e.kill() : !0 === r.stopBackspace && fE(e) && e.prevent() }); const l = gE(e, function (e) { const t = r.triggerEvent('focusin', e); t && e.kill() }); const f = Ln(x.none()); const d = hE(e, function (e) { const n = r.triggerEvent('focusout', e); n && e.kill(), f.set(x.some(t.setTimeout(function () { r.triggerEvent(Ao(), e) }, 0))) }); const m = function () { q(u, function (e) { e.unbind() }), s.unbind(), l.unbind(), d.unbind(), c.unbind(), a.get().each(t.clearTimeout), f.get().each(t.clearTimeout) }; return { unbind: m } }; const vE = function (e, t) { const n = ye(e, 'target').map(function (e) { return e() }).getOr(t); return Ln(n) }; const bE = function (e, t) { const n = Ln(!1); const r = Ln(!1); const o = function () { n.set(!0) }; const u = function () { r.set(!0) }; return { stop: o, cut: u, isStopped: n.get, isCut: r.get, event: i(e), setSource: t.set, getSource: t.get } }; const yE = function (e) { const t = Ln(!1); const r = function () { t.set(!0) }; return { stop: r, cut: n, isStopped: t.get, isCut: i(!1), event: i(e), setSource: s('Cannot set source of a broadcasted event'), getSource: s('Cannot get source of a broadcasted event') } }; const wE = Se.generate([{ stopped: [] }, { resume: ['element'] }, { complete: [] }]); const xE = function (e, t, n, r, o, i) { const u = e(t, r); const a = bE(n, o); return u.fold(function () { return i.logEventNoHandlers(t, r), wE.complete() }, function (e) { const n = e.descHandler(); const r = ea(n); return r(a), a.isStopped() ? (i.logEventStopped(t, e.element(), n.purpose()), wE.stopped()) : a.isCut() ? (i.logEventCut(t, e.element(), n.purpose()), wE.complete()) : Pi(e.element()).fold(function () { return i.logNoParent(t, e.element(), n.purpose()), wE.complete() }, function (r) { return i.logEventResponse(t, e.element(), n.purpose()), wE.resume(r) }) }) }; var CE = function (e, t, n, r, o, i) { return xE(e, t, n, r, o, i).fold(function () { return !0 }, function (r) { return CE(e, t, n, r, o, i) }, function () { return !1 }) }; const SE = function (e, t, n, r, o) { const i = vE(n, r); return xE(e, t, n, r, i, o) }; const kE = function (e, t, n) { const r = yE(t); return q(e, function (e) { const t = e.descHandler(); const n = ea(t); n(r) }), r.isStopped() }; const TE = function (e, t, n, r) { const o = n.target(); return EE(e, t, n, o, r) }; var EE = function (e, t, n, r, o) { const i = vE(n, r); return CE(e, t, n, r, i, o) }; const OE = Ti('element', 'descHandler'); const NE = function (e, t) { return { id: i(e), descHandler: i(t) } }; function _E () { const e = {}; const t = function (t, n, r) { me(r, function (r, o) { const i = void 0 !== e[o] ? e[o] : {}; i[n] = Qu(r, t), e[o] = i }) }; const n = function (e, t) { return Nu(t).fold(function () { return x.none() }, function (n) { return e.bind(function (e) { return ye(e, n) }).map(function (e) { return OE(t, e) }) }) }; const r = function (t) { return ye(e, t).map(function (e) { return pe(e, function (e, t) { return NE(t, e) }) }).getOr([]) }; const o = function (t, r, o) { const i = ye(e, r); return ro(o, function (e) { return n(i, e) }, t) }; const i = function (t) { me(e, function (e, n) { e.hasOwnProperty(t) && delete e[t] }) }; return { registerId: t, unregisterId: i, filterByType: r, find: o } } function DE () { const e = _E(); const t = {}; const n = function (e) { const t = e.element(); return Nu(t).fold(function () { return Eu('uid-', e.element()) }, function (e) { return e }) }; const r = function (e, n) { const r = t[n]; if (r !== e) { throw new Error('The tagId "' + n + '" is already used by: ' + pu(r.element()) + '\nCannot use it for: ' + pu(e.element()) + '\nThe conflicting element is' + (Oa(r.element()) ? ' ' : ' not ') + 'already in the DOM') } i(e) }; const o = function (o) { const i = n(o); xe(t, i) && r(o, i); const u = [o]; e.registerId(u, i, o.events()), t[i] = o }; var i = function (n) { Nu(n.element()).each(function (n) { delete t[n], e.unregisterId(n) }) }; const u = function (t) { return e.filterByType(t) }; const a = function (t, n, r) { return e.find(t, n, r) }; const c = function (e) { return ye(t, e) }; return { find: a, filter: u, register: o, unregister: i, getById: c } } const AE = function (e) { const t = e.dom; const n = t.attributes; const r = g(t, ['attributes']); return { uid: e.uid, dom: m({ tag: 'div', attributes: m({ role: 'presentation' }, n) }, r), components: e.components, behaviours: Pg(e.containerBehaviours), events: e.events, domModification: e.domModification, eventOrder: e.eventOrder } }; const RE = $h({ name: 'Container', factory: AE, configFields: [On('components', []), Mg('containerBehaviours', []), On('events', {}), On('domModification', {}), On('eventOrder', {})] }); const BE = function (e) { const t = function (t) { return Pi(e.element()).fold(function () { return !0 }, function (e) { return Jr(t, e) }) }; const r = DE(); const o = function (e, n) { return r.find(t, e, n) }; const u = pE(e.element(), { triggerEvent (e, t) { return fs(e, t.target(), function (n) { return TE(o, e, t, n) }) } }); var a = { debugInfo: i('real'), triggerEvent (e, t, n) { fs(e, t, function (r) { return EE(o, e, n, t, r) }) }, triggerFocus (e, t) { Nu(e).fold(function () { Rl(e) }, function (r) { fs(Do(), e, function (r) { return SE(o, Do(), { originator: i(t), kill: n, prevent: n, target: i(e) }, e, r), !1 }) }) }, triggerEscape (e, t) { a.triggerEvent('keydown', e.element(), t.event()) }, getByUid (e) { return v(e) }, getByDom (e) { return b(e) }, build: nc, addToGui (e) { l(e) }, removeFromGui (e) { f(e) }, addToWorld (e) { c(e) }, removeFromWorld (e) { s(e) }, broadcast (e) { g(e) }, broadcastOn (e, t) { h(e, t) }, broadcastEvent (e, t) { p(e, t) }, isConnected: i(!0) }; var c = function (e) { e.connect(a), iu(e.element()) || (r.register(e), q(e.components(), c), a.triggerEvent(Fo(), e.element(), { target: i(e.element()) })) }; var s = function (e) { iu(e.element()) || (q(e.components(), s), r.unregister(e)), e.disconnect() }; var l = function (t) { Sm(e, t) }; var f = function (e) { Em(e) }; const d = function () { u.unbind(), Ki(e.element()) }; const m = function (e) { const t = r.filter(Bo()); q(t, function (t) { const n = t.descHandler(); const r = ea(n); r(e) }) }; var g = function (e) { m({ universal: i(!0), data: i(e) }) }; var h = function (e, t) { m({ universal: i(!1), channels: i(e), data: i(t) }) }; var p = function (e, t) { const n = r.filter(e); return kE(n, t) }; var v = function (e) { return r.getById(e).fold(function () { return T.error(new Error('Could not find component with uid: "' + e + '" in system.')) }, T.value) }; var b = function (e) { const t = Nu(e).getOr('not found'); return v(t) }; return c(e), { root: i(e), element: e.element, destroy: d, add: l, remove: f, getByUid: v, getByDom: b, addToWorld: c, removeFromWorld: s, broadcast: g, broadcastOn: h, broadcastEvent: p } }; const ME = xu('form-component-change'); const PE = xu('form-close'); const zE = xu('form-cancel'); const IE = xu('form-action'); const LE = xu('form-submit'); const HE = xu('form-block'); const FE = xu('form-unblock'); const VE = xu('form-tabchange'); const UE = xu('form-resize'); const jE = function (e, t) { return RE.sketch({ dom: { tag: 'div', attributes: { role: 'alert' }, classes: ['tox-notification', 'tox-notification--in', 'tox-notification--' + e.level] }, components: [{ dom: { tag: 'div', classes: ['tox-notification__icon'] }, components: [fx.sketch({ dom: { tag: 'button', classes: ['tox-button', 'tox-button--naked', 'tox-button--icon'], innerHtml: gx(e.icon, t.icons), attributes: { title: t.translate(e.iconTooltip) } }, action (t) { ni(t, IE, { name: 'alert-banner', value: e.url }) } })] }, { dom: { tag: 'div', classes: ['tox-notification__body'], innerHtml: t.translate(e.text) } }] }) }; const WE = function (e, t) { return { dom: { tag: 'div', classes: ['tox-bar', 'tox-form__controls-h-stack'] }, components: W(e.items, t.interpreter) } }; const qE = i([On('prefix', 'form-field'), Mg('fieldBehaviours', [np, Bg])]); const $E = i([gh({ schema: [cn('dom')], name: 'label' }), gh({ factory: { sketch (e) { return { uid: e.uid, dom: { tag: 'span', styles: { display: 'none' }, attributes: { 'aria-hidden': 'true' }, innerHtml: e.text } } } }, schema: [cn('text')], name: 'aria-descriptor' }), dh({ factory: { sketch (e) { const t = Qe(e, ['factory']); return e.factory.sketch(t) } }, schema: [cn('factory')], name: 'field' })]); const GE = function (e, t, n, r) { const o = zg(e.fieldBehaviours, [np.config({ find (t) { return Oh(t, e, 'field') } }), Bg.config({ store: { mode: 'manual', getValue (e) { return np.getCurrent(e).bind(Bg.getValue) }, setValue (e, t) { np.getCurrent(e).each(function (e) { Bg.setValue(e, t) }) } } })]); const i = ai([xi(function (t, n) { const r = _h(t, e, ['label', 'field', 'aria-descriptor']); r.field().each(function (t) { const n = xu(e.prefix); r.label().each(function (e) { au(e.element(), 'for', n), au(t.element(), 'id', n) }), r['aria-descriptor']().each(function (n) { const r = xu(e.prefix); au(n.element(), 'id', r), au(t.element(), 'aria-describedby', r) }) }) })]); const u = { getField (t) { return Oh(t, e, 'field') }, getLabel (t) { return Oh(t, e, 'label') } }; return { uid: e.uid, dom: e.dom, components: t, behaviours: o, events: i, apis: u } }; const XE = Gh({ name: 'FormField', configFields: qE(), partFields: $E(), factory: GE, apis: { getField (e, t) { return e.getField(t) }, getLabel (e, t) { return e.getLabel(t) } } }); const YE = i([yn('data'), On('inputAttributes', {}), On('inputStyles', {}), On('tag', 'input'), On('inputClasses', []), xs('onSetValue'), On('styles', {}), On('eventOrder', {}), Mg('inputBehaviours', [Bg, vy]), On('selectOnFocus', !0)]); const KE = function (e) { return yl([vy.config({ onFocus: e.selectOnFocus ? function (e) { const t = e.element(); const n = Ua(t); t.dom().setSelectionRange(0, n.length) } : n })]) }; const JE = function (e) { return m(m({}, KE(e)), zg(e.inputBehaviours, [Bg.config({ store: m(m({ mode: 'manual' }, e.data.map(function (e) { return { initialValue: e } }).getOr({})), { getValue (e) { return Ua(e.element()) }, setValue (e, t) { const n = Ua(e.element()); n !== t && ja(e.element(), t) } }), onSetValue: e.onSetValue })])) }; const ZE = function (e) { return { tag: e.tag, attributes: m({ type: 'text' }, e.inputAttributes), styles: e.inputStyles, classes: e.inputClasses } }; const QE = function (e, t) { return { uid: e.uid, dom: ZE(e), components: [], behaviours: JE(e), eventOrder: e.eventOrder } }; const eO = $h({ name: 'Input', configFields: YE(), factory: QE }); const tO = {}; const nO = { exports: tO }; (function (t, n, r, o) { (function (o) { if (typeof n === 'object' && typeof r !== 'undefined') { r.exports = o() } else if (typeof t === 'function' && t.amd) { t([], o) } else { let i; i = typeof window !== 'undefined' ? window : typeof e !== 'undefined' ? e : typeof self !== 'undefined' ? self : this, i.EphoxContactWrapper = o() } })(function () { return (function () { function e (t, n, r) { function i (a, c) { if (!n[a]) { if (!t[a]) { const s = typeof o === 'function' && o; if (!c && s) { return s(a, !0) } if (u) { return u(a, !0) } const l = new Error("Cannot find module '" + a + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const f = n[a] = { exports: {} }; t[a][0].call(f.exports, function (e) { const n = t[a][1][e]; return i(n || e) }, f, f.exports, e, t, n, r) } return n[a].exports } for (var u = typeof o === 'function' && o, a = 0; a < r.length; a++) { i(r[a]) } return i } return e }())({ 1: [function (e, t, n) { let r; let o; const i = t.exports = {}; function u () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function c (e) { if (r === setTimeout) { return setTimeout(e, 0) } if ((r === u || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0) } try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function s (e) { if (o === clearTimeout) { return clearTimeout(e) } if ((o === a || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e) } try { return o(e) } catch (t) { try { return o.call(null, e) } catch (t) { return o.call(this, e) } } }(function () { try { r = typeof setTimeout === 'function' ? setTimeout : u } catch (e) { r = u } try { o = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { o = a } })(); let l; let f = []; let d = !1; let m = -1; function g () { d && l && (d = !1, l.length ? f = l.concat(f) : m = -1, f.length && h()) } function h () { if (!d) { const e = c(g); d = !0; let t = f.length; while (t) { l = f, f = []; while (++m < t) { l && l[m].run() }m = -1, t = f.length }l = null, d = !1, s(e) } } function p (e, t) { this.fun = e, this.array = t } function v () {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } }f.push(new p(e, t)), f.length !== 1 || d || c(h) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.prependListener = v, i.prependOnceListener = v, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, {}], 2: [function (e, t, n) { (function (e) { (function (n) { const r = setTimeout; function o () {} function i (e, t) { return function () { e.apply(t, arguments) } } function u (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(e, this) } function a (e, t) { while (e._state === 3) { e = e._value }e._state !== 0 ? (e._handled = !0, u._immediateFn(function () { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let r; try { r = n(e._value) } catch (o) { return void s(t.promise, o) }c(t.promise, r) } else { (e._state === 1 ? c : s)(t.promise, e._value) } })) : e._deferreds.push(t) } function c (e, t) { try { if (t === e) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof u) { return e._state = 3, e._value = t, void l(e) } if (typeof n === 'function') { return void d(i(n, t), e) } }e._state = 1, e._value = t, l(e) } catch (r) { s(e, r) } } function s (e, t) { e._state = 2, e._value = t, l(e) } function l (e) { e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function () { e._handled || u._unhandledRejectionFn(e._value) }); for (let t = 0, n = e._deferreds.length; t < n; t++) { a(e, e._deferreds[t]) }e._deferreds = null } function f (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n } function d (e, t) { let n = !1; try { e(function (e) { n || (n = !0, c(t, e)) }, function (e) { n || (n = !0, s(t, e)) }) } catch (r) { if (n) { return } n = !0, s(t, r) } }u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { const n = new this.constructor(o); return a(this, new f(e, t, n)), n }, u.all = function (e) { const t = Array.prototype.slice.call(e); return new u(function (e, n) { if (t.length === 0) { return e([]) } let r = t.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }t[i] = u, --r === 0 && e(t) } catch (c) { n(c) } } for (let i = 0; i < t.length; i++) { o(i, t[i]) } }) }, u.resolve = function (e) { return e && typeof e === 'object' && e.constructor === u ? e : new u(function (t) { t(e) }) }, u.reject = function (e) { return new u(function (t, n) { n(e) }) }, u.race = function (e) { return new u(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, u._immediateFn = typeof e === 'function' ? function (t) { e(t) } : function (e) { r(e, 0) }, u._unhandledRejectionFn = function (e) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', e) }, u._setImmediateFn = function (e) { u._immediateFn = e }, u._setUnhandledRejectionFn = function (e) { u._unhandledRejectionFn = e }, typeof t !== 'undefined' && t.exports ? t.exports = u : n.Promise || (n.Promise = u) })(this) }).call(this, e('timers').setImmediate) }, { timers: 3 }], 3: [function (e, t, n) { (function (t, r) { const o = e('process/browser.js').nextTick; const i = Function.prototype.apply; const u = Array.prototype.slice; const a = {}; let c = 0; function s (e, t) { this._id = e, this._clearFn = t }n.setTimeout = function () { return new s(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function () { return new s(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function (e) { e.close() }, s.prototype.unref = s.prototype.ref = function () {}, s.prototype.close = function () { this._clearFn.call(window, this._id) }, n.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, n.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, n._unrefActive = n.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(function () { e._onTimeout && e._onTimeout() }, t)) }, n.setImmediate = typeof t === 'function' ? t : function (e) { const t = c++; const r = !(arguments.length < 2) && u.call(arguments, 1); return a[t] = !0, o(function () { a[t] && (r ? e.apply(null, r) : e.call(null), n.clearImmediate(t)) }), t }, n.clearImmediate = typeof r === 'function' ? r : function (e) { delete a[e] } }).call(this, e('timers').setImmediate, e('timers').clearImmediate) }, { 'process/browser.js': 1, timers: 3 }], 4: [function (e, t, n) { const r = e('promise-polyfill'); const o = (function () { return typeof window !== 'undefined' ? window : Function('return this;')() }()); t.exports = { boltExport: o.Promise || r } }, { 'promise-polyfill': 2 }] }, {}, [4])(4) }) })(void 0, tO, nO, void 0); let rO; const oO = nO.exports.boltExport; var iO = function (e) { let n = x.none(); let r = []; const o = function (e) { return iO(function (t) { i(function (n) { t(e(n)) }) }) }; var i = function (e) { a() ? s(e) : r.push(e) }; const u = function (e) { n = x.some(e), c(r), r = [] }; var a = function () { return n.isSome() }; var c = function (e) { q(e, s) }; var s = function (e) { n.each(function (n) { t.setTimeout(function () { e(n) }, 0) }) }; return e(u), { get: i, map: o, isReady: a } }; const uO = function (e) { return iO(function (t) { t(e) }) }; const aO = { nu: iO, pure: uO }; const cO = function (e) { t.setTimeout(function () { throw e }, 0) }; var sO = function (e) { const t = function (t) { e().then(t, cO) }; const n = function (t) { return sO(function () { return e().then(t) }) }; const r = function (t) { return sO(function () { return e().then(function (e) { return t(e).toPromise() }) }) }; const o = function (t) { return sO(function () { return e().then(function () { return t.toPromise() }) }) }; const i = function () { return aO.nu(t) }; const u = function () { let t = null; return sO(function () { return t === null && (t = e()), t }) }; const a = e; return { map: n, bind: r, anonBind: o, toLazy: i, toCached: u, toPromise: a, get: t } }; const lO = function (e) { return sO(function () { return new oO(e) }) }; const fO = function (e) { return sO(function () { return oO.resolve(e) }) }; const dO = { nu: lO, pure: fO }; const mO = ['input', 'textarea']; const gO = function (e) { const t = tu(e); return F(mO, t) }; const hO = function (e, t) { const n = t.getRoot(e).getOr(e.element()); Ca(n, t.invalidClass), t.notify.each(function (t) { gO(e.element()) && au(e.element(), 'aria-invalid', !1), t.getContainer(e).each(function (e) { Qi(e, t.validHtml) }), t.onValid(e) }) }; const pO = function (e, t, n, r) { const o = t.getRoot(e).getOr(e.element()); wa(o, t.invalidClass), t.notify.each(function (t) { gO(e.element()) && au(e.element(), 'aria-invalid', !0), t.getContainer(e).each(function (e) { Qi(e, r) }), t.onInvalid(e, r) }) }; const vO = function (e, t, n) { return t.validator.fold(function () { return dO.pure(T.value(!0)) }, function (t) { return t.validate(e) }) }; const bO = function (e, t, n) { return t.notify.each(function (t) { t.onValidate(e) }), vO(e, t).map(function (r) { return e.getSystem().isConnected() ? r.fold(function (r) { return pO(e, t, n, r), T.error(r) }, function (n) { return hO(e, t), T.value(n) }) : T.error('No longer in system') }) }; const yO = function (e, t) { const n = t.getRoot(e).getOr(e.element()); return Sa(n, t.invalidClass) }; const wO = Object.freeze({ __proto__: null, markValid: hO, markInvalid: pO, query: vO, run: bO, isInvalid: yO }); const xO = function (e, t) { return e.validator.map(function (r) { return ai([fi(r.onEvent, function (n) { bO(n, e, t).get(u) })].concat(r.validateOnLoad ? [xi(function (r) { bO(r, e, t).get(n) })] : [])) }).getOr({}) }; const CO = Object.freeze({ __proto__: null, events: xO }); const SO = [cn('invalidClass'), On('getRoot', x.none), Tn('notify', [On('aria', 'alert'), On('getContainer', x.none), On('validHtml', ''), xs('onValid'), xs('onInvalid'), xs('onValidate')]), Tn('validator', [cn('validate'), On('onEvent', 'input'), On('validateOnLoad', !0)])]; const kO = xl({ fields: SO, name: 'invalidating', active: CO, apis: wO, extra: { validation (e) { return function (t) { const n = Bg.getValue(t); return dO.pure(e(n)) } } } }); const TO = function (e, t) { return Gu({ attributes: tt([{ key: t.tabAttr, value: 'true' }]) }) }; const EO = Object.freeze({ __proto__: null, exhibit: TO }); const OO = [On('tabAttr', 'data-alloy-tabstop')]; const NO = xl({ fields: OO, name: 'tabstopping', active: EO }); const _O = function (e, t, n, r) { const o = AO(e, t, n, r); return XE.sketch(o) }; const DO = function (e, t) { return _O(e, t, [], []) }; var AO = function (e, t, n, r) { return { dom: BO(n), components: e.toArray().concat([t]), fieldBehaviours: yl(r) } }; const RO = function () { return BO([]) }; var BO = function (e) { return { tag: 'div', classes: ['tox-form__group'].concat(e) } }; const MO = function (e, t) { return XE.parts().label({ dom: { tag: 'label', classes: ['tox-label'], innerHtml: t.translate(e) } }) }; const PO = function (e, t, n, r) { return n.getOrCreate(e, t, r) }; const zO = Object.freeze({ __proto__: null, getCoupled: PO }); const IO = [sn('others', Wt(T.value, Zt()))]; const LO = function () { const e = {}; const t = function (t, n, r) { const o = fe(n.others); if (o) { return ye(e, r).getOrThunk(function () { const o = ye(n.others, r).getOrDie('No information found for coupled component: ' + r); const i = o(t); const u = t.getSystem().build(i); return e[r] = u, u }) } throw new Error('Cannot find coupled component: ' + r + '. Known coupled components: ' + JSON.stringify(o, null, 2)) }; const n = i({}); return Uu({ readState: n, getOrCreate: t }) }; const HO = Object.freeze({ __proto__: null, init: LO }); const FO = xl({ fields: IO, name: 'coupling', apis: zO, state: HO }); const VO = i('sink'); const UO = i(gh({ name: VO(), overrides: i({ dom: { tag: 'div' }, behaviours: yl([vm.config({ useFixed: f })]), events: ai([bi(Co()), bi(ho()), bi(Eo())]) }) })); (function (e) { e[e.HighlightFirst = 0] = 'HighlightFirst', e[e.HighlightNone = 1] = 'HighlightNone' })(rO || (rO = {})); const jO = function (e, t) { const n = e.getHotspot(t).getOr(t); const r = 'hotspot'; const o = e.getAnchorOverrides(); return e.layouts.fold(function () { return { anchor: r, hotspot: n, overrides: o } }, function (e) { return { anchor: r, hotspot: n, overrides: o, layouts: e } }) }; const WO = function (e, t, n) { const r = e.fetch; return r(n).map(t) }; const qO = function (e, t, n, r, o, i, u) { const a = WO(e, t, r); const c = KO(r, e); return a.map(function (e) { return e.bind(function (e) { return x.from(yw.sketch(m(m({}, i.menu()), { uid: _u(''), data: e, highlightImmediately: u === rO.HighlightFirst, onOpenMenu (e, t) { const r = c().getOrDie(); vm.position(r, n, t), Jm.decloak(o) }, onOpenSubmenu (e, t, n) { const r = c().getOrDie(); vm.position(r, { anchor: 'submenu', item: t }, n), Jm.decloak(o) }, onRepositionMenu (e, t, r) { const o = c().getOrDie(); vm.position(o, n, t), q(r, function (e) { vm.position(o, { anchor: 'submenu', item: e.triggeringItem }, e.triggeredMenu) }) }, onEscape () { return vy.focus(r), Jm.close(o), x.some(!0) } }))) }) }) }; const $O = function (e, t, n, r, o, i, u) { const a = jO(e, n); const c = qO(e, t, a, n, r, o, u); return c.map(function (e) { return e.fold(function () { Jm.isOpen(r) && Jm.close(r) }, function (e) { Jm.cloak(r), Jm.open(r, e), i(r) }), r }) }; const GO = function (e, t, n, r, o, i, u) { return Jm.close(r), dO.pure(r) }; const XO = function (e, t, n, r, o, i) { const u = FO.getCoupled(n, 'sandbox'); const a = Jm.isOpen(u); const c = a ? GO : $O; return c(e, t, n, u, r, o, i) }; const YO = function (e, t, n) { const r = np.getCurrent(t).getOr(t); const o = vc(e.element()); n ? Ra(r.element(), 'min-width', o + 'px') : pc(r.element(), o) }; var KO = function (e, t) { return e.getSystem().getByUid(t.uid + '-' + VO()).map(function (e) { return function () { return T.value(e) } }).getOrThunk(function () { return t.lazySink.fold(function () { return function () { return T.error(new Error('No internal sink is specified, nor could an external sink be found')) } }, function (t) { return function () { return t(e) } }) }) }; const JO = function (e) { Jm.getState(e).each(function (e) { yw.repositionMenus(e) }) }; const ZO = function (e, t, n) { const r = es(); const o = function (o, i) { const u = jO(e, t); r.link(t.element()), e.matchWidth && YO(u.hotspot, i, e.useMinWidth), e.onOpen(u, o, i), void 0 !== n && void 0 !== n.onOpen && n.onOpen(o, i) }; const i = function (e, o) { r.unlink(t.element()), void 0 !== n && void 0 !== n.onClose && n.onClose(e, o) }; const u = KO(t, e); return { dom: { tag: 'div', classes: e.sandboxClasses, attributes: { id: r.id(), role: 'listbox' } }, behaviours: Ig.augment(e.sandboxBehaviours, [Bg.config({ store: { mode: 'memory', initialValue: t } }), Jm.config({ onOpen: o, onClose: i, isPartOf (e, n, r) { return ns(n, r) || ns(t, r) }, getAttachPoint () { return u().getOrDie() } }), np.config({ find (e) { return Jm.getState(e).bind(function (e) { return np.getCurrent(e) }) } }), _l.config({ channels: m(m({}, ng({ isExtraPart: l })), og({ doReposition: JO })) })]) } }; const QO = function (e) { const t = FO.getCoupled(e, 'sandbox'); JO(t) }; const eN = function () { return [On('sandboxClasses', []), Ig.field('sandboxBehaviours', [np, _l, Jm, Bg])] }; const tN = i([cn('dom'), cn('fetch'), xs('onOpen'), Cs('onExecute'), On('getHotspot', x.some), On('getAnchorOverrides', i({})), Ef(), Mg('dropdownBehaviours', [zy, FO, Kb, vy]), cn('toggleClass'), On('eventOrder', {}), yn('lazySink'), On('matchWidth', !1), On('useMinWidth', !1), yn('role')].concat(eN())); const nN = i([mh({ schema: [bs()], name: 'menu', defaults (e) { return { onExecute: e.onExecute } } }), UO()]); const rN = function (e, t, r, o) { let i; const u = function (t) { return ye(e.dom, 'attributes').bind(function (e) { return ye(e, t) }) }; const a = function (e) { Jm.getState(e).each(function (e) { yw.highlightPrimary(e) }) }; const c = function (t) { const r = a; XO(e, function (e) { return e }, t, o, r, rO.HighlightFirst).get(n) }; const s = { expand (t) { zy.isOn(t) || XO(e, function (e) { return e }, t, o, n, rO.HighlightNone).get(n) }, open (t) { zy.isOn(t) || XO(e, function (e) { return e }, t, o, n, rO.HighlightFirst).get(n) }, isOpen: zy.isOn, close (t) { zy.isOn(t) && XO(e, function (e) { return e }, t, o, n, rO.HighlightFirst).get(n) }, repositionMenus (e) { zy.isOn(e) && QO(e) } }; const l = function (e, t) { return ri(e), x.some(!0) }; return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.dropdownBehaviours, [zy.config({ toggleClass: e.toggleClass, aria: { mode: 'expanded' } }), FO.config({ others: { sandbox (t) { return ZO(e, t, { onOpen () { zy.on(t) }, onClose () { zy.off(t) } }) } } }), Kb.config({ mode: 'special', onSpace: l, onEnter: l, onDown (e, t) { if (oN.isOpen(e)) { const n = FO.getCoupled(e, 'sandbox'); a(n) } else { oN.open(e) } return x.some(!0) }, onEscape (e, t) { return oN.isOpen(e) ? (oN.close(e), x.some(!0)) : x.none() } }), vy.config({})]), events: Ly(x.some(c)), eventOrder: m(m({}, e.eventOrder), (i = {}, i[Mo()] = ['disabling', 'toggling', 'alloy.base.behaviour'], i)), apis: s, domModification: { attributes: m(m({ 'aria-haspopup': 'true' }, e.role.fold(function () { return {} }, function (e) { return { role: e } })), e.dom.tag === 'button' ? { type: u('type').getOr('button') } : {}) } } }; var oN = Gh({ name: 'Dropdown', configFields: tN(), partFields: nN(), factory: rN, apis: { open (e, t) { return e.open(t) }, expand (e, t) { return e.expand(t) }, close (e, t) { return e.close(t) }, isOpen (e, t) { return e.isOpen(t) }, repositionMenus (e, t) { return e.repositionMenus(t) } } }); const iN = function () { return Gu({ styles: { '-webkit-user-select': 'none', 'user-select': 'none', '-ms-user-select': 'none', '-moz-user-select': '-moz-none' }, attributes: { unselectable: 'on' } }) }; const uN = function () { return ai([ci(No(), i(!0))]) }; const aN = Object.freeze({ __proto__: null, events: uN, exhibit: iN }); const cN = xl({ fields: [], name: 'unselecting', active: aN }); const sN = function (e, t) { return oN.sketch({ dom: e.dom, components: e.components, toggleClass: 'mce-active', dropdownBehaviours: yl([cN.config({}), NO.config({})]), layouts: e.layouts, sandboxClasses: ['tox-dialog__popups'], lazySink: t.getSink, fetch (n) { return dO.nu(function (t) { return e.fetch(t) }).map(function (r) { return x.from(KT(Ne(ET(xu('menu-value'), r, function (t) { e.onItemAction(n, t) }, e.columns, e.presets, IS.CLOSE_ON_EXECUTE, function () { return !1 }, t.providers), { movement: NT(e.columns, e.presets) }))) }) }, parts: { menu: gT(!1, 1, e.presets) } }) }; const lN = xu('color-input-change'); const fN = xu('color-swatch-change'); const dN = xu('color-picker-cancel'); const mN = function (e, t, n) { const r = XE.parts().field({ factory: eO, inputClasses: ['tox-textfield'], onSetValue (e) { return kO.run(e).get(function () {}) }, inputBehaviours: yl([NO.config({}), kO.config({ invalidClass: 'tox-textbox-field-invalid', getRoot (e) { return Pi(e.element()) }, notify: { onValid (e) { const t = Bg.getValue(e); ni(e, lN, { color: t }) } }, validator: { validateOnLoad: !1, validate (e) { const t = Bg.getValue(e); if (t.length === 0) { return dO.pure(T.value(!0)) } const n = Wn.fromTag('span'); Ra(n, 'background-color', t); const r = Ia(n, 'background-color').fold(function () { return T.error('blah') }, function (e) { return T.value(t) }); return dO.pure(r) } } })]), selectOnFocus: !1 }); const o = e.label.map(function (e) { return MO(e, t.providers) }); const i = function (e, t) { ni(e, fN, { value: t }) }; const u = function (e, t) { a.getOpt(e).each(function (e) { t === 'custom' ? n.colorPicker(function (t) { t.fold(function () { return ti(e, dN) }, function (t) { i(e, t), Lk.addColor(t) }) }, '#ffffff') : i(e, t === 'remove' ? '' : t) }) }; var a = dx(sN({ dom: { tag: 'span', attributes: { 'aria-label': t.providers.translate('Color swatch') } }, layouts: { onRtl () { return [Qs, Zs, rl] }, onLtr () { return [Zs, Qs, rl] } }, components: [], fetch: cT.getFetch(n.getColors(), n.hasCustomColors()), columns: n.getColorCols(), presets: 'color', onItemAction: u }, t)); return XE.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: o.toArray().concat([{ dom: { tag: 'div', classes: ['tox-color-input'] }, components: [r, a.asSpec()] }]), fieldBehaviours: yl([cy('form-field-events', [fi(lN, function (t, n) { a.getOpt(t).each(function (e) { Ra(e.element(), 'background-color', n.event().color()) }), ni(t, ME, { name: e.name }) }), fi(fN, function (e, t) { XE.getField(e).each(function (n) { Bg.setValue(n, t.event().value()), np.getCurrent(e).each(vy.focus) }) }), fi(dN, function (e, t) { XE.getField(e).each(function (t) { np.getCurrent(e).each(vy.focus) }) })])]) }) }; const gN = function (e, t, n) { return { hue: i(e), saturation: i(t), value: i(n) } }; const hN = function (e) { let t = 0; let n = 0; let r = 0; const o = e.red() / 255; const i = e.green() / 255; const u = e.blue() / 255; const a = Math.min(o, Math.min(i, u)); const c = Math.max(o, Math.max(i, u)); if (a === c) { return r = a, gN(0, 0, 100 * r) } const s = o === a ? i - u : u === a ? o - i : u - o; return t = o === a ? 3 : u === a ? 1 : 5, t = 60 * (t - s / (c - a)), n = (c - a) / c, r = c, gN(Math.round(t), Math.round(100 * n), Math.round(100 * r)) }; const pN = function (e) { const t = (100 - e) / 100 * 360; const n = gN(t, 100, 100); const r = yk(n); return fk(r) }; const vN = i(xu('rgb-hex-update')); const bN = i(xu('slider-update')); const yN = i(xu('palette-update')); const wN = gh({ schema: [cn('dom')], name: 'label' }); const xN = function (e) { return gh({ name: e + '-edge', overrides (t) { const n = t.model.manager.edgeActions[e]; return n.fold(function () { return {} }, function (e) { return { events: ai([di(lo(), function (t, n, r) { return e(t, r) }, [t]), di(ho(), function (t, n, r) { return e(t, r) }, [t]), di(po(), function (t, n, r) { r.mouseIsDown.get() && e(t, r) }, [t])]) } }) } }) }; const CN = xN('top-left'); const SN = xN('top'); const kN = xN('top-right'); const TN = xN('right'); const EN = xN('bottom-right'); const ON = xN('bottom'); const NN = xN('bottom-left'); const _N = xN('left'); const DN = dh({ name: 'thumb', defaults: i({ dom: { styles: { position: 'absolute' } } }), overrides (e) { return { events: ai([pi(lo(), e, 'spectrum'), pi(fo(), e, 'spectrum'), pi(mo(), e, 'spectrum'), pi(ho(), e, 'spectrum'), pi(po(), e, 'spectrum'), pi(bo(), e, 'spectrum')]) } } }); const AN = dh({ schema: [In('mouseIsDown', function () { return Ln(!1) })], name: 'spectrum', overrides (e) { const t = e.model; const n = t.manager; const r = function (t, r) { return n.getValueFromEvent(r).map(function (r) { return n.setValueFrom(t, e, r) }) }; return { behaviours: yl([Kb.config({ mode: 'special', onLeft (t) { return n.onLeft(t, e) }, onRight (t) { return n.onRight(t, e) }, onUp (t) { return n.onUp(t, e) }, onDown (t) { return n.onDown(t, e) } }), vy.config({})]), events: ai([fi(lo(), r), fi(fo(), r), fi(ho(), r), fi(po(), function (t, n) { e.mouseIsDown.get() && r(t, n) })]) } } }); const RN = [wN, _N, TN, SN, ON, CN, kN, NN, EN, DN, AN]; const BN = 'slider.change.value'; const MN = i(BN); const PN = function (e) { return e.type.includes('touch') }; const zN = function (e) { const t = e.event().raw(); if (PN(t)) { const n = t; return void 0 !== n.touches && n.touches.length === 1 ? x.some(n.touches[0]).map(function (e) { return lc(e.clientX, e.clientY) }) : x.none() } const r = t; return void 0 !== r.clientX ? x.some(r).map(function (e) { return lc(e.clientX, e.clientY) }) : x.none() }; const IN = 'top'; const LN = 'right'; const HN = 'bottom'; const FN = 'left'; const VN = function (e) { return e.model.minX }; const UN = function (e) { return e.model.minY }; const jN = function (e) { return e.model.minX - 1 }; const WN = function (e) { return e.model.minY - 1 }; const qN = function (e) { return e.model.maxX }; const $N = function (e) { return e.model.maxY }; const GN = function (e) { return e.model.maxX + 1 }; const XN = function (e) { return e.model.maxY + 1 }; const YN = function (e, t, n) { return t(e) - n(e) }; const KN = function (e) { return YN(e, qN, VN) }; const JN = function (e) { return YN(e, $N, UN) }; const ZN = function (e) { return KN(e) / 2 }; const QN = function (e) { return JN(e) / 2 }; const e_ = function (e) { return e.stepSize }; const t_ = function (e) { return e.snapToGrid }; const n_ = function (e) { return e.snapStart }; const r_ = function (e) { return e.rounded }; const o_ = function (e, t) { return void 0 !== e[t + '-edge'] }; const i_ = function (e) { return o_(e, FN) }; const u_ = function (e) { return o_(e, LN) }; const a_ = function (e) { return o_(e, IN) }; const c_ = function (e) { return o_(e, HN) }; const s_ = function (e) { return e.model.value.get() }; const l_ = function (e) { return { x: i(e) } }; const f_ = function (e) { return { y: i(e) } }; const d_ = function (e, t) { return { x: i(e), y: i(t) } }; const m_ = function (e, t) { ni(e, MN(), { value: t }) }; const g_ = function (e, t) { m_(e, d_(jN(t), WN(t))) }; const h_ = function (e, t) { m_(e, f_(WN(t))) }; const p_ = function (e, t) { m_(e, d_(ZN(t), WN(t))) }; const v_ = function (e, t) { m_(e, d_(GN(t), WN(t))) }; const b_ = function (e, t) { m_(e, l_(GN(t))) }; const y_ = function (e, t) { m_(e, d_(GN(t), QN(t))) }; const w_ = function (e, t) { m_(e, d_(GN(t), XN(t))) }; const x_ = function (e, t) { m_(e, f_(XN(t))) }; const C_ = function (e, t) { m_(e, d_(ZN(t), XN(t))) }; const S_ = function (e, t) { m_(e, d_(jN(t), XN(t))) }; const k_ = function (e, t) { m_(e, l_(jN(t))) }; const T_ = function (e, t) { m_(e, d_(jN(t), QN(t))) }; const E_ = function (e, t, n, r) { return e < t ? e : e > n ? n : e === t ? t - 1 : Math.max(t, e - r) }; const O_ = function (e, t, n, r) { return e > n ? e : e < t ? t : e === n ? n + 1 : Math.min(n, e + r) }; const N_ = function (e, t, n) { return Math.max(t, Math.min(n, e)) }; const __ = function (e, t, n, r, o) { return o.fold(function () { const o = e - t; const i = Math.round(o / r) * r; return N_(t + i, t - 1, n + 1) }, function (t) { const o = (e - t) % r; const i = Math.round(o / r); const u = Math.floor((e - t) / r); const a = Math.floor((n - t) / r); const c = Math.min(a, u + i); const s = t + c * r; return Math.max(t, s) }) }; const D_ = function (e, t, n) { return Math.min(n, Math.max(e, t)) - t }; const A_ = function (e) { const t = e.min; const n = e.max; const r = e.range; const o = e.value; const i = e.step; const u = e.snap; const a = e.snapStart; const c = e.rounded; const s = e.hasMinEdge; const l = e.hasMaxEdge; const f = e.minBound; const d = e.maxBound; const m = e.screenRange; const g = s ? t - 1 : t; const h = l ? n + 1 : n; if (o < f) { return g } if (o > d) { return h } const p = D_(o, f, d); const v = N_(p / m * r + t, g, h); return u && v >= t && v <= n ? __(v, t, n, i, a) : c ? Math.round(v) : v }; const R_ = function (e) { const t = e.min; const n = e.max; const r = e.range; const o = e.value; const i = e.hasMinEdge; const u = e.hasMaxEdge; const a = e.maxBound; const c = e.maxOffset; const s = e.centerMinEdge; const l = e.centerMaxEdge; return o < t ? i ? 0 : s : o > n ? u ? a : l : (o - t) / r * c }; const B_ = 'top'; const M_ = 'right'; const P_ = 'bottom'; const z_ = 'left'; const I_ = 'width'; const L_ = 'height'; const H_ = function (e) { return e.element().dom().getBoundingClientRect() }; const F_ = function (e, t) { return e[t] }; const V_ = function (e) { const t = H_(e); return F_(t, z_) }; const U_ = function (e) { const t = H_(e); return F_(t, M_) }; const j_ = function (e) { const t = H_(e); return F_(t, B_) }; const W_ = function (e) { const t = H_(e); return F_(t, P_) }; const q_ = function (e) { const t = H_(e); return F_(t, I_) }; const $_ = function (e) { const t = H_(e); return F_(t, L_) }; const G_ = function (e, t, n) { return (e + t) / 2 - n }; const X_ = function (e, t) { const n = H_(e); const r = H_(t); const o = F_(n, z_); const i = F_(n, M_); const u = F_(r, z_); return G_(o, i, u) }; const Y_ = function (e, t) { const n = H_(e); const r = H_(t); const o = F_(n, B_); const i = F_(n, P_); const u = F_(r, B_); return G_(o, i, u) }; const K_ = function (e, t) { ni(e, MN(), { value: t }) }; const J_ = function (e) { return { x: i(e) } }; const Z_ = function (e, t, n) { const r = { min: VN(t), max: qN(t), range: KN(t), value: n, step: e_(t), snap: t_(t), snapStart: n_(t), rounded: r_(t), hasMinEdge: i_(t), hasMaxEdge: u_(t), minBound: V_(e), maxBound: U_(e), screenRange: q_(e) }; return A_(r) }; const Q_ = function (e, t, n) { const r = Z_(e, t, n); const o = J_(r); return K_(e, o), r }; const eD = function (e, t) { const n = VN(t); K_(e, J_(n)) }; const tD = function (e, t) { const n = qN(t); K_(e, J_(n)) }; const nD = function (e, t, n) { const r = e > 0 ? O_ : E_; const o = r(s_(n).x(), VN(n), qN(n), e_(n)); return K_(t, J_(o)), x.some(o) }; const rD = function (e) { return function (t, n) { return nD(e, t, n).map(function () { return !0 }) } }; const oD = function (e) { const t = zN(e); return t.map(function (e) { return e.left() }) }; const iD = function (e, t, n, r, o) { const i = 0; const u = q_(e); const a = r.bind(function (t) { return x.some(X_(t, e)) }).getOr(i); const c = o.bind(function (t) { return x.some(X_(t, e)) }).getOr(u); const s = { min: VN(t), max: qN(t), range: KN(t), value: n, hasMinEdge: i_(t), hasMaxEdge: u_(t), minBound: V_(e), minOffset: i, maxBound: U_(e), maxOffset: u, centerMinEdge: a, centerMaxEdge: c }; return R_(s) }; const uD = function (e, t, n, r, o, i) { const u = iD(t, i, n, r, o); return V_(t) - V_(e) + u }; const aD = function (e, t, n, r) { const o = s_(n); const i = uD(e, r.getSpectrum(e), o.x(), r.getLeftEdge(e), r.getRightEdge(e), n); const u = vc(t.element()) / 2; Ra(t.element(), 'left', i - u + 'px') }; const cD = rD(-1); const sD = rD(1); const lD = x.none; const fD = x.none; const dD = { 'top-left': x.none(), top: x.none(), 'top-right': x.none(), right: x.some(b_), 'bottom-right': x.none(), bottom: x.none(), 'bottom-left': x.none(), left: x.some(k_) }; const mD = Object.freeze({ __proto__: null, setValueFrom: Q_, setToMin: eD, setToMax: tD, findValueOfOffset: Z_, getValueFromEvent: oD, findPositionOfValue: uD, setPositionFromValue: aD, onLeft: cD, onRight: sD, onUp: lD, onDown: fD, edgeActions: dD }); const gD = function (e, t) { ni(e, MN(), { value: t }) }; const hD = function (e) { return { y: i(e) } }; const pD = function (e, t, n) { const r = { min: UN(t), max: $N(t), range: JN(t), value: n, step: e_(t), snap: t_(t), snapStart: n_(t), rounded: r_(t), hasMinEdge: a_(t), hasMaxEdge: c_(t), minBound: j_(e), maxBound: W_(e), screenRange: $_(e) }; return A_(r) }; const vD = function (e, t, n) { const r = pD(e, t, n); const o = hD(r); return gD(e, o), r }; const bD = function (e, t) { const n = UN(t); gD(e, hD(n)) }; const yD = function (e, t) { const n = $N(t); gD(e, hD(n)) }; const wD = function (e, t, n) { const r = e > 0 ? O_ : E_; const o = r(s_(n).y(), UN(n), $N(n), e_(n)); return gD(t, hD(o)), x.some(o) }; const xD = function (e) { return function (t, n) { return wD(e, t, n).map(function () { return !0 }) } }; const CD = function (e) { const t = zN(e); return t.map(function (e) { return e.top() }) }; const SD = function (e, t, n, r, o) { const i = 0; const u = $_(e); const a = r.bind(function (t) { return x.some(Y_(t, e)) }).getOr(i); const c = o.bind(function (t) { return x.some(Y_(t, e)) }).getOr(u); const s = { min: UN(t), max: $N(t), range: JN(t), value: n, hasMinEdge: a_(t), hasMaxEdge: c_(t), minBound: j_(e), minOffset: i, maxBound: W_(e), maxOffset: u, centerMinEdge: a, centerMaxEdge: c }; return R_(s) }; const kD = function (e, t, n, r, o, i) { const u = SD(t, i, n, r, o); return j_(t) - j_(e) + u }; const TD = function (e, t, n, r) { const o = s_(n); const i = kD(e, r.getSpectrum(e), o.y(), r.getTopEdge(e), r.getBottomEdge(e), n); const u = uc(t.element()) / 2; Ra(t.element(), 'top', i - u + 'px') }; const ED = x.none; const OD = x.none; const ND = xD(-1); const _D = xD(1); const DD = { 'top-left': x.none(), top: x.some(h_), 'top-right': x.none(), right: x.none(), 'bottom-right': x.none(), bottom: x.some(x_), 'bottom-left': x.none(), left: x.none() }; const AD = Object.freeze({ __proto__: null, setValueFrom: vD, setToMin: bD, setToMax: yD, findValueOfOffset: pD, getValueFromEvent: CD, findPositionOfValue: kD, setPositionFromValue: TD, onLeft: ED, onRight: OD, onUp: ND, onDown: _D, edgeActions: DD }); const RD = function (e, t) { ni(e, MN(), { value: t }) }; const BD = function (e, t) { return { x: i(e), y: i(t) } }; const MD = function (e, t, n) { const r = Z_(e, t, n.left()); const o = pD(e, t, n.top()); const i = BD(r, o); return RD(e, i), i }; const PD = function (e, t, n, r) { const o = e > 0 ? O_ : E_; const i = t ? s_(r).x() : o(s_(r).x(), VN(r), qN(r), e_(r)); const u = t ? o(s_(r).y(), UN(r), $N(r), e_(r)) : s_(r).y(); return RD(n, BD(i, u)), x.some(i) }; const zD = function (e, t) { return function (n, r) { return PD(e, t, n, r).map(function () { return !0 }) } }; const ID = function (e, t) { const n = VN(t); const r = UN(t); RD(e, BD(n, r)) }; const LD = function (e, t) { const n = qN(t); const r = $N(t); RD(e, BD(n, r)) }; const HD = function (e) { return zN(e) }; const FD = function (e, t, n, r) { const o = s_(n); const i = uD(e, r.getSpectrum(e), o.x(), r.getLeftEdge(e), r.getRightEdge(e), n); const u = kD(e, r.getSpectrum(e), o.y(), r.getTopEdge(e), r.getBottomEdge(e), n); const a = vc(t.element()) / 2; const c = uc(t.element()) / 2; Ra(t.element(), 'left', i - a + 'px'), Ra(t.element(), 'top', u - c + 'px') }; const VD = zD(-1, !1); const UD = zD(1, !1); const jD = zD(-1, !0); const WD = zD(1, !0); const qD = { 'top-left': x.some(g_), top: x.some(p_), 'top-right': x.some(v_), right: x.some(y_), 'bottom-right': x.some(w_), bottom: x.some(C_), 'bottom-left': x.some(S_), left: x.some(T_) }; const $D = Object.freeze({ __proto__: null, setValueFrom: MD, setToMin: ID, setToMax: LD, getValueFromEvent: HD, setPositionFromValue: FD, onLeft: VD, onRight: UD, onUp: jD, onDown: WD, edgeActions: qD }); const GD = [On('stepSize', 1), On('onChange', n), On('onChoose', n), On('onInit', n), On('onDragStart', n), On('onDragEnd', n), On('snapToGrid', !1), On('rounded', !0), yn('snapStart'), sn('model', Jt('mode', { x: [On('minX', 0), On('maxX', 100), In('value', function (e) { return Ln(e.mode.minX) }), cn('getInitialValue'), Ts('manager', mD)], y: [On('minY', 0), On('maxY', 100), In('value', function (e) { return Ln(e.mode.minY) }), cn('getInitialValue'), Ts('manager', AD)], xy: [On('minX', 0), On('maxX', 100), On('minY', 0), On('maxY', 100), In('value', function (e) { return Ln({ x: i(e.mode.minX), y: i(e.mode.minY) }) }), cn('getInitialValue'), Ts('manager', $D)] })), Mg('sliderBehaviours', [Kb, Bg]), In('mouseIsDown', function () { return Ln(!1) })]; const XD = function (e, t, n, r) { let o; const u = function (t) { return Nh(t, e, 'thumb') }; const a = function (t) { return Nh(t, e, 'spectrum') }; const c = function (t) { return Oh(t, e, 'left-edge') }; const s = function (t) { return Oh(t, e, 'right-edge') }; const l = function (t) { return Oh(t, e, 'top-edge') }; const f = function (t) { return Oh(t, e, 'bottom-edge') }; const d = e.model; const m = d.manager; const g = function (t, n) { m.setPositionFromValue(t, n, e, { getLeftEdge: c, getRightEdge: s, getTopEdge: l, getBottomEdge: f, getSpectrum: a }) }; const h = function (t, n) { d.value.set(n); const r = u(t); return g(t, r), e.onChange(t, r, n), x.some(!0) }; const p = function (t) { m.setToMin(t, e) }; const v = function (t) { m.setToMax(t, e) }; const b = function (t) { const n = function () { Oh(t, e, 'thumb').each(function (n) { const r = d.value.get(); e.onChoose(t, n, r) }) }; const r = e.mouseIsDown.get(); e.mouseIsDown.set(!1), r && n() }; const y = function (t, n) { n.stop(), e.mouseIsDown.set(!0), e.onDragStart(t, u(t)) }; const w = function (t, n) { n.stop(), e.onDragEnd(t, u(t)), b(t) }; return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.sliderBehaviours, [Kb.config({ mode: 'special', focusIn (t) { return Oh(t, e, 'spectrum').map(Kb.focusIn).map(i(!0)) } }), Bg.config({ store: { mode: 'manual', getValue (e) { return d.value.get() } } }), _l.config({ channels: (o = {}, o[eg()] = { onReceive: b }, o) })]), events: ai([fi(MN(), function (e, t) { h(e, t.event().value()) }), xi(function (t, n) { const r = d.getInitialValue(); d.value.set(r); const o = u(t); g(t, o); const i = a(t); e.onInit(t, o, i, d.value.get()) }), fi(lo(), y), fi(mo(), w), fi(ho(), y), fi(bo(), w)]), apis: { resetToMin: p, resetToMax: v, changeValue: h, refresh: g }, domModification: { styles: { position: 'relative' } } } }; const YD = Gh({ name: 'Slider', configFields: GD, partFields: RN, factory: XD, apis: { resetToMin (e, t) { e.resetToMin(t) }, resetToMax (e, t) { e.resetToMax(t) }, refresh (e, t) { e.refresh(t) } } }); const KD = function (e, t) { const n = YD.parts().spectrum({ dom: { tag: 'div', classes: [t('hue-slider-spectrum')], attributes: { role: 'presentation' } } }); const r = YD.parts().thumb({ dom: { tag: 'div', classes: [t('hue-slider-thumb')], attributes: { role: 'presentation' } } }); return YD.sketch({ dom: { tag: 'div', classes: [t('hue-slider')], attributes: { role: 'presentation' } }, rounded: !1, model: { mode: 'y', getInitialValue: i({ y: i(0) }) }, components: [n, r], sliderBehaviours: yl([vy.config({})]), onChange (e, t, n) { ni(e, bN(), { value: n }) } }) }; const JD = 'form'; const ZD = [Mg('formBehaviours', [Bg])]; const QD = function (e) { return '<alloy.field.' + e + '>' }; const eA = function (e) { const t = (function () { const e = []; const t = function (t, n) { return e.push(t), Ch(JD, QD(t), n) }; return { field: t, record () { return e } } }()); const n = e(t); const r = t.record(); const o = W(r, function (e) { return dh({ name: e, pname: QD(e) }) }); return Hh(JD, ZD, o, nA, n) }; const tA = function (e, t) { return e.fold(function () { return T.error(t) }, T.value) }; var nA = function (e, t) { return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.formBehaviours, [Bg.config({ store: { mode: 'manual', getValue (t) { const n = Dh(t, e); return ge(n, function (e, t) { return e().bind(function (e) { const n = np.getCurrent(e); return tA(n, new Error("Cannot find a current component to extract the value from for form part '" + t + "': " + pu(e.element()))) }).map(Bg.getValue) }) }, setValue (t, n) { me(n, function (n, r) { Oh(t, e, r).each(function (e) { np.getCurrent(e).each(function (e) { Bg.setValue(e, n) }) }) }) } } })]), apis: { getField (t, n) { return Oh(t, e, n).bind(np.getCurrent) } } } }; const rA = { getField: Fu(function (e, t, n) { return e.getField(t, n) }), sketch: eA }; const oA = xu('valid-input'); const iA = xu('invalid-input'); const uA = xu('validating-input'); const aA = 'colorcustom.rgb.'; const cA = function (e, t, r, o) { const u = function (n, r) { return kO.config({ invalidClass: t('invalid'), notify: { onValidate (e) { ni(e, uA, { type: n }) }, onValid (e) { ni(e, oA, { type: n, value: Bg.getValue(e) }) }, onInvalid (e) { ni(e, iA, { type: n, value: Bg.getValue(e) }) } }, validator: { validate (t) { const n = Bg.getValue(t); const o = r(n) ? T.value(!0) : T.error(e('aria.input.invalid')); return dO.pure(o) }, validateOnLoad: !1 } }) }; const a = function (r, o, i, a, c) { const s = e(aA + 'range'); const l = XE.parts().label({ dom: { tag: 'label', innerHtml: i, attributes: { 'aria-label': a } } }); const f = XE.parts().field({ data: c, factory: eO, inputAttributes: m({ type: 'text' }, o === 'hex' ? { 'aria-live': 'polite' } : {}), inputClasses: [t('textfield')], inputBehaviours: yl([u(o, r), NO.config({})]), onSetValue (e) { if (kO.isInvalid(e)) { const t = kO.run(e); t.get(n) } } }); const d = [l, f]; const g = o !== 'hex' ? [XE.parts()['aria-descriptor']({ text: s })] : []; const h = d.concat(g); return { dom: { tag: 'div', attributes: { role: 'presentation' } }, components: h } }; const c = function (e, t) { const n = fk(t); return rA.getField(e, 'hex').each(function (t) { vy.isFocused(t) || Bg.setValue(e, { hex: n.value() }) }), n }; const s = function (e, t) { const n = t.red(); const r = t.green(); const o = t.blue(); Bg.setValue(e, { red: n, green: r, blue: o }) }; const l = dx({ dom: { tag: 'div', classes: [t('rgba-preview')], styles: { 'background-color': 'white' }, attributes: { role: 'presentation' } } }); const f = function (e, t) { l.getOpt(e).each(function (e) { Ra(e.element(), 'background-color', '#' + t.value()) }) }; const d = function () { const n = { red: i(Ln(x.some(255))), green: i(Ln(x.some(255))), blue: i(Ln(x.some(255))), hex: i(Ln(x.some('ffffff'))) }; const u = function (e, t) { const n = wk(t); s(e, n), h(n) }; const d = function (e) { return n[e]().get() }; const m = function (e, t) { n[e]().set(t) }; const g = function () { return d('red').bind(function (e) { return d('green').bind(function (t) { return d('blue').map(function (n) { return vk(e, t, n, 1) }) }) }) }; var h = function (e) { const t = e.red(); const n = e.green(); const r = e.blue(); m('red', x.some(t)), m('green', x.some(n)), m('blue', x.some(r)) }; const p = function (e, t) { const n = t.event(); n.type() !== 'hex' ? m(n.type(), x.none()) : o(e) }; const v = function (e, t) { r(e); const n = ok(t); m('hex', x.some(t)); const o = wk(n); s(e, o), h(o), ni(e, vN(), { hex: n }), f(e, n) }; const b = function (e, t, n) { const r = parseInt(n, 10); m(t, x.some(r)), g().each(function (t) { const n = c(e, t); f(e, n) }) }; const y = function (e) { return e.type() === 'hex' }; const w = function (e, t) { const n = t.event(); y(n) ? v(e, n.value()) : b(e, n.type(), n.value()) }; const C = function (t) { return { label: e(aA + t + '.label'), description: e(aA + t + '.description') } }; const S = C('red'); const k = C('green'); const T = C('blue'); const E = C('hex'); return Ne(rA.sketch(function (n) { return { dom: { tag: 'form', classes: [t('rgb-form')], attributes: { 'aria-label': e('aria.color.picker') } }, components: [n.field('red', XE.sketch(a(bk, 'red', S.label, S.description, 255))), n.field('green', XE.sketch(a(bk, 'green', k.label, k.description, 255))), n.field('blue', XE.sketch(a(bk, 'blue', T.label, T.description, 255))), n.field('hex', XE.sketch(a(ak, 'hex', E.label, E.description, 'ffffff'))), l.asSpec()], formBehaviours: yl([kO.config({ invalidClass: t('form-invalid') }), cy('rgb-form-events', [fi(oA, w), fi(iA, p), fi(uA, p)])]) } }), { apis: { updateHex (e, t) { Bg.setValue(e, { hex: t.value() }), u(e, t), f(e, t) } } }) }; const g = $h({ factory: d, name: 'RgbForm', configFields: [], apis: { updateHex (e, t, n) { e.updateHex(t, n) } }, extraApis: {} }); return g }; const sA = function (e, t) { const n = YD.parts().spectrum({ dom: { tag: 'canvas', attributes: { role: 'presentation' }, classes: [t('sv-palette-spectrum')] } }); const r = YD.parts().thumb({ dom: { tag: 'div', attributes: { role: 'presentation' }, classes: [t('sv-palette-thumb')], innerHtml: '<div class=' + t('sv-palette-inner-thumb') + ' role="presentation"></div>' } }); const o = function (e, t) { const n = e.width; const r = e.height; const o = e.getContext('2d'); if (o !== null) { o.fillStyle = t, o.fillRect(0, 0, n, r); const i = o.createLinearGradient(0, 0, n, 0); i.addColorStop(0, 'rgba(255,255,255,1)'), i.addColorStop(1, 'rgba(255,255,255,0)'), o.fillStyle = i, o.fillRect(0, 0, n, r); const u = o.createLinearGradient(0, 0, 0, r); u.addColorStop(0, 'rgba(0,0,0,0)'), u.addColorStop(1, 'rgba(0,0,0,1)'), o.fillStyle = u, o.fillRect(0, 0, n, r) } }; const u = function (e, t) { const n = e.components()[0].element().dom(); o(n, Sk(t)) }; const a = function (e) { const u = i({ x: i(0), y: i(0) }); const a = function (e, t, n) { ni(e, yN(), { value: n }) }; const c = function (e, t, n, r) { o(n.element().dom(), Sk(kk())) }; const s = yl([np.config({ find: x.some }), vy.config({})]); return YD.sketch({ dom: { tag: 'div', attributes: { role: 'presentation' }, classes: [t('sv-palette')] }, model: { mode: 'xy', getInitialValue: u }, rounded: !1, components: [n, r], onChange: a, onInit: c, sliderBehaviours: s }) }; const c = $h({ factory: a, name: 'SaturationBrightnessPalette', configFields: [], apis: { setRgba (e, t, n) { u(t, n) } }, extraApis: {} }); return c }; const lA = function (e, t) { const r = function (n) { const r = cA(e, t, n.onValidHex, n.onInvalidHex); const o = sA(e, t); const u = { paletteRgba: i(Ln(kk())) }; const a = dx(o.sketch({})); const c = dx(r.sketch({})); const s = function (e, t) { a.getOpt(e).each(function (e) { const n = wk(t); u.paletteRgba().set(n), o.setRgba(e, n) }) }; const l = function (e, t) { c.getOpt(e).each(function (e) { r.updateHex(e, t) }) }; const f = function (e, t, n) { q(n, function (n) { n(e, t) }) }; const d = function () { const e = [l]; return function (t, n) { const r = n.event().value(); const o = u.paletteRgba().get(); const i = hN(o); const a = gN(i.hue(), r.x(), 100 - r.y()); const c = yk(a); const s = fk(c); f(t, s, e) } }; const m = function () { const e = [s, l]; return function (t, n) { const r = n.event().value(); const o = pN(r.y()); f(t, o, e) } }; return { uid: n.uid, dom: n.dom, components: [a.asSpec(), KD(e, t), c.asSpec()], behaviours: yl([cy('colour-picker-events', [fi(yN(), d()), fi(bN(), m())]), np.config({ find (e) { return c.getOpt(e) } }), Kb.config({ mode: 'acyclic' })]) } }; const o = $h({ name: 'ColourPicker', configFields: [cn('dom'), On('onValidHex', n), On('onInvalidHex', n)], factory: r }); return o }; const fA = function () { return np.config({ find: x.some }) }; const dA = function (e) { return np.config({ find: e.getOpt }) }; const mA = function (e) { return np.config({ find (t) { return Hi(t.element(), e).bind(function (e) { return t.getSystem().getByDom(e).toOption() }) } }) }; const gA = { self: fA, memento: dA, childAt: mA }; const hA = { 'colorcustom.rgb.red.label': 'R', 'colorcustom.rgb.red.description': 'Red component', 'colorcustom.rgb.green.label': 'G', 'colorcustom.rgb.green.description': 'Green component', 'colorcustom.rgb.blue.label': 'B', 'colorcustom.rgb.blue.description': 'Blue component', 'colorcustom.rgb.hex.label': '#', 'colorcustom.rgb.hex.description': 'Hex color code', 'colorcustom.rgb.range': 'Range 0 to 255', 'colorcustom.sb.saturation': 'Saturation', 'colorcustom.sb.brightness': 'Brightness', 'colorcustom.sb.picker': 'Saturation and Brightness Picker', 'colorcustom.sb.palette': 'Saturation and Brightness Palette', 'colorcustom.sb.instructions': 'Use arrow keys to select saturation and brightness, on x and y axes', 'colorcustom.hue.hue': 'Hue', 'colorcustom.hue.slider': 'Hue Slider', 'colorcustom.hue.palette': 'Hue Palette', 'colorcustom.hue.instructions': 'Use arrow keys to select a hue', 'aria.color.picker': 'Color Picker', 'aria.input.invalid': 'Invalid input' }; const pA = function (e) { return hA[e] }; const vA = function (e) { return pA(e) }; const bA = function (e) { const n = function (e) { return 'tox-' + e }; const r = lA(vA, n); const o = function (e) { ni(e, IE, { name: 'hex-valid', value: !0 }) }; const i = function (e) { ni(e, IE, { name: 'hex-valid', value: !1 }) }; const u = dx(r.sketch({ dom: { tag: 'div', classes: [n('color-picker-container')], attributes: { role: 'presentation' } }, onValidHex: o, onInvalidHex: i })); return { dom: { tag: 'div' }, components: [u.asSpec()], behaviours: yl([Bg.config({ store: { mode: 'manual', getValue (e) { const t = u.get(e); const n = np.getCurrent(t); const r = n.bind(function (e) { const t = Bg.getValue(e); return t.hex }); return r.map(function (e) { return '#' + e }).getOr('') }, setValue (e, n) { const r = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/; const o = r.exec(n); const i = u.get(e); const a = np.getCurrent(i); a.fold(function () { t.console.log('Can not find form') }, function (e) { Bg.setValue(e, { hex: x.from(o[1]).getOr('') }), rA.getField(e, 'hex').each(function (e) { ti(e, ko()) }) }) } } }), gA.self()]) } }; const yA = tinymce.util.Tools.resolve('tinymce.Resource'); const wA = function (e) { return Object.prototype.hasOwnProperty.call(e, 'init') }; const xA = function (e) { const t = Ln(x.none()); const n = dx({ dom: { tag: e.tag } }); const r = Ln(x.none()); return { dom: { tag: 'div', classes: ['tox-custom-editor'] }, behaviours: yl([cy('editor-foo-events', [xi(function (o) { n.getOpt(o).each(function (n) { (wA(e) ? e.init(n.element().dom()) : yA.load(e.scriptId, e.scriptUrl).then(function (t) { return t(n.element().dom(), e.settings) })).then(function (e) { r.get().each(function (t) { e.setValue(t) }), r.set(x.none()), t.set(x.some(e)) }) }) })]), Bg.config({ store: { mode: 'manual', getValue () { return t.get().fold(function () { return r.get().getOr('') }, function (e) { return e.getValue() }) }, setValue (e, n) { t.get().fold(function () { r.set(x.some(n)) }, function (e) { return e.setValue(n) }) } } }), gA.self()]), components: [n.asSpec()] } }; const CA = _t([On('preprocess', u), On('postprocess', u)]); const SA = function (e, t) { const n = Xt('RepresentingConfigs.memento processors', CA, t); return Bg.config({ store: { mode: 'manual', getValue (t) { const r = e.get(t); const o = Bg.getValue(r); return n.postprocess(o) }, setValue (t, r) { const o = n.preprocess(r); const i = e.get(t); Bg.setValue(i, o) } } }) }; const kA = function (e, t, n) { return Bg.config(Ne({ store: { mode: 'manual', getValue: t, setValue: n } }, e.map(function (e) { return { store: { initialValue: e } } }).getOr({}))) }; const TA = function (e, t, n) { return kA(e, function (e) { return t(e.element()) }, function (e, t) { return n(e.element(), t) }) }; const EA = function (e) { return TA(e, Ua, ja) }; const OA = function (e) { return TA(e, Zi, Qi) }; const NA = function (e) { return Bg.config({ store: { mode: 'memory', initialValue: e } }) }; const _A = { memento: SA, withElement: TA, withComp: kA, domValue: EA, domHtml: OA, memory: NA }; const DA = '.jpg,.jpeg,.png,.gif'; const AA = function (e) { const t = new RegExp('(' + DA.split(/\s*,\s*/).join('|') + ')$', 'i'); return X(se(e), function (e) { return t.test(e.name) }) }; const RA = function (e, t) { const n = function (e, t) { t.stop() }; const r = function (e) { return function (t, n) { q(e, function (e) { e(t, n) }) } }; const o = function (e, t) { if (!NS.isDisabled(e)) { const n = t.event().raw(); u(e, n.dataTransfer.files) } }; const i = function (e, t) { const n = t.event().raw().target.files; u(e, n) }; var u = function (t, n) { Bg.setValue(t, AA(n)), ni(t, ME, { name: e.name }) }; const a = dx({ dom: { tag: 'input', attributes: { type: 'file', accept: 'image/*' }, styles: { display: 'none' } }, behaviours: yl([cy('input-file-events', [bi(Eo()), bi(zo())])]) }); const c = function (e) { return { uid: e.uid, dom: { tag: 'div', classes: ['tox-dropzone-container'] }, behaviours: yl([_A.memory([]), gA.self(), NS.config({}), zy.config({ toggleClass: 'dragenter', toggleOnExecute: !1 }), cy('dropzone-events', [fi('dragenter', r([n, zy.toggle])), fi('dragleave', r([n, zy.toggle])), fi('dragover', n), fi('drop', r([n, o])), fi(To(), i)])]), components: [{ dom: { tag: 'div', classes: ['tox-dropzone'], styles: {} }, components: [{ dom: { tag: 'p', innerHtml: t.translate('Drop an image here') } }, fx.sketch({ dom: { tag: 'button', innerHtml: t.translate('Browse for an image'), styles: { position: 'relative' }, classes: ['tox-button', 'tox-button--secondary'] }, components: [a.asSpec()], action (e) { const t = a.get(e); t.element().dom().click() }, buttonBehaviours: yl([NO.config({})]) })] }] } }; const s = e.label.map(function (e) { return MO(e, t) }); const l = XE.parts().field({ factory: { sketch: c } }); return _O(s, l, ['tox-form__group--stretched'], []) }; const BA = function (e, t) { return { dom: { tag: 'div', classes: ['tox-form__grid', 'tox-form__grid--' + e.columns + 'col'] }, components: W(e.items, t.interpreter) } }; const MA = xu('alloy-fake-before-tabstop'); const PA = xu('alloy-fake-after-tabstop'); const zA = function (e) { return { dom: { tag: 'div', styles: { width: '1px', height: '1px', outline: 'none' }, attributes: { tabindex: '0' }, classes: e }, behaviours: yl([vy.config({ ignore: !0 }), NO.config({})]) } }; const IA = function (e) { return { dom: { tag: 'div', classes: ['tox-navobj'] }, components: [zA([MA]), e, zA([PA])], behaviours: yl([gA.childAt(1)]) } }; const LA = function (e, t) { ni(e, Co(), { raw: { which: 9, shiftKey: t } }) }; const HA = function (e, t) { const n = t.element(); Sa(n, MA) ? LA(e, !0) : Sa(n, PA) && LA(e, !1) }; const FA = function (e) { return oE(e, ['.' + MA, '.' + PA].join(','), i(!1)) }; const VA = { isPseudoStop: FA, onFocus: HA, craft: IA }; const UA = !(Vr().browser.isIE() || Vr().browser.isEdge()); const jA = function (e) { const t = Ln(''); return { getValue (e) { return t.get() }, setValue (n, r) { if (e) { au(n.element(), 'srcdoc', r) } else { au(n.element(), 'src', "javascript:''"); const o = n.element().dom().contentWindow.document; o.open(), o.write(r), o.close() }t.set(r) } } }; const WA = function (e, t) { const n = UA && e.sandboxed; const r = m(m({}, e.label.map(function (e) { return { title: e } }).getOr({})), n ? { sandbox: 'allow-scripts allow-same-origin' } : {}); const o = jA(n); const i = e.label.map(function (e) { return MO(e, t) }); const u = function (e) { return VA.craft({ uid: e.uid, dom: { tag: 'iframe', attributes: r }, behaviours: yl([NO.config({}), vy.config({}), _A.withComp(x.none(), o.getValue, o.setValue)]) }) }; const a = XE.parts().field({ factory: { sketch: u } }); return _O(i, a, ['tox-form__group--stretched'], []) }; function qA (e, n) { return XA(t.document.createElement('canvas'), e, n) } function $A (e) { const t = qA(e.width, e.height); const n = GA(t); return n.drawImage(e, 0, 0), t } function GA (e) { return e.getContext('2d') } function XA (e, t, n) { return e.width = t, e.height = n, e } function YA (e) { return e.naturalWidth || e.width } function KA (e) { return e.naturalHeight || e.height } const JA = function () { const e = function (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = null, this._value = null, this._deferreds = [], l(e, r(u, this), r(a, this)) }; const n = e.immediateFn || typeof window.setImmediate === 'function' && window.setImmediate || function (e) { t.setTimeout(e, 1) }; function r (e, t) { return function () { return e.apply(t, arguments) } } const o = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]' }; function i (e) { const t = this; this._state !== null ? n(function () { const n = t._state ? e.onFulfilled : e.onRejected; if (n !== null) { let r; try { r = n(t._value) } catch (o) { return void e.reject(o) }e.resolve(r) } else { (t._state ? e.resolve : e.reject)(t._value) } }) : this._deferreds.push(e) } function u (e) { try { if (e === this) { throw new TypeError('A promise cannot be resolved with itself.') } if (e && (typeof e === 'object' || typeof e === 'function')) { const t = e.then; if (typeof t === 'function') { return void l(r(t, e), r(u, this), r(a, this)) } } this._state = !0, this._value = e, c.call(this) } catch (n) { a.call(this, n) } } function a (e) { this._state = !1, this._value = e, c.call(this) } function c () { for (let e = 0, t = this._deferreds; e < t.length; e++) { const n = t[e]; i.call(this, n) } this._deferreds = [] } function s (e, t, n, r) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.resolve = n, this.reject = r } function l (e, t, n) { let r = !1; try { e(function (e) { r || (r = !0, t(e)) }, function (e) { r || (r = !0, n(e)) }) } catch (o) { if (r) { return } r = !0, n(o) } } return e.prototype.catch = function (e) { return this.then(null, e) }, e.prototype.then = function (t, n) { const r = this; return new e(function (e, o) { i.call(r, new s(t, n, e, o)) }) }, e.all = function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } const r = Array.prototype.slice.call(t.length === 1 && o(t[0]) ? t[0] : t); return new e(function (e, t) { if (r.length === 0) { return e([]) } let n = r.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, t) } }r[i] = u, --n === 0 && e(r) } catch (c) { t(c) } } for (let i = 0; i < r.length; i++) { o(i, r[i]) } }) }, e.resolve = function (t) { return t && typeof t === 'object' && t.constructor === e ? t : new e(function (e) { e(t) }) }, e.reject = function (t) { return new e(function (e, n) { n(t) }) }, e.race = function (t) { return new e(function (e, n) { for (let r = 0, o = t; r < o.length; r++) { const i = o[r]; i.then(e, n) } }) }, e }; const ZA = window.Promise ? window.Promise : JA(); function QA (e) { return new ZA(function (n, r) { const o = t.URL.createObjectURL(e); const i = new t.Image(); const u = function () { i.removeEventListener('load', a), i.removeEventListener('error', c) }; function a () { u(), n(i) } function c () { u(), r('Unable to load data of type ' + e.type + ': ' + o) }i.addEventListener('load', a), i.addEventListener('error', c), i.src = o, i.complete && a() }) } function eR (e) { const n = e.split(','); const r = /data:([^;]+)/.exec(n[0]); if (!r) { return x.none() } for (var o = r[1], i = n[1], u = 1024, a = t.atob(i), c = a.length, s = Math.ceil(c / u), l = new Array(s), f = 0; f < s; ++f) { for (var d = f * u, m = Math.min(d + u, c), g = new Array(m - d), h = d, p = 0; h < m; ++p, ++h) { g[p] = a[h].charCodeAt(0) }l[f] = new Uint8Array(g) } return x.some(new t.Blob(l, { type: o })) } function tR (e) { return new ZA(function (t, n) { eR(e).fold(function () { n('uri is not base64: ' + e) }, t) }) } function nR (e, n, r) { return n = n || 'image/png', t.HTMLCanvasElement.prototype.toBlob ? new ZA(function (t, o) { e.toBlob(function (e) { e ? t(e) : o() }, n, r) }) : tR(e.toDataURL(n, r)) } function rR (e, t, n) { return t = t || 'image/png', e.toDataURL(t, n) } function oR (e) { return QA(e).then(function (e) { uR(e); const t = qA(YA(e), KA(e)); const n = GA(t); return n.drawImage(e, 0, 0), t }) } function iR (e) { return new ZA(function (n) { const r = new t.FileReader(); r.onloadend = function () { n(r.result) }, r.readAsDataURL(e) }) } function uR (e) { t.URL.revokeObjectURL(e.src) } function aR (e, t, n) { const r = t.type; const o = i(r); function u () { return ZA.resolve(t) } function a () { return n } function c () { return n.split(',')[1] } function s (t, n) { return e.then(function (e) { return nR(e, t, n) }) } function l (t, n) { return e.then(function (e) { return rR(e, t, n) }) } function f (e, t) { return l(e, t).then(function (e) { return e.split(',')[1] }) } function d () { return e.then($A) } return { getType: o, toBlob: u, toDataURL: a, toBase64: c, toAdjustedBlob: s, toAdjustedDataURL: l, toAdjustedBase64: f, toCanvas: d } } function cR (e) { return iR(e).then(function (t) { return aR(oR(e), e, t) }) } function sR (e, t) { return nR(e, t).then(function (t) { return aR(ZA.resolve(e), t, e.toDataURL()) }) } const lR = function (e) { return cR(e) }; function fR (e, t, n) { let r = typeof e === 'string' ? parseFloat(e) : e; return r > n ? r = n : r < t && (r = t), r } function dR () { return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1] } const mR = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.2, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.3, 0.32, 0.34, 0.36, 0.38, 0.4, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.8, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1, 1.06, 1.12, 1.18, 1.24, 1.3, 1.36, 1.42, 1.48, 1.54, 1.6, 1.66, 1.72, 1.78, 1.84, 1.9, 1.96, 2, 2.12, 2.25, 2.37, 2.5, 2.62, 2.75, 2.87, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.3, 4.7, 4.9, 5, 5.5, 6, 6.5, 6.8, 7, 7.3, 7.5, 7.8, 8, 8.4, 8.7, 9, 9.4, 9.6, 9.8, 10]; function gR (e, t) { for (var n, r = [], o = new Array(25), i = 0; i < 5; i++) { for (var u = 0; u < 5; u++) { r[u] = t[u + 5 * i] } for (u = 0; u < 5; u++) { n = 0; for (let a = 0; a < 5; a++) { n += e[u + 5 * a] * r[a] }o[u + 5 * i] = n } } return o } function hR (e, t) { let n; return t = fR(t, -1, 1), t *= 100, t < 0 ? n = 127 + t / 100 * 127 : (n = t % 1, n = n === 0 ? mR[t] : mR[Math.floor(t)] * (1 - n) + mR[Math.floor(t) + 1] * n, n = 127 * n + 127), gR(e, [n / 127, 0, 0, 0, 0.5 * (127 - n), 0, n / 127, 0, 0, 0.5 * (127 - n), 0, 0, n / 127, 0, 0.5 * (127 - n), 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) } function pR (e, t) { return t = fR(255 * t, -255, 255), gR(e, [1, 0, 0, 0, t, 0, 1, 0, 0, t, 0, 0, 1, 0, t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) } function vR (e, t, n, r) { return t = fR(t, 0, 2), n = fR(n, 0, 2), r = fR(r, 0, 2), gR(e, [t, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) } function bR (e, t) { return e.toCanvas().then(function (n) { return yR(n, e.getType(), t) }) } function yR (e, t, n) { const r = GA(e); function o (e, t) { for (var n, r, o, i, u = e.data, a = t[0], c = t[1], s = t[2], l = t[3], f = t[4], d = t[5], m = t[6], g = t[7], h = t[8], p = t[9], v = t[10], b = t[11], y = t[12], w = t[13], x = t[14], C = t[15], S = t[16], k = t[17], T = t[18], E = t[19], O = 0; O < u.length; O += 4) { n = u[O], r = u[O + 1], o = u[O + 2], i = u[O + 3], u[O] = n * a + r * c + o * s + i * l + f, u[O + 1] = n * d + r * m + o * g + i * h + p, u[O + 2] = n * v + r * b + o * y + i * w + x, u[O + 3] = n * C + r * S + o * k + i * T + E } return e } const i = o(r.getImageData(0, 0, e.width, e.height), n); return r.putImageData(i, 0, 0), sR(e, t) } function wR (e, t) { return e.toCanvas().then(function (n) { return xR(n, e.getType(), t) }) } function xR (e, t, n) { const r = GA(e); function o (e, t, n) { function r (e, t, n) { return e > n ? e = n : e < t && (e = t), e } for (let o = Math.round(Math.sqrt(n.length)), i = Math.floor(o / 2), u = e.data, a = t.data, c = e.width, s = e.height, l = 0; l < s; l++) { for (let f = 0; f < c; f++) { for (var d = 0, m = 0, g = 0, h = 0; h < o; h++) { for (let p = 0; p < o; p++) { const v = r(f + p - i, 0, c - 1); const b = r(l + h - i, 0, s - 1); const y = 4 * (b * c + v); const w = n[h * o + p]; d += u[y] * w, m += u[y + 1] * w, g += u[y + 2] * w } } const x = 4 * (l * c + f); a[x] = r(d, 0, 255), a[x + 1] = r(m, 0, 255), a[x + 2] = r(g, 0, 255) } } return t } const i = r.getImageData(0, 0, e.width, e.height); let u = r.getImageData(0, 0, e.width, e.height); return u = o(i, u, n), r.putImageData(u, 0, 0), sR(e, t) } function CR (e) { const t = function (t, n, r) { const o = GA(t); const i = new Array(256); function u (e, t) { for (let n = e.data, r = 0; r < n.length; r += 4) { n[r] = t[n[r]], n[r + 1] = t[n[r + 1]], n[r + 2] = t[n[r + 2]] } return e } for (let a = 0; a < i.length; a++) { i[a] = e(a, r) } const c = u(o.getImageData(0, 0, t.width, t.height), i); return o.putImageData(c, 0, 0), sR(t, n) }; return function (e, n) { return e.toCanvas().then(function (r) { return t(r, e.getType(), n) }) } } function SR (e) { return function (t, n) { return bR(t, e(dR(), n)) } } function kR (e) { return function (t) { return bR(t, e) } } function TR (e) { return function (t) { return wR(t, e) } } const ER = kR([-1, 0, 0, 0, 255, 0, -1, 0, 0, 255, 0, 0, -1, 0, 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]); const OR = SR(pR); const NR = SR(hR); const _R = function (e, t, n, r) { return bR(e, vR(dR(), t, n, r)) }; const DR = TR([0, -1, 0, -1, 5, -1, 0, -1, 0]); const AR = CR(function (e, t) { return 255 * Math.pow(e / 255, 1 - t) }); function RR (e, t, n) { const r = YA(e); const o = KA(e); let i = t / r; let u = n / o; let a = !1; (i < 0.5 || i > 2) && (i = i < 0.5 ? 0.5 : 2, a = !0), (u < 0.5 || u > 2) && (u = u < 0.5 ? 0.5 : 2, a = !0); const c = BR(e, i, u); return a ? c.then(function (e) { return RR(e, t, n) }) : c } function BR (e, t, n) { return new ZA(function (r) { const o = YA(e); const i = KA(e); const u = Math.floor(o * t); const a = Math.floor(i * n); const c = qA(u, a); const s = GA(c); s.drawImage(e, 0, 0, o, i, 0, 0, u, a), r(c) }) } function MR (e, t) { return e.toCanvas().then(function (n) { return PR(n, e.getType(), t) }) } function PR (e, t, n) { const r = qA(e.width, e.height); const o = GA(r); let i = 0; let u = 0; return n = n < 0 ? 360 + n : n, n !== 90 && n !== 270 || XA(r, r.height, r.width), n !== 90 && n !== 180 || (i = r.width), n !== 270 && n !== 180 || (u = r.height), o.translate(i, u), o.rotate(n * Math.PI / 180), o.drawImage(e, 0, 0), sR(r, t) } function zR (e, t) { return e.toCanvas().then(function (n) { return IR(n, e.getType(), t) }) } function IR (e, t, n) { const r = qA(e.width, e.height); const o = GA(r); return n === 'v' ? (o.scale(1, -1), o.drawImage(e, 0, -r.height)) : (o.scale(-1, 1), o.drawImage(e, -r.width, 0)), sR(r, t) } function LR (e, t, n, r, o) { return e.toCanvas().then(function (i) { return HR(i, e.getType(), t, n, r, o) }) } function HR (e, t, n, r, o, i) { const u = qA(o, i); const a = GA(u); return a.drawImage(e, -n, -r), sR(u, t) } function FR (e, t, n) { return e.toCanvas().then(function (r) { return RR(r, t, n).then(function (t) { return sR(t, e.getType()) }) }) } const VR = function (e) { return ER(e) }; const UR = function (e) { return DR(e) }; const jR = function (e, t) { return AR(e, t) }; const WR = function (e, t, n, r) { return _R(e, t, n, r) }; const qR = function (e, t) { return OR(e, t) }; const $R = function (e, t) { return NR(e, t) }; const GR = function (e, t) { return zR(e, t) }; const XR = function (e, t, n, r, o) { return LR(e, t, n, r, o) }; const YR = function (e, t, n) { return FR(e, t, n) }; const KR = function (e, t) { return MR(e, t) }; const JR = function (e, t) { return m({ dom: { tag: 'span', innerHtml: e, classes: ['tox-icon', 'tox-tbtn__icon-wrap'] } }, t) }; const ZR = function (e, t) { return JR(gx(e, t), {}) }; const QR = function (e, t) { return JR(gx(e, t), { behaviours: yl([uy.config({})]) }) }; const eB = function (e, t, n) { return { dom: { tag: 'span', innerHtml: n.translate(e), classes: [t + '__select-label'] }, behaviours: yl([uy.config({})]) } }; const tB = xu('toolbar.button.execute'); const nB = function (e) { return ki(function (t, n) { MS(e, t)(function (n) { ni(t, tB, { buttonApi: n }), e.onAction(n) }) }) }; const rB = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'toolbar-button-events'] }; const oB = xu('update-menu-text'); const iB = xu('update-menu-icon'); const uB = function (e, t, r) { const o = Ln(n); const i = e.text.map(function (e) { return dx(eB(e, t, r.providers)) }); const u = e.icon.map(function (e) { return dx(QR(e, r.providers.icons)) }); const a = function (e, t) { const n = Bg.getValue(e); return vy.focus(n), ni(n, 'keydown', { raw: t.event().raw() }), oN.close(n), x.some(!0) }; const c = e.role.fold(function () { return {} }, function (e) { return { role: e } }); const s = e.tooltip.fold(function () { return {} }, function (e) { const t = r.providers.translate(e); return { title: t, 'aria-label': t } }); const l = dx(oN.sketch(m(m({}, c), { dom: { tag: 'button', classes: [t, t + '--select'].concat(W(e.classes, function (e) { return t + '--' + e })), attributes: m({}, s) }, components: FS([u.map(function (e) { return e.asSpec() }), i.map(function (e) { return e.asSpec() }), x.some({ dom: { tag: 'div', classes: [t + '__select-chevron'], innerHtml: gx('chevron-down', r.providers.icons) } })]), matchWidth: !0, useMinWidth: !0, dropdownBehaviours: yl(h(e.dropdownBehaviours, [BS.button(e.disabled), cN.config({}), uy.config({}), cy('dropdown-events', [PS(e, o), zS(e, o)]), cy('menubutton-update-display-text', [fi(oB, function (e, t) { i.bind(function (t) { return t.getOpt(e) }).each(function (e) { uy.set(e, [Qa(r.providers.translate(t.event().text()))]) }) }), fi(iB, function (e, t) { u.bind(function (t) { return t.getOpt(e) }).each(function (e) { uy.set(e, [QR(t.event().icon(), r.providers.icons)]) }) })])])), eventOrder: Ne(rB, { mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events', 'normal-dropdown-events'] }), sandboxBehaviours: yl([Kb.config({ mode: 'special', onLeft: a, onRight: a })]), lazySink: r.getSink, toggleClass: t + '--active', parts: { menu: gT(!1, e.columns, e.presets) }, fetch () { return dO.nu(e.fetch) } }))); return l.asSpec() }; const aB = function (e) { return N(e) }; const cB = function (e) { return e.type === 'separator' }; const sB = function (e) { return we(e, 'getSubmenuItems') }; const lB = { type: 'separator' }; const fB = function (e, t) { const n = K(e, function (e, n) { return aB(n) ? n === '' ? e : n === '|' ? e.length > 0 && !cB(e[e.length - 1]) ? e.concat([lB]) : e : we(t, n.toLowerCase()) ? e.concat([t[n.toLowerCase()]]) : e : e.concat([n]) }, []); return n.length > 0 && cB(n[n.length - 1]) && n.pop(), n }; const dB = function (e, t) { const n = e.getSubmenuItems(); const r = hB(n, t); const o = Ne(r.menus, et(e.value, r.items)); const i = Ne(r.expansions, et(e.value, e.value)); return { item: e, menus: o, expansions: i } }; const mB = function (e, t) { return sB(e) ? dB(e, t) : { item: e, menus: {}, expansions: {} } }; const gB = function (e) { if (cB(e)) { return e } const t = ye(e, 'value').getOrThunk(function () { return xu('generated-menu-item') }); return Ne({ value: t }, e) }; var hB = function (e, t) { const n = fB(N(e) ? e.split(' ') : e, t); return Y(n, function (e, n) { const r = gB(n); const o = mB(r, t); return { menus: Ne(e.menus, o.menus), items: [o.item].concat(e.items), expansions: Ne(e.expansions, o.expansions) } }, { menus: {}, expansions: {}, items: [] }) }; const pB = function (e, t, n, r) { const o = xu('primary-menu'); const i = hB(e, n.shared.providers.menuItems()); if (i.items.length === 0) { return x.none() } const u = YT(o, i.items, t, n, r); const a = ge(i.menus, function (e, r) { return YT(r, e, t, n, !1) }); const c = Ne(a, et(o, u)); return x.from(yw.tieredData(o, c, i.expansions)) }; const vB = function (e) { return { isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) }, setActive (t) { const n = e.element(); t ? (wa(n, 'tox-tbtn--enabled'), au(n, 'aria-pressed', !0)) : (Ca(n, 'tox-tbtn--enabled'), du(n, 'aria-pressed')) }, isActive () { return Sa(e.element(), 'tox-tbtn--enabled') } } }; const bB = function (e, t, n, r) { return uB({ text: e.text, icon: e.icon, tooltip: e.tooltip, role: r, fetch (t) { e.fetch(function (e) { t(pB(e, IS.CLOSE_ON_EXECUTE, n, !1)) }) }, onSetup: e.onSetup, getApi: vB, columns: 1, presets: 'normal', classes: [], dropdownBehaviours: [NO.config({})] }, t, n.shared) }; const yB = function (e, t, n) { const r = function (e) { return function (r) { const o = !r.isActive(); r.setActive(o), e.storage.set(o), n.shared.getSink().each(function (n) { t().getOpt(n).each(function (t) { Rl(t.element()), ni(t, IE, { name: e.name, value: e.storage.get() }) }) }) } }; const o = function (e) { return function (t) { t.setActive(e.storage.get()) } }; return function (t) { t(W(e, function (e) { const t = e.text.fold(function () { return {} }, function (e) { return { text: e } }); return m(m({ type: e.type, active: !1 }, t), { onAction: r(e), onSetup: o(e) }) })) } }; const wB = function (e, t, n, r, o) { void 0 === n && (n = []); const i = t.fold(function () { return {} }, function (e) { return { action: e } }); const u = m({ buttonBehaviours: yl([BS.button(e.disabled), NO.config({}), cy('button press', [li('click'), li('mousedown')])].concat(n)), eventOrder: { click: ['button press', 'alloy.base.behaviour'], mousedown: ['button press', 'alloy.base.behaviour'] } }, i); const a = Ne(u, { dom: r }); return Ne(a, { components: o }) }; const xB = function (e, t, n, r) { void 0 === r && (r = []); const o = e.tooltip.map(function (e) { return { 'aria-label': n.translate(e), title: n.translate(e) } }).getOr({}); const i = { tag: 'button', classes: ['tox-tbtn'], attributes: o }; const u = e.icon.map(function (e) { return ZR(e, n.icons) }); const a = FS([u]); return wB(e, t, r, i, a) }; const CB = function (e, t, n, r) { void 0 === r && (r = []); const o = xB(e, x.some(t), n, r); return fx.sketch(o) }; const SB = function (e, t, n, r, o) { void 0 === r && (r = []), void 0 === o && (o = []); const i = n.translate(e.text); const u = e.icon ? e.icon.map(function (e) { return ZR(e, n.icons) }) : x.none(); const a = u.isSome() ? FS([u]) : []; const c = u.isSome() ? {} : { innerHtml: i }; const s = h(e.primary || e.borderless ? ['tox-button'] : ['tox-button', 'tox-button--secondary'], u.isSome() ? ['tox-button--icon'] : [], e.borderless ? ['tox-button--naked'] : [], o); const l = m(m({ tag: 'button', classes: s }, c), { attributes: { title: i } }); return wB(e, t, r, l, a) }; const kB = function (e, t, n, r, o) { void 0 === r && (r = []), void 0 === o && (o = []); const i = SB(e, x.some(t), n, r, o); return fx.sketch(i) }; const TB = function (e, n) { return function (r) { n === 'custom' ? ni(r, IE, { name: e, value: {} }) : n === 'submit' ? ti(r, LE) : n === 'cancel' ? ti(r, zE) : t.console.error('Unknown button type: ', n) } }; const EB = function (e, t) { return t === 'menu' }; const OB = function (e, t) { return t === 'custom' || t === 'cancel' || t === 'submit' }; const NB = function (e, r, o) { if (EB(e, r)) { const i = function () { return c }; const u = e; const a = m(m({}, e), { onSetup (t) { return t.setDisabled(e.disabled), n }, fetch: yB(u.items, i, o) }); var c = dx(bB(a, 'tox-tbtn', o, x.none())); return c.asSpec() } if (OB(e, r)) { const s = TB(e.name, r); const l = m(m({}, e), { borderless: !1 }); return kB(l, s, o.shared.providers, []) }t.console.error('Unknown footer button type: ', r) }; const _B = function (e, t) { const n = TB(e.name, 'custom'); return DO(x.none(), XE.parts().field(m({ factory: fx }, SB(e, x.some(n), t, [_A.memory(''), gA.self()])))) }; const DB = i([On('field1Name', 'field1'), On('field2Name', 'field2'), Ss('onLockedChange'), ys(['lockClass']), On('locked', !1), Ig.field('coupledFieldBehaviours', [np, Bg])]); const AB = function (e, t, n) { return Oh(e, t, n).bind(np.getCurrent) }; const RB = function (e, t) { return dh({ factory: XE, name: e, overrides (e) { return { fieldBehaviours: yl([cy('coupled-input-behaviour', [fi(ko(), function (n) { AB(n, e, t).each(function (t) { Oh(n, e, 'lock').each(function (r) { zy.isOn(r) && e.onLockedChange(n, t, r) }) }) })])]) } } }) }; const BB = i([RB('field1', 'field2'), RB('field2', 'field1'), dh({ factory: fx, schema: [cn('dom')], name: 'lock', overrides (e) { return { buttonBehaviours: yl([zy.config({ selected: e.locked, toggleClass: e.markers.lockClass, aria: { mode: 'pressed' } })]) } } })]); const MB = function (e, t, n, r) { return { uid: e.uid, dom: e.dom, components: t, behaviours: Ig.augment(e.coupledFieldBehaviours, [np.config({ find: x.some }), Bg.config({ store: { mode: 'manual', getValue (t) { let n; const r = Rh(t, e, ['field1', 'field2']); return n = {}, n[e.field1Name] = Bg.getValue(r.field1()), n[e.field2Name] = Bg.getValue(r.field2()), n }, setValue (t, n) { const r = Rh(t, e, ['field1', 'field2']); xe(n, e.field1Name) && Bg.setValue(r.field1(), n[e.field1Name]), xe(n, e.field2Name) && Bg.setValue(r.field2(), n[e.field2Name]) } } })]), apis: { getField1 (t) { return Oh(t, e, 'field1') }, getField2 (t) { return Oh(t, e, 'field2') }, getLock (t) { return Oh(t, e, 'lock') } } } }; const PB = Gh({ name: 'FormCoupledInputs', configFields: DB(), partFields: BB(), factory: MB, apis: { getField1 (e, t) { return e.getField1(t) }, getField2 (e, t) { return e.getField2(t) }, getLock (e, t) { return e.getLock(t) } } }); const zB = function (e) { const t = { '': 0, px: 0, pt: 1, mm: 1, pc: 2, ex: 2, em: 2, ch: 2, rem: 2, cm: 3, in: 4, '%': 4 }; const n = function (e) { return e in t ? t[e] : 1 }; let r = e.value.toFixed(n(e.unit)); return r.includes('.') && (r = r.replace(/\.?0*$/, '')), r + e.unit }; const IB = function (e) { const t = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/; const n = t.exec(e); if (n !== null) { const r = parseFloat(n[1]); const o = n[2]; return T.value({ value: r, unit: o }) } return T.error(e) }; const LB = function (e, t) { const n = { '': 96, px: 96, pt: 72, cm: 2.54, pc: 12, mm: 25.4, in: 1 }; const r = function (e) { return Object.prototype.hasOwnProperty.call(n, e) }; return e.unit === t ? x.some(e.value) : r(e.unit) && r(t) ? n[e.unit] === n[t] ? x.some(e.value) : x.some(e.value / n[e.unit] * n[t]) : x.none() }; const HB = function (e) { return x.none() }; const FB = function (e, t) { return function (n) { return LB(n, t).map(function (n) { return { value: n * e, unit: t } }) } }; const VB = function (e, t) { const n = IB(e).toOption(); const r = IB(t).toOption(); return Kh(n, r, function (e, t) { return LB(e, t.unit).map(function (e) { return t.value / e }).map(function (e) { return FB(e, t.unit) }).getOr(HB) }).getOr(HB) }; const UB = function (e, t) { let n = HB; const r = xu('ratio-event'); const o = PB.parts().lock({ dom: { tag: 'button', classes: ['tox-lock', 'tox-button', 'tox-button--naked', 'tox-button--icon'], attributes: { title: t.translate(e.label.getOr('Constrain proportions')) } }, components: [{ dom: { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__lock'], innerHtml: gx('lock', t.icons) } }, { dom: { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__unlock'], innerHtml: gx('unlock', t.icons) } }], buttonBehaviours: yl([BS.button(e.disabled), NO.config({})]) }); const i = function (e) { return { dom: { tag: 'div', classes: ['tox-form__group'] }, components: e } }; const u = function (t) { return XE.parts().field({ factory: eO, inputClasses: ['tox-textfield'], inputBehaviours: yl([NS.config({ disabled: e.disabled }), NO.config({}), cy('size-input-events', [fi(wo(), function (e, n) { ni(e, r, { isField1: t }) }), fi(To(), function (t, n) { ni(t, ME, { name: e.name }) })])]), selectOnFocus: !1 }) }; const a = function (e) { return { dom: { tag: 'label', classes: ['tox-label'], innerHtml: t.translate(e) } } }; const c = PB.parts().field1(i([XE.parts().label(a('Width')), u(!0)])); const s = PB.parts().field2(i([XE.parts().label(a('Height')), u(!1)])); return PB.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: [{ dom: { tag: 'div', classes: ['tox-form__controls-h-stack'] }, components: [c, s, i([a('&nbsp;'), o])] }], field1Name: 'width', field2Name: 'height', locked: !0, markers: { lockClass: 'tox-locked' }, onLockedChange (e, t, r) { IB(Bg.getValue(e)).each(function (e) { n(e).each(function (e) { Bg.setValue(t, zB(e)) }) }) }, coupledFieldBehaviours: yl([NS.config({ disabled: e.disabled, onDisabled (e) { PB.getField1(e).bind(XE.getField).each(NS.disable), PB.getField2(e).bind(XE.getField).each(NS.disable), PB.getLock(e).each(NS.disable) }, onEnabled (e) { PB.getField1(e).bind(XE.getField).each(NS.enable), PB.getField2(e).bind(XE.getField).each(NS.enable), PB.getLock(e).each(NS.enable) } }), cy('size-input-events2', [fi(r, function (e, t) { const r = t.event().isField1(); const o = r ? PB.getField1(e) : PB.getField2(e); const i = r ? PB.getField2(e) : PB.getField1(e); const u = o.map(Bg.getValue).getOr(''); const a = i.map(Bg.getValue).getOr(''); n = VB(u, a) })])]) }) }; const jB = i(xu('undo')); const WB = i(xu('redo')); const qB = i(xu('zoom')); const $B = i(xu('back')); const GB = i(xu('apply')); const XB = i(xu('swap')); const YB = i(xu('transform')); const KB = i(xu('temp-transform')); const JB = i(xu('transform-apply')); const ZB = { undo: jB, redo: WB, zoom: qB, back: $B, apply: GB, swap: XB, transform: YB, tempTransform: KB, transformApply: JB }; const QB = i('save-state'); const eM = i('disable'); const tM = i('enable'); const nM = { formActionEvent: IE, saveState: QB, disable: eM, enable: tM }; const rM = function (e, t) { const r = function (e, n, r, o) { return dx(kB({ name: e, text: e, disabled: r, primary: o, icon: x.none(), borderless: !1 }, n, t)) }; const o = function (e, n, r, o) { return dx(CB({ name: e, icon: x.some(e), tooltip: x.some(n), disabled: o, primary: !1, borderless: !1 }, r, t)) }; const u = function (e, t) { e.map(function (e) { const n = e.get(t); n.hasConfigured(NS) && NS.disable(n) }) }; const a = function (e, t) { e.map(function (e) { const n = e.get(t); n.hasConfigured(NS) && NS.enable(n) }) }; const c = { tag: 'div', classes: ['tox-image-tools__toolbar', 'tox-image-tools-edit-panel'] }; const s = n; const l = function (e, t, n) { ni(e, t, n) }; const f = function (e) { return ti(e, nM.disable()) }; const d = function (e) { return ti(e, nM.enable()) }; const m = function (e, t) { f(e), l(e, ZB.transform(), { transform: t }), d(e) }; const g = function (e, t) { f(e), l(e, ZB.tempTransform(), { transform: t }), d(e) }; const h = function (e) { return function () { ue.getOpt(e).each(function (e) { uy.set(e, [oe]) }) } }; const p = function (e, t) { f(e), l(e, ZB.transformApply(), { transform: t, swap: h(e) }), d(e) }; const v = function () { return r('Back', function (e) { return l(e, ZB.back(), { swap: h(e) }) }, !1, !1) }; const b = function () { return dx({ dom: { tag: 'div', classes: ['tox-spacer'] }, behaviours: yl([NS.config({})]) }) }; const y = function () { return r('Apply', function (e) { return l(e, ZB.apply(), { swap: h(e) }) }, !0, !0) }; const w = function () { return function (t) { const n = e.getRect(); return XR(t, n.x, n.y, n.w, n.h) } }; const C = [v(), b(), r('Apply', function (t) { const n = w(); p(t, n), e.hideCrop() }, !1, !0)]; const S = RE.sketch({ dom: c, components: C.map(function (e) { return e.asSpec() }), containerBehaviours: yl([cy('image-tools-crop-buttons-events', [fi(nM.disable(), function (e, t) { u(C, e) }), fi(nM.enable(), function (e, t) { a(C, e) })])]) }); const k = dx(UB({ name: 'size', label: x.none(), constrain: !0, disabled: !1 }, t)); const T = function (e, t) { return function (n) { return YR(n, e, t) } }; const E = [v(), b(), k, b(), r('Apply', function (e) { k.getOpt(e).each(function (t) { const n = Bg.getValue(t); const r = parseInt(n.width, 10); const o = parseInt(n.height, 10); const i = T(r, o); p(e, i) }) }, !1, !0)]; const O = RE.sketch({ dom: c, components: E.map(function (e) { return e.asSpec() }), containerBehaviours: yl([cy('image-tools-resize-buttons-events', [fi(nM.disable(), function (e, t) { u(E, e) }), fi(nM.enable(), function (e, t) { a(E, e) })])]) }); const N = function (e, t) { return function (n) { return e(n, t) } }; const _ = N(GR, 'h'); const D = N(GR, 'v'); const A = N(KR, -90); const R = N(KR, 90); const B = function (e, t) { g(e, t) }; const M = [v(), b(), o('flip-horizontally', 'Flip horizontally', function (e) { B(e, _) }, !1), o('flip-vertically', 'Flip vertically', function (e) { B(e, D) }, !1), o('rotate-left', 'Rotate counterclockwise', function (e) { B(e, A) }, !1), o('rotate-right', 'Rotate clockwise', function (e) { B(e, R) }, !1), b(), y()]; const P = RE.sketch({ dom: c, components: M.map(function (e) { return e.asSpec() }), containerBehaviours: yl([cy('image-tools-fliprotate-buttons-events', [fi(nM.disable(), function (e, t) { u(M, e) }), fi(nM.enable(), function (e, t) { a(M, e) })])]) }); const z = function (e, n, r, o, u) { const a = YD.parts().label({ dom: { tag: 'label', classes: ['tox-label'], innerHtml: t.translate(e) } }); const c = YD.parts().spectrum({ dom: { tag: 'div', classes: ['tox-slider__rail'], attributes: { role: 'presentation' } } }); const s = YD.parts().thumb({ dom: { tag: 'div', classes: ['tox-slider__handle'], attributes: { role: 'presentation' } } }); return dx(YD.sketch({ dom: { tag: 'div', classes: ['tox-slider'], attributes: { role: 'presentation' } }, model: { mode: 'x', minX: r, maxX: u, getInitialValue: i({ x: i(o) }) }, components: [a, c, s], sliderBehaviours: yl([vy.config({})]), onChoose: n })) }; const I = function (e, t, n, r, o) { const i = function (e, n, r) { const o = N(t, r.x() / 100); m(e, o) }; return z(e, i, n, r, o) }; const L = function (e, t, n, r, o) { return [v(), I(e, t, n, r, o), y()] }; const H = function (e, t, n, r, o) { const i = L(e, t, n, r, o); return RE.sketch({ dom: c, components: i.map(function (e) { return e.asSpec() }), containerBehaviours: yl([cy('image-tools-filter-panel-buttons-events', [fi(nM.disable(), function (e, t) { u(i, e) }), fi(nM.enable(), function (e, t) { a(i, e) })])]) }) }; const F = [v(), b(), y()]; const V = RE.sketch({ dom: c, components: F.map(function (e) { return e.asSpec() }) }); const U = H('Brightness', qR, -100, 0, 100); const j = H('Contrast', $R, -100, 0, 100); const W = H('Gamma', jR, -100, 0, 100); const q = function (e, t, n) { return function (r) { return WR(r, e, t, n) } }; const $ = function (e) { const t = function (e, t, n) { const r = G.getOpt(e); const o = Y.getOpt(e); const i = X.getOpt(e); r.each(function (t) { o.each(function (n) { i.each(function (r) { const o = Bg.getValue(t).x() / 100; const i = Bg.getValue(r).x() / 100; const u = Bg.getValue(n).x() / 100; const a = q(o, i, u); m(e, a) }) }) }) }; return z(e, t, 0, 100, 200) }; var G = $('R'); var X = $('G'); var Y = $('B'); const K = [v(), G, X, Y, y()]; const J = RE.sketch({ dom: c, components: K.map(function (e) { return e.asSpec() }) }); const Z = function (e, t, n) { return function (r) { const o = function () { ue.getOpt(r).each(function (t) { uy.set(t, [e]), n(t) }) }; l(r, ZB.swap(), { transform: t, swap: o }) } }; const Q = function (t) { e.showCrop() }; const ee = function (t) { k.getOpt(t).each(function (t) { const n = e.getMeasurements(); const r = n.width; const o = n.height; Bg.setValue(t, { width: r, height: o }) }) }; const te = x.some(UR); const ne = x.some(VR); const re = [o('crop', 'Crop', Z(S, x.none(), Q), !1), o('resize', 'Resize', Z(O, x.none(), ee), !1), o('orientation', 'Orientation', Z(P, x.none(), s), !1), o('brightness', 'Brightness', Z(U, x.none(), s), !1), o('sharpen', 'Sharpen', Z(V, te, s), !1), o('contrast', 'Contrast', Z(j, x.none(), s), !1), o('color-levels', 'Color levels', Z(J, x.none(), s), !1), o('gamma', 'Gamma', Z(W, x.none(), s), !1), o('invert', 'Invert', Z(V, ne, s), !1)]; var oe = RE.sketch({ dom: c, components: re.map(function (e) { return e.asSpec() }) }); const ie = RE.sketch({ dom: { tag: 'div' }, components: [oe], containerBehaviours: yl([uy.config({})]) }); var ue = dx(ie); const ae = function (e) { return ue.getOpt(e).map(function (e) { const t = e.components()[0]; return t.components()[t.components().length - 1] }) }; return { memContainer: ue, getApplyButton: ae } }; const oM = tinymce.util.Tools.resolve('tinymce.dom.DomQuery'); const iM = tinymce.util.Tools.resolve('tinymce.geom.Rect'); const uM = tinymce.util.Tools.resolve('tinymce.util.Observable'); const aM = tinymce.util.Tools.resolve('tinymce.util.Tools'); const cM = tinymce.util.Tools.resolve('tinymce.util.VK'); function sM (e) { let t; let n; let r; let o; let i; let u; let a; let c; const s = Math.max; return t = e.documentElement, n = e.body, r = s(t.scrollWidth, n.scrollWidth), o = s(t.clientWidth, n.clientWidth), i = s(t.offsetWidth, n.offsetWidth), u = s(t.scrollHeight, n.scrollHeight), a = s(t.clientHeight, n.clientHeight), c = s(t.offsetHeight, n.offsetHeight), { width: r < i ? o : r, height: u < c ? a : u } } function lM (e) { let t, n; if (e.changedTouches) { for (t = 'screenX screenY pageX pageY clientX clientY'.split(' '), n = 0; n < t.length; n++) { e[t[n]] = e.changedTouches[0][t[n]] } } } function fM (e, n) { let r; let o; let i; let u; let a; let c; let s; const l = n.document || t.document; n = n || {}; const f = l.getElementById(n.handle || e); i = function (e) { let i; let d; const m = sM(l); lM(e), e.preventDefault(), o = e.button, i = f, c = e.screenX, s = e.screenY, d = t.window.getComputedStyle ? t.window.getComputedStyle(i, null).getPropertyValue('cursor') : i.runtimeStyle.cursor, r = oM('<div></div>').css({ position: 'absolute', top: 0, left: 0, width: m.width, height: m.height, zIndex: 2147483647, opacity: 1e-4, cursor: d }).appendTo(l.body), oM(l).on('mousemove touchmove', a).on('mouseup touchend', u), n.start(e) }, a = function (e) { if (lM(e), e.button !== o) { return u(e) } e.deltaX = e.screenX - c, e.deltaY = e.screenY - s, e.preventDefault(), n.drag(e) }, u = function (e) { lM(e), oM(l).off('mousemove touchmove', a).off('mouseup touchend', u), r.remove(), n.stop && n.stop(e) }, this.destroy = function () { oM(f).off() }, oM(f).on('mousedown touchstart', i) } let dM = 0; const mM = function (e, t, n, r, o) { let i; let u; let a; const c = 'tox-'; const s = c + 'crid-' + dM++; const l = [{ name: 'move', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: 0, deltaH: 0, label: 'Crop Mask' }, { name: 'nw', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: -1, deltaH: -1, label: 'Top Left Crop Handle' }, { name: 'ne', xMul: 1, yMul: 0, deltaX: 0, deltaY: 1, deltaW: 1, deltaH: -1, label: 'Top Right Crop Handle' }, { name: 'sw', xMul: 0, yMul: 1, deltaX: 1, deltaY: 0, deltaW: -1, deltaH: 1, label: 'Bottom Left Crop Handle' }, { name: 'se', xMul: 1, yMul: 1, deltaX: 0, deltaY: 0, deltaW: 1, deltaH: 1, label: 'Bottom Right Crop Handle' }]; a = ['top', 'right', 'bottom', 'left']; const f = function (e, t) { return { x: t.x + e.x, y: t.y + e.y, w: t.w, h: t.h } }; const d = function (e, t) { return { x: t.x - e.x, y: t.y - e.y, w: t.w, h: t.h } }; const m = function () { return d(n, e) }; function g (t, r, o, u) { let a, c, s, l, f; a = r.x, c = r.y, s = r.w, l = r.h, a += o * t.deltaX, c += u * t.deltaY, s += o * t.deltaW, l += u * t.deltaH, s < 20 && (s = 20), l < 20 && (l = 20), f = e = iM.clamp({ x: a, y: c, w: s, h: l }, n, t.name === 'move'), f = d(n, f), i.fire('updateRect', { rect: f }), w(f) } function h () { function t (t) { let n; return new fM(s, { document: r.ownerDocument, handle: s + '-' + t.name, start () { n = e }, drag (e) { g(t, n, e.deltaX, e.deltaY) } }) }oM('<div id="' + s + '" class="' + c + 'croprect-container" role="grid" aria-dropeffect="execute">').appendTo(r), aM.each(a, function (e) { oM('#' + s, r).append('<div id="' + s + '-' + e + '"class="' + c + 'croprect-block" style="display: none" data-mce-bogus="all">') }), aM.each(l, function (e) { oM('#' + s, r).append('<div id="' + s + '-' + e.name + '" class="' + c + 'croprect-handle ' + c + 'croprect-handle-' + e.name + '"style="display: none" data-mce-bogus="all" role="gridcell" tabindex="-1" aria-label="' + e.label + '" aria-grabbed="false" title="' + e.label + '">') }), u = aM.map(l, t), v(e), oM(r).on('focusin focusout', function (e) { oM(e.target).attr('aria-grabbed', e.type === 'focus' ? 'true' : 'false') }), oM(r).on('keydown', function (t) { let n; function r (e, t, r, o, i) { e.stopPropagation(), e.preventDefault(), g(n, r, o, i) } switch (aM.each(l, function (e) { if (t.target.id === s + '-' + e.name) { return n = e, !1 } }), t.keyCode) { case cM.LEFT:r(t, n, e, -10, 0); break; case cM.RIGHT:r(t, n, e, 10, 0); break; case cM.UP:r(t, n, e, 0, -10); break; case cM.DOWN:r(t, n, e, 0, 10); break; case cM.ENTER:case cM.SPACEBAR:t.preventDefault(), o(); break } }) } function p (e) { let t; t = aM.map(l, function (e) { return '#' + s + '-' + e.name }).concat(aM.map(a, function (e) { return '#' + s + '-' + e })).join(','), e ? oM(t, r).show() : oM(t, r).hide() } function v (e) { function n (e, t) { t.h < 0 && (t.h = 0), t.w < 0 && (t.w = 0), oM('#' + s + '-' + e, r).css({ left: t.x, top: t.y, width: t.w, height: t.h }) }aM.each(l, function (t) { oM('#' + s + '-' + t.name, r).css({ left: e.w * t.xMul + e.x, top: e.h * t.yMul + e.y }) }), n('top', { x: t.x, y: t.y, w: t.w, h: e.y - t.y }), n('right', { x: e.x + e.w, y: e.y, w: t.w - e.x - e.w + t.x, h: e.h }), n('bottom', { x: t.x, y: e.y + e.h, w: t.w, h: t.h - e.y - e.h + t.y }), n('left', { x: t.x, y: e.y, w: e.x - t.x, h: e.h }), n('move', e) } function b (t) { e = t, v(e) } function y (n) { t = n, v(e) } function w (e) { b(f(n, e)) } function x (t) { n = t, v(e) } function C () { aM.each(u, function (e) { e.destroy() }), u = [] } return h(), i = aM.extend({ toggleVisibility: p, setClampRect: x, setRect: b, getInnerRect: m, setInnerRect: w, setViewPortRect: y, destroy: C }, uM), i }; const gM = { create: mM }; const hM = function (e) { return new Hx(function (t) { var n = function () { e.removeEventListener('load', n), t(e) }; e.complete ? t(e) : e.addEventListener('load', n) }) }; const pM = function (e) { const t = dx({ dom: { tag: 'div', classes: ['tox-image-tools__image-bg'], attributes: { role: 'presentation' } } }); const n = Ln(1); const r = Ln(x.none()); const o = Ln({ x: 0, y: 0, w: 1, h: 1 }); const i = Ln({ x: 0, y: 0, w: 1, h: 1 }); const u = function (e, i) { g.getOpt(e).each(function (e) { const u = n.get(); const a = vc(e.element()); const c = uc(e.element()); const s = i.dom().naturalWidth * u; const l = i.dom().naturalHeight * u; const f = Math.max(0, a / 2 - s / 2); const d = Math.max(0, c / 2 - l / 2); const m = { left: f.toString() + 'px', top: d.toString() + 'px', width: s.toString() + 'px', height: l.toString() + 'px', position: 'absolute' }; Ba(i, m), t.getOpt(e).each(function (e) { Ba(e.element(), m) }), r.get().each(function (e) { const t = o.get(); e.setRect({ x: t.x * u + f, y: t.y * u + d, w: t.w * u, h: t.h * u }), e.setClampRect({ x: f, y: d, w: s, h: l }), e.setViewPortRect({ x: 0, y: 0, w: a, h: c }) }) }) }; const a = function (e, t) { g.getOpt(e).each(function (e) { const r = vc(e.element()); const o = uc(e.element()); const i = t.dom().naturalWidth; const u = t.dom().naturalHeight; const a = Math.min(r / i, o / u); a >= 1 ? n.set(1) : n.set(a) }) }; const c = function (e, t) { const n = Wn.fromTag('img'); return au(n, 'src', t), hM(n.dom()).then(function () { return g.getOpt(e).map(function (e) { const t = ec({ element: n }); uy.replaceAt(e, 1, x.some(t)); const r = i.get(); const c = { x: 0, y: 0, w: n.dom().naturalWidth, h: n.dom().naturalHeight }; i.set(c); const s = iM.inflate(c, -20, -20); return o.set(s), r.w === c.w && r.h === c.h || a(e, n), u(e, n), n }) }) }; const s = function (e, t) { const r = n.get(); const o = t > 0 ? Math.min(2, r + 0.1) : Math.max(0.1, r - 0.1); n.set(o), g.getOpt(e).each(function (e) { const t = e.components()[1].element(); u(e, t) }) }; const l = function () { r.get().each(function (e) { e.toggleVisibility(!0) }) }; const f = function () { r.get().each(function (e) { e.toggleVisibility(!1) }) }; const d = function () { return o.get() }; const m = RE.sketch({ dom: { tag: 'div', classes: ['tox-image-tools__image'] }, components: [t.asSpec(), { dom: { tag: 'img', attributes: { src: e } } }, { dom: { tag: 'div' }, behaviours: yl([cy('image-panel-crop-events', [xi(function (e) { g.getOpt(e).each(function (e) { const t = e.element().dom(); const i = gM.create({ x: 10, y: 10, w: 100, h: 100 }, { x: 0, y: 0, w: 200, h: 200 }, { x: 0, y: 0, w: 200, h: 200 }, t, function () {}); i.toggleVisibility(!1), i.on('updateRect', function (e) { const t = e.rect; const r = n.get(); const i = { x: Math.round(t.x / r), y: Math.round(t.y / r), w: Math.round(t.w / r), h: Math.round(t.h / r) }; o.set(i) }), r.set(x.some(i)) }) })])]) }], containerBehaviours: yl([uy.config({}), cy('image-panel-events', [xi(function (t) { c(t, e) })])]) }); var g = dx(m); const h = function () { const e = i.get(); return { width: e.w, height: e.h } }; return { memContainer: g, updateSrc: c, zoom: s, showCrop: l, hideCrop: f, getRect: d, getMeasurements: h } }; const vM = function (e, t, n, r, o) { return CB({ name: e, icon: x.some(t), disabled: n, tooltip: x.some(e), primary: !1, borderless: !1 }, r, o) }; const bM = function (e, t) { t ? NS.enable(e) : NS.disable(e) }; const yM = function (e) { const t = function (e, t, o) { n.getOpt(e).each(function (e) { bM(e, t) }), r.getOpt(e).each(function (e) { bM(e, o) }) }; var n = dx(vM('Undo', 'undo', !0, function (e) { ni(e, ZB.undo(), { direction: 1 }) }, e)); var r = dx(vM('Redo', 'redo', !0, function (e) { ni(e, ZB.redo(), { direction: 1 }) }, e)); const o = RE.sketch({ dom: { tag: 'div', classes: ['tox-image-tools__toolbar', 'tox-image-tools__sidebar'] }, components: [n.asSpec(), r.asSpec(), vM('Zoom in', 'zoom-in', !1, function (e) { ni(e, ZB.zoom(), { direction: 1 }) }, e), vM('Zoom out', 'zoom-out', !1, function (e) { ni(e, ZB.zoom(), { direction: -1 }) }, e)] }); return { container: o, updateButtonUndoStates: t } }; function wM () { const e = []; let t = -1; function n (n) { let r; return r = e.splice(++t), e.push(n), { state: n, removed: r } } function r () { if (i()) { return e[--t] } } function o () { if (u()) { return e[++t] } } function i () { return t > 0 } function u () { return t !== -1 && t < e.length - 1 } return { data: e, add: n, undo: r, redo: o, canUndo: i, canRedo: u } } let xM; const CM = function (e) { const n = Ln(e); const r = Ln(x.none()); const o = wM(); o.add(e); const i = function () { return n.get() }; const u = function (e) { n.set(e) }; const a = function () { return r.get().fold(function () { return n.get() }, function (e) { return e }) }; const c = function (e) { const t = s(e); return d(), r.set(x.some(t)), t.url }; var s = function (e) { return { blob: e, url: t.URL.createObjectURL(e) } }; const l = function (e) { t.URL.revokeObjectURL(e.url) }; const f = function (e) { aM.each(e, l) }; var d = function () { r.get().each(l), r.set(x.none()) }; const m = function (e) { const t = s(e); u(t); const n = o.add(t).removed; return f(n), t.url }; const g = function (e) { const t = s(e); return r.set(x.some(t)), t.url }; const h = function (e) { return r.get().fold(function () {}, function (t) { m(t.blob), e() }) }; const p = function () { const e = o.undo(); return u(e), e.url }; const v = function () { const e = o.redo(); return u(e), e.url }; const b = function () { const e = o.canUndo(); const t = o.canRedo(); return { undoEnabled: e, redoEnabled: t } }; return { getBlobState: i, setBlobState: u, addBlobState: m, getTempState: a, updateTempState: c, addTempState: g, applyTempState: h, destroyTempState: d, undo: p, redo: v, getHistoryStates: b } }; const SM = function (e, r) { const o = CM(e.currentState); const i = function (e, t) { const n = t.event().direction(); T.zoom(e, n) }; const u = function (e) { const t = o.getHistoryStates(); E.updateButtonUndoStates(e, t.undoEnabled, t.redoEnabled), ni(e, nM.formActionEvent, { name: nM.saveState(), value: t.undoEnabled }) }; const a = function (e) { E.updateButtonUndoStates(e, !1, !1) }; const c = function (e, t) { const n = o.undo(); m(e, n).then(function (t) { d(e), u(e) }) }; const s = function (e, t) { const n = o.redo(); m(e, n).then(function (t) { d(e), u(e) }) }; const l = function (e) { return e.toBlob() }; const f = function (e) { ni(e, nM.formActionEvent, { name: nM.disable(), value: {} }) }; var d = function (e) { O.getApplyButton(e).each(function (e) { NS.enable(e) }), ni(e, nM.formActionEvent, { name: nM.enable(), value: {} }) }; var m = function (e, t) { return f(e), T.updateSrc(e, t) }; const g = function (e, n, r, o, i) { return f(e), lR(n).then(r).then(l).then(o).then(function (t) { return m(e, t).then(function (t) { return u(e), i(), d(e), t }) }).catch(function (n) { return t.console.log(n), d(e), n }) }; const h = function (e, t, n) { const r = o.getBlobState().blob; const i = function (e) { return o.updateTempState(e) }; g(e, r, t, i, n) }; const p = function (e, t) { const r = o.getTempState().blob; const i = function (e) { return o.addTempState(e) }; g(e, r, t, i, n) }; const v = function (e, t, n) { const r = o.getBlobState().blob; const i = function (t) { const n = o.addBlobState(t); return y(e), n }; g(e, r, t, i, n) }; const b = function (e, t) { const n = function () { y(e); const n = t.event().swap(); n() }; o.applyTempState(n) }; var y = function (e) { const t = o.getBlobState().url; return o.destroyTempState(), u(e), t }; const w = function (e) { const t = y(e); m(e, t).then(function (t) { d(e) }) }; const x = function (e, t) { w(e); const n = t.event().swap(); n(), T.hideCrop() }; const C = function (e, t) { return h(e, t.event().transform(), n) }; const S = function (e, t) { return p(e, t.event().transform()) }; const k = function (e, t) { return v(e, t.event().transform(), t.event().swap()) }; var T = pM(e.currentState.url); var E = yM(r); var O = rM(T, r); const N = function (e, t) { a(e); const n = t.event().transform(); const r = t.event().swap(); n.fold(function () { r() }, function (t) { h(e, t, r) }) }; return { dom: { tag: 'div', attributes: { role: 'presentation' } }, components: [O.memContainer.asSpec(), T.memContainer.asSpec(), E.container], behaviours: yl([Bg.config({ store: { mode: 'manual', getValue () { return o.getBlobState() } } }), cy('image-tools-events', [fi(ZB.undo(), c), fi(ZB.redo(), s), fi(ZB.zoom(), i), fi(ZB.back(), x), fi(ZB.apply(), b), fi(ZB.transform(), C), fi(ZB.tempTransform(), S), fi(ZB.transformApply(), k), fi(ZB.swap(), N)]), gA.self()]) } }; const kM = function (e, t) { const n = W(e.options, function (e) { return { dom: { tag: 'option', value: e.value, innerHtml: e.text } } }); const r = e.data.map(function (e) { return et('initialValue', e) }).getOr({}); return { uid: e.uid, dom: { tag: 'select', classes: e.selectClasses, attributes: e.selectAttributes }, components: n, behaviours: zg(e.selectBehaviours, [vy.config({}), Bg.config({ store: m({ mode: 'manual', getValue (e) { return Ua(e.element()) }, setValue (t, n) { const r = J(e.options, function (e) { return e.value === n }); r.isSome() && ja(t.element(), n) } }, r) })]) } }; const TM = $h({ name: 'HtmlSelect', configFields: [cn('options'), Mg('selectBehaviours', [vy, Bg]), On('selectClasses', []), On('selectAttributes', {}), yn('data')], factory: kM }); const EM = function (e, t) { const n = W(e.items, function (e) { return { text: t.translate(e.text), value: e.value } }); const r = e.label.map(function (e) { return MO(e, t) }); const o = XE.parts().field({ dom: {}, selectAttributes: { size: e.size }, options: n, factory: TM, selectBehaviours: yl([NS.config({ disabled: e.disabled }), NO.config({}), cy('selectbox-change', [fi(To(), function (t, n) { ni(t, ME, { name: e.name }) })])]) }); const i = e.size > 1 ? x.none() : x.some({ dom: { tag: 'div', classes: ['tox-selectfield__icon-js'], innerHtml: gx('chevron-down', t.icons) } }); const u = { dom: { tag: 'div', classes: ['tox-selectfield'] }, components: Q([[o], i.toArray()]) }; return XE.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: Q([r.toArray(), [u]]), fieldBehaviours: yl([NS.config({ disabled: e.disabled, onDisabled (e) { XE.getField(e).each(NS.disable) }, onEnabled (e) { XE.getField(e).each(NS.enable) } })]) }) }; const OM = function (e, t) { const n = e.label.map(function (e) { return MO(e, t) }); const r = [NS.config({ disabled: e.disabled }), Kb.config({ mode: 'execution', useEnter: !0 !== e.multiline, useControlEnter: !0 === e.multiline, execute (e) { return ti(e, LE), x.some(!0) } }), cy('textfield-change', [fi(ko(), function (t, n) { ni(t, ME, { name: e.name }) }), fi(Ro(), function (t, n) { ni(t, ME, { name: e.name }) })]), NO.config({})]; const o = e.validation.map(function (e) { return kO.config({ getRoot (e) { return Pi(e.element()) }, invalidClass: 'tox-invalid', validator: { validate (t) { const n = Bg.getValue(t); const r = e.validator(n); return dO.pure(!0 === r ? T.value(n) : T.error(r)) }, validateOnLoad: e.validateOnLoad } }) }).toArray(); const u = e.placeholder.fold(i({}), function (e) { return { placeholder: t.translate(e) } }); const a = e.inputMode.fold(i({}), function (e) { return { inputmode: e } }); const c = m(m({}, u), a); const s = XE.parts().field({ tag: !0 === e.multiline ? 'textarea' : 'input', inputAttributes: c, inputClasses: [e.classname], inputBehaviours: yl(Q([r, o])), selectOnFocus: !1, factory: eO }); const l = e.flex ? ['tox-form__group--stretched'] : []; const f = l.concat(e.maximized ? ['tox-form-group--maximize'] : []); const d = [NS.config({ disabled: e.disabled, onDisabled (e) { XE.getField(e).each(NS.disable) }, onEnabled (e) { XE.getField(e).each(NS.enable) } })]; return _O(n, s, f, d) }; const NM = function (e, t) { return OM({ name: e.name, multiline: !1, label: e.label, inputMode: e.inputMode, placeholder: e.placeholder, flex: !1, disabled: e.disabled, classname: 'tox-textfield', validation: x.none(), maximized: e.maximized }, t) }; const _M = function (e, t) { return OM({ name: e.name, multiline: !0, label: e.label, inputMode: x.none(), placeholder: e.placeholder, flex: !0, disabled: e.disabled, classname: 'tox-textarea', validation: x.none(), maximized: e.maximized }, t) }; const DM = function (e, t) { const n = e.stream.streams; const r = n.setup(e, t); return ai([fi(e.event, r), Ci(function () { return t.cancel() })].concat(e.cancelEvent.map(function (e) { return [fi(e, function () { return t.cancel() })] }).getOr([]))) }; const AM = Object.freeze({ __proto__: null, events: DM }); const RM = function (e) { const t = Ln(null); const n = function () { return { timer: t.get() !== null ? 'set' : 'unset' } }; const r = function (e) { t.set(e) }; const o = function () { const e = t.get(); e !== null && e.cancel() }; return Uu({ readState: n, setTimer: r, cancel: o }) }; const BM = function (e) { return e.stream.streams.state(e) }; const MM = Object.freeze({ __proto__: null, throttle: RM, init: BM }); const PM = function (e, t) { const n = e.stream; const r = Sx(e.onStream, n.delay); return t.setTimer(r), function (e, t) { r.throttle(e, t), n.stopEvent && t.stop() } }; const zM = [sn('stream', Jt('mode', { throttle: [cn('delay'), On('stopEvent', !0), Ts('streams', { setup: PM, state: RM })] })), On('event', 'input'), yn('cancelEvent'), Ss('onStream')]; const IM = xl({ fields: zM, name: 'streaming', active: AM, state: MM }); const LM = function (e, t, n) { const r = Bg.getValue(n); Bg.setValue(t, r), FM(t) }; const HM = function (e, t) { const n = e.element(); const r = Ua(n); const o = n.dom(); su(n, 'type') !== 'number' && t(o, r) }; var FM = function (e) { HM(e, function (e, t) { return e.setSelectionRange(t.length, t.length) }) }; const VM = function (e, t) { HM(e, function (e, n) { return e.setSelectionRange(t, n.length) }) }; const UM = function (e, t, n) { if (e.selectsOver) { const r = Bg.getValue(t); const o = e.getDisplayText(r); const i = Bg.getValue(n); const u = e.getDisplayText(i); return u.indexOf(o) === 0 ? x.some(function () { LM(e, t, n), VM(t, o.length) }) : x.none() } return x.none() }; const jM = i('alloy.typeahead.itemexecute'); const WM = function (e, t, r, o) { const i = function (t, r, i) { e.previewing.set(!1); const u = FO.getCoupled(t, 'sandbox'); if (Jm.isOpen(u)) { np.getCurrent(u).each(function (e) { Cp.getHighlighted(e).fold(function () { i(e) }, function () { ui(u, e.element(), 'keydown', r) }) }) } else { const c = function (e) { np.getCurrent(e).each(i) }; $O(e, a(t), t, u, o, c, rO.HighlightFirst).get(n) } }; const u = KE(e); var a = function (e) { return function (t) { return t.map(function (t) { const n = be(t.menus); const r = ee(n, function (e) { return X(e.items, function (e) { return e.type === 'item' }) }); const o = Bg.getState(e); return o.update(W(r, function (e) { return e.data })), t }) } }; const c = [vy.config({}), Bg.config({ onSetValue: e.onSetValue, store: m({ mode: 'dataset', getDataKey (e) { return Ua(e.element()) }, getFallbackEntry (e) { return { value: e, meta: {} } }, setValue (t, n) { ja(t.element(), e.model.getDisplayText(n)) } }, e.initialData.map(function (e) { return et('initialValue', e) }).getOr({})) }), IM.config({ stream: { mode: 'throttle', delay: e.responseTime, stopEvent: !1 }, onStream (t, r) { const i = FO.getCoupled(t, 'sandbox'); const u = vy.isFocused(t); if (u && Ua(t.element()).length >= e.minChars) { const c = np.getCurrent(i).bind(function (e) { return Cp.getHighlighted(e).map(Bg.getValue) }); e.previewing.set(!0); const s = function (t) { np.getCurrent(i).each(function (t) { c.fold(function () { e.model.selectsOver && Cp.highlightFirst(t) }, function (e) { Cp.highlightBy(t, function (t) { const n = Bg.getValue(t); return n.value === e.value }), Cp.getHighlighted(t).orThunk(function () { return Cp.highlightFirst(t), x.none() }) }) }) }; $O(e, a(t), t, i, o, s, rO.HighlightFirst).get(n) } }, cancelEvent: Ho() }), Kb.config({ mode: 'special', onDown (e, t) { return i(e, t, Cp.highlightFirst), x.some(!0) }, onEscape (e) { const t = FO.getCoupled(e, 'sandbox'); return Jm.isOpen(t) ? (Jm.close(t), x.some(!0)) : x.none() }, onUp (e, t) { return i(e, t, Cp.highlightLast), x.some(!0) }, onEnter (t) { const n = FO.getCoupled(t, 'sandbox'); const r = Jm.isOpen(n); if (r && !e.previewing.get()) { return np.getCurrent(n).bind(function (e) { return Cp.getHighlighted(e) }).map(function (e) { return ni(t, jM(), { item: e }), !0 }) } const o = Bg.getValue(t); return ti(t, Ho()), e.onExecute(n, t, o), r && Jm.close(n), x.some(!0) } }), zy.config({ toggleClass: e.markers.openClass, aria: { mode: 'expanded' } }), FO.config({ others: { sandbox (t) { return ZO(e, t, { onOpen () { return zy.on(t) }, onClose () { return zy.off(t) } }) } } }), cy('typeaheadevents', [ki(function (t) { const r = n; XO(e, a(t), t, o, r, rO.HighlightFirst).get(n) }), fi(jM(), function (t, n) { const r = FO.getCoupled(t, 'sandbox'); LM(e.model, t, n.event().item()), ti(t, Ho()), e.onItemExecute(t, r, n.event().item(), Bg.getValue(t)), Jm.close(r), FM(t) })].concat(e.dismissOnBlur ? [fi(Ao(), function (e) { const t = FO.getCoupled(e, 'sandbox'); zl(t.element()).isNone() && Jm.close(t) })] : []))]; return { uid: e.uid, dom: ZE(Ne(e, { inputAttributes: { role: 'combobox', 'aria-autocomplete': 'list', 'aria-haspopup': 'true' } })), behaviours: m(m({}, u), zg(e.typeaheadBehaviours, c)), eventOrder: e.eventOrder } }; const qM = i([yn('lazySink'), cn('fetch'), On('minChars', 5), On('responseTime', 1e3), xs('onOpen'), On('getHotspot', x.some), On('getAnchorOverrides', i({})), On('layouts', x.none()), On('eventOrder', {}), zn('model', {}, [On('getDisplayText', function (e) { return void 0 !== e.meta && void 0 !== e.meta.text ? e.meta.text : e.value }), On('selectsOver', !0), On('populateFromBrowse', !0)]), xs('onSetValue'), Cs('onExecute'), xs('onItemExecute'), On('inputClasses', []), On('inputAttributes', {}), On('inputStyles', {}), On('matchWidth', !0), On('useMinWidth', !1), On('dismissOnBlur', !0), ys(['openClass']), yn('initialData'), Mg('typeaheadBehaviours', [vy, Bg, IM, Kb, zy, FO]), In('previewing', function () { return Ln(!0) })].concat(YE()).concat(eN())); const $M = i([mh({ schema: [bs()], name: 'menu', overrides (e) { return { fakeFocus: !0, onHighlight (t, n) { e.previewing.get() ? t.getSystem().getByUid(e.uid).each(function (r) { UM(e.model, r, n).fold(function () { return Cp.dehighlight(t, n) }, function (e) { return e() }) }) : t.getSystem().getByUid(e.uid).each(function (t) { e.model.populateFromBrowse && LM(e.model, t, n) }), e.previewing.set(!1) }, onExecute (t, n) { return t.getSystem().getByUid(e.uid).toOption().map(function (e) { return ni(e, jM(), { item: n }), !0 }) }, onHover (t, n) { e.previewing.set(!1), t.getSystem().getByUid(e.uid).each(function (t) { e.model.populateFromBrowse && LM(e.model, t, n) }) } } } })]); const GM = Gh({ name: 'Typeahead', configFields: qM(), partFields: $M(), factory: WM }); var XM = function (e) { const n = function () { return XM(e.toCached()) }; const r = function (t) { return XM(e.bind(function (e) { return e.fold(function (e) { return dO.pure(T.error(e)) }, function (e) { return t(e) }) })) }; const o = function (t) { return XM(e.map(function (e) { return e.bind(t) })) }; const i = function (t) { return XM(e.map(function (e) { return e.map(t) })) }; const u = function (t) { return XM(e.map(function (e) { return e.mapError(t) })) }; const a = function (t, n) { return e.map(function (e) { return e.fold(t, n) }) }; const c = function (n, r) { return XM(dO.nu(function (o) { let i = !1; const u = t.setTimeout(function () { i = !0, o(T.error(r())) }, n); e.get(function (e) { i || (t.clearTimeout(u), o(e)) }) })) }; return m(m({}, e), { toCached: n, bindFuture: r, bindResult: o, mapResult: i, mapError: u, foldResult: a, withTimeout: c }) }; const YM = function (e) { return XM(dO.nu(e)) }; const KM = function (e) { return XM(dO.pure(T.value(e))) }; const JM = function (e) { return XM(dO.pure(T.error(e))) }; const ZM = function (e) { return XM(dO.pure(e)) }; const QM = function (e) { return XM(e.map(T.value)) }; const eP = function (e) { return YM(function (t) { e.then(function (e) { t(T.value(e)) }, function (e) { t(T.error(e)) }) }) }; const tP = { nu: YM, wrap: XM, pure: KM, value: KM, error: JM, fromResult: ZM, fromFuture: QM, fromPromise: eP }; const nP = { type: 'separator' }; const rP = function (e) { return { type: 'menuitem', value: e.url, text: e.title, meta: { attach: e.attach }, onAction () {} } }; const oP = function (e, t) { return { type: 'menuitem', value: t, text: e, meta: { attach: void 0 }, onAction () {} } }; const iP = function (e) { return W(e, rP) }; const uP = function (e, t) { return X(t, function (t) { return t.type === e }) }; const aP = function (e, t) { return iP(uP(e, t)) }; const cP = function (e) { return aP('header', e.targets) }; const sP = function (e) { return aP('anchor', e.targets) }; const lP = function (e) { return x.from(e.anchorTop).map(function (e) { return oP('<top>', e) }).toArray() }; const fP = function (e) { return x.from(e.anchorBottom).map(function (e) { return oP('<bottom>', e) }).toArray() }; const dP = function (e) { return W(e, function (e) { return oP(e, e) }) }; const mP = function (e) { return K(e, function (e, t) { const n = e.length === 0 || t.length === 0; return n ? e.concat(t) : e.concat(nP, t) }, []) }; const gP = function (e, t) { const n = e.toLowerCase(); return X(t, function (e) { const t = void 0 !== e.meta && void 0 !== e.meta.text ? e.meta.text : e.text; return _r(t.toLowerCase(), n) || _r(e.value.toLowerCase(), n) }) }; const hP = function (e, t, n) { const r = Bg.getValue(t); const o = void 0 !== r.meta.text ? r.meta.text : r.value; const i = n.getLinkInformation(); return i.fold(function () { return [] }, function (t) { const r = gP(o, dP(n.getHistory(e))); return e === 'file' ? mP([r, gP(o, cP(t)), gP(o, Q([lP(t), sP(t), fP(t)]))]) : r }) }; const pP = xu('aria-invalid'); const vP = function (e, t, r) { let o; const i = t.shared.providers; const u = function (t) { const n = Bg.getValue(t); r.addToHistory(n.value, e.filetype) }; const a = XE.parts().field({ factory: GM, dismissOnBlur: !0, inputClasses: ['tox-textfield'], sandboxClasses: ['tox-dialog__popups'], inputAttributes: { 'aria-errormessage': pP, type: 'url' }, minChars: 0, responseTime: 0, fetch (n) { const o = hP(e.filetype, n, r); const i = pB(o, IS.BUBBLE_TO_SANDBOX, t, !1); return dO.pure(i) }, getHotspot (e) { return h.getOpt(e) }, onSetValue (e, t) { e.hasConfigured(kO) && kO.run(e).get(n) }, typeaheadBehaviours: yl(Q([r.getValidationHandler().map(function (t) { return kO.config({ getRoot (e) { return Pi(e.element()) }, invalidClass: 'tox-control-wrap--status-invalid', notify: { onInvalid (e, t) { l.getOpt(e).each(function (e) { au(e.element(), 'title', i.translate(t)) }) } }, validator: { validate (n) { const r = Bg.getValue(n); return tP.nu(function (n) { t({ type: e.filetype, url: r.value }, function (e) { if (e.status === 'invalid') { const t = T.error(e.message); n(t) } else { const r = T.value(e.message); n(r) } }) }) }, validateOnLoad: !1 } }) }).toArray(), [NS.config({ disabled: e.disabled }), NO.config({}), cy('urlinput-events', Q([e.filetype === 'file' ? [fi(ko(), function (t) { ni(t, ME, { name: e.name }) })] : [], [fi(To(), function (t) { ni(t, ME, { name: e.name }), u(t) }), fi(Ro(), function (t) { ni(t, ME, { name: e.name }), u(t) })]]))]])), eventOrder: (o = {}, o[ko()] = ['streaming', 'urlinput-events', 'invalidating'], o), model: { getDisplayText (e) { return e.value }, selectsOver: !1, populateFromBrowse: !1 }, markers: { openClass: 'tox-textfield--popup-open' }, lazySink: t.shared.getSink, parts: { menu: gT(!1, 1, 'normal') }, onExecute (e, t, n) { ni(t, LE, {}) }, onItemExecute (t, n, r, o) { u(t), ni(t, ME, { name: e.name }) } }); const c = e.label.map(function (e) { return MO(e, i) }); const s = function (e, t, n, r) { return void 0 === n && (n = e), void 0 === r && (r = e), { dom: { tag: 'div', classes: ['tox-icon', 'tox-control-wrap__status-icon-' + e], innerHtml: gx(n, i.icons), attributes: m({ title: i.translate(r), 'aria-live': 'polite' }, t.fold(function () { return {} }, function (e) { return { id: e } })) } } }; var l = dx(s('invalid', x.some(pP), 'warning')); const f = dx({ dom: { tag: 'div', classes: ['tox-control-wrap__status-icon-wrap'] }, components: [l.asSpec()] }); const d = r.getUrlPicker(e.filetype); const g = xu('browser.url.event'); var h = dx({ dom: { tag: 'div', classes: ['tox-control-wrap'] }, components: [a, f.asSpec()], behaviours: yl([NS.config({ disabled: e.disabled })]) }); const p = dx(kB({ name: e.name, icon: x.some('browse'), text: e.label.getOr(''), disabled: e.disabled, primary: !1, borderless: !0 }, function (e) { return ti(e, g) }, i, [], ['tox-browse-url'])); const v = function () { return { dom: { tag: 'div', classes: ['tox-form__controls-h-stack'] }, components: Q([[h.asSpec()], d.map(function () { return p.asSpec() }).toArray()]) } }; const b = function (t) { np.getCurrent(t).each(function (n) { const r = Bg.getValue(n); const o = m({ fieldname: e.name }, r); d.each(function (r) { r(o).get(function (r) { Bg.setValue(n, r), ni(t, ME, { name: e.name }) }) }) }) }; return XE.sketch({ dom: RO(), components: c.toArray().concat([v()]), fieldBehaviours: yl([NS.config({ disabled: e.disabled, onDisabled (e) { XE.getField(e).each(NS.disable), p.getOpt(e).each(NS.disable) }, onEnabled (e) { XE.getField(e).each(NS.enable), p.getOpt(e).each(NS.enable) } }), cy('url-input-events', [fi(g, b)])]) }) }; const bP = function (e, t) { const n = Bg.config({ store: { mode: 'manual', getValue (e) { const t = e.element().dom(); return t.checked }, setValue (e, t) { const n = e.element().dom(); n.checked = t } } }); const r = function (e) { return e.element().dom().click(), x.some(!0) }; const o = XE.parts().field({ factory: { sketch: u }, dom: { tag: 'input', classes: ['tox-checkbox__input'], attributes: { type: 'checkbox' } }, behaviours: yl([gA.self(), NS.config({ disabled: e.disabled }), NO.config({}), vy.config({}), n, Kb.config({ mode: 'special', onEnter: r, onSpace: r, stopSpaceKeyup: !0 }), cy('checkbox-events', [fi(To(), function (t, n) { ni(t, ME, { name: e.name }) })])]) }); const i = XE.parts().label({ dom: { tag: 'span', classes: ['tox-checkbox__label'], innerHtml: t.translate(e.label) }, behaviours: yl([cN.config({})]) }); const a = function (e) { const n = e === 'checked' ? 'selected' : 'unselected'; return { dom: { tag: 'span', classes: ['tox-icon', 'tox-checkbox-icon__' + e], innerHtml: gx(n, t.icons) } } }; const c = dx({ dom: { tag: 'div', classes: ['tox-checkbox__icons'] }, components: [a('checked'), a('unchecked')] }); return XE.sketch({ dom: { tag: 'label', classes: ['tox-checkbox'] }, components: [o, c.asSpec(), i], fieldBehaviours: yl([NS.config({ disabled: e.disabled, disableClass: 'tox-checkbox--disabled', onDisabled (e) { XE.getField(e).each(NS.disable) }, onEnabled (e) { XE.getField(e).each(NS.enable) } })]) }) }; const yP = function (e) { return e.presets === 'presentation' ? RE.sketch({ dom: { tag: 'div', classes: ['tox-form__group'], innerHtml: e.html } }) : RE.sketch({ dom: { tag: 'div', classes: ['tox-form__group'], innerHtml: e.html, attributes: { role: 'document' } }, containerBehaviours: yl([NO.config({}), vy.config({})]) }) }; const wP = function (e, t) { const n = { dom: { tag: 'label', innerHtml: t.providers.translate(e.label), classes: ['tox-label'] } }; const r = W(e.items, t.interpreter); return { dom: { tag: 'div', classes: ['tox-form__group'] }, components: [n].concat(r), behaviours: yl([gA.self(), uy.config({}), _A.domHtml(x.none()), Kb.config({ mode: 'acyclic' })]) } }; const xP = function (e, t) { const n = e.label.map(function (e) { return MO(e, t) }); const r = function (e) { return function (t, n) { Zc(n.event().target(), '[data-collection-item-value]').each(function (r) { e(t, n, r, su(r, 'data-collection-item-value')) }) } }; const o = function (e) { return e === '"' ? '&quot;' : e }; const i = function (t, n) { const r = W(n, function (t) { const n = BC.translate(t.text); const r = e.columns === 1 ? '<div class="tox-collection__item-label">' + n + '</div>' : ''; const i = '<div class="tox-collection__item-icon">' + t.icon + '</div>'; const u = { _: ' ', ' - ': ' ', '-': ' ' }; const a = n.replace(/\_| \- |\-/g, function (e) { return u[e] }); return '<div class="tox-collection__item" tabindex="-1" data-collection-item-value="' + o(t.value) + '" title="' + a + '" aria-label="' + a + '">' + i + r + '</div>' }); const i = e.columns > 1 && e.columns !== 'auto' ? j(r, e.columns) : [r]; const u = W(i, function (e) { return '<div class="tox-collection__group">' + e.join('') + '</div>' }); Qi(t.element(), u.join('')) }; const a = r(function (t, n, r, o) { n.stop(), ni(t, IE, { name: e.name, value: o }) }); const c = [fi(yo(), r(function (e, t, n) { Rl(n) })), fi(Eo(), a), fi(zo(), a), fi(wo(), r(function (e, t, n) { Jc(e.element(), '.' + qC).each(function (e) { Ca(e, qC) }), wa(n, qC) })), fi(xo(), r(function (e) { Jc(e.element(), '.' + qC).each(function (e) { Ca(e, qC) }) })), ki(r(function (t, n, r, o) { ni(t, IE, { name: e.name, value: o }) }))]; const s = XE.parts().field({ dom: { tag: 'div', classes: ['tox-collection'].concat(e.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list']) }, components: [], factory: { sketch: u }, behaviours: yl([uy.config({}), Bg.config({ store: { mode: 'memory', initialValue: [] }, onSetValue (t, n) { i(t, n), e.columns === 'auto' && vC(t, 5, 'tox-collection__item').each(function (e) { const n = e.numRows; const r = e.numColumns; Kb.setGridSize(t, n, r) }), ti(t, UE) } }), NO.config({}), Kb.config(_T(e.columns, 'normal')), cy('collection-events', c)]) }); const l = ['tox-form__group--collection']; return _O(n, s, l, []) }; const CP = function (e, t) { const n = function (e) { return { dom: { tag: 'th', innerHtml: t.translate(e) } } }; const r = function (e) { return { dom: { tag: 'thead' }, components: [{ dom: { tag: 'tr' }, components: W(e, n) }] } }; const o = function (e) { return { dom: { tag: 'td', innerHtml: t.translate(e) } } }; const i = function (e) { return { dom: { tag: 'tr' }, components: W(e, o) } }; const u = function (e) { return { dom: { tag: 'tbody' }, components: W(e, i) } }; return { dom: { tag: 'table', classes: ['tox-dialog__table'] }, components: [r(e.header), u(e.cells)], behaviours: yl([NO.config({}), vy.config({})]) } }; const SP = function (e, t) { return { dom: { tag: 'div', classes: e.classes }, components: W(e.items, t.shared.interpreter) } }; const kP = function (e) { return function (t, n, r) { return ye(n, 'name').fold(function () { return e(n, r) }, function (o) { return t.field(o, e(n, r)) }) } }; const TP = function (e) { return function (t, n, r) { const o = Ne(n, { source: 'dynamic' }); return kP(e)(t, o, r) } }; const EP = { bar: kP(function (e, t) { return WE(e, t.shared) }), collection: kP(function (e, t) { return xP(e, t.shared.providers) }), alertbanner: kP(function (e, t) { return jE(e, t.shared.providers) }), input: kP(function (e, t) { return NM(e, t.shared.providers) }), textarea: kP(function (e, t) { return _M(e, t.shared.providers) }), label: kP(function (e, t) { return wP(e, t.shared) }), iframe: TP(function (e, t) { return WA(e, t.shared.providers) }), button: kP(function (e, t) { return _B(e, t.shared.providers) }), checkbox: kP(function (e, t) { return bP(e, t.shared.providers) }), colorinput: kP(function (e, t) { return mN(e, t.shared, t.colorinput) }), colorpicker: kP(bA), dropzone: kP(function (e, t) { return RA(e, t.shared.providers) }), grid: kP(function (e, t) { return BA(e, t.shared) }), selectbox: kP(function (e, t) { return EM(e, t.shared.providers) }), sizeinput: kP(function (e, t) { return UB(e, t.shared.providers) }), urlinput: kP(function (e, t) { return vP(e, t, t.urlinput) }), customeditor: kP(xA), htmlpanel: kP(yP), imagetools: kP(function (e, t) { return SM(e, t.shared.providers) }), table: kP(function (e, t) { return CP(e, t.shared.providers) }), panel: kP(function (e, t) { return SP(e, t) }) }; const OP = { field (e, t) { return t } }; const NP = function (e, t, n) { var r = Ne(n, { shared: { interpreter (t) { return _P(e, t, r) } } }); return _P(e, t, r) }; var _P = function (e, n, r) { return ye(EP, n.type).fold(function () { return t.console.error('Unknown factory type "' + n.type + '", defaulting to container: ', n), n }, function (t) { return t(e, n, r) }) }; const DP = function (e, t) { const n = OP; return _P(n, e, t) }; const AP = { valignCentre: [], alignCentre: [], alignLeft: [], alignRight: [], right: [], left: [], bottom: [], top: [] }; const RP = function (e, t, n) { const r = yf(-12, 12, AP); const o = { maxHeightFunction: mf() }; const i = function () { return { anchor: 'node', root: _a(Ri(e())), node: x.from(e()), bubble: r, layouts: { onRtl () { return [Aw] }, onLtr () { return [Dw] } }, overrides: o } }; const u = function () { return { anchor: 'hotspot', hotspot: t(), bubble: r, layouts: { onRtl () { return [Zs] }, onLtr () { return [Qs] } }, overrides: o } }; return n ? i : u }; const BP = function (e, t, n) { const r = function () { return { anchor: 'node', root: _a(Ri(e())), node: x.from(e()), layouts: { onRtl () { return [Rw] }, onLtr () { return [Rw] } } } }; const o = function () { return { anchor: 'hotspot', hotspot: t(), layouts: { onRtl () { return [rl] }, onLtr () { return [rl] } } } }; return n ? r : o }; const MP = function (e, t) { return function () { return { anchor: 'selection', root: t(), getSelection () { const t = e.selection.getRng(); return x.some(Jf.range(Wn.fromDom(t.startContainer), t.startOffset, Wn.fromDom(t.endContainer), t.endOffset)) } } } }; const PP = function (e) { return function (t) { return { anchor: 'node', root: e(), node: t } } }; const zP = function (e, t) { const n = ix(e); const r = function () { return Wn.fromDom(e.getBody()) }; const o = function () { return Wn.fromDom(e.getContentAreaContainer()) }; const i = n || !nx(e); return { inlineDialog: RP(o, t, i), banner: BP(o, t, i), cursor: MP(e, r), node: PP(r) } }; const IP = { getAnchors: zP }; const LP = function (e) { return function (t, n) { const r = cT.colorPickerDialog(e); r(t, n) } }; const HP = function (e) { return function () { return Lk.hasCustomColors(e) } }; const FP = function (e) { return function () { return Lk.getColors(e) } }; const VP = function (e) { return function () { return cT.getColorCols(e) } }; const UP = function (e) { return { colorPicker: LP(e), hasCustomColors: HP(e), getColors: FP(e), getColorCols: VP(e) } }; const jP = function (e) { return function () { return sx(e) } }; const WP = function (e) { return { isDraggableModal: jP(e) } }; const qP = [{ title: 'Headings', items: [{ title: 'Heading 1', format: 'h1' }, { title: 'Heading 2', format: 'h2' }, { title: 'Heading 3', format: 'h3' }, { title: 'Heading 4', format: 'h4' }, { title: 'Heading 5', format: 'h5' }, { title: 'Heading 6', format: 'h6' }] }, { title: 'Inline', items: [{ title: 'Bold', icon: 'bold', format: 'bold' }, { title: 'Italic', icon: 'italic', format: 'italic' }, { title: 'Underline', icon: 'underline', format: 'underline' }, { title: 'Strikethrough', icon: 'strike-through', format: 'strikethrough' }, { title: 'Superscript', icon: 'superscript', format: 'superscript' }, { title: 'Subscript', icon: 'subscript', format: 'subscript' }, { title: 'Code', icon: 'code', format: 'code' }] }, { title: 'Blocks', items: [{ title: 'Paragraph', format: 'p' }, { title: 'Blockquote', format: 'blockquote' }, { title: 'Div', format: 'div' }, { title: 'Pre', format: 'pre' }] }, { title: 'Align', items: [{ title: 'Left', icon: 'align-left', format: 'alignleft' }, { title: 'Center', icon: 'align-center', format: 'aligncenter' }, { title: 'Right', icon: 'align-right', format: 'alignright' }, { title: 'Justify', icon: 'align-justify', format: 'alignjustify' }] }]; const $P = function (e) { return we(e, 'items') }; const GP = function (e) { return we(e, 'block') }; const XP = function (e) { return we(e, 'inline') }; const YP = function (e) { return we(e, 'selector') }; var KP = function (e) { return K(e, function (e, t) { if ($P(t)) { const n = KP(t.items); return { customFormats: e.customFormats.concat(n.customFormats), formats: e.formats.concat([{ title: t.title, items: n.formats }]) } } if (XP(t) || GP(t) || YP(t)) { const r = 'custom-' + t.title.toLowerCase(); return { customFormats: e.customFormats.concat([{ name: r, format: t }]), formats: e.formats.concat([{ title: t.title, format: r, icon: t.icon }]) } } return m(m({}, e), { formats: e.formats.concat(t) }) }, { customFormats: [], formats: [] }) }; const JP = function (e, t) { const n = KP(t); const r = function (t) { q(t, function (t) { e.formatter.has(t.name) || e.formatter.register(t.name, t.format) }) }; return e.formatter ? r(n.customFormats) : e.on('init', function () { r(n.customFormats) }), n.formats }; const ZP = function (e) { return $w(e).map(function (t) { const n = JP(e, t); return Gw(e) ? qP.concat(n) : n }).getOr(qP) }; const QP = function (e, t, n) { const r = { type: 'formatter', isSelected: t(e.format), getStylePreview: n(e.format) }; return Ne(e, r) }; const ez = function (e, t, n, r) { const o = function (e) { return QP(e, n, r) }; const i = function (e) { const t = { type: 'submenu' }; return Ne(e, t) }; const u = function (t) { const o = xu(t.title); const i = { type: 'formatter', format: o, isSelected: n(o), getStylePreview: r(o) }; const u = Ne(t, i); return e.formatter.register(o, u), u }; var a = function (e) { return W(e, function (e) { const t = fe(e); if (xe(e, 'items')) { const n = a(e.items); return Ne(i(e), { getStyleItems () { return n } }) } return xe(e, 'format') ? o(e) : t.length === 1 && F(t, 'title') ? Ne(e, { type: 'separator' }) : u(e) }) }; return a(t) }; const tz = function (e) { const t = function (t) { return function () { return e.formatter.match(t) } }; const n = function (t) { return function () { const n = e.formatter.get(t); return void 0 !== n ? x.some({ tag: n.length > 0 && (n[0].inline || n[0].block) || 'div', styles: e.dom.parseStyle(e.formatter.getCssText(t)) }) : x.none() } }; var r = function (e) { const t = e.items; return void 0 !== t && t.length > 0 ? ee(t, r) : [e.format] }; const o = Ln([]); const i = Ln([]); const u = Ln([]); const a = Ln([]); const c = Ln(!1); e.on('PreInit', function (u) { const a = ZP(e); const c = ez(e, a, t, n); o.set(c), i.set(ee(c, r)) }), e.on('addStyleModifications', function (o) { const i = ez(e, o.items, t, n); u.set(i), c.set(o.replace), a.set(ee(i, r)) }); const s = function () { const e = c.get() ? [] : o.get(); const t = u.get(); return e.concat(t) }; const l = function () { const e = c.get() ? [] : i.get(); const t = a.get(); return e.concat(t) }; return { getData: s, getFlattenedKeys: l } }; const nz = aM.trim; const rz = function (e) { return function (t) { if (t && t.nodeType === 1) { if (t.contentEditable === e) { return !0 } if (t.getAttribute('data-mce-contenteditable') === e) { return !0 } } return !1 } }; const oz = rz('true'); const iz = rz('false'); const uz = function (e, t, n, r, o) { return { type: e, title: t, url: n, level: r, attach: o } }; const az = function (e) { while (e = e.parentNode) { const t = e.contentEditable; if (t && t !== 'inherit') { return oz(e) } } return !1 }; const cz = function (e, t) { return W(wd(Wn.fromDom(t), e), function (e) { return e.dom() }) }; const sz = function (e) { return e.textContent || e.textContent }; const lz = function (e) { return e.id ? e.id : xu('h') }; const fz = function (e) { return e && e.nodeName === 'A' && void 0 !== (e.id || e.name) }; const dz = function (e) { return fz(e) && gz(e) }; const mz = function (e) { return e && /^(H[1-6])$/.test(e.nodeName) }; var gz = function (e) { return az(e) && !iz(e) }; const hz = function (e) { return mz(e) && gz(e) }; const pz = function (e) { return mz(e) ? parseInt(e.nodeName.substr(1), 10) : 0 }; const vz = function (e) { const t = lz(e); const n = function () { e.id = t }; return uz('header', sz(e), '#' + t, pz(e), n) }; const bz = function (e) { const t = e.id || e.name; const r = sz(e); return uz('anchor', r || '#' + t, '#' + t, 0, n) }; const yz = function (e) { return W(X(e, hz), vz) }; const wz = function (e) { return W(X(e, dz), bz) }; const xz = function (e) { const t = cz('h1,h2,h3,h4,h5,h6,a:not([href])', e); return t }; const Cz = function (e) { return nz(e.title).length > 0 }; const Sz = function (e) { const t = xz(e); return X(yz(t).concat(wz(t)), Cz) }; const kz = { find: Sz }; const Tz = 'tinymce-url-history'; const Ez = 5; const Oz = function (e) { return N(e) && /^https?/.test(e) }; const Nz = function (e) { return D(e) && e.length <= Ez && te(e, Oz) }; const _z = function (e) { return _(e) && ve(e, function (e) { return !Nz(e) }).isNone() }; const Dz = function () { let e; const n = t.localStorage.getItem(Tz); if (n === null) { return {} } try { e = JSON.parse(n) } catch (r) { if (r instanceof SyntaxError) { return t.console.log('Local storage ' + Tz + ' was not valid JSON', r), {} } throw r } return _z(e) ? e : (t.console.log('Local storage ' + Tz + ' was not valid format', e), {}) }; const Az = function (e) { if (!_z(e)) { throw new Error('Bad format for history:\n' + JSON.stringify(e)) } t.localStorage.setItem(Tz, JSON.stringify(e)) }; const Rz = function (e) { const t = Dz(); return Object.prototype.hasOwnProperty.call(t, e) ? t[e] : [] }; const Bz = function (e, t) { if (Oz(e)) { const n = Dz(); const r = Object.prototype.hasOwnProperty.call(n, t) ? n[t] : []; const o = X(r, function (t) { return t !== e }); n[t] = [e].concat(o).slice(0, Ez), Az(n) } }; const Mz = Object.prototype.hasOwnProperty; const Pz = function (e) { return !!e }; const zz = function (e) { return ge(aM.makeMap(e, /[, ]/), Pz) }; const Iz = function (e, t) { return Mz.call(e, t) ? x.some(e[t]) : x.none() }; const Lz = function (e, t, n) { const r = Iz(e, t).getOr(n); return N(r) ? x.some(r) : x.none() }; const Hz = function (e) { return x.some(e.file_picker_callback).filter(R) }; const Fz = function (e) { const t = x.some(e.file_picker_types).filter(Pz); const n = x.some(e.file_browser_callback_types).filter(Pz); const r = t.or(n).map(zz); return Hz(e).fold(function () { return !1 }, function (e) { return r.fold(function () { return !0 }, function (e) { return fe(e).length > 0 && e }) }) }; const Vz = function (e, t) { const n = Fz(e); return A(n) ? n ? Hz(e) : x.none() : n[t] ? Hz(e) : x.none() }; const Uz = function (e, t) { return Vz(e.settings, t).map(function (n) { return function (r) { return dO.nu(function (o) { const i = function (e, t) { if (!N(e)) { throw new Error('Expected value to be string') } if (void 0 !== t && !_(t)) { throw new Error('Expected meta to be a object') } const n = { value: e, meta: t }; o(n) }; const u = m({ filetype: t, fieldname: r.fieldname }, x.from(r.meta).getOr({})); n.call(e, i, r.value, u) }) } }) }; const jz = function (e) { return !1 === e.settings.typeahead_urls ? x.none() : x.some({ targets: kz.find(e.getBody()), anchorTop: Lz(e.settings, 'anchor_top', '#top').getOrUndefined(), anchorBottom: Lz(e.settings, 'anchor_bottom', '#bottom').getOrUndefined() }) }; const Wz = function (e) { const t = x.from(e.settings.file_picker_validator_handler).filter(R); return t.orThunk(function () { return x.from(e.settings.filepicker_validator_handler).filter(R) }) }; const qz = function (e) { return { getHistory: Rz, addToHistory: Bz, getLinkInformation () { return jz(e) }, getValidationHandler () { return Wz(e) }, getUrlPicker (t) { return Uz(e, t) } } }; const $z = function (e, t, n) { const r = Ln(!1); var o = { shared: { providers: { icons () { return t.ui.registry.getAll().icons }, menuItems () { return t.ui.registry.getAll().menuItems }, translate: BC.translate }, interpreter (e) { return DP(e, o) }, anchors: IP.getAnchors(t, n), getSink () { return T.value(e) } }, urlinput: qz(t), styleselect: tz(t), colorinput: UP(t), dialog: WP(t), isContextMenuOpen () { return r.get() }, setContextMenuState (e) { return r.set(e) } }; return o }; const Gz = i(function (e, t) { yc(e, Math.floor(t)) }); const Xz = 'contexttoolbar-show'; const Yz = 'contexttoolbar-hide'; const Kz = i([cn('items'), ys(['itemSelector']), Mg('tgroupBehaviours', [Kb])]); const Jz = i([hh({ name: 'items', unit: 'item' })]); const Zz = function (e, t, n, r) { return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.tgroupBehaviours, [Kb.config({ mode: 'flow', selector: e.markers.itemSelector })]), domModification: { attributes: { role: 'toolbar' } } } }; const Qz = Gh({ name: 'ToolbarGroup', configFields: Kz(), partFields: Jz(), factory: Zz }); const eI = i([cn('dom'), On('shell', !0), Mg('toolbarBehaviours', [uy])]); const tI = function () { return { behaviours: yl([uy.config({})]) } }; const nI = i([gh({ name: 'groups', overrides: tI })]); const rI = function (e, n, r, o) { const i = function (e, n) { u(e).fold(function () { throw t.console.error('Toolbar was defined to not be a shell, but no groups container was specified in components'), new Error('Toolbar was defined to not be a shell, but no groups container was specified in components') }, function (e) { uy.set(e, n) }) }; var u = function (t) { return e.shell ? x.some(t) : Oh(t, e, 'groups') }; const a = e.shell ? { behaviours: [uy.config({})], components: [] } : { behaviours: [], components: n }; return { uid: e.uid, dom: e.dom, components: a.components, behaviours: zg(e.toolbarBehaviours, a.behaviours), apis: { setGroups: i }, domModification: { attributes: { role: 'group' } } } }; const oI = Gh({ name: 'Toolbar', configFields: eI(), partFields: nI(), factory: rI, apis: { setGroups (e, t, n) { e.setGroups(t, n) } } }); const iI = function (e, t) { const n = { len: 0, list: [] }; const r = K(e, function (e, n) { const r = t(n, e.len); return r.fold(i(e), function (t) { return { len: t.finish(), list: e.list.concat([t]) } }) }, n); return r.list }; const uI = Ti('within', 'extra', 'withinWidth'); const aI = function (e, t, n) { const r = iI(e, function (e, t) { const r = n(e); return x.some({ element: i(e), start: i(t), finish: i(t + r), width: i(r) }) }); const o = X(r, function (e) { return e.finish() <= t }); const u = Y(o, function (e, t) { return e + t.width() }, 0); const a = r.slice(o.length); return { within: i(o), extra: i(a), withinWidth: i(u) } }; const cI = function (e) { return W(e, function (e) { return e.element() }) }; const sI = function (e, t, n) { const r = cI(e.concat(t)); return uI(r, [], n) }; const lI = function (e, t, n, r) { const o = cI(e).concat([n]); return uI(o, cI(t), r) }; const fI = function (e, t, n) { return uI(cI(e), [], n) }; const dI = function (e, t, n) { const r = aI(t, e, n); return r.extra().length === 0 ? x.some(r) : x.none() }; const mI = function (e, t, n, r) { const o = dI(e, t, n).getOrThunk(function () { return aI(t, e - n(r), n) }); const i = o.within(); const u = o.extra(); const a = o.withinWidth(); return u.length === 1 && u[0].width() <= n(r) ? sI(i, u, a) : u.length >= 1 ? lI(i, u, r, a) : fI(i, u, a) }; const gI = function (e, t) { const n = W(t, function (e) { return rc(e) }); oI.setGroups(e, n) }; const hI = function (e) { return le(e, function (e) { return zl(e.element()).bind(function (t) { return e.getSystem().getByDom(t).toOption() }) }) }; const pI = function (e, t, n) { const r = Nh(e, t, 'primary'); const o = FO.getCoupled(e, 'overflowGroup'); Ra(r.element(), 'visibility', 'hidden'); const i = t.builtGroups.get().concat([o]); const u = hI(i); n([]), gI(r, i); const a = vc(r.element()); const c = mI(a, t.builtGroups.get(), function (e) { return vc(e.element()) }, o); c.extra().length === 0 ? (uy.remove(r, o), n([])) : (gI(r, c.within()), n(c.extra())), Fa(r.element(), 'visibility'), Va(r.element()), u.each(vy.focus) }; const vI = i([Mg('splitToolbarBehaviours', [FO]), In('builtGroups', function () { return Ln([]) })]); const bI = i([ys(['overflowToggledClass']), Sn('getOverflowBounds'), cn('lazySink'), In('overflowGroups', function () { return Ln([]) })].concat(vI())); const yI = i([dh({ factory: oI, schema: eI(), name: 'primary' }), mh({ schema: eI(), name: 'overflow' }), mh({ name: 'overflow-button' }), mh({ name: 'overflow-group' })]); const wI = i([ys(['toggledClass']), cn('lazySink'), gn('fetch'), Sn('getBounds'), Tn('fireDismissalEventInstead', [On('event', Go())]), Ef()]); const xI = i([mh({ name: 'button', overrides (e) { return { dom: { attributes: { 'aria-haspopup': 'true' } }, buttonBehaviours: yl([zy.config({ toggleClass: e.markers.toggledClass, aria: { mode: 'expanded' }, toggleOnExecute: !1 })]) } } }), mh({ factory: oI, schema: eI(), name: 'toolbar', overrides (e) { return { toolbarBehaviours: yl([Kb.config({ mode: 'cyclic', onEscape (t) { return Oh(t, e, 'button').each(vy.focus), x.none() } })]) } } })]); const CI = function (e, t) { const n = FO.getCoupled(e, 'toolbarSandbox'); Jm.isOpen(n) ? Jm.close(n) : Jm.open(n, t.toolbar()) }; const SI = function (e, t, n, r) { const o = n.getBounds.map(function (e) { return e() }); const i = n.lazySink(e).getOrDie(); vm.positionWithinBounds(i, { anchor: 'hotspot', hotspot: e, layouts: r, overrides: { maxWidthFunction: Gz() } }, t, o) }; const kI = function (e, t, n, r, o) { oI.setGroups(t, o), SI(e, t, n, r), zy.on(e) }; const TI = function (e, t, n) { const r = es(); const o = function (o, i) { n.fetch().get(function (o) { kI(e, i, n, t.layouts, o), r.link(e.element()), Kb.focusIn(i) }) }; const i = function () { zy.off(e), vy.focus(e), r.unlink(e.element()) }; return { dom: { tag: 'div', attributes: { id: r.id() } }, behaviours: yl([Kb.config({ mode: 'special', onEscape (e) { return Jm.close(e), x.some(!0) } }), Jm.config({ onOpen: o, onClose: i, isPartOf (t, n, r) { return ns(n, r) || ns(e, r) }, getAttachPoint () { return n.lazySink(e).getOrDie() } }), _l.config({ channels: m(m({}, ng(m({ isExtraPart: l }, n.fireDismissalEventInstead.map(function (e) { return { fireEventInstead: { event: e.event } } }).getOr({})))), og({ doReposition () { Jm.getState(FO.getCoupled(e, 'toolbarSandbox')).each(function (r) { SI(e, r, n, t.layouts) }) } })) })]) } }; const EI = function (e, t, n, r) { return m(m({}, fx.sketch(m(m({}, r.button()), { action (e) { CI(e, r) }, buttonBehaviours: Ig.augment({ dump: r.button().buttonBehaviours }, [FO.config({ others: { toolbarSandbox (t) { return TI(t, n, e) } } })]) }))), { apis: { setGroups (t, r) { Jm.getState(FO.getCoupled(t, 'toolbarSandbox')).each(function (o) { kI(t, o, e, n.layouts, r) }) }, reposition (t) { Jm.getState(FO.getCoupled(t, 'toolbarSandbox')).each(function (r) { SI(t, r, e, n.layouts) }) }, toggle (e) { CI(e, r) }, getToolbar (e) { return Jm.getState(FO.getCoupled(e, 'toolbarSandbox')) } } }) }; const OI = Gh({ name: 'FloatingToolbarButton', factory: EI, configFields: wI(), partFields: xI(), apis: { setGroups (e, t, n) { e.setGroups(t, n) }, reposition (e, t) { e.reposition(t) }, toggle (e, t) { e.toggle(t) }, getToolbar (e, t) { return e.getToolbar(t) } } }); const NI = function (e) { return W(e, function (e) { return rc(e) }) }; const _I = function (e, t, n) { pI(e, n, function (r) { n.overflowGroups.set(r), t.getOpt(e).each(function (e) { OI.setGroups(e, NI(r)) }) }) }; const DI = function (e, t, n, r) { const o = dx(OI.sketch({ fetch () { return dO.nu(function (t) { t(NI(e.overflowGroups.get())) }) }, layouts: { onLtr () { return [Qs, Zs] }, onRtl () { return [Zs, Qs] }, onBottomLtr () { return [tl, el] }, onBottomRtl () { return [el, tl] } }, getBounds: n.getOverflowBounds, lazySink: e.lazySink, fireDismissalEventInstead: {}, markers: { toggledClass: e.markers.overflowToggledClass }, parts: { button: r['overflow-button'](), toolbar: r.overflow() } })); return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.splitToolbarBehaviours, [FO.config({ others: { overflowGroup () { return Qz.sketch(m(m({}, r['overflow-group']()), { items: [o.asSpec()] })) } } })]), apis: { setGroups (t, n) { e.builtGroups.set(W(n, t.getSystem().build)), _I(t, o, e) }, refresh (t) { return _I(t, o, e) }, toggle (e) { o.getOpt(e).each(function (e) { OI.toggle(e) }) }, reposition (e) { o.getOpt(e).each(function (e) { OI.reposition(e) }) }, getOverflow (e) { return o.getOpt(e).bind(function (e) { return OI.getToolbar(e) }) } }, domModification: { attributes: { role: 'group' } } } }; const AI = Gh({ name: 'SplitFloatingToolbar', configFields: bI(), partFields: yI(), factory: DI, apis: { setGroups (e, t, n) { e.setGroups(t, n) }, refresh (e, t) { e.refresh(t) }, reposition (e, t) { e.reposition(t) }, toggle (e, t) { e.toggle(t) }, getOverflow (e, t) { return e.getOverflow(t) } } }); const RI = function (e, t) { return t.getAnimationRoot.fold(function () { return e.element() }, function (t) { return t(e) }) }; const BI = function (e) { return e.dimension.property }; const MI = function (e, t) { return e.dimension.getDimension(t) }; const PI = function (e, t) { const n = RI(e, t); Ta(n, [t.shrinkingClass, t.growingClass]) }; const zI = function (e, t) { Ca(e.element(), t.openClass), wa(e.element(), t.closedClass), Ra(e.element(), BI(t), '0px'), Va(e.element()) }; const II = function (e, t) { Ca(e.element(), t.closedClass), wa(e.element(), t.openClass), Fa(e.element(), BI(t)) }; const LI = function (e, t, n, r) { n.setCollapsed(), Ra(e.element(), BI(t), MI(t, e.element())), Va(e.element()), PI(e, t), zI(e, t), t.onStartShrink(e), t.onShrunk(e) }; const HI = function (e, t, n, r) { const o = r.getOrThunk(function () { return MI(t, e.element()) }); n.setCollapsed(), Ra(e.element(), BI(t), o), Va(e.element()); const i = RI(e, t); Ca(i, t.growingClass), wa(i, t.shrinkingClass), zI(e, t), t.onStartShrink(e) }; const FI = function (e, t, n) { const r = MI(t, e.element()); const o = r === '0px' ? LI : HI; o(e, t, n, x.some(r)) }; const VI = function (e, t, n) { const r = RI(e, t); const o = Sa(r, t.shrinkingClass); const i = MI(t, e.element()); II(e, t); const u = MI(t, e.element()); const a = function () { Ra(e.element(), BI(t), i), Va(e.element()) }; const c = function () { zI(e, t) }; const s = o ? a : c; s(), Ca(r, t.shrinkingClass), wa(r, t.growingClass), II(e, t), Ra(e.element(), BI(t), u), n.setExpanded(), t.onStartGrow(e) }; const UI = function (e, t, n) { if (n.isExpanded()) { Fa(e.element(), BI(t)); const r = MI(t, e.element()); Ra(e.element(), BI(t), r) } }; const jI = function (e, t, n) { n.isExpanded() || VI(e, t, n) }; const WI = function (e, t, n) { n.isExpanded() && FI(e, t, n) }; const qI = function (e, t, n) { n.isExpanded() && LI(e, t, n, x.none()) }; const $I = function (e, t, n) { return n.isExpanded() }; const GI = function (e, t, n) { return n.isCollapsed() }; const XI = function (e, t, n) { const r = RI(e, t); return !0 === Sa(r, t.growingClass) }; const YI = function (e, t, n) { const r = RI(e, t); return !0 === Sa(r, t.shrinkingClass) }; const KI = function (e, t, n) { return !0 === XI(e, t) || !0 === YI(e, t) }; const JI = function (e, t, n) { const r = n.isExpanded() ? FI : VI; r(e, t, n) }; const ZI = Object.freeze({ __proto__: null, refresh: UI, grow: jI, shrink: WI, immediateShrink: qI, hasGrown: $I, hasShrunk: GI, isGrowing: XI, isShrinking: YI, isTransitioning: KI, toggleGrow: JI, disableTransitions: PI }); const QI = function (e, t) { const n = t.expanded; return Gu(n ? { classes: [t.openClass], styles: {} } : { classes: [t.closedClass], styles: et(t.dimension.property, '0px') }) }; const eL = function (e, t) { return ai([wi(Oo(), function (n, r) { const o = r.event().raw(); if (o.propertyName === e.dimension.property) { PI(n, e), t.isExpanded() && Fa(n.element(), e.dimension.property); const i = t.isExpanded() ? e.onGrown : e.onShrunk; i(n) } })]) }; const tL = Object.freeze({ __proto__: null, exhibit: QI, events: eL }); const nL = [cn('closedClass'), cn('openClass'), cn('shrinkingClass'), cn('growingClass'), yn('getAnimationRoot'), xs('onShrunk'), xs('onStartShrink'), xs('onGrown'), xs('onStartGrow'), On('expanded', !1), sn('dimension', Jt('property', { width: [Ts('property', 'width'), Ts('getDimension', function (e) { return vc(e) + 'px' })], height: [Ts('property', 'height'), Ts('getDimension', function (e) { return uc(e) + 'px' })] }))]; const rL = function (e) { const t = Ln(e.expanded); const n = function () { return 'expanded: ' + t.get() }; return Uu({ isExpanded () { return !0 === t.get() }, isCollapsed () { return !1 === t.get() }, setCollapsed: a(t.set, !1), setExpanded: a(t.set, !0), readState: n }) }; const oL = Object.freeze({ __proto__: null, init: rL }); const iL = xl({ fields: nL, name: 'sliding', active: tL, apis: ZI, state: oL }); const uL = i([ys(['closedClass', 'openClass', 'shrinkingClass', 'growingClass', 'overflowToggledClass']), xs('onOpened'), xs('onClosed')].concat(vI())); const aL = i([dh({ factory: oI, schema: eI(), name: 'primary' }), dh({ factory: oI, schema: eI(), name: 'overflow', overrides (e) { return { toolbarBehaviours: yl([iL.config({ dimension: { property: 'height' }, closedClass: e.markers.closedClass, openClass: e.markers.openClass, shrinkingClass: e.markers.shrinkingClass, growingClass: e.markers.growingClass, onShrunk (t) { Oh(t, e, 'overflow-button').each(function (e) { zy.off(e), vy.focus(e) }), e.onClosed(t) }, onGrown (t) { Kb.focusIn(t), e.onOpened(t) }, onStartGrow (t) { Oh(t, e, 'overflow-button').each(zy.on) } }), Kb.config({ mode: 'acyclic', onEscape (t) { return Oh(t, e, 'overflow-button').each(vy.focus), x.some(!0) } })]) } } }), mh({ name: 'overflow-button', overrides (e) { return { buttonBehaviours: yl([zy.config({ toggleClass: e.markers.overflowToggledClass, aria: { mode: 'pressed' }, toggleOnExecute: !1 })]) } } }), mh({ name: 'overflow-group' })]); const cL = function (e, t) { Oh(e, t, 'overflow').each(function (n) { sL(e, t), iL.toggleGrow(n) }) }; var sL = function (e, t) { Oh(e, t, 'overflow').each(function (n) { pI(e, t, function (e) { const t = W(e, function (e) { return rc(e) }); oI.setGroups(n, t) }), Oh(e, t, 'overflow-button').each(function (e) { iL.hasGrown(n) && zy.on(e) }), iL.refresh(n) }) }; const lL = function (e, t, n, r) { const o = 'alloy.toolbar.toggle'; const i = function (t, n) { const r = W(n, t.getSystem().build); e.builtGroups.set(r) }; return { uid: e.uid, dom: e.dom, components: t, behaviours: zg(e.splitToolbarBehaviours, [FO.config({ others: { overflowGroup (e) { return Qz.sketch(m(m({}, r['overflow-group']()), { items: [fx.sketch(m(m({}, r['overflow-button']()), { action (t) { ti(e, o) } }))] })) } } }), cy('toolbar-toggle-events', [fi(o, function (t) { Oh(t, e, 'overflow').each(function (n) { sL(t, e), iL.toggleGrow(n) }) })])]), apis: { setGroups (t, n) { i(t, n), sL(t, e) }, refresh (t) { return sL(t, e) }, toggle (t) { return cL(t, e) } }, domModification: { attributes: { role: 'group' } } } }; const fL = Gh({ name: 'SplitSlidingToolbar', configFields: uL(), partFields: aL(), factory: lL, apis: { setGroups (e, t, n) { e.setGroups(t, n) }, refresh (e, t) { e.refresh(t) }, toggle (e, t) { e.toggle(t) } } }); const dL = i(xu('toolbar-height-change')); const mL = 'silver.readonly'; const gL = _t([mn('readonly')]); const hL = function (e, t) { Yr('*', e.element()).forEach(function (n) { e.getSystem().getByDom(n).each(function (e) { e.hasConfigured(NS) && NS.set(e, t) }) }) }; const pL = function (e, t) { const n = e.outerContainer; const r = n.element(); t && (e.mothership.broadcastOn([Zm()], { target: r }), e.uiMothership.broadcastOn([Zm()], { target: r })), e.mothership.broadcastOn([mL], { readonly: t }), e.uiMothership.broadcastOn([mL], { readonly: t }) }; const vL = function (e, t) { const n = e.outerContainer; pL(e, t), Yr('*', n.element()).forEach(function (e) { n.getSystem().getByDom(e).each(function (e) { e.hasConfigured(NS) && NS.set(e, t) }) }) }; const bL = function (e, t) { e.on('init', function () { e.mode.isReadOnly() && vL(t, !0) }), e.on('SwitchMode', function () { return vL(t, e.mode.isReadOnly()) }), Lw(e) && e.setMode('readonly') }; const yL = function (e) { let t; return _l.config({ channels: (t = {}, t[mL] = { schema: gL, onReceive (t, n) { e(t).each(function (e) { hL(e, n.readonly) }) } }, t) }) }; const wL = function (e) { const t = e.title.fold(function () { return {} }, function (e) { return { attributes: { title: e } } }); return { dom: m({ tag: 'div', classes: ['tox-toolbar__group'] }, t), components: [Qz.parts().items({})], items: e.items, markers: { itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])' }, tgroupBehaviours: yl([NO.config({}), vy.config({})]) } }; const xL = function (e) { return Qz.sketch(wL(e)) }; const CL = function (e, t, n) { const r = xi(function (t) { const n = W(e.initGroups, xL); oI.setGroups(t, n) }); return yl([Kb.config({ mode: t, onEscape: e.onEscape, selector: '.tox-toolbar__group' }), cy('toolbar-events', [r]), yL(n)]) }; const SL = function (e, t) { const n = e.cyclicKeying ? 'cyclic' : 'acyclic'; return { uid: e.uid, dom: { tag: 'div', classes: ['tox-toolbar-overlord'] }, parts: { 'overflow-group': wL({ title: x.none(), items: [] }), 'overflow-button': xB({ name: 'more', icon: x.some('more-drawer'), disabled: !1, tooltip: x.some('More...'), primary: !1, borderless: !1 }, x.none(), e.backstage.shared.providers) }, splitToolbarBehaviours: CL(e, n, t) } }; const kL = function (e) { const t = SL(e, AI.getOverflow); const n = 4; const r = AI.parts().primary({ dom: { tag: 'div', classes: ['tox-toolbar__primary'] } }); return AI.sketch(m(m({}, t), { lazySink: e.getSink, getOverflowBounds () { const t = e.moreDrawerData.lazyHeader().element(); const r = Uc(t); const o = Bi(t); const i = Uc(o); const u = Math.max(o.dom().scrollHeight, i.height()); return Fc(r.x() + n, i.y(), r.width() - 2 * n, u) }, parts: m(m({}, t.parts), { overflow: { dom: { tag: 'div', classes: ['tox-toolbar__overflow'], attributes: e.attributes } } }), components: [r], markers: { overflowToggledClass: 'tox-tbtn--enabled' } })) }; const TL = function (e) { const t = fL.parts().primary({ dom: { tag: 'div', classes: ['tox-toolbar__primary'] } }); const n = fL.parts().overflow({ dom: { tag: 'div', classes: ['tox-toolbar__overflow'] } }); const r = SL(e, x.none); return fL.sketch(m(m({}, r), { components: [t, n], markers: { openClass: 'tox-toolbar__overflow--open', closedClass: 'tox-toolbar__overflow--closed', growingClass: 'tox-toolbar__overflow--growing', shrinkingClass: 'tox-toolbar__overflow--shrinking', overflowToggledClass: 'tox-tbtn--enabled' }, onOpened (e) { e.getSystem().broadcastOn([dL()], { type: 'opened' }) }, onClosed (e) { e.getSystem().broadcastOn([dL()], { type: 'closed' }) } })) }; const EL = function (e) { const t = e.cyclicKeying ? 'cyclic' : 'acyclic'; return oI.sketch({ uid: e.uid, dom: { tag: 'div', classes: ['tox-toolbar'].concat(e.type === $p.scrolling ? ['tox-toolbar--scrolling'] : []) }, components: [oI.parts().groups({})], toolbarBehaviours: CL(e, t, i(x.none())) }) }; const OL = [Rn('disabled', !1), Cn('tooltip'), Cn('icon'), Cn('text'), Bn('onSetup', function () { return n })]; const NL = _t([fn('type'), gn('onAction')].concat(OL)); const _L = function (e) { return $t('toolbarbutton', NL, e) }; const DL = [Cn('text'), Cn('tooltip'), Cn('icon'), gn('fetch'), Bn('onSetup', function () { return n })]; const AL = _t(h([fn('type')], DL)); const RL = function (e) { return $t('menubutton', AL, e) }; const BL = _t([fn('type'), Cn('tooltip'), Cn('icon'), Cn('text'), Sn('select'), gn('fetch'), Bn('onSetup', function () { return n }), An('presets', 'normal', ['normal', 'color', 'listpreview']), On('columns', 1), gn('onAction'), gn('onItemAction')]); const ML = function (e) { return $t('SplitButton', BL, e) }; const PL = [Rn('active', !1)].concat(OL); const zL = _t(PL.concat([fn('type'), gn('onAction')])); const IL = function (e) { return $t('ToggleButton', zL, e) }; const LL = _t([fn('type'), sn('items', At([Ft([fn('name'), bn('items', tn)]), tn]))].concat(OL)); const HL = function (e) { return $t('GroupToolbarButton', LL, e) }; const FL = [Bn('predicate', function () { return !1 }), An('scope', 'node', ['node', 'editor']), An('position', 'selection', ['node', 'selection', 'line'])]; const VL = OL.concat([On('type', 'contextformbutton'), On('primary', !1), gn('onAction'), In('original', u)]); const UL = PL.concat([On('type', 'contextformbutton'), On('primary', !1), gn('onAction'), In('original', u)]); const jL = OL.concat([On('type', 'contextformbutton')]); const WL = PL.concat([On('type', 'contextformtogglebutton')]); const qL = Jt('type', { contextformbutton: VL, contextformtogglebutton: UL }); const $L = _t([On('type', 'contextform'), Bn('initValue', function () { return '' }), Cn('label'), bn('commands', qL), wn('launch', Jt('type', { contextformbutton: jL, contextformtogglebutton: WL }))].concat(FL)); const GL = _t([On('type', 'contexttoolbar'), fn('items')].concat(FL)); const XL = function (e) { return $t('ContextToolbar', GL, e) }; const YL = function (e) { return $t('ContextForm', $L, e) }; const KL = function (e, t, n) { return n }; const JL = Object.freeze({ __proto__: null, getState: KL }); const ZL = function (e, t) { const n = function (n, r) { e.updateState.each(function (e) { const o = e(n, r); t.set(o) }), e.renderComponents.each(function (e) { const o = e(r, t.get()); const i = W(o, n.getSystem().build); Cm(n, i) }) }; return ai([fi(Bo(), function (t, r) { const o = r; const i = e.channel; F(o.channels(), i) && n(t, o.data()) }), xi(function (t, r) { e.initialData.each(function (e) { n(t, e) }) })]) }; const QL = Object.freeze({ __proto__: null, events: ZL }); const eH = function () { const e = Ln(x.none()); const t = function (t) { return e.set(t) }; const n = function () { return e.set(x.none()) }; const r = function () { return e.get() }; const o = function () { return e.get().fold(function () { return 'none' }, function (e) { return e }) }; return { readState: o, get: r, set: t, clear: n } }; const tH = Object.freeze({ __proto__: null, init: eH }); const nH = [cn('channel'), yn('renderComponents'), yn('updateState'), yn('initialData')]; const rH = xl({ fields: nH, name: 'reflecting', active: QL, apis: JL, state: tH }); const oH = i([cn('toggleClass'), cn('fetch'), Ss('onExecute'), On('getHotspot', x.some), On('getAnchorOverrides', i({})), Ef(), Ss('onItemExecute'), yn('lazySink'), cn('dom'), xs('onOpen'), Mg('splitDropdownBehaviours', [FO, Kb, vy]), On('matchWidth', !1), On('useMinWidth', !1), On('eventOrder', {}), yn('role')].concat(eN())); const iH = dh({ factory: fx, schema: [cn('dom')], name: 'arrow', defaults () { return { buttonBehaviours: yl([vy.revoke()]) } }, overrides (e) { return { dom: { tag: 'span', attributes: { role: 'presentation' } }, action (t) { t.getSystem().getByUid(e.uid).each(ri) }, buttonBehaviours: yl([zy.config({ toggleOnExecute: !1, toggleClass: e.toggleClass })]) } } }); const uH = dh({ factory: fx, schema: [cn('dom')], name: 'button', defaults () { return { buttonBehaviours: yl([vy.revoke()]) } }, overrides (e) { return { dom: { tag: 'span', attributes: { role: 'presentation' } }, action (t) { t.getSystem().getByUid(e.uid).each(function (n) { e.onExecute(n, t) }) } } } }); const aH = i([iH, uH, gh({ factory: { sketch (e) { return { uid: e.uid, dom: { tag: 'span', styles: { display: 'none' }, attributes: { 'aria-hidden': 'true' }, innerHtml: e.text } } } }, schema: [cn('text')], name: 'aria-descriptor' }), mh({ schema: [bs()], name: 'menu', defaults (e) { return { onExecute (t, n) { t.getSystem().getByUid(e.uid).each(function (r) { e.onItemExecute(r, t, n) }) } } } }), UO()]); const cH = function (e, t, r, o) { const i = function (e) { np.getCurrent(e).each(function (e) { Cp.highlightFirst(e), Kb.focusIn(e) }) }; const u = function (t) { const r = i; XO(e, function (e) { return e }, t, o, r, rO.HighlightFirst).get(n) }; const a = function (e) { return u(e), x.some(!0) }; const c = function (t) { const n = Nh(t, e, 'button'); return ri(n), x.some(!0) }; const s = m(m({}, ai([xi(function (t, n) { const r = Oh(t, e, 'aria-descriptor'); r.each(function (e) { const n = xu('aria'); au(e.element(), 'id', n), au(t.element(), 'aria-describedby', n) }) })])), Ly(x.some(u))); const l = { repositionMenus (e) { zy.isOn(e) && QO(e) } }; return { uid: e.uid, dom: e.dom, components: t, apis: l, eventOrder: m(m({}, e.eventOrder), { 'alloy.execute': ['disabling', 'toggling', 'alloy.base.behaviour'] }), events: s, behaviours: zg(e.splitDropdownBehaviours, [FO.config({ others: { sandbox (t) { const n = Nh(t, e, 'arrow'); const r = { onOpen () { zy.on(n), zy.on(t) }, onClose () { zy.off(n), zy.off(t) } }; return ZO(e, t, r) } } }), Kb.config({ mode: 'special', onSpace: c, onEnter: c, onDown: a }), vy.config({}), zy.config({ toggleOnExecute: !1, aria: { mode: 'expanded' } })]), domModification: { attributes: { role: e.role.getOr('button'), 'aria-haspopup': !0 } } } }; const sH = Gh({ name: 'SplitDropdown', configFields: oH(), partFields: aH(), factory: cH, apis: { repositionMenus (e, t) { return e.repositionMenus(t) } } }); const lH = function (e) { return { isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const fH = function (e) { return { setActive (t) { zy.set(e, t) }, isActive () { return zy.isOn(e) }, isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) } } }; const dH = function (e, t) { return e.map(function (e) { return { 'aria-label': t.translate(e), title: t.translate(e) } }).getOr({}) }; const mH = xu('focus-button'); const gH = ['checklist', 'ordered-list']; const hH = ['indent', 'outdent', 'table-insert-column-after', 'table-insert-column-before', 'unordered-list']; const pH = function (e, t, n, r, o, i) { let u; const a = function (e) { return BC.isRtl() && F(gH, e) ? e + '-rtl' : e }; const c = BC.isRtl() && e.exists(function (e) { return F(hH, e) }); return { dom: { tag: 'button', classes: ['tox-tbtn'].concat(t.isSome() ? ['tox-tbtn--select'] : []).concat(c ? ['tox-tbtn__icon-rtl'] : []), attributes: dH(n, i) }, components: FS([e.map(function (e) { return ZR(a(e), i.icons) }), t.map(function (e) { return eB(e, 'tox-tbtn', i) })]), eventOrder: (u = {}, u[ho()] = ['focusing', 'alloy.base.behaviour', 'common-button-display-events'], u), buttonBehaviours: yl([cy('common-button-display-events', [fi(ho(), function (e, t) { t.event().prevent(), ti(e, mH) })])].concat(r.map(function (n) { return rH.config({ channel: n, initialData: { icon: e, text: t }, renderComponents (e, t) { return FS([e.icon.map(function (e) { return ZR(a(e), i.icons) }), e.text.map(function (e) { return eB(e, 'tox-tbtn', i) })]) } }) }).toArray()).concat(o.getOr([]))) } }; const vH = function (e, t, n, r) { const o = t.shared; return OI.sketch({ lazySink: o.getSink, fetch () { return dO.nu(function (t) { t(W(n(e.items), xL)) }) }, markers: { toggledClass: 'tox-tbtn--enabled' }, parts: { button: pH(e.icon, e.text, e.tooltip, x.none(), x.none(), o.providers), toolbar: { dom: { tag: 'div', classes: ['tox-toolbar__overflow'], attributes: r } } } }) }; const bH = function (e, t, r) { const o = Ln(n); const i = pH(e.icon, e.text, e.tooltip, x.none(), x.none(), r); return fx.sketch({ dom: i.dom, components: i.components, eventOrder: rB, buttonBehaviours: yl([cy('toolbar-button-events', [nB({ onAction: e.onAction, getApi: t.getApi }), PS(t, o), zS(t, o)]), BS.toolbarButton(e.disabled)].concat(t.toolbarButtonBehaviours)) }) }; const yH = function (e, t) { return wH(e, t, []) }; var wH = function (e, t, n) { return bH(e, { toolbarButtonBehaviours: [].concat(n.length > 0 ? [cy('toolbarButtonWith', n)] : []), getApi: lH, onSetup: e.onSetup }, t) }; const xH = function (e, t) { return CH(e, t, []) }; var CH = function (e, t, n) { return Ne(bH(e, { toolbarButtonBehaviours: [uy.config({}), zy.config({ toggleClass: 'tox-tbtn--enabled', aria: { mode: 'pressed' }, toggleOnExecute: !1 })].concat(n.length > 0 ? [cy('toolbarToggleButtonWith', n)] : []), getApi: fH, onSetup: e.onSetup }, t)) }; const SH = function (e, t, n) { return function (r) { return dO.nu(function (e) { return t.fetch(e) }).map(function (o) { return x.from(KT(Ne(ET(xu('menu-value'), o, function (n) { t.onItemAction(e(r), n) }, t.columns, t.presets, IS.CLOSE_ON_EXECUTE, t.select.getOr(function () { return !1 }), n), { movement: NT(t.columns, t.presets), menuBehaviours: wC.unnamedEvents(t.columns !== 'auto' ? [] : [xi(function (e, n) { vC(e, 4, GC(t.presets)).each(function (t) { const n = t.numRows; const r = t.numColumns; Kb.setGridSize(e, n, r) }) })]) }))) }) } }; const kH = function (e, t) { let r; const o = xu('channel-update-split-dropdown-display'); const i = function (e) { return { isDisabled () { return NS.isDisabled(e) }, setDisabled (t) { return NS.set(e, t) }, setIconFill (t, n) { Jc(e.element(), 'svg path[id="' + t + '"], rect[id="' + t + '"]').each(function (e) { au(e, 'fill', n) }) }, setIconStroke (t, n) { Jc(e.element(), 'svg path[id="' + t + '"], rect[id="' + t + '"]').each(function (e) { au(e, 'stroke', n) }) }, setActive (t) { au(e.element(), 'aria-pressed', t), Jc(e.element(), 'span').each(function (n) { e.getSystem().getByDom(n).each(function (e) { return zy.set(e, t) }) }) }, isActive () { return Jc(e.element(), 'span').exists(function (t) { return e.getSystem().getByDom(t).exists(zy.isOn) }) } } }; const u = Ln(n); const a = { getApi: i, onSetup: e.onSetup }; return sH.sketch({ dom: { tag: 'div', classes: ['tox-split-button'], attributes: m({ 'aria-pressed': !1 }, dH(e.tooltip, t.providers)) }, onExecute (t) { e.onAction(i(t)) }, onItemExecute (e, t, n) {}, splitDropdownBehaviours: yl([BS.splitButton(!1), cy('split-dropdown-events', [fi(mH, vy.focus), PS(a, u), zS(a, u)]), cN.config({})]), eventOrder: (r = {}, r[qo()] = ['alloy.base.behaviour', 'split-dropdown-events'], r), toggleClass: 'tox-tbtn--enabled', lazySink: t.getSink, fetch: SH(i, e, t.providers), parts: { menu: gT(!1, e.columns, e.presets) }, components: [sH.parts().button(pH(e.icon, e.text, x.none(), x.some(o), x.some([zy.config({ toggleClass: 'tox-tbtn--enabled', toggleOnExecute: !1 })]), t.providers)), sH.parts().arrow({ dom: { tag: 'button', classes: ['tox-tbtn', 'tox-split-button__chevron'], innerHtml: gx('chevron-down', t.providers.icons) } }), sH.parts()['aria-descriptor']({ text: t.providers.translate('To open the popup, press Shift+Enter') })] }) }; const TH = function (e) { return { hide () { return ti(e, Lo()) }, getValue () { return Bg.getValue(e) } } }; const EH = function (e, t) { return fi(tB, function (n, r) { const o = e.get(n); const i = TH(o); t.onAction(i, r.event().buttonApi()) }) }; const OH = function (e, t, n) { const r = t.original; const o = (r.primary, g(r, ['primary'])); const i = Gt(_L(m(m({}, o), { type: 'button', onAction () {} }))); return wH(i, n.backstage.shared.providers, [EH(e, t)]) }; const NH = function (e, t, n) { const r = t.original; const o = (r.primary, g(r, ['primary'])); const i = Gt(IL(m(m({}, o), { type: 'togglebutton', onAction () {} }))); return CH(i, n.backstage.shared.providers, [EH(e, t)]) }; const _H = function (e, t, n) { const r = { backstage: { shared: { providers: n } } }; return t.type === 'contextformtogglebutton' ? NH(e, t, r) : OH(e, t, r) }; const DH = function (e, t, n) { const r = W(t, function (t) { return dx(_H(e, t, n)) }); const o = function () { return W(r, function (e) { return e.asSpec() }) }; const i = function (e) { return le(t, function (t, n) { return t.primary ? x.from(r[n]).bind(function (t) { return t.getOpt(e) }).filter(c(NS.isDisabled)) : x.none() }) }; return { asSpecs: o, findPrimary: i } }; const AH = function (e, t, n) { const r = t.label.fold(function () { return {} }, function (e) { return { 'aria-label': e } }); const o = dx(eO.sketch({ inputClasses: ['tox-toolbar-textfield', 'tox-toolbar-nav-js'], data: t.initValue(), inputAttributes: r, selectOnFocus: !0, inputBehaviours: yl([Kb.config({ mode: 'special', onEnter (e) { return i.findPrimary(e).map(function (e) { return ri(e), !0 }) }, onLeft (e, t) { return t.cut(), x.none() }, onRight (e, t) { return t.cut(), x.none() } })]) })); var i = DH(o, t.commands, n.shared.providers); return EL({ type: e, uid: xu('context-toolbar'), initGroups: [{ title: x.none(), items: [o.asSpec()] }, { title: x.none(), items: i.asSpecs() }], onEscape: x.none, cyclicKeying: !0 }) }; const RH = { renderContextForm: AH }; const BH = function (e, t) { const n = Math.max(t.x(), e.x()); const r = e.right() - n; const o = t.width() - (n - t.x()); const i = Math.min(r, o); return { x: n, width: i } }; const MH = function (e, t, n) { const r = Wn.fromDom(e.getContainer()); const o = Jc(r, '.tox-editor-header').getOr(r); const i = Vc(o); const u = i.y() >= t.bottom(); const a = nx(e); const c = a && !u; if (e.inline && c) { return { y: Math.max(i.bottom(), n.y()), bottom: n.bottom() } } if (e.inline && !c) { return { y: n.y(), bottom: Math.min(i.y(), n.bottom()) } } const s = Vc(r); return c ? { y: Math.max(i.bottom(), n.y()), bottom: Math.min(s.bottom(), n.bottom()) } : { y: Math.max(s.y(), n.y()), bottom: Math.min(i.y(), n.bottom()) } }; const PH = function (e) { const n = Ac(t.window); const r = Vc(Wn.fromDom(e.getContentAreaContainer())); const o = Yw(e) || Kw(e) || Zw(e); const i = BH(r, n); const u = i.x; const a = i.width; if (e.inline && !o) { return Fc(u, n.y(), a, n.height()) } const c = MH(e, r, n); const s = c.y; const l = c.bottom; return Fc(u, s, a, l - s) }; const zH = function (e, t) { return le(t, function (t) { return t.predicate(e.dom()) ? x.some({ toolbarApi: t, elem: e }) : x.none() }) }; const IH = function (e, t) { const n = Wn.fromDom(t.getBody()); const r = function (e) { return Jr(e, n) }; const o = function (e) { return !r(e) && !to(n, e) }; const i = Wn.fromDom(t.selection.getNode()); return o(i) ? x.none() : zH(i, e.inNodeScope).orThunk(function () { return zH(i, e.inEditorScope).orThunk(function () { return r(i) ? x.none() : no(i, function (t) { return zH(t, e.inNodeScope) }, r) }) }) }; const LH = { lookup: IH }; const HH = function (e, t) { const n = {}; const r = []; const o = []; const i = {}; const u = {}; const a = function (e, a) { const c = Gt(YL(a)); n[e] = c, c.launch.map(function (n) { i['form:' + e] = m(m({}, a.launch), { type: n.type === 'contextformtogglebutton' ? 'togglebutton' : 'button', onAction () { t(c) } }) }), c.scope === 'editor' ? o.push(c) : r.push(c), u[e] = c }; const c = function (e, t) { XL(t).each(function (n) { t.scope === 'editor' ? o.push(n) : r.push(n), u[e] = n }) }; const s = fe(e); return q(s, function (t) { const n = e[t]; n.type === 'contextform' ? a(t, n) : n.type === 'contexttoolbar' && c(t, n) }), { forms: n, inNodeScope: r, inEditorScope: o, lookupTable: u, formNavigators: i } }; const FH = { categorise: HH }; const VH = xu('forward-slide'); const UH = xu('backward-slide'); const jH = xu('change-slide-event'); const WH = 'tox-pop--resizing'; const qH = function (e) { const t = Ln([]); return Cw.sketch({ dom: { tag: 'div', classes: ['tox-pop'] }, fireDismissalEventInstead: { event: 'doNotDismissYet' }, onShow (e) { t.set([]), Cw.getContent(e).each(function (e) { Fa(e.element(), 'visibility') }), Ca(e.element(), WH), Fa(e.element(), 'width') }, inlineBehaviours: yl([cy('context-toolbar-events', [wi(Oo(), function (e, t) { Cw.getContent(e).each(function (e) {}), Ca(e.element(), WH), Fa(e.element(), 'width') }), fi(jH, function (e, t) { Fa(e.element(), 'width'); const n = vc(e.element()); Cw.setContent(e, t.event().contents()), wa(e.element(), WH); const r = vc(e.element()); Ra(e.element(), 'width', n + 'px'), Cw.getContent(e).each(function (n) { t.event().focus().bind(function (t) { return Rl(t), zl(e.element()) }).orThunk(function () { return Kb.focusIn(n), Pl() }) }), Mw.setTimeout(function () { Ra(e.element(), 'width', r + 'px') }, 0) }), fi(VH, function (e, n) { Cw.getContent(e).each(function (e) { t.set(t.get().concat([{ bar: e, focus: Pl() }])) }), ni(e, jH, { contents: n.event().forwardContents(), focus: x.none() }) }), fi(UH, function (e, n) { ce(t.get()).each(function (n) { t.set(t.get().slice(0, t.get().length - 1)), ni(e, jH, { contents: rc(n.bar), focus: n.focus }) }) })]), Kb.config({ mode: 'special', onEscape (n) { return ce(t.get()).fold(function () { return e.onEscape() }, function (e) { return ti(n, UH), x.some(!0) }) } })]), lazySink () { return T.value(e.sink) } }) }; const $H = function (e, t, n) { const r = function (e, r, i, u) { const a = t.shared.providers.translate(e.title); if (e.type === 'separator') { return x.some({ type: 'separator', text: a }) } if (e.type === 'submenu') { const c = ee(e.getStyleItems(), function (e) { return o(e, r, u) }); return r === 0 && c.length <= 0 ? x.none() : x.some({ type: 'nestedmenuitem', text: a, disabled: c.length <= 0, getSubmenuItems () { return ee(e.getStyleItems(), function (e) { return o(e, r, u) }) } }) } return x.some(m({ type: 'togglemenuitem', text: a, active: e.isSelected(u), disabled: i, onAction: n.onAction(e) }, e.getStylePreview().fold(function () { return {} }, function (e) { return { meta: { style: e } } }))) }; var o = function (e, t, o) { const i = e.type === 'formatter' && n.isInvalid(e); return t === 0 ? i ? [] : r(e, t, !1, o).toArray() : r(e, t, i, o).toArray() }; const i = function (e) { const t = n.getCurrentValue(); const r = n.shouldHide ? 0 : 1; return ee(e, function (e) { return o(e, r, t) }) }; const u = function (e, t) { return function (n) { const r = t(); const o = i(r); const u = pB(o, IS.CLOSE_ON_EXECUTE, e, !1); n(u) } }; return { validateItems: i, getFetch: u } }; const GH = function (e, t, n) { const r = n.dataset; const o = r.type === 'basic' ? function () { return W(r.data, function (e) { return QP(e, n.isSelectedFor, n.getPreviewFor) }) } : r.getData; return { items: $H(e, t, n), getStyleItems: o } }; const XH = function (e, t, r) { const o = GH(e, t, r); const i = o.items; const u = o.getStyleItems; const a = function (e) { return { getComponent () { return e } } }; const c = function (t) { return r.setInitialValue.each(function (e) { return e(t.getComponent()) }), r.nodeChangeHandler.map(function (n) { const r = n(t.getComponent()); return e.on('NodeChange', r), function () { e.off('NodeChange', r) } }).getOr(n) }; return uB({ text: r.icon.isSome() ? x.none() : x.some(''), icon: r.icon, tooltip: x.from(r.tooltip), role: x.none(), fetch: i.getFetch(t, u), onSetup: c, getApi: a, columns: 1, presets: 'normal', classes: r.icon.isSome() ? [] : ['bespoke'], dropdownBehaviours: [] }, 'tox-tbtn', t.shared) }; const YH = function (e) { return W(e, function (e) { let t = e; let n = e; const r = e.split('='); return r.length > 1 && (t = r[0], n = r[1]), { title: t, format: n } }) }; const KH = function (e) { return { type: 'basic', data: e } }; (function (e) { e[e.SemiColon = 0] = 'SemiColon', e[e.Space = 1] = 'Space' })(xM || (xM = {})); let JH; const ZH = function (e, t) { return t === xM.SemiColon ? e.replace(/;$/, '').split(';') : e.split(' ') }; const QH = function (e, t, n, r) { const o = ye(e.settings, t).getOr(n); const i = YH(ZH(o, r)); return { type: 'basic', data: i } }; const eF = [{ title: 'Left', icon: 'align-left', format: 'alignleft', command: 'JustifyLeft' }, { title: 'Center', icon: 'align-center', format: 'aligncenter', command: 'JustifyCenter' }, { title: 'Right', icon: 'align-right', format: 'alignright', command: 'JustifyRight' }, { title: 'Justify', icon: 'align-justify', format: 'alignjustify', command: 'JustifyFull' }]; const tF = function (e) { const t = function () { return J(eF, function (t) { return e.formatter.match(t.format) }) }; const n = function (t) { return function () { return e.formatter.match(t) } }; const r = function (e) { return function () { return x.none() } }; const o = function (e) { const n = t(); const r = n.fold(function () { return 'left' }, function (e) { return e.title.toLowerCase() }); ni(e, iB, { icon: 'align-' + r }) }; const u = x.some(function (e) { return function () { return o(e) } }); const a = x.some(function (e) { return o(e) }); const c = KH(eF); const s = function (t) { return function () { return J(eF, function (e) { return e.format === t.format }).each(function (t) { return e.execCommand(t.command) }) } }; return { tooltip: 'Align', icon: x.some('align-left'), isSelectedFor: n, getCurrentValue: i(x.none()), getPreviewFor: r, onAction: s, setInitialValue: a, nodeChangeHandler: u, dataset: c, shouldHide: !1, isInvalid (t) { return !e.formatter.canApply(t.format) } } }; const nF = function (e, t) { return XH(e, t, tF(e)) }; const rF = function (e, t) { const n = GH(e, t, tF(e)); e.ui.registry.addNestedMenuItem('align', { text: t.shared.providers.translate('Align'), getSubmenuItems () { return n.items.validateItems(n.getStyleItems()) } }) }; const oF = 'Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats'; const iF = ['-apple-system', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'sans-serif']; const uF = function (e) { const t = e.split(/\s*,\s*/); return W(t, function (e) { return e.replace(/^['"]+|['"]+$/g, '') }) }; const aF = function (e) { const t = function () { const t = uF(e.toLowerCase()); return te(iF, function (e) { return t.includes(e.toLowerCase()) }) }; return e.indexOf('-apple-system') === 0 && t() }; const cF = function (e) { const t = function () { const t = function (e) { return e ? uF(e)[0] : '' }; const n = e.queryCommandValue('FontName'); const r = s.data; const o = n ? n.toLowerCase() : ''; const i = J(r, function (e) { const n = e.format; return n.toLowerCase() === o || t(n).toLowerCase() === t(o).toLowerCase() }).orThunk(function () { return aF(o) ? x.from({ title: 'System Font', format: o }) : x.none() }); return { matchOpt: i, font: n } }; const n = function (e) { return function (t) { return t.exists(function (t) { return t.format === e }) } }; const r = function () { const e = t().matchOpt; return e }; const o = function (e) { return function () { return x.some({ tag: 'div', styles: !e.includes('dings') ? { 'font-family': e } : {} }) } }; const i = function (t) { return function () { e.undoManager.transact(function () { e.focus(), e.execCommand('FontName', !1, t.format) }) } }; const u = function (e) { const n = t(); const r = n.matchOpt; const o = n.font; const i = r.fold(function () { return o }, function (e) { return e.title }); ni(e, oB, { text: i }) }; const a = x.some(function (e) { return function () { return u(e) } }); const c = x.some(function (e) { return u(e) }); var s = QH(e, 'font_formats', oF, xM.SemiColon); return { tooltip: 'Fonts', icon: x.none(), isSelectedFor: n, getCurrentValue: r, getPreviewFor: o, onAction: i, setInitialValue: c, nodeChangeHandler: a, dataset: s, shouldHide: !1, isInvalid () { return !1 } } }; const sF = function (e, t) { return XH(e, t, cF(e)) }; const lF = function (e, t) { const n = GH(e, t, cF(e)); e.ui.registry.addNestedMenuItem('fontformats', { text: t.shared.providers.translate('Fonts'), getSubmenuItems () { return n.items.validateItems(n.getStyleItems()) } }) }; const fF = '8pt 10pt 12pt 14pt 18pt 24pt 36pt'; const dF = { '8pt': '1', '10pt': '2', '12pt': '3', '14pt': '4', '18pt': '5', '24pt': '6', '36pt': '7' }; const mF = function (e, t) { const n = Math.pow(10, t); return Math.round(e * n) / n }; const gF = function (e, t) { return /[0-9.]+px$/.test(e) ? mF(72 * parseInt(e, 10) / 96, t || 0) + 'pt' : e }; const hF = function (e) { return ye(dF, e).getOr('') }; const pF = function (e) { const t = function () { let t = x.none(); const n = l.data; const r = e.queryCommandValue('FontSize'); if (r) { for (let o = function (e) { const o = gF(r, e); const i = hF(o); t = J(n, function (e) { return e.format === r || e.format === o || e.format === i }) }, i = 3; t.isNone() && i >= 0; i--) { o(i) } } return { matchOpt: t, size: r } }; const n = function (e) { return function (t) { return t.exists(function (t) { return t.format === e }) } }; const r = function () { const e = t().matchOpt; return e }; const o = i(i(x.none())); const u = function (t) { return function () { e.undoManager.transact(function () { e.focus(), e.execCommand('FontSize', !1, t.format) }) } }; const a = function (e) { const n = t(); const r = n.matchOpt; const o = n.size; const i = r.fold(function () { return o }, function (e) { return e.title }); ni(e, oB, { text: i }) }; const c = x.some(function (e) { return function () { return a(e) } }); const s = x.some(function (e) { return a(e) }); var l = QH(e, 'fontsize_formats', fF, xM.Space); return { tooltip: 'Font sizes', icon: x.none(), isSelectedFor: n, getPreviewFor: o, getCurrentValue: r, onAction: u, setInitialValue: s, nodeChangeHandler: c, dataset: l, shouldHide: !1, isInvalid () { return !1 } } }; const vF = function (e, t) { return XH(e, t, pF(e)) }; const bF = function (e, t) { const n = GH(e, t, pF(e)); e.ui.registry.addNestedMenuItem('fontsizes', { text: 'Font sizes', getSubmenuItems () { return n.items.validateItems(n.getStyleItems()) } }) }; const yF = function (e, t, n) { const r = t(); return le(n, function (t) { return J(r, function (n) { return e.formatter.matchNode(t, n.format) }) }).orThunk(function () { return e.formatter.match('p') ? x.some({ title: 'Paragraph', format: 'p' }) : x.none() }) }; const wF = function (e) { const t = e.selection.getStart(!0) || e.getBody(); return e.dom.getParents(t, function () { return !0 }, e.getBody()) }; const xF = function (e, t) { return function (n) { const r = Ln(x.none()); const o = function () { n.setActive(e.formatter.match(t)); const o = e.formatter.formatChanged(t, n.setActive).unbind; r.set(x.some(o)) }; return e.initialized ? o() : e.on('init', o), function () { return r.get().each(function (e) { return e() }) } } }; const CF = function (e) { return function (t) { return function () { e.undoManager.transact(function () { e.focus(), e.execCommand('mceToggleFormat', !1, t.format) }) } } }; const SF = 'Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre'; const kF = function (e) { const t = function (t) { return yF(e, function () { return c.data }, t) }; const n = function (t) { return function () { return e.formatter.match(t) } }; const r = function (t) { return function () { const n = e.formatter.get(t); return x.some({ tag: n.length > 0 && (n[0].inline || n[0].block) || 'div', styles: e.dom.parseStyle(e.formatter.getCssText(t)) }) } }; const o = function (e, n) { const r = t(e); const o = r.fold(function () { return 'Paragraph' }, function (e) { return e.title }); ni(n, oB, { text: o }) }; const u = x.some(function (e) { return function (t) { return o(t.parents, e) } }); const a = x.some(function (t) { const n = wF(e); o(n, t) }); var c = QH(e, 'block_formats', SF, xM.SemiColon); return { tooltip: 'Blocks', icon: x.none(), isSelectedFor: n, getCurrentValue: i(x.none()), getPreviewFor: r, onAction: CF(e), setInitialValue: a, nodeChangeHandler: u, dataset: c, shouldHide: !1, isInvalid (t) { return !e.formatter.canApply(t.format) } } }; const TF = function (e, t) { return XH(e, t, kF(e)) }; const EF = function (e, t) { const n = GH(e, t, kF(e)); e.ui.registry.addNestedMenuItem('blockformats', { text: 'Blocks', getSubmenuItems () { return n.items.validateItems(n.getStyleItems()) } }) }; const OF = function (e, t) { const n = function (t) { return function () { return e.formatter.match(t) } }; const r = function (t) { return function () { const n = e.formatter.get(t); return void 0 !== n ? x.some({ tag: n.length > 0 && (n[0].inline || n[0].block) || 'div', styles: e.dom.parseStyle(e.formatter.getCssText(t)) }) : x.none() } }; const o = function (t, n) { var r = function (e) { const t = e.items; return void 0 !== t && t.length > 0 ? ee(t, r) : [{ title: e.title, format: e.format }] }; const o = ee(ZP(e), r); const i = yF(e, function () { return o }, t); const u = i.fold(function () { return 'Paragraph' }, function (e) { return e.title }); ni(n, oB, { text: u }) }; const u = x.some(function (e) { return function (t) { return o(t.parents, e) } }); const a = x.some(function (t) { const n = wF(e); o(n, t) }); return { tooltip: 'Formats', icon: x.none(), isSelectedFor: n, getCurrentValue: i(x.none()), getPreviewFor: r, onAction: CF(e), setInitialValue: a, nodeChangeHandler: u, shouldHide: e.getParam('style_formats_autohide', !1, 'boolean'), isInvalid (t) { return !e.formatter.canApply(t.format) }, dataset: t } }; const NF = function (e, t) { const n = m({ type: 'advanced' }, t.styleselect); return XH(e, t, OF(e, n)) }; const _F = function (e, t) { const n = m({ type: 'advanced' }, t.styleselect); const r = GH(e, t, OF(e, n)); e.ui.registry.addNestedMenuItem('formats', { text: 'Formats', getSubmenuItems () { return r.items.validateItems(r.getStyleItems()) } }) }; const DF = [{ name: 'history', items: ['undo', 'redo'] }, { name: 'styles', items: ['styleselect'] }, { name: 'formatting', items: ['bold', 'italic'] }, { name: 'alignment', items: ['alignleft', 'aligncenter', 'alignright', 'alignjustify'] }, { name: 'indentation', items: ['outdent', 'indent'] }, { name: 'permanent pen', items: ['permanentpen'] }, { name: 'comments', items: ['addcomment'] }]; const AF = function (e, t) { return function (n, r, o) { const i = e(n).mapError(function (e) { return Yt(e) }).getOrDie(); return t(i, r, o) } }; const RF = { button: AF(_L, function (e, t) { return yH(e, t.backstage.shared.providers) }), togglebutton: AF(IL, function (e, t) { return xH(e, t.backstage.shared.providers) }), menubutton: AF(RL, function (e, t) { return bB(e, 'tox-tbtn', t.backstage, x.none()) }), splitbutton: AF(ML, function (e, t) { return kH(e, t.backstage.shared) }), grouptoolbarbutton: AF(HL, function (e, t, n) { let r; const o = n.ui.registry.getAll().buttons; const i = function (e) { return FF(n, { buttons: o, toolbar: e, allowToolbarGroups: !1 }, t, x.none()) }; const u = (r = {}, r[kf] = nx(n) ? os.TopToBottom : os.BottomToTop, r); switch (ex(n)) { case $p.floating:return vH(e, t.backstage, i, u); default:throw new Error('Toolbar groups are only supported when using floating toolbar mode') } }), styleSelectButton (e, t) { return NF(e, t.backstage) }, fontsizeSelectButton (e, t) { return vF(e, t.backstage) }, fontSelectButton (e, t) { return sF(e, t.backstage) }, formatButton (e, t) { return TF(e, t.backstage) }, alignMenuButton (e, t) { return nF(e, t.backstage) } }; const BF = function (e, n, r) { return ye(RF, e.type).fold(function () { return t.console.error('skipping button defined by', e), x.none() }, function (t) { return x.some(t(e, n, r)) }) }; const MF = { styleselect: RF.styleSelectButton, fontsizeselect: RF.fontsizeSelectButton, fontselect: RF.fontSelectButton, formatselect: RF.formatButton, align: RF.alignMenuButton }; const PF = function (e) { const t = W(DF, function (t) { const n = X(t.items, function (t) { return we(e, t) || we(MF, t) }); return { name: t.name, items: n } }); return X(t, function (e) { return e.items.length > 0 }) }; const zF = function (e) { const t = e.split('|'); return W(t, function (e) { return { items: e.trim().split(' ') } }) }; const IF = function (e) { return M(e, function (e) { return we(e, 'name') && we(e, 'items') }) }; const LF = function (e) { const n = e.toolbar; const r = e.buttons; return !1 === n ? [] : void 0 === n || !0 === n ? PF(r) : N(n) ? zF(n) : IF(n) ? n : (t.console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]'), []) }; const HF = function (e, n, r, o, i, u) { return ye(n, r.toLowerCase()).orThunk(function () { return u.bind(function (e) { return le(e, function (e) { return ye(n, e + r.toLowerCase()) }) }) }).fold(function () { return ye(MF, r.toLowerCase()).map(function (t) { return t(e, i) }).orThunk(function () { return x.none() }) }, function (n) { return n.type !== 'grouptoolbarbutton' || o ? BF(n, i, e) : (t.console.warn("Ignoring the '" + r + "' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested."), x.none()) }) }; var FF = function (e, t, n, r) { const o = LF(t); const i = W(o, function (o) { const i = ee(o.items, function (o) { return o.trim().length === 0 ? [] : HF(e, t.buttons, o, t.allowToolbarGroups, n, r).toArray() }); return { title: x.from(e.translate(o.name)), items: i } }); return X(i, function (e) { return e.items.length > 0 }) }; const VF = 12; const UF = { valignCentre: [], alignCentre: [], alignLeft: ['tox-pop--align-left'], alignRight: ['tox-pop--align-right'], right: ['tox-pop--right'], left: ['tox-pop--left'], bottom: ['tox-pop--bottom'], top: ['tox-pop--top'] }; const jF = { maxHeightFunction: mf(), maxWidthFunction: Gz() }; const WF = { onLtr () { return [nl, rl, el, Zs, tl, Qs, Rw, Bw, Dw, Nw, Aw, _w] }, onRtl () { return [nl, rl, tl, Qs, el, Zs, Rw, Bw, Aw, _w, Dw, Nw] } }; const qF = { onLtr () { return [rl, Zs, Qs, el, tl, nl, Rw, Bw, Dw, Nw, Aw, _w] }, onRtl () { return [rl, Qs, Zs, tl, el, nl, Rw, Bw, Aw, _w, Dw, Nw] } }; const $F = function (e, t) { return e === 'line' ? { bubble: yf(VF, 0, UF), layouts: { onLtr () { return [ol] }, onRtl () { return [il] } }, overrides: jF } : { bubble: yf(0, VF, UF), layouts: t ? qF : WF, overrides: jF } }; const GF = function (e, t, n, r) { const o = Vr().deviceType.isTouch; const i = nc(qH({ sink: n, onEscape () { return e.focus(), x.some(!0) } })); const u = function () { return PH(e) }; const a = function (e, t, n, r) { return Math.max(e, n) <= Math.min(t, r) }; const c = function () { const t = g.get().map(function (e) { return e.getBoundingClientRect() }).getOrThunk(function () { return e.selection.getRng().getBoundingClientRect() }); const n = e.inline ? Oc().top() : Uc(Wn.fromDom(e.getBody())).y(); return { y: t.top + n, bottom: t.bottom + n } }; const s = function () { if (o() && r.backstage.isContextMenuOpen()) { return !0 } const e = c(); const t = u(); return !a(e.y, e.bottom, t.y(), t.bottom()) }; const l = function () { Cw.hide(i) }; const f = function () { d.get().each(function (e) { const t = i.element(); Fa(t, 'display'), s() ? Ra(t, 'display', 'none') : vm.positionWithinBounds(n, e, i, x.some(u())) }) }; var d = Ln(x.none()); var g = Ln(x.none()); const h = Ln(null); const p = function (t) { return { dom: { tag: 'div', classes: ['tox-pop__dialog'] }, components: [t], behaviours: yl([Kb.config({ mode: 'acyclic' }), cy('pop-dialog-wrap-events', [xi(function (t) { e.shortcuts.add('ctrl+F9', 'focus statusbar', function () { return Kb.focusIn(t) }) }), Ci(function (t) { e.shortcuts.remove('ctrl+F9') })])]) } }; const v = De(function () { return FH.categorise(t, function (e) { const t = b(e); ni(i, VH, { forwardContents: p(t) }) }) }); var b = function (t) { const n = e.ui.registry.getAll().buttons; const o = ex(e) === $p.scrolling ? $p.scrolling : $p.default; const i = v(); return t.type === 'contexttoolbar' ? (function () { const u = m(m({}, n), i.formNavigators); const a = FF(e, { buttons: u, toolbar: t.items, allowToolbarGroups: !1 }, r, x.some(['form:'])); return EL({ type: o, uid: xu('context-toolbar'), initGroups: a, onEscape: x.none, cyclicKeying: !0 }) }()) : (function () { return RH.renderContextForm(o, t, r.backstage) }()) }; e.on(Xz, function (t) { const n = v(); ye(n.lookupTable, t.toolbarKey).each(function (n) { w(n, t.target === e ? x.none() : x.some(t)), Cw.getContent(i).each(Kb.focusIn) }) }); const y = function (e, t) { const n = e === 'node' ? r.backstage.shared.anchors.node(t) : r.backstage.shared.anchors.cursor(); return Ne(n, $F(e, o())) }; var w = function (e, t) { if (S(), !o() || !r.backstage.isContextMenuOpen()) { const n = b(e); const a = t.map(Wn.fromDom); const c = y(e.position, a); d.set(x.some(c)), g.set(t); const l = i.element(); Fa(l, 'display'), Cw.showWithinBounds(i, c, p(n), function () { return x.some(u()) }), s() && Ra(l, 'display', 'none') } }; const C = function () { if (e.hasFocus()) { const t = v(); LH.lookup(t, e).fold(function () { d.set(x.none()), Cw.hide(i) }, function (e) { w(e.toolbarApi, x.some(e.elem.dom())) }) } }; var S = function () { const e = h.get(); e !== null && (Mw.clearTimeout(e), h.set(null)) }; const k = function (e) { S(), h.set(e) }; e.on('init', function () { e.on(Yz, l), e.on('ScrollContent ScrollWindow longpress', f), e.on('click keyup focus SetContent ObjectResized ResizeEditor', function () { k(Mw.setEditorTimeout(e, C, 0)) }), e.on('focusout', function (t) { Mw.setEditorTimeout(e, function () { zl(n.element()).isNone() && zl(i.element()).isNone() && (d.set(x.none()), Cw.hide(i)) }, 0) }), e.on('SwitchMode', function () { e.mode.isReadOnly() && (d.set(x.none()), Cw.hide(i)) }), e.on('NodeChange', function (t) { zl(i.element()).fold(function () { k(Mw.setEditorTimeout(e, C, 0)) }, function (e) {}) }) }) }; const XF = { register: GF }; const YF = function (e, n, r) { const o = function (e, t) { q([n, r], function (n) { n.broadcastEvent(e, t) }) }; const i = function (e, t) { q([n, r], function (n) { n.broadcastOn([e], t) }) }; const u = function (e) { return i(Zm(), { target: e.target() }) }; const a = tE(Wn.fromDom(t.document), 'touchstart', u); const c = tE(Wn.fromDom(t.document), 'touchmove', function (e) { return o(Vo(), e) }); const s = tE(Wn.fromDom(t.document), 'touchend', function (e) { return o(Uo(), e) }); const l = tE(Wn.fromDom(t.document), 'mousedown', u); const f = tE(Wn.fromDom(t.document), 'mouseup', function (e) { e.raw().button === 0 && i(eg(), { target: e.target() }) }); const d = function (e) { return i(Zm(), { target: Wn.fromDom(e.target) }) }; const m = function (e) { e.button === 0 && i(eg(), { target: Wn.fromDom(e.target) }) }; const g = function (e) { return o(jo(), rE(e)) }; const h = function (e) { i(Qm(), {}), o(Wo(), rE(e)) }; const p = function () { return i(Qm(), {}) }; e.on('PostRender', function () { e.on('click', d), e.on('tap', d), e.on('mouseup', m), e.on('ScrollWindow', g), e.on('ResizeWindow', h), e.on('ResizeEditor', p) }), e.on('remove', function () { e.off('click', d), e.off('tap', d), e.off('mouseup', m), e.off('ScrollWindow', g), e.off('ResizeWindow', h), e.off('ResizeEditor', p), l.unbind(), a.unbind(), c.unbind(), s.unbind(), f.unbind() }), e.on('detach', function () { Am(n), Am(r), n.destroy(), r.destroy() }) }; const KF = { setup: YF }; const JF = Ph; const ZF = vh; const QF = i([On('shell', !1), cn('makeItem'), On('setupItem', n), Ig.field('listBehaviours', [uy])]); const eV = function () { return { behaviours: yl([uy.config({})]) } }; const tV = gh({ name: 'items', overrides: eV }); const nV = i([tV]); const rV = i('CustomList'); const oV = function (e, n, r, o) { const i = function (n, r) { a(n).fold(function () { throw t.console.error('Custom List was defined to not be a shell, but no item container was specified in components'), new Error('Custom List was defined to not be a shell, but no item container was specified in components') }, function (t) { const o = uy.contents(t); const i = r.length; const u = i - o.length; const a = u > 0 ? U(u, function () { return e.makeItem() }) : []; const c = o.slice(i); q(c, function (e) { return uy.remove(t, e) }), q(a, function (e) { return uy.append(t, e) }); const s = uy.contents(t); q(s, function (t, o) { e.setupItem(n, t, r[o], o) }) }) }; const u = e.shell ? { behaviours: [uy.config({})], components: [] } : { behaviours: [], components: n }; var a = function (t) { return e.shell ? x.some(t) : Oh(t, e, 'items') }; return { uid: e.uid, dom: e.dom, components: u.components, behaviours: zg(e.listBehaviours, u.behaviours), apis: { setItems: i } } }; const iV = Gh({ name: rV(), configFields: QF(), partFields: nV(), factory: oV, apis: { setItems (e, t, n) { e.setItems(t, n) } } }); const uV = function (e) { const t = Ia(e, 'position').is('fixed'); const n = t ? x.none() : zi(e); return n.orThunk(function () { const t = Wn.fromTag('span'); return Pi(e).bind(function (e) { qi(e, t); const n = zi(t); return Ki(t), n }) }) }; const aV = function (e) { return uV(e).map(mc).getOrThunk(function () { return lc(0, 0) }) }; const cV = Se.generate([{ static: [] }, { absolute: ['positionCss'] }, { fixed: ['positionCss'] }]); const sV = function (e, t) { const n = e.element(); wa(n, t.transitionClass), Ca(n, t.fadeOutClass), wa(n, t.fadeInClass), t.onShow(e) }; const lV = function (e, t) { const n = e.element(); wa(n, t.transitionClass), Ca(n, t.fadeInClass), wa(n, t.fadeOutClass), t.onHide(e) }; const fV = function (e, t) { return e.y() < t.bottom() && e.bottom() > t.y() }; const dV = function (e, t) { return e.y() >= t.y() }; const mV = function (e, t) { return e.bottom() <= t.bottom() }; const gV = function (e, t, n) { return te(e, function (e) { switch (e) { case 'bottom':return mV(t, n); case 'top':return dV(t, n) } }) }; const hV = function (e, t) { return t.getInitialPosition().map(function (t) { return Fc(t.bounds.x(), t.bounds.y(), vc(e), uc(e)) }) }; const pV = function (e, t, n) { n.setInitialPosition(x.some({ style: La(e), position: Pa(e, 'position') || 'static', bounds: t })) }; const vV = function (e, t, n) { return n.getInitialPosition().bind(function (r) { switch (n.setInitialPosition(x.none()), r.position) { case 'static':return x.some(cV.static()); case 'absolute':var o = uV(e).map(Vc).getOrThunk(function () { return Vc(Na()) }); return x.some(cV.absolute(Ll('absolute', ye(r.style, 'left').map(function (e) { return t.x() - o.x() }), ye(r.style, 'top').map(function (e) { return t.y() - o.y() }), ye(r.style, 'right').map(function (e) { return o.right() - t.right() }), ye(r.style, 'bottom').map(function (e) { return o.bottom() - t.bottom() })))); default:return x.none() } }) }; const bV = function (e, t, n, r) { return hV(e, r).filter(function (e) { return gV(t.modes, e, n) }).bind(function (t) { return vV(e, t, r) }) }; const yV = function (e, t, n, r) { const o = Vc(e); if (gV(t.modes, o, n)) { return x.none() } pV(e, o, r); const i = jc(); const u = o.x() - i.x(); const a = n.y() - i.y(); const c = i.bottom() - n.bottom(); const s = o.y() <= n.y(); return x.some(cV.fixed(Ll('fixed', x.some(u), s ? x.some(a) : x.none(), x.none(), s ? x.none() : x.some(c)))) }; const wV = function (e, t, n, r) { const o = e.element(); const i = Ia(o, 'position').is('fixed'); return i ? bV(o, t, n, r) : yV(o, t, n, r) }; const xV = function (e, t) { const n = e.element(); return hV(n, t).bind(function (e) { return vV(n, e, t) }) }; const CV = function (e, t) { q(['left', 'right', 'top', 'bottom', 'position'], function (t) { return Fa(e.element(), t) }), t.onUndocked(e) }; const SV = function (e, t, n) { Hl(e.element(), n); const r = n.position() === 'fixed' ? t.onDocked : t.onUndocked; r(e) }; const kV = function (e, t, n, r, o) { void 0 === o && (o = !1), t.contextual.each(function (t) { t.lazyContext(e).each(function (i) { const u = fV(i, r); if (u !== n.isVisible()) { if (n.setVisible(u), o && !u) { ka(e.element(), [t.fadeOutClass]), t.onHide(e) } else { const a = u ? sV : lV; a(e, t) } } }) }) }; const TV = function (e, t, n) { const r = t.lazyViewport(e); const o = n.isDocked(); o && kV(e, t, n, r), wV(e, t, r, n).each(function (i) { n.setDocked(!o), i.fold(function () { return CV(e, t) }, function (n) { return SV(e, t, n) }, function (o) { kV(e, t, n, r, !0), SV(e, t, o) }) }) }; const EV = function (e, t, r) { const o = e.element(); r.setDocked(!1), xV(e, r).each(function (r) { r.fold(function () { return CV(e, t) }, function (n) { return SV(e, t, n) }, n) }), r.setVisible(!0), t.contextual.each(function (t) { Ta(o, [t.fadeInClass, t.fadeOutClass, t.transitionClass]), t.onShow(e) }), OV(e, t, r) }; var OV = function (e, t, n) { e.getSystem().isConnected() && TV(e, t, n) }; const NV = function (e, t, n) { n.isDocked() && EV(e, t, n) }; const _V = function (e, t, n) { return n.isDocked() }; const DV = Object.freeze({ __proto__: null, refresh: OV, reset: NV, isDocked: _V }); const AV = function (e, t) { return ai([wi(Oo(), function (n, r) { e.contextual.each(function (e) { if (Sa(n.element(), e.transitionClass)) { Ta(n.element(), [e.transitionClass, e.fadeInClass]); const o = t.isVisible() ? e.onShown : e.onHidden; o(n) }r.stop() }) }), fi(jo(), function (n, r) { OV(n, e, t) }), fi(Wo(), function (n, r) { NV(n, e, t) })]) }; const RV = Object.freeze({ __proto__: null, events: AV }); const BV = [Tn('contextual', [fn('fadeInClass'), fn('fadeOutClass'), fn('transitionClass'), gn('lazyContext'), xs('onShow'), xs('onShown'), xs('onHide'), xs('onHidden')]), Bn('lazyViewport', jc), Pn('modes', ['top', 'bottom'], tn), xs('onDocked'), xs('onUndocked')]; const MV = function () { const e = Ln(!1); const t = Ln(!0); const n = Ln(x.none()); const r = function () { return 'docked:  ' + e.get() + ', visible: ' + t.get() }; return Uu({ isDocked () { return e.get() }, setDocked (t) { return e.set(t) }, getInitialPosition () { return n.get() }, setInitialPosition (e) { return n.set(e) }, isVisible () { return t.get() }, setVisible (e) { return t.set(e) }, readState: r }) }; const PV = Object.freeze({ __proto__: null, init: MV }); const zV = xl({ fields: BV, name: 'docking', active: RV, apis: DV, state: PV }); const IV = { fadeInClass: 'tox-editor-dock-fadein', fadeOutClass: 'tox-editor-dock-fadeout', transitionClass: 'tox-editor-dock-transition' }; const LV = 'tox-tinymce--toolbar-sticky-on'; const HV = 'tox-tinymce--toolbar-sticky-off'; const FV = function (e, t) { const n = Ri(t); const r = n.dom().defaultView.innerHeight; const o = Oc(n); const i = Wn.fromDom(e.elm); const u = Uc(i); const a = uc(i); const c = u.y(); const s = c + a; const l = mc(t); const f = uc(t); const d = l.top(); const m = d + f; const g = Math.abs(d - o.top()) < 2; const h = Math.abs(m - (o.top() + r)) < 2; if (g && c < m) { Nc(o.left(), c - f, n) } else if (h && s > d) { const p = c - r + a + f; Nc(o.left(), p, n) } }; const VV = function (e, t) { const n = function (e) { return ac(e) + (parseInt(Pa(e, 'margin-top'), 10) || 0) + (parseInt(Pa(e, 'margin-bottom'), 10) || 0) }; const r = e.element(); Pi(r).each(function (o) { const i = 'padding-' + (t ? 'top' : 'bottom'); if (zV.isDocked(e)) { const u = vc(o); Ra(r, 'width', u + 'px'), Ra(o, i, n(r) + 'px') } else { Fa(r, 'width'), Fa(o, i) } }) }; const UV = function (e, t) { t ? (Ca(e, IV.fadeOutClass), ka(e, [IV.transitionClass, IV.fadeInClass])) : (Ca(e, IV.fadeInClass), ka(e, [IV.fadeOutClass, IV.transitionClass])) }; const jV = function (e, t) { const n = Wn.fromDom(e.getContainer()); t ? (wa(n, LV), Ca(n, HV)) : (wa(n, HV), Ca(n, LV)) }; const WV = function (e, t) { const n = Ri(t); Pl(n).filter(function (e) { return !Jr(t, e) }).filter(function (t) { return Jr(t, Wn.fromDom(n.dom().body)) || to(e, t) }).each(function () { return Rl(t) }) }; const qV = function (e, t) { return zl(e).orThunk(function () { return t().toOption().bind(function (e) { return zl(e.element()) }) }) }; const $V = function (e, t) { e.inline || (nx(e) || e.on('ResizeEditor', function () { t().each(zV.reset) }), e.on('ResizeWindow ResizeEditor', function () { t().each(function (t) { return VV(t, nx(e)) }) }), e.on('SkinLoaded', function () { t().each(function (e) { zV.isDocked(e) ? zV.reset(e) : zV.refresh(e) }) }), e.on('FullscreenStateChanged', function () { t().each(zV.reset) })), e.on('AfterScrollIntoView', function (e) { t().each(function (t) { zV.refresh(t); const n = t.element(); vv(n) && FV(e, n) }) }), e.on('PostRender', function () { jV(e, !1) }) }; const GV = function (e) { return e().map(zV.isDocked).getOr(!1) }; const XV = function (e) { let t; return [_l.config({ channels: (t = {}, t[dL()] = { onReceive (t) { VV(t, e) } }, t) })] }; const YV = function (e, t) { const n = Ln(x.none()); const r = nx(e); const o = function (e) { t().each(function (t) { return e(t.element()) }) }; const i = function (n) { e.inline || VV(n, r), jV(e, zV.isDocked(n)), n.getSystem().broadcastOn([Qm()], {}), t().each(function (e) { return e.getSystem().broadcastOn([Qm()], {}) }) }; const u = e.inline ? [] : XV(r); return h([vy.config({}), zV.config({ contextual: m({ lazyContext (t) { const n = ac(t.element()); const o = e.inline ? e.getContentAreaContainer() : e.getContainer(); const i = Vc(Wn.fromDom(o)); const u = i.height() - n; const a = i.y() + (r ? 0 : n); return x.some(Fc(i.x(), a, i.width(), u)) }, onShow () { o(function (e) { return UV(e, !0) }) }, onShown (e) { o(function (e) { return Ta(e, [IV.transitionClass, IV.fadeInClass]) }), n.get().each(function (t) { WV(e.element(), t), n.set(x.none()) }) }, onHide (e) { n.set(qV(e.element(), t)), o(function (e) { return UV(e, !1) }) }, onHidden () { o(function (e) { return Ta(e, [IV.transitionClass]) }) } }, IV), modes: [r ? 'top' : 'bottom'], onDocked: i, onUndocked: i })], u) }; const KV = Object.freeze({ __proto__: null, setup: $V, isDocked: GV, getBehaviours: YV }); const JV = n; const ZV = l; const QV = i([]); const eU = Object.freeze({ __proto__: null, setup: JV, isDocked: ZV, getBehaviours: QV }); const tU = function (e) { const t = e.editor; const n = e.sticky ? YV : QV; return { uid: e.uid, dom: e.dom, components: e.components, behaviours: yl(n(t, e.getSink)) } }; const nU = function (e, t) { const n = function (e, n) { const r = W(n, function (e) { const n = { type: 'menubutton', text: e.text, fetch (t) { t(e.getItems()) } }; const r = RL(n).mapError(function (e) { return Yt(e) }).getOrDie(); return bB(r, 'tox-mbtn', t.backstage, x.some('menuitem')) }); uy.set(e, r) }; const r = { focus: Kb.focusIn, setMenus: n }; return { uid: e.uid, dom: e.dom, components: [], behaviours: yl([uy.config({}), cy('menubar-events', [xi(function (t) { e.onSetup(t) }), fi(yo(), function (e, t) { Jc(e.element(), '.tox-mbtn--active').each(function (n) { Zc(t.event().target(), '.tox-mbtn').each(function (t) { Jr(n, t) || e.getSystem().getByDom(n).each(function (n) { e.getSystem().getByDom(t).each(function (e) { oN.expand(e), oN.close(n), vy.focus(e) }) }) }) }) }), fi(Yo(), function (e, t) { t.event().prevFocus().bind(function (t) { return e.getSystem().getByDom(t).toOption() }).each(function (n) { t.event().newFocus().bind(function (t) { return e.getSystem().getByDom(t).toOption() }).each(function (e) { oN.isOpen(n) && (oN.expand(e), oN.close(n)) }) }) })]), Kb.config({ mode: 'flow', selector: '.tox-mbtn', onEscape (t) { return e.onEscape(t), x.some(!0) } }), NO.config({})]), apis: r, domModification: { attributes: { role: 'menubar' } } } }; const rU = $h({ factory: nU, name: 'silver.Menubar', configFields: [cn('dom'), cn('uid'), cn('onEscape'), cn('backstage'), On('onSetup', n)], apis: { focus (e, t) { e.focus(t) }, setMenus (e, t, n) { e.setMenus(t, n) } } }); const oU = 'container'; const iU = [Mg('slotBehaviours', [])]; const uU = function (e) { return '<alloy.field.' + e + '>' }; const aU = function (e) { const t = (function () { const e = []; const t = function (t, n) { return e.push(t), Ch(oU, uU(t), n) }; return { slot: t, record () { return e } } }()); const n = e(t); const r = t.record(); const o = W(r, function (e) { return dh({ name: e, pname: uU(e) }) }); return Hh(oU, iU, o, cU, n) }; var cU = function (e, t) { const n = function (t) { return Ah(e) }; const r = function (t, n) { return Oh(t, e, n) }; const o = function (t, n) { return function (r, o) { return Oh(r, e, o).map(function (e) { return t(e, o) }).getOr(n) } }; const i = function (e) { return function (t, n) { q(n, function (n) { return e(t, n) }) } }; const u = function (e, t) { return su(e.element(), 'aria-hidden') !== 'true' }; const a = function (e, t) { if (!u(e)) { const n = e.element(); Fa(n, 'display'), du(n, 'aria-hidden'), ni(e, Ko(), { name: t, visible: !0 }) } }; const c = function (e, t) { if (u(e)) { const n = e.element(); Ra(n, 'display', 'none'), au(n, 'aria-hidden', 'true'), ni(e, Ko(), { name: t, visible: !1 }) } }; const s = o(u, !1); const l = o(c); const f = i(l); const d = function (e) { return f(e, n()) }; const m = o(a); const g = { getSlotNames: n, getSlot: r, isShowing: s, hideSlot: l, hideAllSlots: d, showSlot: m }; return { uid: e.uid, dom: e.dom, components: t, behaviours: Pg(e.slotBehaviours), apis: g } }; const sU = ge({ getSlotNames (e, t) { return e.getSlotNames(t) }, getSlot (e, t, n) { return e.getSlot(t, n) }, isShowing (e, t, n) { return e.isShowing(t, n) }, hideSlot (e, t, n) { return e.hideSlot(t, n) }, hideAllSlots (e, t) { return e.hideAllSlots(t) }, showSlot (e, t, n) { return e.showSlot(t, n) } }, function (e) { return Fu(e) }); const lU = m(m({}, sU), { sketch: aU }); const fU = _t([Cn('icon'), Cn('tooltip'), Bn('onShow', n), Bn('onHide', n), Bn('onSetup', function () { return n })]); const dU = function (e) { return $t('sidebar', fU, e) }; const mU = function (e) { const t = e.ui.registry.getAll().sidebars; q(fe(t), function (n) { const r = t[n]; const o = function () { return x.from(e.queryCommandValue('ToggleSidebar')).is(n) }; e.ui.registry.addToggleButton(n, { icon: r.icon, tooltip: r.tooltip, onAction (t) { e.execCommand('ToggleSidebar', !1, n), t.setActive(o()) }, onSetup (t) { const n = function () { return t.setActive(o()) }; return e.on('ToggleSidebar', n), function () { e.off('ToggleSidebar', n) } } }) }) }; const gU = function (e) { return { element () { return e.element().dom() } } }; const hU = function (e, t) { const r = W(fe(t), function (e) { const n = t[e]; const r = Gt(dU(n)); return { name: e, getApi: gU, onSetup: r.onSetup, onShow: r.onShow, onHide: r.onHide } }); return W(r, function (t) { const o = Ln(n); return e.slot(t.name, { dom: { tag: 'div', classes: ['tox-sidebar__pane'] }, behaviours: wC.unnamedEvents([PS(t, o), zS(t, o), fi(Ko(), function (e, t) { const n = t.event(); const o = J(r, function (e) { return e.name === n.name() }); o.each(function (t) { const r = n.visible() ? t.onShow : t.onHide; r(t.getApi(e)) }) })]) }) }) }; const pU = function (e) { return lU.sketch(function (t) { return { dom: { tag: 'div', classes: ['tox-sidebar__pane-container'] }, components: hU(t, e), slotBehaviours: wC.unnamedEvents([xi(function (e) { return lU.hideAllSlots(e) })]) } }) }; const vU = function (e, t) { const n = np.getCurrent(e); n.each(function (e) { return uy.set(e, [pU(t)]) }) }; const bU = function (e, t) { const n = np.getCurrent(e); n.each(function (e) { const n = np.getCurrent(e); n.each(function (n) { iL.hasGrown(e) ? lU.isShowing(n, t) ? iL.shrink(e) : (lU.hideAllSlots(n), lU.showSlot(n, t)) : (lU.hideAllSlots(n), lU.showSlot(n, t), iL.grow(e)) }) }) }; const yU = function (e) { const t = np.getCurrent(e); return t.bind(function (e) { const t = iL.isGrowing(e) || iL.hasGrown(e); if (t) { const n = np.getCurrent(e); return n.bind(function (e) { return J(lU.getSlotNames(e), function (t) { return lU.isShowing(e, t) }) }) } return x.none() }) }; const wU = xu('FixSizeEvent'); const xU = xu('AutoSizeEvent'); const CU = function (e) { return { uid: e.uid, dom: { tag: 'div', classes: ['tox-sidebar'], attributes: { role: 'complementary' } }, components: [{ dom: { tag: 'div', classes: ['tox-sidebar__slider'] }, components: [], behaviours: yl([NO.config({}), vy.config({}), iL.config({ dimension: { property: 'width' }, closedClass: 'tox-sidebar--sliding-closed', openClass: 'tox-sidebar--sliding-open', shrinkingClass: 'tox-sidebar--sliding-shrinking', growingClass: 'tox-sidebar--sliding-growing', onShrunk (e) { const t = np.getCurrent(e); t.each(lU.hideAllSlots), ti(e, xU) }, onGrown (e) { ti(e, xU) }, onStartGrow (e) { ni(e, wU, { width: Ia(e.element(), 'width').getOr('') }) }, onStartShrink (e) { ni(e, wU, { width: vc(e.element()) + 'px' }) } }), uy.config({}), np.config({ find (e) { const t = uy.contents(e); return ae(t) } })]) }], behaviours: yl([gA.childAt(0), cy('sidebar-sliding-events', [fi(wU, function (e, t) { Ra(e.element(), 'width', t.event().width()) }), fi(xU, function (e, t) { Fa(e.element(), 'width') })])]) } }; const SU = function (e) { const t = void 0 !== e.dom().attributes ? e.dom().attributes : []; return K(t, function (e, t) { let n; return t.name === 'class' ? e : m(m({}, e), (n = {}, n[t.name] = t.value, n)) }, {}) }; const kU = function (e) { return Array.prototype.slice.call(e.dom().classList, 0) }; const TU = function (e) { const t = Wn.fromHtml(e); const n = Li(t); const r = SU(t); const o = kU(t); const i = n.length === 0 ? {} : { innerHtml: Zi(t) }; return m({ tag: tu(t), classes: o, attributes: r }, i) }; const EU = function (e) { return { dom: { tag: 'div', attributes: { 'aria-label': e.translate('Loading...') }, classes: ['tox-throbber__busy-spinner'] }, components: [{ dom: TU('<div class="tox-spinner"><div></div><div></div><div></div></div>') }], behaviours: yl([Kb.config({ mode: 'special', onTab () { return x.some(!0) }, onShiftTab () { return x.some(!0) } }), vy.config({})]) } }; const OU = function (e, t, n) { const r = e.element(); !0 === t ? (uy.set(e, [EU(n)]), Fa(r, 'display'), du(r, 'aria-hidden')) : (uy.set(e, []), Ra(r, 'display', 'none'), au(r, 'aria-hidden', 'true')) }; const NU = function (e) { return { uid: e.uid, dom: { tag: 'div', attributes: { 'aria-hidden': 'true' }, classes: ['tox-throbber'], styles: { display: 'none' } }, behaviours: yl([uy.config({})]), components: [] } }; const _U = function (e, t, n) { const r = Ln(!1); const o = Ln(x.none()); const i = function (e) { e !== r.get() && (OU(t(), e, n.providers), r.set(e)) }; e.on('ProgressState', function (t) { if (o.get().each(Mw.clearTimeout), B(t.time)) { const n = Mw.setEditorTimeout(e, function () { return i(t.state) }, t.time); o.set(x.some(n)) } else { i(t.state), o.set(x.none()) } }) }; const DU = function (e, t, n) { const r = { getSocket (t) { return JF.getPart(t, e, 'socket') }, setSidebar (t, n) { JF.getPart(t, e, 'sidebar').each(function (e) { return vU(e, n) }) }, toggleSidebar (t, n) { JF.getPart(t, e, 'sidebar').each(function (e) { return bU(e, n) }) }, whichSidebar (t) { return JF.getPart(t, e, 'sidebar').bind(yU).getOrNull() }, getHeader (t) { return JF.getPart(t, e, 'header') }, getToolbar (t) { return JF.getPart(t, e, 'toolbar') }, setToolbar (t, n) { JF.getPart(t, e, 'toolbar').each(function (e) { e.getApis().setGroups(e, n) }) }, setToolbars (t, n) { JF.getPart(t, e, 'multiple-toolbar').each(function (e) { iV.setItems(e, n) }) }, refreshToolbar (t) { const n = JF.getPart(t, e, 'toolbar'); n.each(function (e) { return e.getApis().refresh(e) }) }, getThrobber (t) { return JF.getPart(t, e, 'throbber') }, focusToolbar (t) { const n = JF.getPart(t, e, 'toolbar').orThunk(function () { return JF.getPart(t, e, 'multiple-toolbar') }); n.each(function (e) { Kb.focusIn(e) }) }, setMenubar (t, n) { JF.getPart(t, e, 'menubar').each(function (e) { rU.setMenus(e, n) }) }, focusMenubar (t) { JF.getPart(t, e, 'menubar').each(function (e) { rU.focus(e) }) } }; return { uid: e.uid, dom: e.dom, components: t, apis: r, behaviours: e.behaviours } }; const AU = ZF.optional({ factory: rU, name: 'menubar', schema: [cn('backstage')] }); const RU = function (e) { return e.type === $p.sliding ? TL : e.type === $p.floating ? kL : EL }; const BU = ZF.optional({ factory: { sketch (e) { return iV.sketch({ uid: e.uid, dom: e.dom, listBehaviours: yl([Kb.config({ mode: 'acyclic', selector: '.tox-toolbar' })]), makeItem () { return EL({ type: e.type, uid: xu('multiple-toolbar-item'), cyclicKeying: !1, initGroups: [], onEscape () { return x.none() } }) }, setupItem (e, t, n, r) { oI.setGroups(t, n) }, shell: !0 }) } }, name: 'multiple-toolbar', schema: [cn('dom'), cn('onEscape')] }); const MU = ZF.optional({ factory: { sketch (e) { const t = RU(e); const n = { type: e.type, uid: e.uid, onEscape () { return e.onEscape(), x.some(!0) }, cyclicKeying: !1, initGroups: [], getSink: e.getSink, backstage: e.backstage, moreDrawerData: { lazyToolbar: e.lazyToolbar, lazyMoreButton: e.lazyMoreButton, lazyHeader: e.lazyHeader }, attributes: e.attributes }; return t(n) } }, name: 'toolbar', schema: [cn('dom'), cn('onEscape'), cn('getSink')] }); const PU = ZF.optional({ factory: { sketch: tU }, name: 'header', schema: [cn('dom')] }); const zU = ZF.optional({ name: 'socket', schema: [cn('dom')] }); const IU = ZF.optional({ factory: { sketch: CU }, name: 'sidebar', schema: [cn('dom')] }); const LU = ZF.optional({ factory: { sketch: NU }, name: 'throbber', schema: [cn('dom')] }); const HU = Gh({ name: 'OuterContainer', factory: DU, configFields: [cn('dom'), cn('behaviours')], partFields: [PU, AU, MU, BU, zU, IU, LU], apis: { getSocket (e, t) { return e.getSocket(t) }, setSidebar (e, t, n) { e.setSidebar(t, n) }, toggleSidebar (e, t, n) { e.toggleSidebar(t, n) }, whichSidebar (e, t) { return e.whichSidebar(t) }, getHeader (e, t) { return e.getHeader(t) }, getToolbar (e, t) { return e.getToolbar(t) }, setToolbar (e, t, n) { const r = W(n, function (e) { return xL(e) }); e.setToolbar(t, r) }, setToolbars (e, t, n) { const r = W(n, function (e) { return W(e, xL) }); e.setToolbars(t, r) }, refreshToolbar (e, t) { return e.refreshToolbar(t) }, getThrobber (e, t) { return e.getThrobber(t) }, setMenubar (e, t, n) { e.setMenubar(t, n) }, focusMenubar (e, t) { e.focusMenubar(t) }, focusToolbar (e, t) { e.focusToolbar(t) } } }); const FU = 'file edit view insert format tools table help'; const VU = { file: { title: 'File', items: 'newdocument restoredraft | preview | print | deleteallconversations' }, edit: { title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall | searchreplace' }, view: { title: 'View', items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments' }, insert: { title: 'Insert', items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime' }, format: { title: 'Format', items: 'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align | forecolor backcolor | removeformat' }, tools: { title: 'Tools', items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount' }, table: { title: 'Table', items: 'inserttable | cell row column | advtablesort | tableprops deletetable' }, help: { title: 'Help', items: 'help' } }; const UU = function (e, t, n) { const r = Xw(n).split(/[ ,]/); return { text: e.title, getItems () { return ee(e.items, function (e) { const n = e.toLowerCase(); return n.trim().length === 0 ? [] : V(r, function (e) { return e === n }) ? [] : n === 'separator' || n === '|' ? [{ type: 'separator' }] : t.menuItems[n] ? [t.menuItems[n]] : [] }) } } }; const jU = function (e) { return typeof e === 'string' ? e.split(' ') : e }; const WU = function (e, t) { const n = m(m({}, VU), t.menus); const r = fe(t.menus).length > 0; const o = void 0 === t.menubar || !0 === t.menubar ? jU(FU) : jU(!1 === t.menubar ? '' : t.menubar); const i = X(o, function (e) { return r && t.menus.hasOwnProperty(e) && t.menus[e].hasOwnProperty('items') || VU.hasOwnProperty(e) }); const u = W(i, function (r) { const o = n[r]; return UU({ title: o.title, items: jU(o.items) }, t, e) }); return X(u, function (e) { const t = function (e) { return e.type !== 'separator' }; return e.getItems().length > 0 && V(e.getItems(), t) }) }; const qU = function (e) { const t = function () { e._skinLoaded = !0, $k.fireSkinLoaded(e) }; return function () { e.initialized ? t() : e.on('init', t) } }; const $U = function (e, t) { return function () { return $k.fireSkinLoadError(e, { message: t }) } }; const GU = { fireSkinLoaded: qU, fireSkinLoadError: $U }; const XU = function (e, t) { let n; const r = Iw(t); r && (n = r + '/skin.min.css', t.contentCSS.push(r + (e ? '/content.inline' : '/content') + '.min.css')), !1 === Hw(t) && n ? Pw.DOM.styleSheetLoader.load(n, GU.fireSkinLoaded(t), GU.fireSkinLoadError(t, 'Skin could not be loaded')) : GU.fireSkinLoaded(t)() }; const YU = a(XU, !1); const KU = a(XU, !0); const JU = function (e, t, n, r) { const o = t.outerContainer; const i = n.toolbar; const u = n.buttons; if (M(i, N)) { const a = i.map(function (t) { const o = { toolbar: t, buttons: u, allowToolbarGroups: n.allowToolbarGroups }; return FF(e, o, { backstage: r }, x.none()) }); HU.setToolbars(o, a) } else { HU.setToolbar(o, FF(e, n, { backstage: r }, x.none())) } }; const ZU = Pw.DOM; const QU = Vr(); const ej = QU.os.isiOS() && QU.os.version.major <= 12; const tj = function (e) { const t = e.getWin(); const n = e.getDoc().documentElement; const r = Ln(lc(t.innerWidth, t.innerHeight)); const o = Ln(lc(n.offsetWidth, n.offsetHeight)); const i = function (n) { const i = e.getDoc().documentElement; const u = r.get(); const a = o.get(); u.left() !== t.innerWidth || u.top() !== t.innerHeight ? (r.set(lc(t.innerWidth, t.innerHeight)), $k.fireResizeContent(e, n)) : a.left() === i.offsetWidth && a.top() === i.offsetHeight || (o.set(lc(i.offsetWidth, i.offsetHeight)), $k.fireResizeContent(e, n)) }; const u = function (t) { return $k.fireScrollContent(e, t) }; ZU.bind(t, 'resize', i), ZU.bind(t, 'scroll', u); const a = nE(Wn.fromDom(e.getBody()), 'load', i); e.on('remove', function () { a.unbind(), ZU.unbind(t, 'resize', i), ZU.unbind(t, 'scroll', u) }) }; const nj = function (e, t, n, r, o) { const i = Ln(0); YU(e), _m(Wn.fromDom(o.targetNode), t.mothership), Nm(Na(), t.uiMothership), e.on('PostRender', function () { JU(e, t, n, r), i.set(e.getWin().innerWidth), HU.setMenubar(t.outerContainer, WU(e, n)), HU.setSidebar(t.outerContainer, n.sidebar), tj(e) }); const u = HU.getSocket(t.outerContainer).getOrDie('Could not find expected socket element'); if (!0 === ej) { Ba(u.element(), { overflow: 'scroll', '-webkit-overflow-scrolling': 'touch' }); const a = Cx(function () { e.fire('ScrollContent') }, 20); tE(u.element(), 'scroll', a.throttle) }bL(e, t), e.addCommand('ToggleSidebar', function (n, r) { HU.toggleSidebar(t.outerContainer, r), e.fire('ToggleSidebar') }), e.addQueryValueHandler('ToggleSidebar', function () { return HU.whichSidebar(t.outerContainer) }); const c = ex(e); const s = function () { HU.refreshToolbar(t.outerContainer) }; return c !== $p.sliding && c !== $p.floating || e.on('ResizeWindow ResizeEditor ResizeContent', function () { const t = e.getWin().innerWidth; t !== i.get() && (s(), i.set(t)) }), { iframeContainer: u.element().dom(), editorContainer: t.outerContainer.element().dom() } }; const rj = { render: nj }; const oj = function (e) { const t = /^[0-9\.]+(|px)$/i; return t.test('' + e) ? x.some(parseInt('' + e, 10)) : x.none() }; const ij = function (e) { return B(e) ? e + 'px' : e }; const uj = function (e, t, n) { const r = t.filter(function (t) { return e < t }); const o = n.filter(function (t) { return e > t }); return r.or(o).getOr(e) }; const aj = { calcCappedSize: uj, parseToInt: oj, numToPx: ij }; const cj = function (e) { const t = Fw(e); const n = jw(e); const r = qw(e); return aj.parseToInt(t).map(function (e) { return aj.calcCappedSize(e, n, r) }) }; const sj = function (e) { const t = cj(e); return t.getOr(Fw(e)) }; const lj = function (e) { const t = Vw(e); const n = Uw(e); const r = Ww(e); return aj.parseToInt(t).map(function (e) { return aj.calcCappedSize(e, n, r) }) }; const fj = function (e) { const t = lj(e); return t.getOr(Vw(e)) }; const dj = function (e, t) { const n = Vc(e); return { pos: t ? n.y() : n.bottom(), height: n.height() } }; const mj = function (e, t, n, r, o) { let i; const u = t.mothership; const a = t.uiMothership; const c = t.outerContainer; const s = Pw.DOM; const l = ix(e); const f = cx(e); const d = Wn.fromDom(o.targetNode); const m = Ww(e).or(lj(e)); const g = ex(e); const h = g === $p.sliding || g === $p.floating; const p = nx(e); const v = Ln(dj(d, p)); const b = Ln(!1); KU(e); const y = function (e) { const t = h ? e.fold(function () { return 0 }, function (e) { return e.components().length > 1 ? uc(e.components()[1].element()) : 0 }) : 0; const n = Vc(d); const r = p ? n.y() - uc(i.element()) + t : n.bottom(); Ba(c.element(), { position: 'absolute', top: Math.round(r) + 'px', left: Math.round(n.x()) + 'px' }); const o = m.getOrThunk(function () { const e = aj.parseToInt(Pa(Na(), 'margin-left')).getOr(0); return vc(Na()) - n.x() + e }); Ra(i.element(), 'max-width', o + 'px') }; const w = function () { a.broadcastOn([Qm()], {}) }; const x = function (e) { if (void 0 === e && (e = !1), h && HU.refreshToolbar(c), !l) { const t = HU.getToolbar(c); y(t) }f && (e ? zV.reset(i) : zV.refresh(i)), w() }; const C = function () { b.set(!0), Ra(c.element(), 'display', 'flex'), s.addClass(e.getBody(), 'mce-edit-focus'), Fa(a.element(), 'display'), x() }; const S = function () { b.set(!1), t.outerContainer && (Ra(c.element(), 'display', 'none'), s.removeClass(e.getBody(), 'mce-edit-focus')), Ra(a.element(), 'display', 'none') }; const k = function () { if (i) { C() } else { i = HU.getHeader(c).getOrDie(); const o = ux(e); Nm(o, u), Nm(o, a), JU(e, t, n, r), HU.setMenubar(c, WU(e, n)), C(), e.on('activate', C), e.on('deactivate', S), e.on('SkinLoaded ResizeWindow', function () { b.get() && x(!0) }), e.on('NodeChange keydown', function () { Mw.requestAnimationFrame(function () { const e = dj(d, p); const t = v.get(); b.get() && (e.pos !== t.pos ? (x(!0), v.set(e)) : e.height !== t.height && (w(), v.set(e))) }) }), e.nodeChanged() } }; return e.on('focus', k), e.on('blur hide', S), e.on('init', function () { e.hasFocus() && k() }), bL(e, t), { editorContainer: c.element().dom() } }; const gj = { render: mj }; const hj = function (e) { const t = [{ name: 'alignleft', text: 'Align left', cmd: 'JustifyLeft', icon: 'align-left' }, { name: 'aligncenter', text: 'Align center', cmd: 'JustifyCenter', icon: 'align-center' }, { name: 'alignright', text: 'Align right', cmd: 'JustifyRight', icon: 'align-right' }, { name: 'alignjustify', text: 'Justify', cmd: 'JustifyFull', icon: 'align-justify' }]; aM.each(t, function (t) { e.ui.registry.addToggleButton(t.name, { tooltip: t.text, onAction () { return e.execCommand(t.cmd) }, icon: t.icon, onSetup: xF(e, t.name) }) }); const n = { name: 'alignnone', text: 'No alignment', cmd: 'JustifyNone', icon: 'align-none' }; e.ui.registry.addButton(n.name, { tooltip: n.text, onAction () { return e.execCommand(n.cmd) }, icon: n.icon }) }; const pj = { register: hj }; const vj = function (e, t) { return function () { e.execCommand('mceToggleFormat', !1, t) } }; const bj = function (e) { aM.each([{ name: 'bold', text: 'Bold', icon: 'bold' }, { name: 'italic', text: 'Italic', icon: 'italic' }, { name: 'underline', text: 'Underline', icon: 'underline' }, { name: 'strikethrough', text: 'Strikethrough', icon: 'strike-through' }, { name: 'subscript', text: 'Subscript', icon: 'subscript' }, { name: 'superscript', text: 'Superscript', icon: 'superscript' }], function (t, n) { e.ui.registry.addToggleButton(t.name, { tooltip: t.text, icon: t.icon, onSetup: xF(e, t.name), onAction: vj(e, t.name) }) }); for (let t = 1; t <= 6; t++) { const n = 'h' + t; e.ui.registry.addToggleButton(n, { text: n.toUpperCase(), tooltip: 'Heading ' + t, onSetup: xF(e, n), onAction: vj(e, n) }) } }; const yj = function (e) { aM.each([{ name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut' }, { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy' }, { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste' }, { name: 'help', text: 'Help', action: 'mceHelp', icon: 'help' }, { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all' }, { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document' }, { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting' }, { name: 'remove', text: 'Remove', action: 'Delete', icon: 'remove' }], function (t) { e.ui.registry.addButton(t.name, { tooltip: t.text, icon: t.icon, onAction () { return e.execCommand(t.action) } }) }) }; const wj = function (e) { aM.each([{ name: 'blockquote', text: 'Blockquote', action: 'mceBlockQuote', icon: 'quote' }], function (t) { e.ui.registry.addToggleButton(t.name, { tooltip: t.text, icon: t.icon, onAction () { return e.execCommand(t.action) }, onSetup: xF(e, t.name) }) }) }; const xj = function (e) { bj(e), yj(e), wj(e) }; const Cj = function (e) { aM.each([{ name: 'bold', text: 'Bold', action: 'Bold', icon: 'bold', shortcut: 'Meta+B' }, { name: 'italic', text: 'Italic', action: 'Italic', icon: 'italic', shortcut: 'Meta+I' }, { name: 'underline', text: 'Underline', action: 'Underline', icon: 'underline', shortcut: 'Meta+U' }, { name: 'strikethrough', text: 'Strikethrough', action: 'Strikethrough', icon: 'strike-through', shortcut: '' }, { name: 'subscript', text: 'Subscript', action: 'Subscript', icon: 'subscript', shortcut: '' }, { name: 'superscript', text: 'Superscript', action: 'Superscript', icon: 'superscript', shortcut: '' }, { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting', shortcut: '' }, { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document', shortcut: '' }, { name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut', shortcut: 'Meta+X' }, { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy', shortcut: 'Meta+C' }, { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste', shortcut: 'Meta+V' }, { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all', shortcut: 'Meta+A' }], function (t) { e.ui.registry.addMenuItem(t.name, { text: t.text, icon: t.icon, shortcut: t.shortcut, onAction () { return e.execCommand(t.action) } }) }), e.ui.registry.addMenuItem('codeformat', { text: 'Code', icon: 'sourcecode', onAction: vj(e, 'code') }) }; const Sj = function (e) { xj(e), Cj(e) }; const kj = { register: Sj }; const Tj = function (e, t, n) { const r = function () { return !!t.undoManager && t.undoManager[n]() }; const o = function () { e.setDisabled(t.mode.isReadOnly() || !r()) }; return e.setDisabled(!r()), t.on('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', o), function () { return t.off('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', o) } }; const Ej = function (e) { e.ui.registry.addMenuItem('undo', { text: 'Undo', icon: 'undo', shortcut: 'Meta+Z', onSetup (t) { return Tj(t, e, 'hasUndo') }, onAction () { return e.execCommand('undo') } }), e.ui.registry.addMenuItem('redo', { text: 'Redo', icon: 'redo', shortcut: 'Meta+Y', onSetup (t) { return Tj(t, e, 'hasRedo') }, onAction () { return e.execCommand('redo') } }) }; const Oj = function (e) { e.ui.registry.addButton('undo', { tooltip: 'Undo', icon: 'undo', onSetup (t) { return Tj(t, e, 'hasUndo') }, onAction () { return e.execCommand('undo') } }), e.ui.registry.addButton('redo', { tooltip: 'Redo', icon: 'redo', onSetup (t) { return Tj(t, e, 'hasRedo') }, onAction () { return e.execCommand('redo') } }) }; const Nj = function (e) { Ej(e), Oj(e) }; const _j = { register: Nj }; const Dj = function (e, t) { e.setActive(t.hasVisual); const n = function (t) { e.setActive(t.hasVisual) }; return t.on('VisualAid', n), function () { return t.off('VisualAid', n) } }; const Aj = function (e) { e.ui.registry.addToggleMenuItem('visualaid', { text: 'Visual aids', onSetup (t) { return Dj(t, e) }, onAction () { e.execCommand('mceToggleVisualAid') } }) }; const Rj = function (e) { e.ui.registry.addButton('visualaid', { tooltip: 'Visual aids', text: 'Visual aids', onAction () { return e.execCommand('mceToggleVisualAid') } }) }; const Bj = function (e) { Rj(e), Aj(e) }; const Mj = { register: Bj }; const Pj = function (e, t) { e.setDisabled(!t.queryCommandState('outdent')); const n = function () { e.setDisabled(!t.queryCommandState('outdent')) }; return t.on('NodeChange', n), function () { return t.off('NodeChange', n) } }; const zj = function (e) { e.ui.registry.addButton('outdent', { tooltip: 'Decrease indent', icon: 'outdent', onSetup (t) { return Pj(t, e) }, onAction () { return e.execCommand('outdent') } }), e.ui.registry.addButton('indent', { tooltip: 'Increase indent', icon: 'indent', onAction () { return e.execCommand('indent') } }) }; const Ij = function (e) { zj(e) }; const Lj = { register: Ij }; const Hj = function (e, t) { rF(e, t), lF(e, t), _F(e, t), EF(e, t), bF(e, t) }; const Fj = { register: Hj }; const Vj = function (e, t) { pj.register(e), kj.register(e), Fj.register(e, t), _j.register(e), cT.register(e), Mj.register(e), Lj.register(e) }; const Uj = { setup: Vj }; const jj = function (e, t) { return { anchor: 'makeshift', x: e, y: t } }; const Wj = function (e, t, n) { return jj(e.x + t, e.y + n) }; const qj = function (e) { return e.type === 'longpress' || e.type.indexOf('touch') === 0 }; const $j = function (e) { if (qj(e)) { const t = e.touches[0]; return jj(t.pageX, t.pageY) } return jj(e.pageX, e.pageY) }; const Gj = function (e) { if (qj(e)) { const t = e.touches[0]; return jj(t.clientX, t.clientY) } return jj(e.clientX, e.clientY) }; const Xj = function (e, t) { const n = Pw.DOM.getPos(e); return Wj(t, n.x, n.y) }; const Yj = function (e, t) { return t.type === 'contextmenu' || t.type === 'longpress' ? e.inline ? $j(t) : Xj(e.getContentAreaContainer(), Gj(t)) : Kj(e) }; var Kj = function (e) { return { anchor: 'selection', root: Wn.fromDom(e.selection.getNode()) } }; const Jj = function (e) { return { anchor: 'node', node: x.some(Wn.fromDom(e.selection.getNode())), root: Wn.fromDom(e.getBody()) } }; const Zj = function (e, t, n) { return n ? Jj(e) : Yj(e, t) }; const Qj = function (e, t, n, r, o, i) { const u = n(); const a = Zj(e, t, i); pB(u, IS.CLOSE_ON_EXECUTE, r, !1).map(function (e) { t.preventDefault(), Cw.showMenuAt(o, a, { menu: { markers: fT('normal') }, data: e }) }) }; const eW = { onLtr () { return [rl, Zs, Qs, el, tl, nl, Rw, Bw, Dw, Nw, Aw, _w] }, onRtl () { return [rl, Qs, Zs, tl, el, nl, Rw, Bw, Aw, _w, Dw, Nw] } }; const tW = 12; const nW = { valignCentre: [], alignCentre: [], alignLeft: ['tox-pop--align-left'], alignRight: ['tox-pop--align-right'], right: ['tox-pop--right'], left: ['tox-pop--left'], bottom: ['tox-pop--bottom'], top: ['tox-pop--top'] }; const rW = function (e, t) { const n = e.selection; if (n.isCollapsed() || t.touches.length < 1) { return !1 } const r = t.touches[0]; const o = n.getRng(); const i = Ed(e.getWin(), Jf.domRange(o)); return i.exists(function (e) { return e.left() <= r.clientX && e.right() >= r.clientX && e.top() <= r.clientY && e.bottom() >= r.clientY }) }; const oW = function (e, t, n) { const r = t ? Jj(e) : Yj(e, n); return m({ bubble: yf(0, tW, nW), layouts: eW, overrides: { maxWidthFunction: Gz(), maxHeightFunction: mf() } }, r) }; const iW = function (e) { const t = e.selection.getRng(); const n = function () { Mw.setEditorTimeout(e, function () { e.selection.setRng(t) }, 10), i() }; e.once('touchend', n); const r = function (e) { e.preventDefault(), e.stopImmediatePropagation() }; e.on('mousedown', r, !0); const o = function () { return i() }; e.once('longpresscancel', o); var i = function () { e.off('touchend', n), e.off('longpresscancel', o), e.off('mousedown', r) } }; const uW = function (e, t, n, r, o, i, u) { const a = oW(e, i, t); pB(n, IS.CLOSE_ON_EXECUTE, r, !0).map(function (n) { t.preventDefault(), Cw.showMenuWithinBounds(o, a, { menu: { markers: fT('normal'), highlightImmediately: u }, data: n, type: 'horizontal' }, function () { return x.some(PH(e)) }), e.fire(Yz) }) }; const aW = function (e, t, n, r, o, i) { const u = Vr(); const a = u.os.isiOS(); const c = u.os.isOSX(); const s = u.os.isAndroid(); const l = u.deviceType.isTouch(); const f = function () { return !(s || a || c && l) }; const d = function () { const u = n(); uW(e, t, u, r, o, i, f()) }; if (!c && !a || i) { s && !i && e.selection.setCursorLocation(t.target, 0), d() } else { const m = function () { iW(e), d() }; rW(e, t) ? m() : (e.once('selectionchange', m), e.once('touchend', function () { return e.off('selectionchange', m) })) } }; const cW = function (e) { return typeof e === 'string' ? e.split(/[ ,]/) : e }; const sW = function (e) { return e.settings.contextmenu_never_use_native || !1 }; const lW = function (e, t, n) { const r = e.ui.registry.getAll().contextMenus; return ye(e.settings, t).map(cW).getOrThunk(function () { return X(cW(n), function (e) { return we(r, e) }) }) }; const fW = function (e) { return !1 === e.getParam('contextmenu') }; const dW = function (e) { return lW(e, 'contextmenu', 'link linkchecker image imagetools table spellchecker configurepermanentpen') }; const mW = { shouldNeverUseNative: sW, getContextMenu: dW, isContextMenuDisabled: fW }; const gW = function (e) { return N(e) ? e === '|' : e.type === 'separator' }; const hW = { type: 'separator' }; var pW = function (e) { if (N(e)) { return e } switch (e.type) { case 'separator':return hW; case 'submenu':return { type: 'nestedmenuitem', text: e.text, icon: e.icon, getSubmenuItems () { const t = e.getSubmenuItems(); return N(t) ? t : W(t, pW) } }; default:return { type: 'menuitem', text: e.text, icon: e.icon, onAction: r(e.onAction) } } }; const vW = function (e, t) { if (t.length === 0) { return e } const n = ce(e).filter(function (e) { return !gW(e) }); const r = n.fold(function () { return [] }, function (e) { return [hW] }); return e.concat(r).concat(t).concat([hW]) }; const bW = function (e, t, n) { const r = K(t, function (t, r) { if (we(e, r)) { const o = e[r].update(n); if (N(o)) { return vW(t, o.split(' ')) } if (o.length > 0) { const i = W(o, pW); return vW(t, i) } return t } return t.concat([r]) }, []); return r.length > 0 && gW(r[r.length - 1]) && r.pop(), r }; const yW = function (e, t) { return t.ctrlKey && !mW.shouldNeverUseNative(e) }; const wW = function (e, t) { return t.type !== 'longpress' && (t.button !== 2 || t.target === e.getBody() && t.pointerType === '') }; const xW = function (e, t, n) { const r = Vr(); const o = r.deviceType.isTouch; const i = nc(Cw.sketch({ dom: { tag: 'div' }, lazySink: t, onEscape () { return e.focus() }, onShow () { return n.setContextMenuState(!0) }, onHide () { return n.setContextMenuState(!1) }, fireDismissalEventInstead: {}, inlineBehaviours: yl([cy('dismissContextMenu', [fi(Go(), function (t, n) { Jm.close(t), e.focus() })])]) })); const u = function (e) { return Cw.hide(i) }; const a = function (t) { if (mW.shouldNeverUseNative(e) && t.preventDefault(), !yW(e, t) && !mW.isContextMenuDisabled(e)) { const r = wW(e, t); const u = function () { const n = r ? e.selection.getStart(!0) : t.target; const o = e.ui.registry.getAll(); const i = mW.getContextMenu(e); return bW(o.contextMenus, i, n) }; const a = o() ? aW : Qj; a(e, t, u, n, i, r) } }; e.on('init', function () { const t = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (o() ? '' : ' ResizeWindow'); e.on(t, u), e.on('longpress contextmenu', a) }) }; const CW = Se.generate([{ offset: ['x', 'y'] }, { absolute: ['x', 'y'] }, { fixed: ['x', 'y'] }]); const SW = function (e) { return function (t) { return t.translate(-e.left(), -e.top()) } }; const kW = function (e) { return function (t) { return t.translate(e.left(), e.top()) } }; const TW = function (e) { return function (t, n) { return K(e, function (e, t) { return t(e) }, lc(t, n)) } }; const EW = function (e, t, n) { return e.fold(TW([kW(n), SW(t)]), TW([SW(t)]), TW([])) }; const OW = function (e, t, n) { return e.fold(TW([kW(n)]), TW([]), TW([kW(t)])) }; const NW = function (e, t, n) { return e.fold(TW([]), TW([SW(n)]), TW([kW(t), SW(n)])) }; const _W = function (e, t, n, r, o, i) { const u = OW(e, o, i); const a = OW(t, o, i); return Math.abs(u.left() - a.left()) <= n && Math.abs(u.top() - a.top()) <= r }; const DW = function (e, t, n, r, o, i) { const u = OW(e, o, i); const a = OW(t, o, i); const c = Math.abs(u.left() - a.left()); const s = Math.abs(u.top() - a.top()); return lc(c, s) }; const AW = function (e, t, n) { const r = e.fold(function (e, t) { return { position: x.some('absolute'), left: x.some(e + 'px'), top: x.some(t + 'px') } }, function (e, t) { return { position: x.some('absolute'), left: x.some(e - n.left() + 'px'), top: x.some(t - n.top() + 'px') } }, function (e, t) { return { position: x.some('fixed'), left: x.some(e + 'px'), top: x.some(t + 'px') } }); return m({ right: x.none(), bottom: x.none() }, r) }; const RW = function (e, t, n) { return e.fold(function (e, r) { return MW(e + t, r + n) }, function (e, r) { return PW(e + t, r + n) }, function (e, r) { return zW(e + t, r + n) }) }; const BW = function (e, t, n, r) { const o = function (e, o) { return function (i, u) { const a = e(t, n, r); return o(i.getOr(a.left()), u.getOr(a.top())) } }; return e.fold(o(NW, MW), o(OW, PW), o(EW, zW)) }; var MW = CW.offset; var PW = CW.absolute; var zW = CW.fixed; const IW = function (e, t) { const n = e.element(); const r = parseInt(su(n, t.leftAttr), 10); const o = parseInt(su(n, t.topAttr), 10); return isNaN(r) || isNaN(o) ? x.none() : x.some(lc(r, o)) }; const LW = function (e, t, n) { const r = e.element(); au(r, t.leftAttr, n.left() + 'px'), au(r, t.topAttr, n.top() + 'px') }; const HW = function (e, t) { const n = e.element(); du(n, t.leftAttr), du(n, t.topAttr) }; const FW = function (e, t, n, r) { return IW(e, t).fold(function () { return n }, function (e) { return zW(e.left() + r.left(), e.top() + r.top()) }) }; const VW = function (e, t, n, r, o, i) { const u = FW(e, t, n, r); const a = t.mustSnap ? WW(e, t, u, o, i) : qW(e, t, u, o, i); const c = EW(u, o, i); return LW(e, t, c), a.fold(function () { return { coord: zW(c.left(), c.top()), extra: x.none() } }, function (e) { return { coord: e.output(), extra: e.extra() } }) }; const UW = function (e, t) { HW(e, t) }; const jW = function (e, t, n, r) { return le(e, function (e) { const o = e.sensor(); const u = _W(t, o, e.range().left(), e.range().top(), n, r); return u ? x.some({ output: i(BW(e.output(), t, n, r)), extra: e.extra }) : x.none() }) }; var WW = function (e, t, n, r, o) { const u = t.getSnapPoints(e); const a = jW(u, n, r, o); return a.orThunk(function () { const e = K(u, function (e, t) { const i = t.sensor(); const u = DW(n, i, t.range().left(), t.range().top(), r, o); return e.deltas.fold(function () { return { deltas: x.some(u), snap: x.some(t) } }, function (n) { const r = (u.left() + u.top()) / 2; const o = (n.left() + n.top()) / 2; return r <= o ? { deltas: x.some(u), snap: x.some(t) } : e }) }, { deltas: x.none(), snap: x.none() }); return e.snap.map(function (e) { return { output: i(BW(e.output(), n, r, o)), extra: e.extra } }) }) }; var qW = function (e, t, n, r, o) { const i = t.getSnapPoints(e); return jW(i, n, r, o) }; const $W = function (e, t, n) { return { coord: BW(e.output(), e.output(), t, n), extra: e.extra() } }; const GW = function (e, t, n, r) { const o = t.getTarget(e.element()); if (t.repositionTarget) { const i = Ri(e.element()); const u = Oc(i); const a = aV(o); const c = $W(r, u, a); const s = AW(c.coord, u, a); Ma(o, s) } }; const XW = Object.freeze({ __proto__: null, snapTo: GW }); const YW = 'data-initial-z-index'; const KW = function (e) { Pi(e.element()).filter(ou).each(function (e) { const t = su(e, YW); fu(e, YW) ? Ra(e, 'z-index', t) : Fa(e, 'z-index'), du(e, YW) }) }; const JW = function (e) { Pi(e.element()).filter(ou).each(function (t) { Ia(t, 'z-index').each(function (e) { au(t, YW, e) }), Ra(t, 'z-index', Pa(e.element(), 'z-index')) }) }; const ZW = function (e, t) { e.getSystem().addToGui(t), JW(t) }; const QW = function (e) { KW(e), e.getSystem().removeFromGui(e) }; const eq = function (e, t, n) { return e.getSystem().build(RE.sketch({ dom: { styles: { left: '0px', top: '0px', width: '100%', height: '100%', position: 'fixed', 'z-index': '1000000000000000' }, classes: [t] }, events: n })) }; const tq = Tn('snaps', [cn('getSnapPoints'), xs('onSensor'), cn('leftAttr'), cn('topAttr'), On('lazyViewport', jc), On('mustSnap', !1)]); const nq = [On('useFixed', l), cn('blockerClass'), On('getTarget', u), On('onDrag', n), On('repositionTarget', !0), On('onDrop', n), Bn('getBounds', jc), tq]; const rq = function (e) { return Jh(Ia(e, 'left'), Ia(e, 'top'), Ia(e, 'position'), function (e, t, n) { const r = n === 'fixed' ? zW : MW; return r(parseInt(e, 10), parseInt(t, 10)) }).getOrThunk(function () { const t = mc(e); return PW(t.left(), t.top()) }) }; const oq = function (e, t, n, r, o) { const i = o.bounds; const u = OW(t, n, r); const a = Zl(u.left(), i.x(), i.x() + i.width() - o.width); const c = Zl(u.top(), i.y(), i.y() + i.height() - o.height); const s = PW(a, c); return t.fold(function () { const e = NW(s, n, r); return MW(e.left(), e.top()) }, function () { return s }, function () { const e = EW(s, n, r); return zW(e.left(), e.top()) }) }; const iq = function (e, t, n, r, o, i, u) { const a = t.fold(function () { const e = RW(n, i.left(), i.top()); const t = EW(e, r, o); return zW(t.left(), t.top()) }, function (t) { const u = VW(e, t, n, i, r, o); return u.extra.each(function (n) { t.onSensor(e, n) }), u.coord }); return oq(e, a, r, o, u) }; const uq = function (e, t, n, r) { const o = t.getTarget(e.element()); if (t.repositionTarget) { const i = Ri(e.element()); const u = Oc(i); const a = aV(o); const c = rq(o); const s = iq(e, t.snaps, c, u, a, r, n); const l = AW(s, u, a); Ma(o, l) }t.onDrag(e, o, r) }; const aq = function (e, t) { return { bounds: e.getBounds(), height: ac(t.element()), width: bc(t.element()) } }; const cq = function (e, t, n, r, o) { const i = n.update(r, o); const u = n.getStartData().getOrThunk(function () { return aq(t, e) }); i.each(function (n) { uq(e, t, u, n) }) }; const sq = function (e, t, n, r) { t.each(QW), n.snaps.each(function (t) { UW(e, t) }); const o = n.getTarget(e.element()); r.reset(), n.onDrop(e, o) }; const lq = function (e) { return function (t, n) { const r = function (e) { n.setStartData(aq(t, e)) }; return ai(h([fi(jo(), function (e) { n.getStartData().each(function () { return r(e) }) })], e(t, n, r))) } }; const fq = function (e) { return ai([fi(ho(), e.forceDrop), fi(bo(), e.drop), fi(po(), function (t, n) { e.move(n.event()) }), fi(vo(), e.delayDrop)]) }; const dq = function (e) { return x.from(lc(e.x(), e.y())) }; const mq = function (e, t) { return lc(t.left() - e.left(), t.top() - e.top()) }; const gq = Object.freeze({ __proto__: null, getData: dq, getDelta: mq }); const hq = function (e, t, n) { return [fi(ho(), function (r, o) { const i = o.event().raw(); if (i.button === 0) { o.stop(); const u = function () { return sq(r, x.some(s), e, t) }; const a = iE(u, 200); const c = { drop: u, delayDrop: a.schedule, forceDrop: u, move (n) { a.cancel(), cq(r, e, t, gq, n) } }; var s = eq(r, e.blockerClass, fq(c)); const l = function () { n(r), ZW(r, s) }; l() } })] }; const pq = h(nq, [Ts('dragger', { handlers: lq(hq) })]); const vq = function (e) { return ai([fi(lo(), e.forceDrop), fi(mo(), e.drop), fi(go(), e.drop), fi(fo(), function (t, n) { e.move(n.event()) })]) }; const bq = function (e) { const t = e[0]; return x.some(lc(t.clientX, t.clientY)) }; const yq = function (e) { const t = e.raw(); const n = t.touches; return n.length === 1 ? bq(n) : x.none() }; const wq = function (e, t) { return lc(t.left() - e.left(), t.top() - e.top()) }; const xq = Object.freeze({ __proto__: null, getData: yq, getDelta: wq }); const Cq = function (e, t, n) { const r = Ln(x.none()); return [fi(lo(), function (o, i) { i.stop(); const u = function () { sq(o, r.get(), e, t), r.set(x.none()) }; const a = { drop: u, delayDrop () {}, forceDrop: u, move (n) { cq(o, e, t, xq, n) } }; const c = eq(o, e.blockerClass, vq(a)); r.set(x.some(c)); const s = function () { n(o), ZW(o, c) }; s() }), fi(fo(), function (n, r) { r.stop(), cq(n, e, t, xq, r.event()) }), fi(mo(), function (n, o) { o.stop(), sq(n, r.get(), e, t), r.set(x.none()) }), fi(go(), function (n) { sq(n, r.get(), e, t), r.set(x.none()) })] }; const Sq = h(nq, [Ts('dragger', { handlers: lq(Cq) })]); const kq = function (e, t, n) { return h(hq(e, t, n), Cq(e, t, n)) }; const Tq = h(nq, [Ts('dragger', { handlers: lq(kq) })]); const Eq = pq; const Oq = Sq; const Nq = Tq; const _q = Object.freeze({ __proto__: null, mouse: Eq, touch: Oq, mouseOrTouch: Nq }); const Dq = function () { let e = x.none(); let t = x.none(); const n = function () { e = x.none(), t = x.none() }; const r = function (t, n) { const r = e.map(function (e) { return t.getDelta(e, n) }); return e = x.some(n), r }; const o = function (e, t) { return e.getData(t).bind(function (t) { return r(e, t) }) }; const u = function (e) { t = x.some(e) }; const a = function () { return t }; const c = i({}); return Uu({ readState: c, reset: n, update: o, getStartData: a, setStartData: u }) }; const Aq = Object.freeze({ __proto__: null, init: Dq }); const Rq = Sl({ branchKey: 'mode', branches: _q, name: 'dragging', active: { events (e, t) { const n = e.dragger; return n.handlers(e, t) } }, extra: { snap: Ai(['sensor', 'range', 'output'], ['extra']) }, state: Aq, apis: XW }); const Bq = Vr(); const Mq = 40; const Pq = Mq / 2; const zq = function (e, t, n, r, o, i) { return e.fold(function () { return Rq.snap({ sensor: PW(n - Pq, r - Pq), range: lc(o, i), output: PW(x.some(n), x.some(r)), extra: { td: t } }) }, function (e) { const o = n - Pq; const i = r - Pq; const u = Mq; const a = Mq; const c = e.element().dom().getBoundingClientRect(); return Rq.snap({ sensor: PW(o, i), range: lc(u, a), output: PW(x.some(n - c.width / 2), x.some(r - c.height / 2)), extra: { td: t } }) }) }; const Iq = function (e, t, n) { const r = function (e, t) { return e.exists(function (e) { return Jr(e, t) }) }; return { getSnapPoints: e, leftAttr: 'data-drag-left', topAttr: 'data-drag-top', onSensor (e, o) { const i = o.td; r(t.get(), i) || (t.set(x.some(i)), n(i)) }, mustSnap: !0 } }; const Lq = function (e) { return dx(fx.sketch({ dom: { tag: 'div', classes: ['tox-selector'] }, buttonBehaviours: yl([Rq.config({ mode: 'mouseOrTouch', blockerClass: 'blocker', snaps: e }), cN.config({})]), eventOrder: { mousedown: ['dragging', 'alloy.base.behaviour'], touchstart: ['dragging', 'alloy.base.behaviour'] } })) }; const Hq = function (e, t) { const n = Ln([]); const r = Ln([]); const o = Ln(!1); const i = Ln(x.none()); const u = Ln(x.none()); const a = function (e) { const n = Uc(e); return zq(m.getOpt(t), e, n.x(), n.y(), n.width(), n.height()) }; const c = function () { return W(n.get(), function (e) { return a(e) }) }; const s = function (e) { const n = Uc(e); return zq(g.getOpt(t), e, n.right(), n.bottom(), n.width(), n.height()) }; const l = function () { return W(r.get(), function (e) { return s(e) }) }; const f = Iq(c, i, function (t) { u.get().each(function (n) { e.fire('TableSelectorChange', { start: t, finish: n }) }) }); const d = Iq(l, u, function (t) { i.get().each(function (n) { e.fire('TableSelectorChange', { start: n, finish: t }) }) }); var m = Lq(f); var g = Lq(d); const h = nc(m.asSpec()); const p = nc(g.asSpec()); const v = function (t, n, r, o) { const i = n.dom().getBoundingClientRect(); Fa(t.element(), 'display'); const u = Mi(Wn.fromDom(e.getBody())).dom().innerHeight; const a = r(i); const c = o(i, u); (a || c) && Ra(t.element(), 'display', 'none') }; const b = function (e, t, n, r) { const o = n(t); Rq.snapTo(e, o); const i = function (e) { return e[r] < 0 }; const u = function (e, t) { return e[r] > t }; v(e, t, i, u) }; const y = function (e) { return b(h, e, a, 'top') }; const w = function () { return i.get().each(y) }; const C = function (e) { return b(p, e, s, 'bottom') }; const S = function () { return u.get().each(C) }; Bq.deviceType.isTouch() && (e.on('TableSelectionChange', function (e) { o.get() || (Sm(t, h), Sm(t, p), o.set(!0)), i.set(x.some(e.start)), u.set(x.some(e.finish)), e.otherCells.each(function (t) { n.set(t.upOrLeftCells), r.set(t.downOrRightCells), y(e.start), C(e.finish) }) }), e.on('ResizeEditor ResizeWindow ScrollContent', function () { w(), S() }), e.on('TableSelectionClear', function () { o.get() && (Em(h), Em(p), o.set(!1)), i.set(x.none()), u.set(x.none()) })) }; const Fq = { setup: Hq }; (function (e) { e[e.None = 0] = 'None', e[e.Both = 1] = 'Both', e[e.Vertical = 2] = 'Vertical' })(JH || (JH = {})); const Vq = function (e, t, n, r, o) { const i = {}; return i.height = aj.calcCappedSize(r + t.top(), jw(e), qw(e)), n === JH.Both && (i.width = aj.calcCappedSize(o + t.left(), Uw(e), Ww(e))), i }; const Uq = function (e, t, n) { const r = Wn.fromDom(e.getContainer()); const o = Vq(e, t, n, uc(r), vc(r)); me(o, function (e, t) { return Ra(r, t, aj.numToPx(e)) }), $k.fireResizeEditor(e) }; const jq = function (e) { if (e.nodeType === 1) { if (e.nodeName === 'BR' || e.getAttribute('data-mce-bogus')) { return !0 } if (e.getAttribute('data-mce-type') === 'bookmark') { return !0 } } return !1 }; const Wq = function (e, t) { t.delimiter || (t.delimiter = '»'); const n = function (n) { const r = n || []; const o = W(r, function (t, n) { return fx.sketch({ dom: { tag: 'div', classes: ['tox-statusbar__path-item'], attributes: { role: 'button', 'data-index': n, 'tab-index': -1, 'aria-level': n + 1 }, innerHtml: t.name }, action (n) { e.focus(), e.selection.select(t.element), e.nodeChanged() } }) }); const i = { dom: { tag: 'div', classes: ['tox-statusbar__path-divider'], attributes: { 'aria-hidden': !0 }, innerHtml: ' ' + t.delimiter + ' ' } }; return K(o.slice(1), function (e, t) { const n = e; return n.push(i), n.push(t), n }, [o[0]]) }; const r = function (t) { const n = []; let r = t.length; while (r-- > 0) { const o = t[r]; if (o.nodeType === 1 && !jq(o)) { const i = e.fire('ResolveName', { name: o.nodeName.toLowerCase(), target: o }); if (i.isDefaultPrevented() || n.push({ name: i.name, element: o }), i.isPropagationStopped()) { break } } } return n }; return { dom: { tag: 'div', classes: ['tox-statusbar__path'], attributes: { role: 'navigation' } }, behaviours: yl([Kb.config({ mode: 'flow', selector: 'div[role=button]' }), NO.config({}), uy.config({}), cy('elementPathEvents', [xi(function (t, o) { e.shortcuts.add('alt+F11', 'focus statusbar elementpath', function () { return Kb.focusIn(t) }), e.on('NodeChange', function (e) { const o = r(e.parents); o.length > 0 ? uy.set(t, n(o)) : uy.set(t, []) }) })])]), components: [] } }; const qq = { renderElementPath: Wq }; const $q = function (e, t) { const n = function (e, n, r) { return uy.set(e, [Qa(t.translate(['{0} ' + r, n[r]]))]) }; return fx.sketch({ dom: { tag: 'button', classes: ['tox-statusbar__wordcount'] }, components: [], buttonBehaviours: yl([NO.config({}), uy.config({}), Bg.config({ store: { mode: 'memory', initialValue: { mode: 'words', count: { words: 0, characters: 0 } } } }), cy('wordcount-events', [ki(function (e) { const t = Bg.getValue(e); const r = t.mode === 'words' ? 'characters' : 'words'; Bg.setValue(e, { mode: r, count: t.count }), n(e, t.count, r) }), xi(function (t) { e.on('wordCountUpdate', function (e) { const r = Bg.getValue(t).mode; Bg.setValue(t, { mode: r, count: e.wordCount }), n(t, e.wordCount, r) }) })])]) }) }; const Gq = function (e, t) { const n = function (n) { return { dom: { tag: 'div', classes: ['tox-statusbar__resize-handle'], attributes: { title: t.translate('Resize'), 'aria-hidden': 'true' }, innerHtml: gx('resize-handle', t.icons) }, behaviours: yl([Rq.config({ mode: 'mouse', repositionTarget: !1, onDrag (t, r, o) { Uq(e, o, n) }, blockerClass: 'tox-blocker' })]) } }; const r = function () { const e = BC.translate(['Powered by {0}', 'Tiny']); const t = '<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5" rel="noopener" target="_blank" tabindex="-1" aria-label="' + e + '">' + e + '</a>'; return { dom: { tag: 'span', classes: ['tox-statusbar__branding'], innerHtml: t } } }; const o = function (e) { const t = !_r(e.settings.plugins, 'autoresize'); const n = e.getParam('resize', t); return !1 === n ? JH.None : n === 'both' ? JH.Both : JH.Vertical }; const i = function () { const n = []; return e.getParam('elementpath', !0, 'boolean') && n.push(qq.renderElementPath(e, {})), _r(e.settings.plugins, 'wordcount') && n.push($q(e, t)), e.getParam('branding', !0, 'boolean') && n.push(r()), n.length > 0 ? [{ dom: { tag: 'div', classes: ['tox-statusbar__text-container'] }, components: n }] : [] }; const u = function () { const t = i(); const r = o(e); return r !== JH.None && t.push(n(r)), t }; return { dom: { tag: 'div', classes: ['tox-statusbar'] }, components: u() } }; const Xq = function (e) { let t; const n = e.inline; const r = n ? gj : rj; const o = cx(e) ? KV : eU; let i = x.none(); const u = Vr(); const a = u.browser.isIE(); const c = a ? ['tox-platform-ie'] : []; const s = u.deviceType.isTouch(); const l = 'tox-platform-touch'; const f = s ? [l] : []; const d = nx(e); const g = BC.isRtl() ? { attributes: { dir: 'rtl' } } : {}; const h = { attributes: (t = {}, t[kf] = d ? os.TopToBottom : os.BottomToTop, t) }; const p = function () { return i.bind(HU.getHeader) }; const v = function () { return o.isDocked(p) }; const b = nc({ dom: m({ tag: 'div', classes: ['tox', 'tox-silver-sink', 'tox-tinymce-aux'].concat(c).concat(f) }, g), behaviours: yl([vm.config({ useFixed () { return v() } })]) }); const y = function () { return T.value(b) }; const w = dx({ dom: { tag: 'div', classes: ['tox-anchorbar'] } }); const C = function () { return i.bind(function (e) { return w.getOpt(e) }).getOrDie('Could not find a anchor bar element') }; const S = function () { return i.bind(function (e) { return HU.getToolbar(e) }).getOrDie('Could not find more toolbar element') }; const k = function () { return i.bind(function (e) { return HU.getThrobber(e) }).getOrDie('Could not find throbber element') }; const E = $z(b, e, C); const O = HU.parts().menubar({ dom: { tag: 'div', classes: ['tox-menubar'] }, backstage: E, onEscape () { e.focus() } }); const N = ex(e); const _ = HU.parts().toolbar(m({ dom: { tag: 'div', classes: ['tox-toolbar'] }, getSink: y, backstage: E, onEscape () { e.focus() }, type: N, lazyToolbar: S, lazyHeader () { return p().getOrDie('Could not find header element') } }, h)); const D = HU.parts()['multiple-toolbar']({ dom: { tag: 'div', classes: ['tox-toolbar-overlord'] }, onEscape () {}, type: N }); const A = HU.parts().socket({ dom: { tag: 'div', classes: ['tox-edit-area'] } }); const R = HU.parts().sidebar({ dom: { tag: 'div', classes: ['tox-sidebar'] } }); const B = HU.parts().throbber({ dom: { tag: 'div', classes: ['tox-throbber'] }, backstage: E }); const M = e.getParam('statusbar', !0, 'boolean'); const P = M && !n ? x.some(Gq(e, E.shared.providers)) : x.none(); const z = { dom: { tag: 'div', classes: ['tox-sidebar-wrap'] }, components: [A, R] }; const I = Zw(e); const L = Kw(e); const H = Yw(e); const F = function () { return I ? [D] : L ? [_] : [] }; const V = HU.parts().header({ dom: m({ tag: 'div', classes: ['tox-editor-header'] }, h), components: Q([H ? [O] : [], F(), ix(e) ? [] : [w.asSpec()]]), sticky: cx(e), editor: e, getSink: y }); const U = Q([d ? [V] : [], n ? [] : [z], d ? [] : [V]]); const j = { dom: { tag: 'div', classes: ['tox-editor-container'] }, components: U }; const W = Q([[j], n ? [] : P.toArray(), [B]]); const q = ax(e); const $ = m(m({ role: 'application' }, BC.isRtl() ? { dir: 'rtl' } : {}), q ? { 'aria-hidden': 'true' } : {}); const G = nc(HU.sketch({ dom: { tag: 'div', classes: ['tox', 'tox-tinymce'].concat(n ? ['tox-tinymce-inline'] : []).concat(d ? [] : ['tox-tinymce--toolbar-bottom']).concat(f).concat(c), styles: m({ visibility: 'hidden' }, q ? { opacity: '0', border: '0' } : {}), attributes: $ }, components: W, behaviours: yl([Kb.config({ mode: 'cyclic', selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a' })]) })); i = x.some(G), e.shortcuts.add('alt+F9', 'focus menubar', function () { HU.focusMenubar(G) }), e.shortcuts.add('alt+F10', 'focus toolbar', function () { HU.focusToolbar(G) }); const X = BE(G); const Y = BE(b); KF.setup(e, X, Y); const K = function () { const e = { broadcastAll: Y.broadcast, broadcastOn: Y.broadcastOn, register () {} }; return { channels: e } }; const J = function () { const t = aj.numToPx(sj(e)); const n = aj.numToPx(fj(e)); return e.inline || (Ha('div', 'width', n) && Ra(G.element(), 'width', n), Ha('div', 'height', t) ? Ra(G.element(), 'height', t) : Ra(G.element(), 'height', '200px')), t }; const Z = function () { o.setup(e, p), Uj.setup(e, E), xW(e, y, E), mU(e), _U(e, k, E.shared), ge(tx(e), function (t, n) { e.ui.registry.addGroupToolbarButton(n, t) }); const t = e.ui.registry.getAll(); const n = t.buttons; const i = t.menuItems; const u = t.contextToolbars; const a = t.sidebars; const c = Jw(e); const s = { menuItems: i, menus: e.settings.menu ? ge(e.settings.menu, function (e) { return m(m({}, e), { items: e.items }) }) : {}, menubar: e.settings.menubar, toolbar: c.getOrThunk(function () { return e.getParam('toolbar', !0) }), allowToolbarGroups: N === $p.floating, buttons: n, sidebar: a }; XF.register(e, u, b, { backstage: E }), Fq.setup(e, b); const l = e.getElement(); const f = J(); const d = { mothership: X, uiMothership: Y, outerContainer: G }; const g = { targetNode: l, height: f }; return r.render(e, d, s, E, g) }; return { mothership: X, uiMothership: Y, backstage: E, renderUI: Z, getUi: K } }; const Yq = { setup: Xq }; const Kq = function (e, t) { const n = x.from(su(e, 'id')).fold(function () { const e = xu('dialog-describe'); return au(t, 'id', e), e }, u); au(e, 'aria-describedby', n) }; const Jq = { labelledBy (e, t) { const n = x.from(su(e, 'id')).fold(function () { const e = xu('dialog-label'); return au(t, 'id', e), e }, u); au(e, 'aria-labelledby', n) } }; const Zq = i([cn('lazySink'), yn('dragBlockClass'), Bn('getBounds', jc), On('useTabstopAt', i(!0)), On('eventOrder', {}), Mg('modalBehaviours', [Kb]), Cs('onExecute'), ks('onEscape')]); const Qq = { sketch: u }; const e$ = i([gh({ name: 'draghandle', overrides (e, t) { return { behaviours: yl([Rq.config({ mode: 'mouse', getTarget (e) { return Kc(e, '[role="dialog"]').getOr(e) }, blockerClass: e.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \n' + JSON.stringify(t, null, 2)).message), getBounds: e.getDragBounds })]) } } }), dh({ schema: [cn('dom')], name: 'title' }), dh({ factory: Qq, schema: [cn('dom')], name: 'close' }), dh({ factory: Qq, schema: [cn('dom')], name: 'body' }), gh({ factory: Qq, schema: [cn('dom')], name: 'footer' }), mh({ factory: { sketch (e, t) { return m(m({}, e), { dom: t.dom, components: t.components }) } }, schema: [On('dom', { tag: 'div', styles: { position: 'fixed', left: '0px', top: '0px', right: '0px', bottom: '0px' } }), On('components', [])], name: 'blocker' })]); const t$ = function (e, t, n, r) { const o = xu('alloy.dialog.busy'); const i = xu('alloy.dialog.idle'); const u = yl([Kb.config({ mode: 'special', onTab () { return x.some(!0) }, onShiftTab () { return x.some(!0) } }), vy.config({})]); const a = function (t) { const n = e.lazySink(t).getOrDie(); const a = Ln(x.none()); const c = r.blocker(); const s = n.getSystem().build(m(m({}, c), { components: c.components.concat([rc(t)]), behaviours: yl([vy.config({}), cy('dialog-blocker-events', [wi(wo(), function () { Kb.focusIn(t) }), fi(i, function (e, n) { fu(t.element(), 'aria-busy') && (du(t.element(), 'aria-busy'), a.get().each(function (e) { return uy.remove(t, e) })) }), fi(o, function (e, n) { au(t.element(), 'aria-busy', 'true'); const r = n.event().getBusySpec(); a.get().each(function (e) { uy.remove(t, e) }); const o = r(t, u); const i = e.getSystem().build(o); a.set(x.some(i)), uy.append(t, rc(i)), i.hasConfigured(Kb) && Kb.focusIn(i) })])]) })); Sm(n, s), Kb.focusIn(t) }; const c = function (e) { Pi(e.element()).each(function (t) { e.getSystem().getByDom(t).each(function (e) { Em(e) }) }) }; const s = function (t) { return Nh(t, e, 'body') }; const l = function (t) { return Nh(t, e, 'footer') }; const f = function (e, t) { ni(e, o, { getBusySpec: t }) }; const d = function (e) { ti(e, i) }; const g = xu('modal-events'); const h = m(m({}, e.eventOrder), { 'alloy.system.attached': [g].concat(e.eventOrder['alloy.system.attached'] || []) }); return { uid: e.uid, dom: e.dom, components: t, apis: { show: a, hide: c, getBody: s, getFooter: l, setIdle: d, setBusy: f }, eventOrder: h, domModification: { attributes: { role: 'dialog', 'aria-modal': 'true' } }, behaviours: zg(e.modalBehaviours, [uy.config({}), Kb.config({ mode: 'cyclic', onEnter: e.onExecute, onEscape: e.onEscape, useTabstopAt: e.useTabstopAt }), cy(g, [xi(function (t) { Jq.labelledBy(t.element(), Nh(t, e, 'title').element()), Kq(t.element(), Nh(t, e, 'body').element()) })])]) } }; const n$ = Gh({ name: 'ModalDialog', configFields: Zq(), partFields: e$(), factory: t$, apis: { show (e, t) { e.show(t) }, hide (e, t) { e.hide(t) }, getBody (e, t) { return e.getBody(t) }, getFooter (e, t) { return e.getFooter(t) }, setBusy (e, t, n) { e.setBusy(t, n) }, setIdle (e, t) { e.setIdle(t) } } }); const r$ = [fn('type'), fn('text'), dn('level', ['info', 'warn', 'error', 'success']), fn('icon'), On('url', '')]; const o$ = _t(r$); const i$ = function (e) { return [fn('type'), e] }; const u$ = [fn('type'), fn('text'), Rn('disabled', !1), Rn('primary', !1), zt('name', 'name', Ge(function () { return xu('button-name') }), tn), Cn('icon'), Rn('borderless', !1)]; const a$ = _t(u$); const c$ = [fn('type'), fn('name'), fn('label'), Rn('disabled', !1)]; const s$ = _t(c$); const l$ = nn; const f$ = [fn('type'), fn('name')]; const d$ = f$.concat([Cn('label')]); const m$ = d$; const g$ = _t(m$); const h$ = tn; const p$ = d$; const v$ = _t(p$); const b$ = tn; const y$ = d$; const w$ = _t(y$); const x$ = Vt(); const C$ = function (e) { return [fn('type'), ln('columns'), e] }; const S$ = d$.concat([Rn('sandboxed', !0)]); const k$ = _t(S$); const T$ = tn; const E$ = d$.concat([Cn('inputMode'), Cn('placeholder'), Rn('maximized', !1), Rn('disabled', !1)]); const O$ = _t(E$); const N$ = tn; const _$ = d$.concat([vn('items', [fn('text'), fn('value')]), _n('size', 1), Rn('disabled', !1)]); const D$ = _t(_$); const A$ = tn; const R$ = d$.concat([Rn('constrain', !0), Rn('disabled', !1)]); const B$ = _t(R$); const M$ = _t([fn('width'), fn('height')]); const P$ = d$.concat([Cn('placeholder'), Rn('maximized', !1), Rn('disabled', !1)]); const z$ = _t(P$); const I$ = tn; const L$ = d$.concat([An('filetype', 'file', ['image', 'media', 'file']), On('disabled', !1)]); const H$ = _t(L$); const F$ = _t([fn('value'), On('meta', {})]); const V$ = f$.concat([Dn('tag', 'textarea'), fn('scriptId'), fn('scriptUrl'), Mn('settings', void 0)]); const U$ = f$.concat([Dn('tag', 'textarea'), gn('init')]); const j$ = jt(function (e) { return $t('customeditor.old', Nt(U$), e).orThunk(function () { return $t('customeditor.new', Nt(V$), e) }) }); const W$ = tn; const q$ = [fn('type'), fn('html'), An('presets', 'presentation', ['presentation', 'document'])]; const $$ = _t(q$); const G$ = d$.concat([sn('currentState', _t([cn('blob'), fn('url')]))]); const X$ = _t(G$); const Y$ = d$.concat([On('columns', 'auto')]); const K$ = _t(Y$); const J$ = Ft([fn('value'), fn('text'), fn('icon')]); const Z$ = function (e) { return [fn('type'), fn('label'), e] }; const Q$ = [fn('type'), bn('header', tn), bn('cells', Dt(tn))]; const eG = _t(Q$); const tG = function (e) { return zt('items', 'items', qe(), Dt(jt(function (t) { return $t('Checking item of ' + e, nG, t).fold(function (e) { return T.error(Yt(e)) }, function (e) { return T.value(e) }) }))) }; var nG = Ut(function () { return Kt('type', { alertbanner: o$, bar: _t(i$(tG('bar'))), button: a$, checkbox: s$, colorinput: g$, colorpicker: v$, dropzone: w$, grid: _t(C$(tG('grid'))), iframe: k$, input: O$, selectbox: D$, sizeinput: B$, textarea: z$, urlinput: H$, customeditor: j$, htmlpanel: $$, imagetools: X$, collection: K$, label: _t(Z$(tG('label'))), table: eG, panel: oG }) }); const rG = [fn('type'), On('classes', []), bn('items', nG)]; var oG = _t(rG); const iG = [zt('name', 'name', Ge(function () { return xu('tab-name') }), tn), fn('title'), bn('items', nG)]; const uG = [fn('type'), vn('tabs', iG)]; const aG = _t(uG); const cG = _t([fn('type'), fn('name')].concat(iC)); const sG = nn; const lG = [zt('name', 'name', Ge(function () { return xu('button-name') }), tn), Cn('icon'), An('align', 'end', ['start', 'end']), Rn('primary', !1), Rn('disabled', !1)]; const fG = h(lG, [fn('text')]); const dG = h([dn('type', ['submit', 'cancel', 'custom'])], fG); const mG = h([dn('type', ['menu']), Cn('text'), Cn('tooltip'), Cn('icon'), bn('items', cG)], lG); const gG = Jt('type', { submit: dG, cancel: dG, custom: dG, menu: mG }); const hG = fG; const pG = gG; const vG = _t([fn('title'), sn('body', Kt('type', { panel: oG, tabpanel: aG })), Dn('size', 'normal'), bn('buttons', pG), On('initialData', {}), Bn('onAction', n), Bn('onChange', n), Bn('onSubmit', n), Bn('onClose', n), Bn('onCancel', n), On('onTabChange', n)]); const bG = function (e) { return $t('dialog', vG, e) }; var yG = function (e) { return _(e) ? [e].concat(ee(be(e), yG)) : D(e) ? ee(e, yG) : [] }; const wG = function (e) { return N(e.type) && N(e.name) }; const xG = { checkbox: l$, colorinput: h$, colorpicker: b$, dropzone: x$, input: N$, iframe: T$, sizeinput: M$, selectbox: A$, size: M$, textarea: I$, urlinput: F$, customeditor: W$, collection: J$, togglemenuitem: sG }; const CG = function (e) { return x.from(xG[e.type]) }; const SG = function (e) { return X(yG(e), wG) }; const kG = function (e) { const t = SG(e); const n = ee(t, function (e) { return CG(e).fold(function () { return [] }, function (t) { return [sn(e.name, t)] }) }); return _t(n) }; const TG = _t(h([dn('type', ['cancel', 'custom'])], hG)); const EG = _t([fn('title'), fn('url'), xn('height'), xn('width'), kn('buttons', TG), Bn('onAction', n), Bn('onCancel', n), Bn('onClose', n), Bn('onMessage', n)]); const OG = function (e) { return $t('dialog', EG, e) }; const NG = function (e) { const t = Gt(bG(e)); const n = kG(e); const r = e.initialData; return { internalDialog: t, dataValidator: n, initialData: r } }; const _G = { open (e, t) { const n = NG(t); return e(n.internalDialog, n.initialData, n.dataValidator) }, openUrl (e, t) { const n = Gt(OG(t)); return e(n) }, redial (e) { return NG(e) } }; const DG = function () { const e = Ln(x.none()); const t = function () { e.set(x.none()) }; const n = function (t) { e.set(x.some(t)) }; const r = function (t) { e.get().each(t) }; const o = function () { return e.get().isSome() }; return { clear: t, set: n, isSet: o, on: r } }; const AG = function (e) { const t = []; const n = {}; return me(e, function (e, r) { e.fold(function () { t.push(r) }, function (e) { n[r] = e }) }), t.length > 0 ? T.error(t) : T.value(n) }; const RG = function (e, n) { const r = dx(rA.sketch(function (t) { return { dom: { tag: 'div', classes: ['tox-form'].concat(e.classes) }, components: W(e.items, function (e) { return NP(t, e, n) }) } })); return { dom: { tag: 'div', classes: ['tox-dialog__body'] }, components: [{ dom: { tag: 'div', classes: ['tox-dialog__body-content'] }, components: [r.asSpec()] }], behaviours: yl([Kb.config({ mode: 'acyclic', useTabstopAt: c(VA.isPseudoStop) }), gA.memento(r), _A.memento(r, { postprocess (e) { return AG(e).fold(function (e) { return t.console.error(e), {} }, function (e) { return e }) } })]) } }; const BG = function (e, t) { return { uid: e.uid, dom: e.dom, components: e.components, events: Ly(e.action), behaviours: zg(e.tabButtonBehaviours, [vy.config({}), Kb.config({ mode: 'execution', useSpace: !0, useEnter: !0 }), Bg.config({ store: { mode: 'memory', initialValue: e.value } })]), domModification: e.domModification } }; const MG = $h({ name: 'TabButton', configFields: [On('uid', void 0), cn('value'), zt('dom', 'dom', Xe(function () { return { attributes: { role: 'tab', id: xu('aria'), 'aria-selected': 'false' } } }), Zt()), yn('action'), On('domModification', {}), Mg('tabButtonBehaviours', [vy, Kb, Bg]), cn('view')], factory: BG }); const PG = i([cn('tabs'), cn('dom'), On('clickToDismiss', !1), Mg('tabbarBehaviours', [Cp, Kb]), ys(['tabClass', 'selectedClass'])]); const zG = hh({ factory: MG, name: 'tabs', unit: 'tab', overrides (e) { const t = function (e, t) { Cp.dehighlight(e, t), ni(e, Zo(), { tabbar: e, button: t }) }; const r = function (e, t) { Cp.highlight(e, t), ni(e, Jo(), { tabbar: e, button: t }) }; return { action (o) { const i = o.getSystem().getByUid(e.uid).getOrDie(); const u = Cp.isHighlighted(i, o); const a = (function () { return u && e.clickToDismiss ? t : u ? n : r }()); a(i, o) }, domModification: { classes: [e.markers.tabClass] } } } }); const IG = i([zG]); const LG = function (e, t, n, r) { return { uid: e.uid, dom: e.dom, components: t, 'debug.sketcher': 'Tabbar', domModification: { attributes: { role: 'tablist' } }, behaviours: zg(e.tabbarBehaviours, [Cp.config({ highlightClass: e.markers.selectedClass, itemClass: e.markers.tabClass, onHighlight (e, t) { au(t.element(), 'aria-selected', 'true') }, onDehighlight (e, t) { au(t.element(), 'aria-selected', 'false') } }), Kb.config({ mode: 'flow', getInitial (e) { return Cp.getHighlighted(e).map(function (e) { return e.element() }) }, selector: '.' + e.markers.tabClass, executeOnMove: !0 })]) } }; const HG = Gh({ name: 'Tabbar', configFields: PG(), partFields: IG(), factory: LG }); const FG = function (e, t) { return { uid: e.uid, dom: e.dom, behaviours: zg(e.tabviewBehaviours, [uy.config({})]), domModification: { attributes: { role: 'tabpanel' } } } }; const VG = $h({ name: 'Tabview', configFields: [Mg('tabviewBehaviours', [uy])], factory: FG }); const UG = i([On('selectFirst', !0), xs('onChangeTab'), xs('onDismissTab'), On('tabs', []), Mg('tabSectionBehaviours', [])]); const jG = dh({ factory: HG, schema: [cn('dom'), pn('markers', [cn('tabClass'), cn('selectedClass')])], name: 'tabbar', defaults (e) { return { tabs: e.tabs } } }); const WG = dh({ factory: VG, name: 'tabview' }); const qG = i([jG, WG]); const $G = function (e, t, n, r) { const o = function (t) { const n = Bg.getValue(t); Oh(t, e, 'tabview').each(function (r) { const o = J(e.tabs, function (e) { return e.value === n }); o.each(function (n) { const o = n.view(); lu(t.element(), 'id').each(function (e) { au(r.element(), 'aria-labelledby', e) }), uy.set(r, o), e.onChangeTab(r, t, o) }) }) }; const i = function (t, n) { Oh(t, e, 'tabbar').each(function (e) { n(e).each(ri) }) }; return { uid: e.uid, dom: e.dom, components: t, behaviours: Pg(e.tabSectionBehaviours), events: ai(Q([e.selectFirst ? [xi(function (e, t) { i(e, Cp.getFirst) })] : [], [fi(Jo(), function (e, t) { const n = t.event().button(); o(n) }), fi(Zo(), function (t, n) { const r = n.event().button(); e.onDismissTab(t, r) })]])), apis: { getViewItems (t) { return Oh(t, e, 'tabview').map(function (e) { return uy.contents(e) }).getOr([]) }, showTab (e, t) { const n = function (e) { const n = Cp.getCandidates(e); const r = J(n, function (e) { return Bg.getValue(e) === t }); return r.filter(function (t) { return !Cp.isHighlighted(e, t) }) }; i(e, n) } } } }; const GG = Gh({ name: 'TabSection', configFields: UG(), partFields: qG(), factory: $G, apis: { getViewItems (e, t) { return e.getViewItems(t) }, showTab (e, t, n) { e.showTab(t, n) } } }); const XG = function (e, t, n) { return W(e, function (r, o) { uy.set(n, e[o].view()); const i = t.dom().getBoundingClientRect(); return uy.set(n, []), i.height }) }; const YG = function (e) { return ae(ue(e, function (e, t) { return e > t ? -1 : e < t ? 1 : 0 })) }; const KG = function (e, n, r) { let o; const i = Bi(e).dom(); const u = Kc(e, '.tox-dialog-wrap').getOr(e); const a = Pa(u, 'position') === 'fixed'; o = a ? Math.max(i.clientHeight, t.window.innerHeight) : Math.max(i.offsetHeight, i.scrollHeight); const c = uc(n); const s = n.dom().offsetLeft >= r.dom().offsetLeft + vc(r); const l = s ? Math.max(uc(r), c) : c; const f = parseInt(Pa(e, 'margin-top'), 10) || 0; const d = parseInt(Pa(e, 'margin-bottom'), 10) || 0; const m = uc(e) + f + d; const g = m - l; return o - g }; const JG = function (e, t) { ae(e).each(function (e) { return GG.showTab(t, e.value) }) }; const ZG = function (e, t) { Ra(e, 'height', t + 'px'), Vr().browser.isIE() ? Fa(e, 'flex-basis') : Ra(e, 'flex-basis', t + 'px') }; const QG = function (e, t, n) { Kc(e, '[role="dialog"]').each(function (e) { Jc(e, '[role="tablist"]').each(function (r) { n.get().map(function (n) { return Ra(t, 'height', '0'), Ra(t, 'flex-basis', '0'), Math.min(n, KG(e, t, r)) }).each(function (e) { ZG(t, e) }) }) }) }; const eX = function (e) { return Jc(e, '[role="tabpanel"]') }; const tX = function (e) { const t = (function () { const t = Ln(x.none()); const n = [xi(function (n) { const r = n.element(); eX(r).each(function (o) { Ra(o, 'visibility', 'hidden'), n.getSystem().getByDom(o).toOption().each(function (n) { const r = XG(e, o, n); const i = YG(r); t.set(i) }), QG(r, o, t), Fa(o, 'visibility'), JG(e, n), Mw.requestAnimationFrame(function () { QG(r, o, t) }) }) }), fi(Wo(), function (e) { const n = e.element(); eX(n).each(function (e) { QG(n, e, t) }) }), fi(UE, function (e, n) { const r = e.element(); eX(r).each(function (e) { const n = Pl(); Ra(e, 'visibility', 'hidden'); const o = Ia(e, 'height').map(function (e) { return parseInt(e, 10) }); Fa(e, 'height'), Fa(e, 'flex-basis'); const i = e.dom().getBoundingClientRect().height; const u = o.forall(function (e) { return i > e }); u ? (t.set(x.from(i)), QG(r, e, t)) : o.each(function (t) { ZG(e, t) }), Fa(e, 'visibility'), n.each(Rl) }) })]; const r = !1; return { extraEvents: n, selectFirst: r } }()); const n = (function () { const e = []; const t = !0; return { extraEvents: e, selectFirst: t } }()); return { smartTabHeight: t, naiveTabHeight: n } }; const nX = 'send-data-to-section'; const rX = 'send-data-to-view'; const oX = function (e, t) { const n = Ln({}); const r = function (e) { const t = Bg.getValue(e); const r = AG(t).getOr({}); const o = n.get(); const i = Ne(o, r); n.set(i) }; const o = function (e) { const t = n.get(); Bg.setValue(e, t) }; const i = Ln(null); const u = W(e.tabs, function (e) { return { value: e.name, dom: { tag: 'div', classes: ['tox-dialog__body-nav-item'], innerHtml: t.shared.providers.translate(e.title) }, view () { return [rA.sketch(function (n) { return { dom: { tag: 'div', classes: ['tox-form'] }, components: W(e.items, function (e) { return NP(n, e, t) }), formBehaviours: yl([Kb.config({ mode: 'acyclic', useTabstopAt: c(VA.isPseudoStop) }), cy('TabView.form.events', [xi(o), Ci(r)]), _l.config({ channels: tt([{ key: nX, value: { onReceive: r } }, { key: rX, value: { onReceive: o } }]) })]) } })] } } }); const a = tX(u).smartTabHeight; return GG.sketch({ dom: { tag: 'div', classes: ['tox-dialog__body'] }, onChangeTab (e, t, n) { const r = Bg.getValue(t); ni(e, VE, { name: r, oldName: i.get() }), i.set(r) }, tabs: u, components: [GG.parts().tabbar({ dom: { tag: 'div', classes: ['tox-dialog__body-nav'] }, components: [HG.parts().tabs({})], markers: { tabClass: 'tox-tab', selectedClass: 'tox-dialog__body-nav-item--active' }, tabbarBehaviours: yl([NO.config({})]) }), GG.parts().tabview({ dom: { tag: 'div', classes: ['tox-dialog__body-content'] } })], selectFirst: a.selectFirst, tabSectionBehaviours: yl([cy('tabpanel', a.extraEvents), Kb.config({ mode: 'acyclic' }), np.config({ find (e) { return ae(GG.getViewItems(e)) } }), Bg.config({ store: { mode: 'manual', getValue (e) { return e.getSystem().broadcastOn([nX], {}), n.get() }, setValue (e, t) { n.set(t), e.getSystem().broadcastOn([rX], {}) } } })]) }) }; const iX = xu('update-dialog'); const uX = xu('update-title'); const aX = xu('update-body'); const cX = xu('update-footer'); const sX = xu('body-send-message'); const lX = function (e, t, n, r) { const o = function (e) { switch (e.body.type) { case 'tabpanel':return [oX(e.body, n)]; default:return [RG(e.body, n)] } }; const i = function (e, t) { return x.some({ isTabPanel () { return t.body.type === 'tabpanel' } }) }; const u = { 'aria-live': 'polite' }; return { dom: { tag: 'div', classes: ['tox-dialog__content-js'], attributes: m(m({}, t.map(function (e) { return { id: e } }).getOr({})), r ? u : {}) }, components: [], behaviours: yl([gA.childAt(0), rH.config({ channel: aX, updateState: i, renderComponents: o, initialData: e })]) } }; const fX = function (e, t, n, r) { return lX(e, x.some(t), n, r) }; const dX = function (e, t) { const n = lX(e, x.none(), t, !1); return n$.parts().body(n) }; const mX = function (e) { const t = { dom: { tag: 'div', classes: ['tox-dialog__content-js'] }, components: [{ dom: { tag: 'div', classes: ['tox-dialog__body-iframe'] }, components: [VA.craft({ dom: { tag: 'iframe', attributes: { src: e.url } }, behaviours: yl([NO.config({}), vy.config({})]) })] }], behaviours: yl([Kb.config({ mode: 'acyclic', useTabstopAt: c(VA.isPseudoStop) })]) }; return n$.parts().body(t) }; const gX = XC.deviceType.isTouch(); const hX = function (e, t) { return { dom: { tag: 'div', styles: { display: 'none' }, classes: ['tox-dialog__header'] }, components: [e, t] } }; const pX = function (e, t) { return n$.parts().close(fx.sketch({ dom: { tag: 'button', classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'], attributes: { type: 'button', 'aria-label': t.translate('Close') } }, action: e, buttonBehaviours: yl([NO.config({})]) })) }; const vX = function () { return n$.parts().title({ dom: { tag: 'div', classes: ['tox-dialog__title'], innerHtml: '', styles: { display: 'none' } } }) }; const bX = function (e, t) { return n$.parts().body({ dom: { tag: 'div', classes: ['tox-dialog__body'] }, components: [{ dom: { tag: 'div', classes: ['tox-dialog__body-content'] }, components: [{ dom: TU('<p>' + t.translate(e) + '</p>') }] }] }) }; const yX = function (e) { return n$.parts().footer({ dom: { tag: 'div', classes: ['tox-dialog__footer'] }, components: e }) }; const wX = function (e, t) { return [RE.sketch({ dom: { tag: 'div', classes: ['tox-dialog__footer-start'] }, components: e }), RE.sketch({ dom: { tag: 'div', classes: ['tox-dialog__footer-end'] }, components: t })] }; const xX = function (e) { let t; const n = 'tox-dialog'; const r = n + '-wrap'; const o = r + '__backdrop'; const i = n + '__disable-scroll'; return n$.sketch({ lazySink: e.lazySink, onEscape (t) { return e.onEscape(t), x.some(!0) }, useTabstopAt (e) { return !VA.isPseudoStop(e) }, dom: { tag: 'div', classes: [n].concat(e.extraClasses), styles: m({ position: 'relative' }, e.extraStyles) }, components: h([e.header, e.body], e.footer.toArray()), parts: { blocker: { dom: TU('<div class="' + r + '"></div>'), components: [{ dom: { tag: 'div', classes: gX ? [o, o + '--opaque'] : [o] } }] } }, dragBlockClass: r, modalBehaviours: yl(h([vy.config({}), cy('dialog-events', e.dialogEvents.concat([wi(wo(), function (e, t) { Kb.focusIn(e) })])), cy('scroll-lock', [xi(function () { wa(Na(), i) }), Ci(function () { Ca(Na(), i) })])], e.extraBehaviours)), eventOrder: m((t = {}, t[Mo()] = ['dialog-events'], t[qo()] = ['scroll-lock', 'dialog-events', 'alloy.base.behaviour'], t[$o()] = ['alloy.base.behaviour', 'dialog-events', 'scroll-lock'], t), e.eventOrder) }) }; const CX = function (e) { return fx.sketch({ dom: { tag: 'button', classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'], attributes: { type: 'button', 'aria-label': e.translate('Close'), title: e.translate('Close') } }, components: [{ dom: { tag: 'div', classes: ['tox-icon'], innerHtml: '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M17.953 7.453L13.422 12l4.531 4.547-1.406 1.406L12 13.422l-4.547 4.531-1.406-1.406L10.578 12 6.047 7.453l1.406-1.406L12 10.578l4.547-4.531z" fill-rule="evenodd"></path></svg>' } }], action (e) { ti(e, zE) } }) }; const SX = function (e, t, n) { const r = function (e) { return [Qa(n.translate(e.title))] }; return { dom: { tag: 'div', classes: ['tox-dialog__title'], attributes: m({}, t.map(function (e) { return { id: e } }).getOr({})) }, components: r(e), behaviours: yl([rH.config({ channel: uX, renderComponents: r })]) } }; const kX = function () { return { dom: TU('<div class="tox-dialog__draghandle"></div>') } }; const TX = function (e, t, n) { return RE.sketch({ dom: TU('<div class="tox-dialog__header"></div>'), components: [SX(e, x.some(t), n), kX(), CX(n)], containerBehaviours: yl([Rq.config({ mode: 'mouse', blockerClass: 'blocker', getTarget (e) { return Zc(e, '[role="dialog"]').getOrDie() }, snaps: { getSnapPoints () { return [] }, leftAttr: 'data-drag-left', topAttr: 'data-drag-top' } })]) }) }; const EX = function (e, t) { const n = n$.parts().title(SX(e, x.none(), t)); const r = n$.parts().draghandle(kX()); const o = n$.parts().close(CX(t)); const i = [n].concat(e.draggable ? [r] : []).concat([o]); return RE.sketch({ dom: TU('<div class="tox-dialog__header"></div>'), components: i }) }; const OX = function (e, t) { return EX({ title: t.shared.providers.translate(e), draggable: t.dialog.isDraggableModal() }, t.shared.providers) }; const NX = function (e, t) { return { onClose () { return t.closeWindow() }, onBlock (t) { n$.setBusy(e(), function (e, n) { return { dom: { tag: 'div', classes: ['tox-dialog__busy-spinner'], attributes: { 'aria-label': t.message() }, styles: { left: '0px', right: '0px', bottom: '0px', top: '0px', position: 'absolute' } }, behaviours: n, components: [{ dom: TU('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] } }) }, onUnblock () { n$.setIdle(e()) } } }; const _X = function (e, t, n, r) { let o; const i = function (e, t) { return x.some(t) }; return nc(xX(m(m({}, e), { lazySink: r.shared.getSink, extraBehaviours: h([rH.config({ channel: iX, updateState: i, initialData: t }), _A.memory({})], e.extraBehaviours), onEscape (e) { ti(e, zE) }, dialogEvents: n, eventOrder: (o = {}, o[Bo()] = ['reflecting', 'receiving'], o[qo()] = ['scroll-lock', 'reflecting', 'messages', 'dialog-events', 'alloy.base.behaviour'], o[$o()] = ['alloy.base.behaviour', 'dialog-events', 'messages', 'reflecting', 'scroll-lock'], o) }))) }; const DX = function (e) { const t = function (e) { const t = W(e.items, function (e) { const t = Ln(!1); return m(m({}, e), { storage: t }) }); return m(m({}, e), { items: t }) }; return W(e, function (e) { return e.type === 'menu' ? t(e) : e }) }; const AX = function (e) { return K(e, function (e, t) { if (t.type === 'menu') { const n = t; return K(n.items, function (e, t) { return e[t.name] = t.storage, e }, e) } return e }, {}) }; const RX = function (e, t) { return [vi(wo(), VA.onFocus), e(PE, function (e, n) { t.onClose(), n.onClose() }), e(zE, function (e, t, n, r) { t.onCancel(e), ti(r, PE) }), fi(FE, function (e, n) { return t.onUnblock() }), fi(HE, function (e, n) { return t.onBlock(n.event()) })] }; const BX = function (e, t) { const n = function (t, n) { return fi(t, function (t, o) { r(t, function (r, i) { n(e(), r, o.event(), t) }) }) }; var r = function (e, t) { rH.getState(e).get().each(function (n) { t(n, e) }) }; return h(RX(n, t), [n(IE, function (e, t, n) { t.onAction(e, { name: n.name() }) })]) }; const MX = function (e, t, n) { const r = function (t, n) { return fi(t, function (t, r) { o(t, function (o, i) { n(e(), o, r.event(), t) }) }) }; var o = function (e, t) { rH.getState(e).get().each(function (n) { t(n.internalDialog, e) }) }; return h(RX(r, t), [r(LE, function (e, t) { return t.onSubmit(e) }), r(ME, function (e, t, n) { t.onChange(e, { name: n.name() }) }), r(IE, function (e, t, r, o) { const i = function () { return Kb.focusIn(o) }; const u = function (e) { return fu(e, 'disabled') || lu(e, 'aria-disabled').exists(function (e) { return e === 'true' }) }; const a = Pl(); t.onAction(e, { name: r.name(), value: r.value() }), Pl().fold(i, function (e) { u(e) ? i() : a.exists(function (t) { return to(e, t) && u(t) }) ? i() : n().toOption().filter(function (t) { return !to(t.element(), e) }).each(i) }) }), r(VE, function (e, t, n) { t.onTabChange(e, { newTabName: n.name(), oldTabName: n.oldName() }) }), Ci(function (t) { const n = e(); Bg.setValue(t, n.getData()) })]) }; const PX = { initUrlDialog: BX, initDialog: MX }; const zX = function (e, t) { return NB(e, e.type, t) }; const IX = function (e, t, n) { return J(t, function (e) { return e.name === n }).bind(function (t) { return t.memento.getOpt(e) }) }; const LX = function (e, t) { const n = t.map(function (e) { return e.footerButtons }).getOr([]); const r = G(n, function (e) { return e.align === 'start' }); const o = function (e, t) { return RE.sketch({ dom: { tag: 'div', classes: ['tox-dialog__footer-' + e] }, components: W(t, function (e) { return e.memento.asSpec() }) }) }; const i = o('start', r.pass); const u = o('end', r.fail); return [i, u] }; const HX = function (e, t) { const n = function (e, n) { const r = W(n.buttons, function (e) { const n = dx(zX(e, t)); return { name: e.name, align: e.align, memento: n } }); const o = function (e, t) { return IX(e, r, t) }; return x.some({ lookupByName: o, footerButtons: r }) }; return { dom: TU('<div class="tox-dialog__footer"></div>'), components: [], behaviours: yl([rH.config({ channel: cX, initialData: e, updateState: n, renderComponents: LX })]) } }; const FX = function (e, t) { return HX(e, t) }; const VX = function (e, t) { return n$.parts().footer(HX(e, t)) }; const UX = function (e, t) { const n = e.getRoot(); if (n.getSystem().isConnected()) { const r = np.getCurrent(e.getFormWrapper()).getOr(e.getFormWrapper()); return rA.getField(r, t).fold(function () { const n = e.getFooter(); const o = rH.getState(n); return o.get().bind(function (e) { return e.lookupByName(r, t) }) }, function (e) { return x.some(e) }) } return x.none() }; const jX = function (e, t) { const n = e.getRoot(); return rH.getState(n).get().map(function (e) { return Gt($t('data', e.dataValidator, t)) }).getOr(t) }; const WX = function (e, t, n) { const r = function (t) { const n = e.getRoot(); n.getSystem().isConnected() && t(n) }; const o = function () { const t = e.getRoot(); const r = t.getSystem().isConnected() ? e.getFormWrapper() : t; const o = Bg.getValue(r); const i = ge(n, function (e) { return e.get() }); return m(m({}, o), i) }; const i = function (t) { r(function (r) { const o = h.getData(); const i = m(m({}, o), t); const u = jX(e, i); const a = e.getFormWrapper(); Bg.setValue(a, u), me(n, function (e, t) { we(i, t) && e.set(i[t]) }) }) }; const u = function (t) { UX(e, t).each(NS.disable) }; const a = function (t) { UX(e, t).each(NS.enable) }; const c = function (t) { UX(e, t).each(vy.focus) }; const s = function (e) { if (!N(e)) { throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument') } r(function (t) { ni(t, HE, { message: e }) }) }; const l = function () { r(function (e) { ti(e, FE) }) }; const f = function (t) { r(function (n) { const r = e.getBody(); const o = rH.getState(r); o.get().exists(function (e) { return e.isTabPanel() }) && np.getCurrent(r).each(function (e) { GG.showTab(e, t) }) }) }; const d = function (e) { r(function (n) { const r = t(e); n.getSystem().broadcastOn([iX], r), n.getSystem().broadcastOn([uX], r.internalDialog), n.getSystem().broadcastOn([aX], r.internalDialog), n.getSystem().broadcastOn([cX], r.internalDialog), h.setData(r.initialData) }) }; const g = function () { r(function (e) { ti(e, PE) }) }; var h = { getData: o, setData: i, disable: u, enable: a, focus: c, block: s, unblock: l, showTab: f, redial: d, close: g }; return h }; const qX = function (e, t, n) { const r = OX(e.internalDialog.title, n); const o = dX({ body: e.internalDialog.body }, n); const i = DX(e.internalDialog.buttons); const u = AX(i); const a = VX({ buttons: i }, n); const c = PX.initDialog(function () { return m }, NX(function () { return f }, t), n.shared.getSink); const s = e.internalDialog.size !== 'normal' ? e.internalDialog.size === 'large' ? ['tox-dialog--width-lg'] : ['tox-dialog--width-md'] : []; const l = { header: r, body: o, footer: x.some(a), extraClasses: s, extraBehaviours: [], extraStyles: {} }; var f = _X(l, e, c, n); const d = (function () { const e = function () { const e = n$.getBody(f); return np.getCurrent(e).getOr(e) }; return { getRoot () { return f }, getBody () { return n$.getBody(f) }, getFooter () { return n$.getFooter(f) }, getFormWrapper: e } }()); var m = WX(d, t.redial, u); return { dialog: f, instanceApi: m } }; const $X = function (e, t, n, r) { let o; let i; const u = xu('dialog-label'); const a = xu('dialog-content'); const c = function (e, t) { return x.some(t) }; const s = dx(TX({ title: e.internalDialog.title, draggable: !0 }, u, n.shared.providers)); const l = dx(fX({ body: e.internalDialog.body }, a, n, r)); const f = DX(e.internalDialog.buttons); const d = AX(f); const m = dx(FX({ buttons: f }, n)); const g = PX.initDialog(function () { return p }, { onBlock () {}, onUnblock () {}, onClose () { return t.closeWindow() } }, n.shared.getSink); const h = nc({ dom: { tag: 'div', classes: ['tox-dialog', 'tox-dialog-inline'], attributes: (o = { role: 'dialog' }, o['aria-labelledby'] = u, o['aria-describedby'] = '' + a, o) }, eventOrder: (i = {}, i[Bo()] = [rH.name(), _l.name()], i[Mo()] = ['execute-on-form'], i[qo()] = ['reflecting', 'execute-on-form'], i), behaviours: yl([Kb.config({ mode: 'cyclic', onEscape (e) { return ti(e, PE), x.some(!0) }, useTabstopAt (e) { return !VA.isPseudoStop(e) && (tu(e) !== 'button' || su(e, 'disabled') !== 'disabled') } }), rH.config({ channel: iX, updateState: c, initialData: e }), vy.config({}), cy('execute-on-form', g.concat([wi(wo(), function (e, t) { Kb.focusIn(e) })])), _A.memory({})]), components: [s.asSpec(), l.asSpec(), m.asSpec()] }); var p = WX({ getRoot () { return h }, getFooter () { return m.get(h) }, getBody () { return l.get(h) }, getFormWrapper () { const e = l.get(h); return np.getCurrent(e).getOr(e) } }, t.redial, d); return { dialog: h, instanceApi: p } }; const GX = tinymce.util.Tools.resolve('tinymce.util.URI'); const XX = function (e) { const t = function (t) { e.getSystem().isConnected() && t(e) }; const n = function (e) { if (!N(e)) { throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument') } t(function (t) { ni(t, HE, { message: e }) }) }; const r = function () { t(function (e) { ti(e, FE) }) }; const o = function () { t(function (e) { ti(e, PE) }) }; const i = function (e) { t(function (t) { t.getSystem().broadcastOn([sX], e) }) }; return { block: n, unblock: r, close: o, sendMessage: i } }; const YX = ['insertContent', 'setContent', 'execCommand', 'close', 'block', 'unblock']; const KX = function (e) { return _(e) && YX.includes(e.mceAction) }; const JX = function (e) { return !KX(e) && _(e) && we(e, 'mceAction') }; const ZX = function (e, t, n) { switch (n.mceAction) { case 'insertContent':e.insertContent(n.content); break; case 'setContent':e.setContent(n.content); break; case 'execCommand':var r = !!A(n.ui) && n.ui; e.execCommand(n.cmd, r, n.value); break; case 'close':t.close(); break; case 'block':t.block(n.message); break; case 'unblock':t.unblock(); break } }; const QX = function (e, n, r, o) { let i; const u = OX(e.title, o); const a = mX(e); const c = e.buttons.bind(function (e) { return e.length === 0 ? x.none() : x.some(VX({ buttons: e }, o)) }); const s = PX.initUrlDialog(function () { return y }, NX(function () { return b }, n)); const l = m(m({}, e.height.fold(function () { return {} }, function (e) { return { height: e + 'px', 'max-height': e + 'px' } })), e.width.fold(function () { return {} }, function (e) { return { width: e + 'px', 'max-width': e + 'px' } })); const f = e.width.isNone() && e.height.isNone() ? ['tox-dialog--width-lg'] : []; const d = new GX(e.url, { base_uri: new GX(t.window.location.href) }); const g = d.protocol + '://' + d.host + (d.port ? ':' + d.port : ''); const h = Ln(x.none()); const p = [cy('messages', [xi(function () { const n = tE(Wn.fromDom(t.window), 'message', function (t) { if (d.isSameOrigin(new GX(t.raw().origin))) { const n = t.raw().data; KX(n) ? ZX(r, y, n) : JX(n) && e.onMessage(y, n) } }); h.set(x.some(n)) }), Ci(function () { h.get().each(function (e) { return e.unbind() }) })]), _l.config({ channels: (i = {}, i[sX] = { onReceive (e, t) { Jc(e.element(), 'iframe').each(function (e) { const n = e.dom().contentWindow; n.postMessage(t, g) }) } }, i) })]; const v = { header: u, body: a, footer: c, extraClasses: f, extraBehaviours: p, extraStyles: l }; var b = _X(v, e, s, o); var y = XX(b); return { dialog: b, instanceApi: y } }; const eY = function (e) { const t = e.backstage.shared; const n = function (n, r) { const o = function () { n$.hide(c), r() }; const i = dx(NB({ name: 'close-alert', text: 'OK', primary: !0, align: 'end', disabled: !1, icon: x.none() }, 'cancel', e.backstage)); const u = vX(); const a = pX(o, t.providers); var c = nc(xX({ lazySink () { return t.getSink() }, header: hX(u, a), body: bX(n, t.providers), footer: x.some(yX(wX([], [i.asSpec()]))), onEscape: o, extraClasses: ['tox-alert-dialog'], extraBehaviours: [], extraStyles: {}, dialogEvents: [fi(zE, o)], eventOrder: {} })); n$.show(c); const s = i.get(c); vy.focus(s) }; return { open: n } }; const tY = function (e) { const t = e.backstage.shared; const n = function (n, r) { const o = function (e) { n$.hide(s), r(e) }; const i = dx(NB({ name: 'yes', text: 'Yes', primary: !0, align: 'end', disabled: !1, icon: x.none() }, 'submit', e.backstage)); const u = NB({ name: 'no', text: 'No', primary: !1, align: 'end', disabled: !1, icon: x.none() }, 'cancel', e.backstage); const a = vX(); const c = pX(function () { return o(!1) }, t.providers); var s = nc(xX({ lazySink () { return t.getSink() }, header: hX(a, c), body: bX(n, t.providers), footer: x.some(yX(wX([], [u, i.asSpec()]))), onEscape () { return o(!1) }, extraClasses: ['tox-confirm-dialog'], extraBehaviours: [], extraStyles: {}, dialogEvents: [fi(zE, function () { return o(!1) }), fi(LE, function () { return o(!0) })], eventOrder: {} })); n$.show(s); const l = i.get(s); vy.focus(l) }; return { open: n } }; const nY = function (e, t) { return Gt($t('data', t, e)) }; const rY = function (e) { return oE(e, '.tox-alert-dialog') || oE(e, '.tox-confirm-dialog') }; const oY = function (e, t, n) { return t && n ? [] : [zV.config({ contextual: { lazyContext () { return x.some(Vc(Wn.fromDom(e.getContentAreaContainer()))) }, fadeInClass: 'tox-dialog-dock-fadein', fadeOutClass: 'tox-dialog-dock-fadeout', transitionClass: 'tox-dialog-dock-transition' }, modes: ['top'] })] }; const iY = function (e) { const t = e.backstage; const n = e.editor; const r = cx(n); const o = nx(n); const i = eY(e); const u = tY(e); const a = function (e, n, r) { return void 0 !== n && n.inline === 'toolbar' ? f(e, t.shared.anchors.inlineDialog(), r, n.ariaAttrs) : void 0 !== n && n.inline === 'cursor' ? f(e, t.shared.anchors.cursor(), r, n.ariaAttrs) : l(e, r) }; const c = function (e, t) { return s(e, t) }; var s = function (e, r) { const o = function (e) { var o = QX(e, { closeWindow () { n$.hide(o.dialog), r(o.instanceApi) } }, n, t); return n$.show(o.dialog), o.instanceApi }; return _G.openUrl(o, e) }; var l = function (e, n) { const r = function (e, r, o) { const i = r; const u = { dataValidator: o, initialData: i, internalDialog: e }; var a = qX(u, { redial: _G.redial, closeWindow () { n$.hide(a.dialog), n(a.instanceApi) } }, t); return n$.show(a.dialog), a.instanceApi.setData(i), a.instanceApi }; return _G.open(r, e) }; var f = function (e, i, u, a) { const c = function (e, c, s) { const l = nY(c, s); const f = DG(); const d = { dataValidator: s, initialData: l, internalDialog: e }; const g = function () { return f.on(function (e) { Cw.reposition(e), zV.refresh(e) }) }; var p = $X(d, { redial: _G.redial, closeWindow () { f.on(Cw.hide), n.off('ResizeEditor', g), f.clear(), u(p.instanceApi) } }, t, a); const v = nc(Cw.sketch(m(m({ lazySink: t.shared.getSink, dom: { tag: 'div', classes: [] }, fireDismissalEventInstead: {} }, o ? {} : { fireRepositionEventInstead: {} }), { inlineBehaviours: yl(h([cy('window-manager-inline-events', [fi(Go(), function (e, t) { ti(p.dialog, zE) })])], oY(n, r, o))), isExtraPart (e, t) { return rY(t) } }))); return f.set(v), Cw.showWithin(v, i, rc(p.dialog), x.some(Na())), r && o || (zV.refresh(v), n.on('ResizeEditor', g)), p.instanceApi.setData(l), Kb.focusIn(p.dialog), p.instanceApi }; return _G.open(c, e) }; const d = function (e, t) { u.open(e, function (e) { t(e) }) }; const g = function (e, t) { i.open(e, function () { t() }) }; const p = function (e) { e.close() }; return { open: a, openUrl: c, alert: g, close: p, confirm: d } }; const uY = { setup: iY }; function aY () { d.add('silver', function (e) { const t = Yq.setup(e); const n = t.uiMothership; const r = t.backstage; const o = t.renderUI; const u = t.getUi; QT.register(e, r.shared); const a = uY.setup({ editor: e, backstage: r }); return { renderUI: o, getWindowManagerImpl: i(a), getNotificationManagerImpl () { return wx(e, { backstage: r }, n) }, ui: u() } }) }aY() })(window) }).call(this, n('c8ba')) }, '080b' (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = tinymce.util.Tools.resolve('tinymce.Env'); const n = function (e) { return e.getParam('pagebreak_separator', '\x3C!-- pagebreak --\x3E') }; const r = function (e) { return e.getParam('pagebreak_split_block', !1) }; const o = { getSeparatorHtml: n, shouldSplitBlock: r }; const i = function () { return 'mce-pagebreak' }; const u = function () { return '<img src="' + t.transparentSrc + '" class="' + i() + '" data-mce-resize="false" data-mce-placeholder />' }; const a = function (e) { const t = o.getSeparatorHtml(e); const n = new RegExp(t.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, function (e) { return '\\' + e }), 'gi'); e.on('BeforeSetContent', function (e) { e.content = e.content.replace(n, u()) }), e.on('PreInit', function () { e.serializer.addNodeFilter('img', function (n) { let r; let i; let u = n.length; while (u--) { if (r = n[u], i = r.attr('class'), i && i.includes('mce-pagebreak')) { const a = r.parent; if (e.schema.getBlockElements()[a.name] && o.shouldSplitBlock(e)) { a.type = 3, a.value = t, a.raw = !0, r.remove(); continue }r.type = 3, r.value = t, r.raw = !0 } } }) }) }; const c = { setup: a, getPlaceholderHtml: u, getPageBreakClass: i }; const s = function (e) { e.addCommand('mcePageBreak', function () { e.settings.pagebreak_split_block ? e.insertContent('<p>' + c.getPlaceholderHtml() + '</p>') : e.insertContent(c.getPlaceholderHtml()) }) }; const l = { register: s }; const f = function (e) { e.on('ResolveName', function (t) { t.target.nodeName === 'IMG' && e.dom.hasClass(t.target, c.getPageBreakClass()) && (t.name = 'pagebreak') }) }; const d = { setup: f }; const m = function (e) { e.ui.registry.addButton('pagebreak', { icon: 'page-break', tooltip: 'Page break', onAction () { return e.execCommand('mcePageBreak') } }), e.ui.registry.addMenuItem('pagebreak', { text: 'Page break', icon: 'page-break', onAction () { return e.execCommand('mcePageBreak') } }) }; const g = { register: m }; function h () { e.add('pagebreak', function (e) { l.register(e), g.register(e), c.setup(e), d.setup(e) }) }h() })() }, '0d68' (e, t, n) { n('030f') }, '1df9' (e, t, n) { 'use strict'; n.r(t); const r = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'interface-wysiwyg' }, [n('Editor', { ref: 'editorElement', attrs: { init: e.initOptions, value: e.value }, on: { onKeyUp: e.planToUpdateValue, onExecCommand: e.updateValue, onBlur: e.updateValue, onPaste: e.updateValue, onUndo: e.updateValue, onRedo: e.updateValue } }), e.newInlineFile ? n('v-modal', { attrs: { title: e.$t('file_upload'), buttons: { done: { text: e.$t('done') } } }, on: { close: e.closeInlineFileModal, done: e.selectCallback } }, [n('div', { staticClass: 'body' }, [n('v-ext-input', { attrs: { id: 'file', name: 'file', required: !1, readonly: !1, options: e.fileInputOptions, type: 'file', datatype: 'INT', value: e.selectedFile, relation: e.relation, fields: null, collection: 'directus_files', values: null, length: 10, 'new-item': e.newItem, width: 'full' }, on: { input (t) { e.selectedFile = t } } })], 1)]) : e._e()], 1) }; const o = []; const i = (n('a4d3'), n('99af'), n('4de4'), n('4160'), n('a15b'), n('e439'), n('dbb4'), n('b64b'), n('159b'), n('53ca')); const u = (n('96cf'), n('1da1')); const a = n('ade3'); const c = n('8db2'); const s = n.n(c); const l = (n('e562'), n('0d68'), n('36998'), n('94ce'), n('dbbc'), n('2401'), n('cdd9'), n('9dd9'), n('be7f'), n('080b'), n('ef1f'), n('a376'), n('ae68'), n('7c4f'), n('69a4'), n('f034'), n('e2d6'), ['onActivate', 'onAddUndo', 'onBeforeAddUndo', 'onBeforeExecCommand', 'onBeforeGetContent', 'onBeforeRenderUI', 'onBeforeSetContent', 'onBeforePaste', 'onBlur', 'onChange', 'onClearUndos', 'onClick', 'onContextMenu', 'onCopy', 'onCut', 'onDblclick', 'onDeactivate', 'onDirty', 'onDrag', 'onDragDrop', 'onDragEnd', 'onDragGesture', 'onDragOver', 'onDrop', 'onExecCommand', 'onFocus', 'onFocusIn', 'onFocusOut', 'onGetContent', 'onHide', 'onInit', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onLoadContent', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onNodeChange', 'onObjectResizeStart', 'onObjectResized', 'onObjectSelected', 'onPaste', 'onPostProcess', 'onPostRender', 'onPreProcess', 'onProgressState', 'onRedo', 'onRemove', 'onReset', 'onSaveContent', 'onSelectionChange', 'onSetAttrib', 'onSetContent', 'onShow', 'onSubmit', 'onUndo', 'onVisualAid']); const f = function (e) { return l.includes(e) }; const d = function (e, t, n) { Object.keys(t).filter(f).forEach(function (r) { const o = t[r]; typeof o === 'function' && (r === 'onInit' ? o(e, n) : n.on(r.substring(2), function (e) { return o(e, n) })) }) }; const m = function (e, t) { let n; const r = e.$props.modelEvents ? e.$props.modelEvents : null; const o = Array.isArray(r) ? r.join(' ') : r; e.$watch('value', function (e, r) { t && typeof e === 'string' && e !== n && e !== r && (t.setContent(e), n = e) }), t.on(o || 'change keyup undo redo', function () { n = t.getContent(), e.$emit('input', n) }) }; const g = function (e, t, n) { const r = t.$props.value ? t.$props.value : ''; const o = t.$props.initialValue ? t.$props.initialValue : ''; n.setContent(r || o), t.$listeners.input && m(t, n), d(e, t.$listeners, n) }; let h = 0; const p = function (e) { const t = Date.now(); const n = Math.floor(1e9 * Math.random()); return h++, e + '_' + n + h + String(t) }; const v = function (e) { return e !== null && e.tagName.toLowerCase() === 'textarea' }; const b = function (e) { return typeof e === 'undefined' || e === '' ? [] : Array.isArray(e) ? e : e.split(' ') }; const y = function (e, t) { return b(e).concat(b(t)) }; const w = function (e, t, n, r) { const o = t.createElement('script'); o.referrerPolicy = 'origin', o.type = 'application/javascript', o.id = e, o.addEventListener('load', r), o.src = n, t.head && t.head.appendChild(o) }; const x = function () { return { listeners: [], scriptId: p('tiny-script'), scriptLoaded: !1 } }; const C = function (e, t, n, r) { e.scriptLoaded ? r() : (e.listeners.push(r), t.getElementById(e.scriptId) || w(e.scriptId, t, n, function () { e.listeners.forEach(function (e) { return e() }), e.scriptLoaded = !0 })) }; const S = n('c4a9'); const k = { apiKey: String, cloudChannel: String, id: String, init: Object, initialValue: String, inline: Boolean, modelEvents: [String, Array], plugins: [String, Array], tagName: String, toolbar: [String, Array], value: String, disabled: Boolean }; var T = function () { return T = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, T.apply(this, arguments) }; const E = x(); const O = function (e, t, n) { return e(n || 'div', { attrs: { id: t } }) }; const N = function (e, t) { return e('textarea', { attrs: { id: t }, style: { visibility: 'hidden' } }) }; const _ = function (e) { return function () { const t = T({}, e.$props.init, { readonly: e.$props.disabled, selector: '#' + e.elementId, plugins: y(e.$props.init && e.$props.init.plugins, e.$props.plugins), toolbar: e.$props.toolbar || e.$props.init && e.$props.init.toolbar, inline: e.inlineEditor, setup (t) { e.editor = t, t.on('init', function (n) { return g(n, e, t) }), e.$props.init && typeof e.$props.init.setup === 'function' && e.$props.init.setup(t) } }); v(e.element) && (e.element.style.visibility = ''), Object(S.a)().init(t) } }; const D = { props: k, created () { this.elementId = this.$props.id || p('tiny-vue'), this.inlineEditor = this.$props.init && this.$props.init.inline || this.$props.inline }, watch: { disabled () { this.editor.setMode(this.disabled ? 'readonly' : 'design') } }, mounted () { if (this.element = this.$el, Object(S.a)() !== null) { _(this)() } else if (this.element && this.element.ownerDocument) { const e = this.element.ownerDocument; const t = this.$props.cloudChannel ? this.$props.cloudChannel : '5'; const n = this.$props.apiKey ? this.$props.apiKey : 'no-api-key'; C(E, e, 'https://cdn.tiny.cloud/1/' + n + '/tinymce/' + t + '/tinymce.min.js', _(this)) } }, beforeDestroy () { Object(S.a)() !== null && Object(S.a)().remove(this.editor) }, render (e) { return this.inlineEditor ? O(e, this.elementId, this.$props.tagName) : N(e, this.elementId) } }; const A = D; const R = n('2ef0'); function B (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function M (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? B(Object(n), !0).forEach(function (t) { Object(a.a)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function P (e) { return getComputedStyle(document.body).getPropertyValue(e) } const z = { components: { Editor: A }, mixins: [s.a], data () { return { newInlineFile: !1, selectedFile: null, selectCallback () {} } }, computed: { fileInputOptions () { return { viewOptions: { content: 'description', src: 'data', subtitle: 'type', title: 'title' }, viewType: 'cards' } }, initOptions () { const e = this.getStyleFormats(); let t = this.options.toolbar.join(' '); return e && (t += ' styleselect'), M({ skin: !1, skin_url: !1, content_css: !1, content_style: this.contentStyle, plugins: 'media table hr lists image link pagebreak code insertdatetime autoresize paste preview fullscreen directionality', branding: !1, max_height: 1e3, elementpath: !1, statusbar: !1, menubar: !1, convert_urls: !1, readonly: this.readonly, extended_valid_elements: 'audio[loop],source', toolbar: t, style_formats: e, file_picker_callback: this.selectFile }, this.options.tinymce_options) }, contentStyle () { return '\n        body {\n          color: '.concat(P('--input-text-color'), ';\n          background-color: ').concat(P('--input-background-color'), ";\n          margin: 20px;\n          font-family: 'Roboto', sans-serif;\n          -webkit-font-smoothing: antialiased;\n          text-rendering: optimizeLegibility;\n          -moz-osx-font-smoothing: grayscale;\n        }\n        h1 {\n          font-family: 'Merriweather', serif;\n          font-size: 44px;\n          line-height: 52px;\n          font-weight: 300;\n          margin-bottom: 0;\n        }\n        h2 {\n          font-size: 34px;\n          line-height: 38px;\n          font-weight: 600;\n          margin-top: 60px;\n          margin-bottom: 0;\n        }\n        h3 {\n          font-size: 26px;\n          line-height: 31px;\n          font-weight: 600;\n          margin-top: 40px;\n          margin-bottom: 0;\n        }\n        h4 {\n          font-size: 22px;\n          line-height: 28px;\n          font-weight: 600;\n          margin-top: 40px;\n          margin-bottom: 0;\n        }\n        h5 {\n          font-size: 18px;\n          line-height: 26px;\n          font-weight: 600;\n          margin-top: 40px;\n          margin-bottom: 0;\n        }\n        h6 {\n          font-size: 16px;\n          line-height: 24px;\n          font-weight: 600;\n          margin-top: 40px;\n          margin-bottom: 0;\n        }\n        p {\n          font-family: 'Merriweather', serif;\n          font-size: 16px;\n          line-height: 32px;\n          margin-top: 20px;\n          margin-bottom: 20px;\n        }\n        a {\n          color: #546e7a;\n        }\n        ul,ol {\n          font-family: 'Merriweather', serif;\n          font-size: 18px;\n          line-height: 34px;\n          margin: 24px 0;\n        }\n        ul ul,\n        ol ol,\n        ul ol,\n        ol ul {\n          margin: 0;\n        }\n        b,strong {\n          font-weight: 600;\n        }\n        code {\n          font-size: 18px;\n          line-height: 34px;\n          padding: 2px 4px;\n          font-family: 'Roboto Mono', monospace;\n          background-color: #eceff1;\n          border-radius: 3px;\n          overflow-wrap: break-word;\n        }\n        pre {\n          font-size: 18px;\n          line-height: 24px;\n          padding: 20px;\n          font-family: 'Roboto Mono', monospace;\n          background-color: #eceff1;\n          border-radius: 3px;\n          overflow: auto;\n        }\n        blockquote {\n          font-family: 'Merriweather', serif;\n          font-size: 18px;\n          line-height: 34px;\n          border-left: 2px solid #546e7a;\n          padding-left: 10px;\n          margin-left: -10px;\n          font-style: italic;\n        }\n        video,\n        iframe,\n        img {\n          max-width: 100%;\n          border-radius: 3px;\n          height: auto;\n        }\n        hr {\n          border: 0;\n          margin-top: 52px;\n          margin-bottom: 56px;\n          text-align: center;\n        }\n        hr:after {\n          content: \"...\";\n          font-size: 28px;\n          letter-spacing: 16px;\n          line-height: 0;\n        }\n        table {\n          border-collapse: collapse;\n        }\n        table th,\n        table td {\n          border: 1px solid #cfd8dc;\n          padding: 0.4rem;\n        }\n        figure {\n          display: table;\n          margin: 1rem auto;\n        }\n        figure figcaption {\n          color: #999;\n          display: block;\n          margin-top: 0.25rem;\n          text-align: center;\n        }\n      ") } }, created () { this.planToUpdateValue = Object(R.debounce)(this.updateValue, 200) }, methods: { updateValue () { const e = this.$refs.editorElement.editor; const t = e.getContent(); this.$emit('input', t) }, getStyleFormats () { return Array.isArray(this.options.custom_formats) && this.options.custom_formats.length > 0 ? this.options.custom_formats : null }, selectFile (e) { const t = this; document.querySelector('.tox.tox-tinymce-aux').style.display = 'none', this.newInlineFile = !0, this.selectCallback = Object(u.a)(regeneratorRuntime.mark(function n () { let r, o, u; return regeneratorRuntime.wrap(function (n) { while (1) { switch (n.prev = n.next) { case 0:return document.querySelector('.tox.tox-tinymce-aux').style.display = 'block', r = Object(i.a)(t.selectedFile) === 'object' ? t.selectedFile.id : t.selectedFile, n.next = 4, t.$api.getItem('directus_files', r); case 4:o = n.sent, u = o.data, t.newInlineFile = !1, e(u.data.full_url, { alt: u.title }), t.selectedFile = null; case 9:case 'end':return n.stop() } } }, n) })) }, closeInlineFileModal () { this.newInlineFile = !1, document.querySelector('.tox.tox-tinymce-aux').style.display = 'block' } } }; const I = z; const L = (n('eefc'), n('2877')); const H = Object(L.a)(I, r, o, !1, null, '003b6458', null); t.default = H.exports }, 2401 (e, t) { (function (e) { 'use strict'; const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const n = function () {}; const r = function (e) { return function () { return e } }; const o = function (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } return !e.apply(null, t) } }; const i = r(!1); const u = r(!0); const a = function () { return c }; var c = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const o = function (e) { return e }; const c = { fold (e, t) { return e() }, is: i, isSome: i, isNone: u, getOr: o, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: r(null), getOrUndefined: r(void 0), or: o, orThunk: t, map: a, each: n, bind: a, exists: i, forall: u, filter: a, equals: e, equals_: e, toArray () { return [] }, toString: r('none()') }; return Object.freeze && Object.freeze(c), c }()); var s = function (e) { const t = r(e); const n = function () { return a }; const o = function (t) { return t(e) }; var a = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: u, isNone: i, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return s(t(e)) }, each (t) { t(e) }, bind: o, exists: o, forall: o, filter (t) { return t(e) ? a : c }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(i, function (t) { return n(e, t) }) } }; return a }; const l = function (e) { return e === null || void 0 === e ? c : s(e) }; const f = { some: s, none: a, from: l }; const d = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const m = function (e) { return function (t) { return d(t) === e } }; const g = m('string'); const h = m('array'); const p = m('boolean'); const v = m('function'); const b = m('number'); const y = Array.prototype.slice; const w = Array.prototype.push; const x = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const C = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const S = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const k = function (e, t) { if (e.length === 0) { return [] } for (var n = t(e[0]), r = [], o = [], i = 0, u = e.length; i < u; i++) { const a = e[i]; const c = t(a); c !== n && (r.push(o), o = []), n = c, o.push(a) } return o.length !== 0 && r.push(o), r }; const T = function (e, t, n) { return C(e, function (e) { n = t(n, e) }), n }; const E = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return f.some(o) } } return f.none() }; const O = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!h(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } w.apply(t, e[n]) } return t }; const N = function (e, t) { return O(x(e, t)) }; const _ = function (e) { const t = y.call(e, 0); return t.reverse(), t }; const D = function (e) { return e.length === 0 ? f.none() : f.some(e[0]) }; const A = function (e) { return e.length === 0 ? f.none() : f.some(e[e.length - 1]) }; const R = (v(Array.from) && Array.from, function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }); const B = function (t, n) { return R(t, n, e.Node.DOCUMENT_POSITION_PRECEDING) }; const M = function (t, n) { return R(t, n, e.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const P = { documentPositionPreceding: B, documentPositionContainedBy: M }; var z = function () { return z = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, z.apply(this, arguments) }; var I = function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return I(n()) }; return { get: n, set: r, clone: o } }; const L = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const H = function (e, t) { const n = L(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return U(r(1), r(2)) }; const F = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? V() : H(e, n) }; var V = function () { return U(0, 0) }; var U = function (e, t) { return { major: e, minor: t } }; const j = { nu: U, detect: F, unknown: V }; const W = 'Edge'; const q = 'Chrome'; const $ = 'IE'; const G = 'Opera'; const X = 'Firefox'; const Y = 'Safari'; const K = function (e, t) { return function () { return t === e } }; const J = function () { return Z({ current: void 0, version: j.unknown() }) }; var Z = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: K(W, t), isChrome: K(q, t), isIE: K($, t), isOpera: K(G, t), isFirefox: K(X, t), isSafari: K(Y, t) } }; const Q = { unknown: J, nu: Z, edge: r(W), chrome: r(q), ie: r($), opera: r(G), firefox: r(X), safari: r(Y) }; const ee = 'Windows'; const te = 'iOS'; const ne = 'Android'; const re = 'Linux'; const oe = 'OSX'; const ie = 'Solaris'; const ue = 'FreeBSD'; const ae = 'ChromeOS'; const ce = function (e, t) { return function () { return t === e } }; const se = function () { return le({ current: void 0, version: j.unknown() }) }; var le = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: ce(ee, t), isiOS: ce(te, t), isAndroid: ce(ne, t), isOSX: ce(oe, t), isLinux: ce(re, t), isSolaris: ce(ie, t), isFreeBSD: ce(ue, t), isChromeOS: ce(ae, t) } }; const fe = { unknown: se, nu: le, windows: r(ee), ios: r(te), android: r(ne), linux: r(re), osx: r(oe), solaris: r(ie), freebsd: r(ue), chromeos: r(ae) }; const de = function (e, t, n, o) { const i = e.isiOS() && !0 === /ipad/i.test(n); const u = e.isiOS() && !i; const a = e.isiOS() || e.isAndroid(); const c = a || o('(pointer:coarse)'); const s = i || !u && a && o('(min-device-width:768px)'); const l = u || a && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: r(i), isiPhone: r(u), isTablet: r(s), isPhone: r(l), isTouch: r(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: r(f), isDesktop: r(d) } }; const me = function (e, t) { const n = String(t).toLowerCase(); return E(e, function (e) { return e.search(n) }) }; const ge = function (e, t) { return me(e, t).map(function (e) { const n = j.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const he = function (e, t) { return me(e, t).map(function (e) { const n = j.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const pe = { detectBrowser: ge, detectOs: he }; const ve = function (e, t) { return e.includes(t) }; const be = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const ye = function (e) { return function (t) { return ve(t, e) } }; const we = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return ve(e, 'edge/') && ve(e, 'chrome') && ve(e, 'safari') && ve(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, be], search (e) { return ve(e, 'chrome') && !ve(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return ve(e, 'msie') || ve(e, 'trident') } }, { name: 'Opera', versionRegexes: [be, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: ye('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: ye('firefox') }, { name: 'Safari', versionRegexes: [be, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (ve(e, 'safari') || ve(e, 'mobile/')) && ve(e, 'applewebkit') } }]; const xe = [{ name: 'Windows', search: ye('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return ve(e, 'iphone') || ve(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: ye('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: ye('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: ye('linux'), versionRegexes: [] }, { name: 'Solaris', search: ye('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: ye('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: ye('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const Ce = { browsers: r(we), oses: r(xe) }; const Se = function (e, t) { const n = Ce.browsers(); const r = Ce.oses(); const o = pe.detectBrowser(n, e).fold(Q.unknown, Q.nu); const i = pe.detectOs(r, e).fold(fe.unknown, fe.nu); const u = de(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const ke = { detect: Se }; const Te = function (t) { return e.window.matchMedia(t).matches }; const Ee = I(ke.detect(e.navigator.userAgent, Te)); const Oe = function () { return Ee.get() }; const Ne = function (t, n) { const r = n || e.document; const o = r.createElement('div'); if (o.innerHTML = t, !o.hasChildNodes() || o.childNodes.length > 1) { throw e.console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node') } return Ae(o.childNodes[0]) }; const _e = function (t, n) { const r = n || e.document; const o = r.createElement(t); return Ae(o) }; const De = function (t, n) { const r = n || e.document; const o = r.createTextNode(t); return Ae(o) }; var Ae = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: r(e) } }; const Re = function (e, t, n) { const r = e.dom(); return f.from(r.elementFromPoint(t, n)).map(Ae) }; const Be = { fromHtml: Ne, fromTag: _e, fromText: De, fromDom: Ae, fromPoint: Re }; const Me = (e.Node.ATTRIBUTE_NODE, e.Node.CDATA_SECTION_NODE, e.Node.COMMENT_NODE, e.Node.DOCUMENT_NODE, e.Node.DOCUMENT_TYPE_NODE, e.Node.DOCUMENT_FRAGMENT_NODE, e.Node.ELEMENT_NODE); const Pe = (e.Node.TEXT_NODE, e.Node.PROCESSING_INSTRUCTION_NODE, e.Node.ENTITY_REFERENCE_NODE, e.Node.ENTITY_NODE, e.Node.NOTATION_NODE, Me); const ze = function (e, t) { const n = e.dom(); if (n.nodeType !== Pe) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const Ie = function (e, t) { return e.dom() === t.dom() }; const Le = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const He = function (e, t) { return P.documentPositionContainedBy(e.dom(), t.dom()) }; const Fe = Oe().browser; const Ve = Fe.isIE() ? He : Le; const Ue = ze; const je = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils'); const We = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker'); const qe = tinymce.util.Tools.resolve('tinymce.util.VK'); const $e = function (e, t, n) { return e.isSome() && t.isSome() ? f.some(n(e.getOrDie(), t.getOrDie())) : f.none() }; const Ge = function (t, n) { const r = n || e.document; const o = r.createDocumentFragment(); return C(t, function (e) { o.appendChild(e.dom()) }), Be.fromDom(o) }; const Xe = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } if (e.length !== t.length) { throw new Error('Wrong number of arguments to struct. Expected "[' + e.length + ']", got ' + t.length + ' arguments') } const o = {}; return C(e, function (e, n) { o[e] = r(t[n]) }), o } }; const Ye = Object.keys; const Ke = function (e, t) { for (let n = Ye(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; t(u, i) } }; const Je = function (e) { return f.from(e.dom().parentNode).map(Be.fromDom) }; const Ze = function (e) { return x(e.dom().childNodes, Be.fromDom) }; const Qe = function (e, t) { const n = e.dom().childNodes; return f.from(n[t]).map(Be.fromDom) }; const et = function (e) { return Qe(e, 0) }; const tt = function (e) { return Qe(e, e.dom().childNodes.length - 1) }; const nt = (Xe('element', 'offset'), function (e, t) { const n = Je(e); n.each(function (n) { n.dom().insertBefore(t.dom(), e.dom()) }) }); const rt = function (e, t) { e.dom().appendChild(t.dom()) }; const ot = function (e, t) { C(t, function (t) { nt(e, t) }) }; const it = function (e, t) { C(t, function (t) { rt(e, t) }) }; const ut = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const at = function (e, t, n) { return e.fire('ListMutation', { action: t, element: n }) }; const ct = typeof e.window !== 'undefined' ? e.window : Function('return this;')(); const st = function (e, t) { for (var n = void 0 !== t && t !== null ? t : ct, r = 0; r < e.length && void 0 !== n && n !== null; ++r) { n = n[e[r]] } return n }; const lt = function (e, t) { const n = e.split('.'); return st(n, t) }; const ft = function (e, t) { return lt(e, t) }; const dt = function (e, t) { const n = ft(e, t); if (void 0 === n || n === null) { throw new Error(e + ' not available on this browser') } return n }; const mt = { getOrDie: dt }; const gt = function (e) { return mt.getOrDie('HTMLElement', e) }; const ht = function (e) { const t = lt('ownerDocument.defaultView', e); return gt(t).prototype.isPrototypeOf(e) }; const pt = { isPrototypeOf: ht }; const vt = tinymce.util.Tools.resolve('tinymce.dom.DomQuery'); const bt = tinymce.util.Tools.resolve('tinymce.util.Tools'); const yt = function (e) { return e && e.nodeType === 3 }; const wt = function (e) { return e && /^(OL|UL|DL)$/.test(e.nodeName) }; const xt = function (e) { return e && /^(OL|UL)$/.test(e.nodeName) }; const Ct = function (e) { return e && /^(LI|DT|DD)$/.test(e.nodeName) }; const St = function (e) { return e && /^(DT|DD)$/.test(e.nodeName) }; const kt = function (e) { return e && /^(TH|TD)$/.test(e.nodeName) }; const Tt = function (e) { return e && e.nodeName === 'BR' }; const Et = function (e) { return e.parentNode.firstChild === e }; const Ot = function (e) { return e.parentNode.lastChild === e }; const Nt = function (e, t) { return t && !!e.schema.getTextBlockElements()[t.nodeName] }; const _t = function (e, t) { return e && e.nodeName in t }; const Dt = function (e, t) { return !!Tt(t) && !(!e.isBlock(t.nextSibling) || Tt(t.previousSibling)) }; const At = function (e, t, n) { const r = e.isEmpty(t); return !(n && e.select('span[data-mce-type=bookmark]', t).length > 0) && r }; const Rt = function (e, t) { return e.isChildOf(t, e.getRoot()) }; const Bt = { isTextNode: yt, isListNode: wt, isOlUlNode: xt, isDlItemNode: St, isListItemNode: Ct, isTableCellNode: kt, isBr: Tt, isFirstChild: Et, isLastChild: Ot, isTextBlock: Nt, isBlock: _t, isBogusBr: Dt, isEmpty: At, isChildOfBody: Rt }; const Mt = function (e) { const t = e.selection.getStart(!0); return e.dom.getParent(t, 'OL,UL,DL', Vt(e, t)) }; const Pt = function (e, t) { return e && t.length === 1 && t[0] === e }; const zt = function (e) { return bt.grep(e.querySelectorAll('ol,ul,dl'), function (e) { return Bt.isListNode(e) }) }; const It = function (e) { const t = Mt(e); const n = e.selection.getSelectedBlocks(); return Pt(t, n) ? zt(t) : bt.grep(n, function (e) { return Bt.isListNode(e) && t !== e }) }; const Lt = function (e, t) { const n = bt.map(t, function (t) { const n = e.dom.getParent(t, 'li,dd,dt', Vt(e, t)); return n || t }); return vt.unique(n) }; const Ht = function (e) { const t = e.selection.getSelectedBlocks(); return bt.grep(Lt(e, t), function (e) { return Bt.isListItemNode(e) }) }; const Ft = function (e) { return S(Ht(e), Bt.isDlItemNode) }; var Vt = function (e, t) { const n = e.dom.getParents(t, 'TD,TH'); const r = n.length > 0 ? n[0] : e.getBody(); return r }; const Ut = function (e, t) { const n = e.dom.getParents(t, 'ol,ul', Vt(e, t)); return A(n) }; const jt = function (e) { const t = Ut(e, e.selection.getStart()); const n = S(e.selection.getSelectedBlocks(), Bt.isOlUlNode); return t.toArray().concat(n) }; const Wt = function (e) { const t = jt(e); return qt(e, t) }; var qt = function (e, t) { const n = x(t, function (t) { return Ut(e, t).getOr(t) }); return vt.unique(n) }; const $t = function (e) { const t = Mt(e); return pt.isPrototypeOf(t) }; const Gt = { isList: $t, getParentList: Mt, getSelectedSubLists: It, getSelectedListItems: Ht, getClosestListRootElm: Vt, getSelectedDlItems: Ft, getSelectedListRoots: Wt }; const Xt = function (e) { return e.getParam('lists_indent_on_tab', !0) }; const Yt = function (e) { const t = e.getParam('forced_root_block', 'p'); return !1 === t ? '' : !0 === t ? 'p' : t }; const Kt = function (e) { return e.getParam('forced_root_block_attrs', {}) }; const Jt = { shouldIndentOnTab: Xt, getForcedRootBlock: Yt, getForcedRootBlockAttrs: Kt }; const Zt = function (e, t) { let n; let r; let o; const i = e.dom; const u = e.schema.getBlockElements(); const a = i.createFragment(); const c = Jt.getForcedRootBlock(e); if (c && (r = i.create(c), r.tagName === c.toUpperCase() && i.setAttribs(r, Jt.getForcedRootBlockAttrs(e)), Bt.isBlock(t.firstChild, u) || a.appendChild(r)), t) { while (n = t.firstChild) { const s = n.nodeName; o || s === 'SPAN' && n.getAttribute('data-mce-type') === 'bookmark' || (o = !0), Bt.isBlock(n, u) ? (a.appendChild(n), r = null) : c ? (r || (r = i.create(c), a.appendChild(r)), r.appendChild(n)) : a.appendChild(n) } } return c ? o || r.appendChild(i.create('br', { 'data-mce-bogus': '1' })) : a.appendChild(i.create('br')), a }; const Qt = function (e) { const t = e.dom().nodeName; return t.toLowerCase() }; const en = function (e) { return e.dom().nodeType }; const tn = function (e) { return function (t) { return en(t) === e } }; const nn = tn(Me); const rn = function (t, n, r) { if (!(g(r) || p(r) || b(r))) { throw e.console.error('Invalid call to Attr.set. Key ', n, ':: Value ', r, ':: Element ', t), new Error('Attribute value was not simple') } t.setAttribute(n, r + '') }; const on = function (e, t) { const n = e.dom(); Ke(t, function (e, t) { rn(n, t, e) }) }; const un = function (e) { return T(e.dom().attributes, function (e, t) { return e[t.name] = t.value, e }, {}) }; const an = function (e) { return void 0 !== e.style && v(e.style.getPropertyValue) }; const cn = function (t, n, r) { if (!g(r)) { throw e.console.error('Invalid call to CSS.set. Property ', n, ':: Value ', r, ':: Element ', t), new Error('CSS value must be a string: ' + r) } an(t) && t.style.setProperty(n, r) }; const sn = function (e, t, n) { const r = e.dom(); cn(r, t, n) }; const ln = function (e, t) { return Be.fromDom(e.dom().cloneNode(t)) }; const fn = function (e) { return ln(e, !0) }; const dn = function (e, t) { const n = Be.fromTag(t); const r = un(e); return on(n, r), n }; const mn = function (e, t) { const n = dn(e, t); nt(e, n); const r = Ze(e); return it(n, r), ut(e), n }; const gn = function (e, t) { rt(e.item, t.list) }; const hn = function (e) { for (let t = 1; t < e.length; t++) { gn(e[t - 1], e[t]) } }; const pn = function (e, t) { $e(A(e), D(t), gn) }; const vn = function (e, t) { const n = { list: Be.fromTag(t, e), item: Be.fromTag('li', e) }; return rt(n.list, n.item), n }; const bn = function (e, t, n) { for (var r = [], o = 0; o < n; o++) { r.push(vn(e, t.listType)) } return r }; const yn = function (e, t) { for (let n = 0; n < e.length - 1; n++) { sn(e[n].item, 'list-style-type', 'none') }A(e).each(function (e) { on(e.list, t.listAttributes), on(e.item, t.itemAttributes), it(e.item, t.content) }) }; const wn = function (e, t) { Qt(e.list) !== t.listType && (e.list = mn(e.list, t.listType)), on(e.list, t.listAttributes) }; const xn = function (e, t, n) { const r = Be.fromTag('li', e); return on(r, t), it(r, n), r }; const Cn = function (e, t) { rt(e.list, t), e.item = t }; const Sn = function (e, t, n) { const r = t.slice(0, n.depth); return A(r).each(function (t) { const r = xn(e, n.itemAttributes, n.content); Cn(t, r), wn(t, n) }), r }; const kn = function (e, t, n) { const r = bn(e, n, n.depth - t.length); return hn(r), yn(r, n), pn(t, r), t.concat(r) }; const Tn = function (e, t) { const n = T(t, function (t, n) { return n.depth > t.length ? kn(e, t, n) : Sn(e, t, n) }, []); return D(n).map(function (e) { return e.list }) }; const En = function (e) { return Ue(e, 'OL,UL') }; const On = function (e) { return et(e).map(En).getOr(!1) }; const Nn = function (e) { return tt(e).map(En).getOr(!1) }; const _n = function (e) { return e.depth > 0 }; const Dn = function (e) { return e.isSelected }; const An = function (e) { const t = Ze(e); const n = Nn(e) ? t.slice(0, -1) : t; return x(n, fn) }; const Rn = function (e, t, n) { return Je(e).filter(nn).map(function (r) { return { depth: t, isSelected: n, content: An(e), itemAttributes: un(e), listAttributes: un(r), listType: Qt(r) } }) }; const Bn = function (e, t) { switch (e) { case 'Indent':t.depth++; break; case 'Outdent':t.depth--; break; case 'Flatten':t.depth = 0 } }; const Mn = function (e, t) { e.listType = t.listType, e.listAttributes = z({}, t.listAttributes) }; const Pn = function (e, t) { for (let n = e[t].depth, r = t - 1; r >= 0; r--) { if (e[r].depth === n) { return f.some(e[r]) } if (e[r].depth < n) { break } } return f.none() }; const zn = function (e) { C(e, function (t, n) { Pn(e, n).each(function (e) { Mn(t, e) }) }) }; const In = function (e, t, n, r) { return et(r).filter(En).fold(function () { t.each(function (e) { Ie(e.start, r) && n.set(!0) }); const o = Rn(r, e, n.get()); t.each(function (e) { Ie(e.end, r) && n.set(!1) }); const i = tt(r).filter(En).map(function (r) { return Ln(e, t, n, r) }).getOr([]); return o.toArray().concat(i) }, function (r) { return Ln(e, t, n, r) }) }; var Ln = function (e, t, n, r) { return N(Ze(r), function (r) { const o = En(r) ? Ln : In; const i = e + 1; return o(i, t, n, r) }) }; const Hn = function (e, t) { const n = I(!1); const r = 0; return x(e, function (e) { return { sourceList: e, entries: Ln(r, t, n, e) } }) }; const Fn = function (e, t) { return x(t, function (t) { const n = Ge(t.content); return Be.fromDom(Zt(e, n.dom())) }) }; const Vn = function (e, t) { return zn(t), Tn(e.contentDocument, t).toArray() }; const Un = function (e, t) { return N(k(t, _n), function (t) { const n = D(t).map(_n).getOr(!1); return n ? Vn(e, t) : Fn(e, t) }) }; const jn = function (e, t) { C(S(e, Dn), function (e) { return Bn(t, e) }) }; const Wn = function (e) { const t = x(Gt.getSelectedListItems(e), Be.fromDom); return $e(E(t, o(On)), E(_(t), o(On)), function (e, t) { return { start: e, end: t } }) }; const qn = function (e, t, n) { const r = Hn(t, Wn(e)); C(r, function (t) { jn(t.entries, n); const r = Un(e, t.entries); C(r, function (t) { at(e, n === 'Indent' ? 'IndentList' : 'OutdentList', t.dom()) }), ot(t.sourceList, r), ut(t.sourceList) }) }; const $n = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const Gn = $n.DOM; const Xn = function (e, t, n) { let r; let o; let i; let u; let a; const c = function (e) { bt.each(i, function (t) { e.parentNode.insertBefore(t, n.parentNode) }), Gn.remove(e) }; for (i = Gn.select('span[data-mce-type="bookmark"]', t), a = Zt(e, n), r = Gn.createRng(), r.setStartAfter(n), r.setEndAfter(t), o = r.extractContents(), u = o.firstChild; u; u = u.firstChild) { if (u.nodeName === 'LI' && e.dom.isEmpty(u)) { Gn.remove(u); break } }e.dom.isEmpty(o) || Gn.insertAfter(o, t), Gn.insertAfter(a, t), Bt.isEmpty(e.dom, n.parentNode) && c(n.parentNode), Gn.remove(n), Bt.isEmpty(e.dom, t) && Gn.remove(t) }; const Yn = { splitList: Xn }; const Kn = function (e, t) { Ue(t, 'dd') ? mn(t, 'dt') : Ue(t, 'dt') && Je(t).each(function (n) { return Yn.splitList(e, n.dom(), t.dom()) }) }; const Jn = function (e) { Ue(e, 'dt') && mn(e, 'dd') }; const Zn = function (e, t, n) { C(n, t === 'Indent' ? Jn : function (t) { return Kn(e, t) }) }; const Qn = function (e, t) { if (Bt.isTextNode(e)) { return { container: e, offset: t } } const n = je.getNode(e, t); return Bt.isTextNode(n) ? { container: n, offset: t >= e.childNodes.length ? n.data.length : 0 } : n.previousSibling && Bt.isTextNode(n.previousSibling) ? { container: n.previousSibling, offset: n.previousSibling.data.length } : n.nextSibling && Bt.isTextNode(n.nextSibling) ? { container: n.nextSibling, offset: 0 } : { container: e, offset: t } }; const er = function (e) { const t = e.cloneRange(); const n = Qn(e.startContainer, e.startOffset); t.setStart(n.container, n.offset); const r = Qn(e.endContainer, e.endOffset); return t.setEnd(r.container, r.offset), t }; const tr = { getNormalizedPoint: Qn, normalizeRange: er }; const nr = function (e, t) { const n = x(Gt.getSelectedListRoots(e), Be.fromDom); const r = x(Gt.getSelectedDlItems(e), Be.fromDom); let o = !1; if (n.length || r.length) { const i = e.selection.getBookmark(); qn(e, n, t), Zn(e, t, r), e.selection.moveToBookmark(i), e.selection.setRng(tr.normalizeRange(e.selection.getRng())), e.nodeChanged(), o = !0 } return o }; const rr = function (e) { return nr(e, 'Indent') }; const or = function (e) { return nr(e, 'Outdent') }; const ir = function (e) { return nr(e, 'Flatten') }; const ur = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager'); const ar = $n.DOM; const cr = function (e) { const t = {}; const n = function (n) { let r, o, i; o = e[n ? 'startContainer' : 'endContainer'], i = e[n ? 'startOffset' : 'endOffset'], o.nodeType === 1 && (r = ar.create('span', { 'data-mce-type': 'bookmark' }), o.hasChildNodes() ? (i = Math.min(i, o.childNodes.length - 1), n ? o.insertBefore(r, o.childNodes[i]) : ar.insertAfter(r, o.childNodes[i])) : o.appendChild(r), o = r, i = 0), t[n ? 'startContainer' : 'endContainer'] = o, t[n ? 'startOffset' : 'endOffset'] = i }; return n(!0), e.collapsed || n(), t }; const sr = function (e) { function t (t) { let n; let r; let o; const i = function (e) { let t = e.parentNode.firstChild; let n = 0; while (t) { if (t === e) { return n } t.nodeType === 1 && t.getAttribute('data-mce-type') === 'bookmark' || n++, t = t.nextSibling } return -1 }; n = o = e[t ? 'startContainer' : 'endContainer'], r = e[t ? 'startOffset' : 'endOffset'], n && (n.nodeType === 1 && (r = i(n), n = n.parentNode, ar.remove(o), !n.hasChildNodes() && ar.isBlock(n) && n.appendChild(ar.create('br'))), e[t ? 'startContainer' : 'endContainer'] = n, e[t ? 'startOffset' : 'endOffset'] = r) }t(!0), t(); const n = ar.createRng(); return n.setStart(e.startContainer, e.startOffset), e.endContainer && n.setEnd(e.endContainer, e.endOffset), tr.normalizeRange(n) }; const lr = { createBookmark: cr, resolveBookmark: sr }; const fr = function (e) { return /\btox\-/.test(e.className) }; const dr = function (e) { switch (e) { case 'UL':return 'ToggleUlList'; case 'OL':return 'ToggleOlList'; case 'DL':return 'ToggleDLList' } }; const mr = function (e, t, n) { const r = n['list-style-type'] ? n['list-style-type'] : null; e.setStyle(t, 'list-style-type', r) }; const gr = function (e, t) { bt.each(t, function (t, n) { e.setAttribute(n, t) }) }; const hr = function (e, t, n) { gr(t, n['list-attributes']), bt.each(e.select('li', t), function (e) { gr(e, n['list-item-attributes']) }) }; const pr = function (e, t, n) { mr(e, t, n), hr(e, t, n) }; const vr = function (e, t, n) { bt.each(n, function (n) { let r; return e.setStyle(t, (r = {}, r[n] = '', r)) }) }; const br = function (e, t, n, r) { let o, i; o = t[n ? 'startContainer' : 'endContainer'], i = t[n ? 'startOffset' : 'endOffset'], o.nodeType === 1 && (o = o.childNodes[Math.min(i, o.childNodes.length - 1)] || o), !n && Bt.isBr(o.nextSibling) && (o = o.nextSibling); while (o.parentNode !== r) { if (Bt.isTextBlock(e, o)) { return o } if (/^(TD|TH)$/.test(o.parentNode.nodeName)) { return o } o = o.parentNode } return o }; const yr = function (e, t, n) { for (var r, o = [], i = e.dom, u = br(e, t, !0, n), a = br(e, t, !1, n), c = [], s = u; s; s = s.nextSibling) { if (c.push(s), s === a) { break } } return bt.each(c, function (t) { if (Bt.isTextBlock(e, t)) { return o.push(t), void (r = null) } if (i.isBlock(t) || Bt.isBr(t)) { return Bt.isBr(t) && i.remove(t), void (r = null) } const u = t.nextSibling; ur.isBookmarkNode(t) && (Bt.isTextBlock(e, u) || !u && t.parentNode === n) ? r = null : (r || (r = i.create('p'), t.parentNode.insertBefore(r, t), o.push(r)), r.appendChild(t)) }), o }; const wr = function (e, t, n) { const r = e.getStyle(t, 'list-style-type'); let o = n ? n['list-style-type'] : ''; return o = o === null ? '' : o, r === o }; const xr = function (e, t, n) { void 0 === n && (n = {}); let r; const o = e.selection.getRng(!0); let i = 'LI'; const u = Gt.getClosestListRootElm(e, e.selection.getStart(!0)); const a = e.dom; a.getContentEditable(e.selection.getNode()) !== 'false' && (t = t.toUpperCase(), t === 'DL' && (i = 'DT'), r = lr.createBookmark(o), bt.each(yr(e, o, u), function (r) { let o, u; u = r.previousSibling, u && Bt.isListNode(u) && u.nodeName === t && wr(a, u, n) ? (o = u, r = a.rename(r, i), u.appendChild(r)) : (o = a.create(t), r.parentNode.insertBefore(o, r), o.appendChild(r), r = a.rename(r, i)), vr(a, r, ['margin', 'margin-right', 'margin-bottom', 'margin-left', 'margin-top', 'padding', 'padding-right', 'padding-bottom', 'padding-left', 'padding-top']), pr(a, o, n), Er(e.dom, o) }), e.selection.setRng(lr.resolveBookmark(r))) }; const Cr = function (e, t) { return e && t && Bt.isListNode(e) && e.nodeName === t.nodeName }; const Sr = function (e, t, n) { const r = e.getStyle(t, 'list-style-type', !0); const o = e.getStyle(n, 'list-style-type', !0); return r === o }; const kr = function (e, t) { return e.className === t.className }; const Tr = function (e, t, n) { return Cr(t, n) && Sr(e, t, n) && kr(t, n) }; var Er = function (e, t) { let n, r; if (n = t.nextSibling, Tr(e, t, n)) { while (r = n.firstChild) { t.appendChild(r) }e.remove(n) } if (n = t.previousSibling, Tr(e, t, n)) { while (r = n.lastChild) { t.insertBefore(r, t.firstChild) }e.remove(n) } }; const Or = function (e, t, n, r) { if (t.nodeName !== n) { const o = e.dom.rename(t, n); pr(e.dom, o, r), at(e, dr(n), o) } else { pr(e.dom, t, r), at(e, dr(n), t) } }; const Nr = function (e, t, n, r, o) { if (t.nodeName !== r || _r(o)) { const i = lr.createBookmark(e.selection.getRng(!0)); bt.each([t].concat(n), function (t) { Or(e, t, r, o) }), e.selection.setRng(lr.resolveBookmark(i)) } else { ir(e) } }; var _r = function (e) { return 'list-style-type' in e }; const Dr = function (e, t, n, r) { if (t !== e.getBody()) { if (t) { if (t.nodeName !== n || _r(r) || fr(t)) { const o = lr.createBookmark(e.selection.getRng(!0)); pr(e.dom, t, r); const i = e.dom.rename(t, n); Er(e.dom, i), e.selection.setRng(lr.resolveBookmark(o)), at(e, dr(n), i) } else { ir(e) } } else { xr(e, n, r), at(e, dr(n), t) } } }; const Ar = function (e, t, n) { const r = Gt.getParentList(e); const o = Gt.getSelectedSubLists(e); n = n || {}, r && o.length > 0 ? Nr(e, r, o, t, n) : Dr(e, r, t, n) }; const Rr = { toggleList: Ar, mergeWithAdjacentLists: Er }; const Br = $n.DOM; const Mr = function (e, t) { let n; const r = t.parentNode; r.nodeName === 'LI' && r.firstChild === t && (n = r.previousSibling, n && n.nodeName === 'LI' ? (n.appendChild(t), Bt.isEmpty(e, r) && Br.remove(r)) : Br.setStyle(r, 'listStyleType', 'none')), Bt.isListNode(r) && (n = r.previousSibling, n && n.nodeName === 'LI' && n.appendChild(t)) }; const Pr = function (e, t) { bt.each(bt.grep(e.select('ol,ul', t)), function (t) { Mr(e, t) }) }; const zr = { normalizeList: Mr, normalizeLists: Pr }; const Ir = function (e, t, n, r) { let o = t.startContainer; const i = t.startOffset; if (Bt.isTextNode(o) && (n ? i < o.data.length : i > 0)) { return o } const u = e.schema.getNonEmptyElements(); o.nodeType === 1 && (o = je.getNode(o, i)); const a = new We(o, r); n && Bt.isBogusBr(e.dom, o) && a.next(); while (o = a[n ? 'next' : 'prev2']()) { if (o.nodeName === 'LI' && !o.hasChildNodes()) { return o } if (u[o.nodeName]) { return o } if (Bt.isTextNode(o) && o.data.length > 0) { return o } } }; const Lr = function (e, t) { const n = t.childNodes; return n.length === 1 && !Bt.isListNode(n[0]) && e.isBlock(n[0]) }; const Hr = function (e, t) { Lr(e, t) && e.remove(t.firstChild, !0) }; const Fr = function (e, t, n) { let r, o; if (o = Lr(e, n) ? n.firstChild : n, Hr(e, t), !Bt.isEmpty(e, t, !0)) { while (r = t.firstChild) { o.appendChild(r) } } }; const Vr = function (e, t, n) { let r; let o; const i = t.parentNode; if (Bt.isChildOfBody(e, t) && Bt.isChildOfBody(e, n)) { Bt.isListNode(n.lastChild) && (o = n.lastChild), i === n.lastChild && Bt.isBr(i.previousSibling) && e.remove(i.previousSibling), r = n.lastChild, r && Bt.isBr(r) && t.hasChildNodes() && e.remove(r), Bt.isEmpty(e, n, !0) && e.$(n).empty(), Fr(e, t, n), o && n.appendChild(o); const u = Ve(Be.fromDom(n), Be.fromDom(t)); const a = u ? e.getParents(t, Bt.isListNode, n) : []; e.remove(t), C(a, function (t) { Bt.isEmpty(e, t) && t !== e.getRoot() && e.remove(t) }) } }; const Ur = function (e, t, n) { e.dom.$(n).empty(), Vr(e.dom, t, n), e.selection.setCursorLocation(n) }; const jr = function (e, t, n, r) { const o = e.dom; if (o.isEmpty(r)) { Ur(e, n, r) } else { const i = lr.createBookmark(t); Vr(o, n, r), e.selection.setRng(lr.resolveBookmark(i)) } }; const Wr = function (e, t, n, r) { const o = lr.createBookmark(t); Vr(e.dom, n, r); const i = lr.resolveBookmark(o); e.selection.setRng(i) }; const qr = function (e, t) { const n = e.dom; const r = e.selection; const o = r.getStart(); const i = Gt.getClosestListRootElm(e, o); const u = n.getParent(r.getStart(), 'LI', i); if (u) { const a = u.parentNode; if (a === e.getBody() && Bt.isEmpty(n, a)) { return !0 } const c = tr.normalizeRange(r.getRng()); const s = n.getParent(Ir(e, c, t, i), 'LI', i); if (s && s !== u) { return e.undoManager.transact(function () { t ? jr(e, c, s, u) : Bt.isFirstChild(u) ? or(e) : Wr(e, c, u, s) }), !0 } if (!s && !t && c.startOffset === 0 && c.endOffset === 0) { return e.undoManager.transact(function () { ir(e) }), !0 } } return !1 }; const $r = function (e, t, n) { const r = e.getParent(t.parentNode, e.isBlock, n); e.remove(t), r && e.isEmpty(r) && e.remove(r) }; const Gr = function (e, t) { const n = e.dom; const r = e.selection.getStart(); const o = Gt.getClosestListRootElm(e, r); const i = n.getParent(r, n.isBlock, o); if (i && n.isEmpty(i)) { const u = tr.normalizeRange(e.selection.getRng()); const a = n.getParent(Ir(e, u, t, o), 'LI', o); if (a) { return e.undoManager.transact(function () { $r(n, i, o), Rr.mergeWithAdjacentLists(n, a.parentNode), e.selection.select(a, !0), e.selection.collapse(t) }), !0 } } return !1 }; const Xr = function (e, t) { return qr(e, t) || Gr(e, t) }; const Yr = function (e) { const t = e.selection.getStart(); const n = Gt.getClosestListRootElm(e, t); const r = e.dom.getParent(t, 'LI,DT,DD', n); return !!(r || Gt.getSelectedListItems(e).length > 0) && (e.undoManager.transact(function () { e.execCommand('Delete'), zr.normalizeLists(e.dom, e.getBody()) }), !0) }; const Kr = function (e, t) { return e.selection.isCollapsed() ? Xr(e, t) : Yr(e) }; const Jr = function (e) { e.on('keydown', function (t) { t.keyCode === qe.BACKSPACE ? Kr(e, !1) && t.preventDefault() : t.keyCode === qe.DELETE && Kr(e, !0) && t.preventDefault() }) }; const Zr = { setup: Jr, backspaceDelete: Kr }; const Qr = function (e) { return { backspaceDelete (t) { Zr.backspaceDelete(e, t) } } }; const eo = { get: Qr }; const to = function (e, t) { return function () { const n = e.dom.getParent(e.selection.getStart(), 'UL,OL,DL'); return n && n.nodeName === t } }; const no = function (e) { e.on('BeforeExecCommand', function (t) { const n = t.command.toLowerCase(); n === 'indent' ? rr(e) : n === 'outdent' && or(e) }), e.addCommand('InsertUnorderedList', function (t, n) { Rr.toggleList(e, 'UL', n) }), e.addCommand('InsertOrderedList', function (t, n) { Rr.toggleList(e, 'OL', n) }), e.addCommand('InsertDefinitionList', function (t, n) { Rr.toggleList(e, 'DL', n) }), e.addCommand('RemoveList', function () { ir(e) }), e.addQueryStateHandler('InsertUnorderedList', to(e, 'UL')), e.addQueryStateHandler('InsertOrderedList', to(e, 'OL')), e.addQueryStateHandler('InsertDefinitionList', to(e, 'DL')) }; const ro = { register: no }; const oo = function (e) { e.on('keydown', function (t) { t.keyCode !== qe.TAB || qe.metaKeyPressed(t) || e.undoManager.transact(function () { (t.shiftKey ? or(e) : rr(e)) && t.preventDefault() }) }) }; const io = function (e) { Jt.shouldIndentOnTab(e) && oo(e), Zr.setup(e) }; const uo = { setup: io }; const ao = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (t(r)) { return n } } return -1 }; const co = function (e, t) { return function (n) { const r = function (e) { const r = ao(e.parents, Bt.isTableCellNode); const o = r !== -1 ? e.parents.slice(0, r) : e.parents; const i = bt.grep(o, Bt.isListNode); n.setActive(i.length > 0 && i[0].nodeName === t && !fr(i[0])) }; return e.on('NodeChange', r), function () { return e.off('NodeChange', r) } } }; const so = function (e) { const t = function (e, t) { const n = e.settings.plugins ? e.settings.plugins : ''; return bt.inArray(n.split(/[ ,]/), t) !== -1 }; const n = function (t) { return function () { return e.execCommand(t) } }; t(e, 'advlist') || (e.ui.registry.addToggleButton('numlist', { icon: 'ordered-list', active: !1, tooltip: 'Numbered list', onAction: n('InsertOrderedList'), onSetup: co(e, 'OL') }), e.ui.registry.addToggleButton('bullist', { icon: 'unordered-list', active: !1, tooltip: 'Bullet list', onAction: n('InsertUnorderedList'), onSetup: co(e, 'UL') })) }; const lo = { register: so }; function fo () { t.add('lists', function (e) { return uo.setup(e), lo.register(e), ro.register(e), eo.get(e) }) }fo() })(window) }, 36998 (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); var t = function () { return t = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, t.apply(this, arguments) }; const n = function () {}; const r = function (e) { return function () { return e } }; const o = r(!1); const i = r(!0); const u = function () { return a }; var a = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const a = function (e) { return e }; const c = { fold (e, t) { return e() }, is: o, isSome: o, isNone: i, getOr: a, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: r(null), getOrUndefined: r(void 0), or: a, orThunk: t, map: u, each: n, bind: u, exists: o, forall: i, filter: u, equals: e, equals_: e, toArray () { return [] }, toString: r('none()') }; return Object.freeze && Object.freeze(c), c }()); var c = function (e) { const t = r(e); const n = function () { return s }; const u = function (t) { return t(e) }; var s = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: i, isNone: o, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return c(t(e)) }, each (t) { t(e) }, bind: u, exists: u, forall: u, filter (t) { return t(e) ? s : a }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(o, function (t) { return n(e, t) }) } }; return s }; const s = function (e) { return e === null || void 0 === e ? a : c(e) }; const l = { some: c, none: u, from: s }; const f = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const d = function (e) { return function (t) { return f(t) === e } }; const m = d('string'); const g = d('object'); const h = d('array'); const p = d('function'); const v = Array.prototype.slice; const b = Array.prototype.push; const y = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const w = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!h(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } b.apply(t, e[n]) } return t }; var x = (p(Array.from) && Array.from, function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return x(n()) }; return { get: n, set: r, clone: o } }); const C = Object.hasOwnProperty; const S = function (e, t) { return k(e, t) ? l.from(e[t]) : l.none() }; var k = function (e, t) { return C.call(e, t) }; const T = function (e) { return e.getParam('media_scripts') }; const E = function (e) { return e.getParam('audio_template_callback') }; const O = function (e) { return e.getParam('video_template_callback') }; const N = function (e) { return e.getParam('media_live_embeds', !0) }; const _ = function (e) { return e.getParam('media_filter_html', !0) }; const D = function (e) { return e.getParam('media_url_resolver') }; const A = function (e) { return e.getParam('media_alt_source', !0) }; const R = function (e) { return e.getParam('media_poster', !0) }; const B = function (e) { return e.getParam('media_dimensions', !0) }; const M = { getScripts: T, getAudioTemplateCallback: E, getVideoTemplateCallback: O, hasLiveEmbeds: N, shouldFilterHtml: _, getUrlResolver: D, hasAltSource: A, hasPoster: R, hasDimensions: B }; const P = tinymce.util.Tools.resolve('tinymce.util.Tools'); const z = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const I = tinymce.util.Tools.resolve('tinymce.html.SaxParser'); const L = function (e, t) { if (e) { for (let n = 0; n < e.length; n++) { if (t.includes(e[n].filter)) { return e[n] } } } }; const H = z.DOM; const F = function (e) { return e.replace(/px$/, '') }; const V = function (e) { const t = e.map.style; const n = t ? H.parseStyle(t) : {}; return { type: 'ephox-embed-iri', source: e.map['data-ephox-embed-iri'], altsource: '', poster: '', width: S(n, 'max-width').map(F).getOr(''), height: S(n, 'max-height').map(F).getOr('') } }; const U = function (e, t) { const n = x(!1); let r = {}; return I({ validate: !1, allow_conditional_comments: !0, start (t, o) { if (n.get()) { ; } else if (k(o.map, 'data-ephox-embed-iri')) { n.set(!0), r = V(o) } else { if (r.source || t !== 'param' || (r.source = o.map.movie), t !== 'iframe' && t !== 'object' && t !== 'embed' && t !== 'video' && t !== 'audio' || (r.type || (r.type = t), r = P.extend(o.map, r)), t === 'script') { const i = L(e, o.map.src); if (!i) { return } r = { type: 'script', source: o.map.src, width: String(i.width), height: String(i.height) } }t === 'source' && (r.source ? r.altsource || (r.altsource = o.map.src) : r.source = o.map.src), t !== 'img' || r.poster || (r.poster = o.map.src) } } }).parse(t), r.source = r.source || r.src || r.data, r.altsource = r.altsource || '', r.poster = r.poster || '', r }; const j = function (e) { const t = { mp3: 'audio/mpeg', m4a: 'audio/x-m4a', wav: 'audio/wav', mp4: 'video/mp4', webm: 'video/webm', ogg: 'video/ogg', swf: 'application/x-shockwave-flash' }; const n = e.toLowerCase().split('.').pop(); const r = t[n]; return r || '' }; const W = { guess: j }; const q = tinymce.util.Tools.resolve('tinymce.html.Schema'); const $ = tinymce.util.Tools.resolve('tinymce.html.Writer'); const G = z.DOM; const X = function (e) { return /^[0-9.]+$/.test(e) ? e + 'px' : e }; const Y = function (e, t) { for (const n in t) { const r = '' + t[n]; if (e.map[n]) { let o = e.length; while (o--) { const i = e[o]; i.name === n && (r ? (e.map[n] = r, i.value = r) : (delete e.map[n], e.splice(o, 1))) } } else { r && (e.push({ name: n, value: r }), e.map[n] = r) } } }; const K = function (e, t) { const n = t.map.style; const r = n ? G.parseStyle(n) : {}; r['max-width'] = X(e.width), r['max-height'] = X(e.height), Y(t, { style: G.serializeStyle(r) }) }; const J = ['source', 'altsource']; const Z = function (e, t, n) { let r; const o = $(); const i = x(!1); let u = 0; return I({ validate: !1, allow_conditional_comments: !0, comment (e) { o.comment(e) }, cdata (e) { o.cdata(e) }, text (e, t) { o.text(e, t) }, start (e, a, c) { if (i.get()) { ; } else if (k(a.map, 'data-ephox-embed-iri')) { i.set(!0), K(t, a) } else { switch (e) { case 'video':case 'object':case 'embed':case 'img':case 'iframe':void 0 !== t.height && void 0 !== t.width && Y(a, { width: t.width, height: t.height }); break } if (n) { switch (e) { case 'video':Y(a, { poster: t.poster, src: '' }), t.altsource && Y(a, { src: '' }); break; case 'iframe':Y(a, { src: t.source }); break; case 'source':if (u < 2 && (Y(a, { src: t[J[u]], type: t[J[u] + 'mime'] }), !t[J[u]])) { return } u++; break; case 'img':if (!t.poster) { return } r = !0; break } } }o.start(e, a, c) }, end (e) { if (!i.get()) { if (e === 'video' && n) { for (let a = 0; a < 2; a++) { if (t[J[a]]) { const c = []; c.map = {}, u < a && (Y(c, { src: t[J[a]], type: t[J[a] + 'mime'] }), o.start('source', c, !0)) } } } if (t.poster && e === 'object' && n && !r) { const s = []; s.map = {}, Y(s, { src: t.poster, width: t.width, height: t.height }), o.start('img', s, !0) } }o.end(e) } }, q({})).parse(e), o.getContent() }; const Q = { updateHtml: Z }; const ee = [{ regex: /youtu\.be\/([\w\-_\?&=.]+)/i, type: 'iframe', w: 560, h: 314, url: 'www.youtube.com/embed/$1', allowFullscreen: !0 }, { regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i, type: 'iframe', w: 560, h: 314, url: 'www.youtube.com/embed/$2?$4', allowFullscreen: !0 }, { regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i, type: 'iframe', w: 560, h: 314, url: 'www.youtube.com/embed/$1', allowFullscreen: !0 }, { regex: /vimeo\.com\/([0-9]+)/, type: 'iframe', w: 425, h: 350, url: 'player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc', allowFullscreen: !0 }, { regex: /vimeo\.com\/(.*)\/([0-9]+)/, type: 'iframe', w: 425, h: 350, url: 'player.vimeo.com/video/$2?title=0&amp;byline=0', allowFullscreen: !0 }, { regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/, type: 'iframe', w: 425, h: 350, url: 'maps.google.com/maps/ms?msid=$2&output=embed"', allowFullscreen: !1 }, { regex: /dailymotion\.com\/video\/([^_]+)/, type: 'iframe', w: 480, h: 270, url: 'www.dailymotion.com/embed/video/$1', allowFullscreen: !0 }, { regex: /dai\.ly\/([^_]+)/, type: 'iframe', w: 480, h: 270, url: 'www.dailymotion.com/embed/video/$1', allowFullscreen: !0 }]; const te = function (e) { const t = e.match(/^(https?:\/\/|www\.)(.+)$/i); return t && t.length > 1 ? t[1] === 'www.' ? 'https://' : t[1] : 'https://' }; const ne = function (e, t) { for (var n = te(t), r = e.regex.exec(t), o = n + e.url, i = function (e) { o = o.replace('$' + e, function () { return r[e] ? r[e] : '' }) }, u = 0; u < r.length; u++) { i(u) } return o.replace(/\?$/, '') }; const re = function (e) { const t = ee.filter(function (t) { return t.regex.test(e) }); return t.length > 0 ? P.extend({}, t[0], { url: ne(t[0], e) }) : null }; const oe = function (e) { const t = e.allowFullscreen ? ' allowFullscreen="1"' : ''; return '<iframe src="' + e.source + '" width="' + e.width + '" height="' + e.height + '"' + t + '></iframe>' }; const ie = function (e) { let t = '<object data="' + e.source + '" width="' + e.width + '" height="' + e.height + '" type="application/x-shockwave-flash">'; return e.poster && (t += '<img src="' + e.poster + '" width="' + e.width + '" height="' + e.height + '" />'), t += '</object>', t }; const ue = function (e, t) { return t ? t(e) : '<audio controls="controls" src="' + e.source + '">' + (e.altsource ? '\n<source src="' + e.altsource + '"' + (e.altsourcemime ? ' type="' + e.altsourcemime + '"' : '') + ' />\n' : '') + '</audio>' }; const ae = function (e, t) { return t ? t(e) : '<video width="' + e.width + '" height="' + e.height + '"' + (e.poster ? ' poster="' + e.poster + '"' : '') + ' controls="controls">\n<source src="' + e.source + '"' + (e.sourcemime ? ' type="' + e.sourcemime + '"' : '') + ' />\n' + (e.altsource ? '<source src="' + e.altsource + '"' + (e.altsourcemime ? ' type="' + e.altsourcemime + '"' : '') + ' />\n' : '') + '</video>' }; const ce = function (e) { return '<script src="' + e.source + '"><\/script>' }; const se = function (e, t) { const n = P.extend({}, t); if (!n.source && (P.extend(n, U(M.getScripts(e), n.embed)), !n.source)) { return '' } n.altsource || (n.altsource = ''), n.poster || (n.poster = ''), n.source = e.convertURL(n.source, 'source'), n.altsource = e.convertURL(n.altsource, 'source'), n.sourcemime = W.guess(n.source), n.altsourcemime = W.guess(n.altsource), n.poster = e.convertURL(n.poster, 'poster'); const r = re(n.source); if (r && (n.source = r.url, n.type = r.type, n.allowFullscreen = r.allowFullscreen, n.width = n.width || String(r.w), n.height = n.height || String(r.h)), n.embed) { return Q.updateHtml(n.embed, n, !0) } const o = L(M.getScripts(e), n.source); o && (n.type = 'script', n.width = String(o.width), n.height = String(o.height)); const i = M.getAudioTemplateCallback(e); const u = M.getVideoTemplateCallback(e); return n.width = n.width || '300', n.height = n.height || '150', P.each(n, function (t, r) { n[r] = e.dom.encode('' + t) }), n.type === 'iframe' ? oe(n) : n.sourcemime === 'application/x-shockwave-flash' ? ie(n) : n.sourcemime.includes('audio') ? ue(n, i) : n.type === 'script' ? ce(n) : ae(n, u) }; const le = tinymce.util.Tools.resolve('tinymce.util.Promise'); const fe = {}; const de = function (e, t, n) { return new le(function (r, o) { const i = function (n) { return n.html && (fe[e.source] = n), r({ url: e.source, html: n.html ? n.html : t(e) }) }; fe[e.source] ? i(fe[e.source]) : n({ url: e.source }, i, o) }) }; const me = function (e, t) { return new le(function (n) { n({ html: t(e), url: e.source }) }) }; const ge = function (e) { return function (t) { return se(e, t) } }; const he = function (e, t) { const n = M.getUrlResolver(e); return n ? de(t, ge(e), n) : me(t, ge(e)) }; const pe = function (e) { return fe.hasOwnProperty(e) }; const ve = { getEmbedHtml: he, isCached: pe }; const be = function (e, t) { return S(t, e).bind(function (e) { return S(e, 'meta') }) }; const ye = function (e, t, n) { return function (r) { let o; const i = function () { return S(e, r) }; const u = function () { return S(t, r) }; const a = function (e) { return S(e, 'value').bind(function (e) { return e.length > 0 ? l.some(e) : l.none() }) }; const c = function () { return i().bind(function (e) { return g(e) ? a(e).orThunk(u) : u().orThunk(function () { return l.from(e) }) }) }; const s = function () { return u().orThunk(function () { return i().bind(function (e) { return g(e) ? a(e) : l.from(e) }) }) }; return o = {}, o[r] = (r === n ? c() : s()).getOr(''), o } }; const we = function (e, t) { const n = {}; return S(e, 'dimensions').each(function (e) { y(['width', 'height'], function (r) { S(t, r).orThunk(function () { return S(e, r) }).each(function (e) { return n[r] = e }) }) }), n }; const xe = function (e, n) { const r = n ? be(n, e).getOr({}) : {}; const o = ye(e, r, n); return t(t(t(t(t({}, o('source')), o('altsource')), o('poster')), o('embed')), we(e, r)) }; const Ce = function (e) { const n = t(t({}, e), { source: { value: S(e, 'source').getOr('') }, altsource: { value: S(e, 'altsource').getOr('') }, poster: { value: S(e, 'poster').getOr('') } }); return y(['width', 'height'], function (t) { S(e, t).each(function (e) { const r = n.dimensions || {}; r[t] = e, n.dimensions = r }) }), n }; const Se = function (e) { return function (t) { const n = t && t.msg ? 'Media embed handler error: ' + t.msg : 'Media embed handler threw unknown error.'; e.notificationManager.open({ type: 'error', text: n }) } }; const ke = function (e, t) { return U(M.getScripts(e), t) }; const Te = function (e) { return e.getAttribute('data-mce-object') || e.getAttribute('data-ephox-embed-iri') }; const Ee = function (e) { const n = e.selection.getNode(); const r = Te(n) ? e.serializer.serialize(n, { selection: !0 }) : ''; return t({ embed: r }, U(M.getScripts(e), r)) }; const Oe = function (e, n) { return function (r) { if (m(r.url) && r.url.trim().length > 0) { const o = r.html; const i = ke(n, o); const u = t(t({}, i), { source: r.url, embed: o }); e.setData(Ce(u)) } } }; const Ne = function (e, t) { for (var n = e.dom.select('img[data-mce-object]'), r = 0; r < t.length; r++) { for (let o = n.length - 1; o >= 0; o--) { t[r] === n[o] && n.splice(o, 1) } }e.selection.select(n[0]) }; const _e = function (e, t) { const n = e.dom.select('img[data-mce-object]'); e.insertContent(t), Ne(e, n), e.nodeChanged() }; const De = function (e, t, n) { t.embed = Q.updateHtml(t.embed, t), t.embed && (e.source === t.source || ve.isCached(t.source)) ? _e(n, t.embed) : ve.getEmbedHtml(n, t).then(function (e) { _e(n, e.html) }).catch(Se(n)) }; const Ae = function (e) { const n = Ee(e); const r = x(n); const o = Ce(n); const i = function (t, n) { const r = xe(n.getData(), 'source'); t.source !== r.source && (Oe(v, e)({ url: r.source, html: '' }), ve.getEmbedHtml(e, r).then(Oe(v, e)).catch(Se(e))) }; const u = function (t) { const n = xe(t.getData()); const r = ke(e, n.embed); t.setData(Ce(r)) }; const a = function (n, r) { const o = xe(n.getData(), r); const i = se(e, o); n.setData(Ce(t(t({}, o), { embed: i }))) }; const c = [{ name: 'source', type: 'urlinput', filetype: 'media', label: 'Source' }]; const s = M.hasDimensions(e) ? [{ type: 'sizeinput', name: 'dimensions', label: 'Constrain proportions', constrain: !0 }] : []; const l = { title: 'General', name: 'general', items: w([c, s]) }; const f = { type: 'textarea', name: 'embed', label: 'Paste your embed code below:' }; const d = { title: 'Embed', items: [f] }; const m = []; M.hasAltSource(e) && m.push({ name: 'altsource', type: 'urlinput', filetype: 'media', label: 'Alternative source URL' }), M.hasPoster(e) && m.push({ name: 'poster', type: 'urlinput', filetype: 'image', label: 'Media poster (Image URL)' }); const g = { title: 'Advanced', name: 'advanced', items: m }; const h = [l, d]; m.length > 0 && h.push(g); const p = { type: 'tabpanel', tabs: h }; var v = e.windowManager.open({ title: 'Insert/Edit Media', size: 'normal', body: p, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], onSubmit (t) { const n = xe(t.getData()); De(r.get(), n, e), t.close() }, onChange (e, t) { switch (t.name) { case 'source':i(r.get(), e); break; case 'embed':u(e); break; case 'dimensions':case 'altsource':case 'poster':a(e, t.name); break }r.set(xe(e.getData())) }, initialData: o }) }; const Re = { showDialog: Ae, unwrap: xe }; const Be = function (e) { const t = function () { Re.showDialog(e) }; return { showDialog: t } }; const Me = { get: Be }; const Pe = function (e) { const t = function () { Re.showDialog(e) }; e.addCommand('mceMedia', t) }; const ze = { register: Pe }; const Ie = tinymce.util.Tools.resolve('tinymce.html.Node'); const Le = tinymce.util.Tools.resolve('tinymce.Env'); const He = function (e, t) { if (!1 === M.shouldFilterHtml(e)) { return t } let n; const r = $(); return I({ validate: !1, allow_conditional_comments: !1, comment (e) { r.comment(e) }, cdata (e) { r.cdata(e) }, text (e, t) { r.text(e, t) }, start (t, o, i) { if (n = !0, t !== 'script' && t !== 'noscript' && t !== 'svg') { for (let u = o.length - 1; u >= 0; u--) { const a = o[u].name; a.indexOf('on') === 0 && (delete o.map[a], o.splice(u, 1)), a === 'style' && (o[u].value = e.dom.serializeStyle(e.dom.parseStyle(o[u].value), t)) }r.start(t, o, i), n = !1 } }, end (e) { n || r.end(e) } }, q({})).parse(t), r.getContent() }; const Fe = { sanitize: He }; const Ve = function (e, t) { let n; const r = t.name; return n = new Ie('img', 1), n.shortEnded = !0, je(e, t, n), n.attr({ width: t.attr('width') || '300', height: t.attr('height') || (r === 'audio' ? '30' : '150'), style: t.attr('style'), src: Le.transparentSrc, 'data-mce-object': r, class: 'mce-object mce-object-' + r }), n }; const Ue = function (e, t) { let n; let r; let o; const i = t.name; return n = new Ie('span', 1), n.attr({ contentEditable: 'false', style: t.attr('style'), 'data-mce-object': i, class: 'mce-preview-object mce-object-' + i }), je(e, t, n), r = new Ie(i, 1), r.attr({ src: t.attr('src'), allowfullscreen: t.attr('allowfullscreen'), style: t.attr('style'), class: t.attr('class'), width: t.attr('width'), height: t.attr('height'), frameborder: '0' }), o = new Ie('span', 1), o.attr('class', 'mce-shim'), n.append(r), n.append(o), n }; var je = function (e, t, n) { let r, o, i, u, a; i = t.attributes, u = i.length; while (u--) { r = i[u].name, o = i[u].value, r !== 'width' && r !== 'height' && r !== 'style' && (r !== 'data' && r !== 'src' || (o = e.convertURL(o, r)), n.attr('data-mce-p-' + r, o)) }a = t.firstChild && t.firstChild.value, a && (n.attr('data-mce-html', escape(Fe.sanitize(e, a))), n.firstChild = null) }; const We = function (e) { const t = e.attr('class'); return t && /\btiny-pageembed\b/.test(t) }; const qe = function (e) { while (e = e.parent) { if (e.attr('data-ephox-embed-iri') || We(e)) { return !0 } } return !1 }; const $e = function (e) { return function (t) { let n; let r; let o = t.length; while (o--) { n = t[o], n.parent && (n.parent.attr('data-mce-object') || (n.name !== 'script' || (r = L(M.getScripts(e), n.attr('src')), r)) && (r && (r.width && n.attr('width', r.width.toString()), r.height && n.attr('height', r.height.toString())), n.name === 'iframe' && M.hasLiveEmbeds(e) && Le.ceFalse ? qe(n) || n.replace(Ue(e, n)) : qe(n) || n.replace(Ve(e, n)))) } } }; const Ge = { createPreviewIframeNode: Ue, createPlaceholderNode: Ve, placeHolderConverter: $e }; const Xe = function (e) { e.on('preInit', function () { const t = e.schema.getSpecialElements(); P.each('video audio iframe object'.split(' '), function (e) { t[e] = new RegExp('</' + e + '[^>]*>', 'gi') }); const n = e.schema.getBoolAttrs(); P.each('webkitallowfullscreen mozallowfullscreen allowfullscreen'.split(' '), function (e) { n[e] = {} }), e.parser.addNodeFilter('iframe,video,audio,object,embed,script', Ge.placeHolderConverter(e)), e.serializer.addAttributeFilter('data-mce-object', function (t, n) { let r; let o; let i; let u; let a; let c; let s; let l; let f = t.length; while (f--) { if (r = t[f], r.parent) { s = r.attr(n), o = new Ie(s, 1), s !== 'audio' && s !== 'script' && (l = r.attr('class'), l && l.includes('mce-preview-object') ? o.attr({ width: r.firstChild.attr('width'), height: r.firstChild.attr('height') }) : o.attr({ width: r.attr('width'), height: r.attr('height') })), o.attr({ style: r.attr('style') }), u = r.attributes, i = u.length; while (i--) { const d = u[i].name; d.indexOf('data-mce-p-') === 0 && o.attr(d.substr(11), u[i].value) }s === 'script' && o.attr('type', 'text/javascript'), a = r.attr('data-mce-html'), a && (c = new Ie('#text', 3), c.raw = !0, c.value = Fe.sanitize(e, unescape(a)), o.append(c)), r.replace(o) } } }) }), e.on('SetContent', function () { e.$('span.mce-preview-object').each(function (t, n) { const r = e.$(n); r.find('span.mce-shim').length === 0 && r.append('<span class="mce-shim"></span>') }) }) }; const Ye = { setup: Xe }; const Ke = function (e) { e.on('ResolveName', function (e) { let t; e.target.nodeType === 1 && (t = e.target.getAttribute('data-mce-object')) && (e.name = t) }) }; const Je = { setup: Ke }; const Ze = function (e) { e.on('click keyup touchend', function () { const t = e.selection.getNode(); t && e.dom.hasClass(t, 'mce-preview-object') && e.dom.getAttrib(t, 'data-mce-selected') && t.setAttribute('data-mce-selected', '2') }), e.on('ObjectSelected', function (e) { const t = e.target.getAttribute('data-mce-object'); t !== 'audio' && t !== 'script' || e.preventDefault() }), e.on('ObjectResized', function (e) { let t; const n = e.target; n.getAttribute('data-mce-object') && (t = n.getAttribute('data-mce-html'), t && (t = unescape(t), n.setAttribute('data-mce-html', escape(Q.updateHtml(t, { width: String(e.width), height: String(e.height) }))))) }) }; const Qe = { setup: Ze }; const et = function (e, t) { return function (n) { return e.selection.selectorChangedWithUnbind(t.join(','), n.setActive).unbind } }; const tt = function (e) { e.ui.registry.addToggleButton('media', { tooltip: 'Insert/edit media', icon: 'embed', onAction () { e.execCommand('mceMedia') }, onSetup: et(e, ['img[data-mce-object]', 'span[data-mce-object]', 'div[data-ephox-embed-iri]']) }), e.ui.registry.addMenuItem('media', { icon: 'embed', text: 'Media...', onAction () { e.execCommand('mceMedia') } }) }; const nt = { register: tt }; function rt () { e.add('media', function (e) { return ze.register(e), nt.register(e), Je.setup(e), Ye.setup(e), Qe.setup(e), Me.get(e) }) }rt() })() }, '53ca' (e, t, n) { 'use strict'; n.d(t, 'a', function () { return r }); n('a4d3'), n('e01a'), n('d28b'), n('e260'), n('d3b7'), n('3ca3'), n('ddb0'); function r (e) { return r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }, r(e) } }, '69a4' (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = tinymce.util.Tools.resolve('tinymce.util.Tools'); const n = function (e) { return parseInt(e.getParam('plugin_preview_width', '650'), 10) }; const r = function (e) { return parseInt(e.getParam('plugin_preview_height', '500'), 10) }; const o = function (e) { return e.getParam('content_style', '') }; const i = function (e) { return e.getParam('content_css_cors', !1, 'boolean') }; const u = { getPreviewDialogWidth: n, getPreviewDialogHeight: r, getContentStyle: o, shouldUseContentCssCors: i }; const a = tinymce.util.Tools.resolve('tinymce.Env'); const c = function (e) { let n = ''; const r = e.dom.encode; const o = u.getContentStyle(e); n += '<base href="' + r(e.documentBaseURI.getURI()) + '">', o && (n += '<style type="text/css">' + o + '</style>'); const i = u.shouldUseContentCssCors(e) ? ' crossorigin="anonymous"' : ''; t.each(e.contentCSS, function (t) { n += '<link type="text/css" rel="stylesheet" href="' + r(e.documentBaseURI.toAbsolute(t)) + '"' + i + '>' }); let c = e.settings.body_id || 'tinymce'; c.includes('=') && (c = e.getParam('body_id', '', 'hash'), c = c[e.id] || c); let s = e.settings.body_class || ''; s.includes('=') && (s = e.getParam('body_class', '', 'hash'), s = s[e.id] || ''); const l = a.mac ? 'e.metaKey' : 'e.ctrlKey && !e.altKey'; const f = '<script>document.addEventListener && document.addEventListener("click", function(e) {for (var elm = e.target; elm; elm = elm.parentNode) {if (elm.nodeName === "A" && !(' + l + ')) {e.preventDefault();}}}, false);<\/script> '; const d = e.getBody().dir; const m = d ? ' dir="' + r(d) + '"' : ''; const g = '<!DOCTYPE html><html><head>' + n + '</head><body id="' + r(c) + '" class="mce-content-body ' + r(s) + '"' + m + '>' + e.getContent() + f + '</body></html>'; return g }; const s = { getPreviewHtml: c }; const l = function (e) { const t = s.getPreviewHtml(e); const n = e.windowManager.open({ title: 'Preview', size: 'large', body: { type: 'panel', items: [{ name: 'preview', type: 'iframe', sandboxed: !0 }] }, buttons: [{ type: 'cancel', name: 'close', text: 'Close', primary: !0 }], initialData: { preview: t } }); n.focus('close') }; const f = function (e) { e.addCommand('mcePreview', function () { l(e) }) }; const d = { register: f }; const m = function (e) { e.ui.registry.addButton('preview', { icon: 'preview', tooltip: 'Preview', onAction () { return e.execCommand('mcePreview') } }), e.ui.registry.addMenuItem('preview', { icon: 'preview', text: 'Preview', onAction () { return e.execCommand('mcePreview') } }) }; const g = { register: m }; function h () { e.add('preview', function (e) { d.register(e), g.register(e) }) }h() })() }, '7c4f' (e, t, n) { (function (e) { (function (t) { 'use strict'; var n = function (e) { let t = e; const r = function () { return t }; const o = function (e) { t = e }; const i = function () { return n(r()) }; return { get: r, set: o, clone: i } }; const r = tinymce.util.Tools.resolve('tinymce.PluginManager'); const o = function (e) { return !(!/(^|[ ,])powerpaste([, ]|$)/.test(e.settings.plugins) || !r.get('powerpaste')) && (typeof t.window.console !== 'undefined' && t.window.console.log && t.window.console.log("PowerPaste is incompatible with Paste plugin! Remove 'paste' from the 'plugins' option."), !0) }; const i = { hasProPlugin: o }; const u = function (e, t) { return { clipboard: e, quirks: t } }; const a = { get: u }; const c = function (e, t, n, r) { return e.fire('PastePreProcess', { content: t, internal: n, wordContent: r }) }; const s = function (e, t, n, r) { return e.fire('PastePostProcess', { node: t, internal: n, wordContent: r }) }; const l = function (e, t) { return e.fire('PastePlainTextToggle', { state: t }) }; const f = function (e, t) { return e.fire('paste', { ieFake: t }) }; const d = { firePastePreProcess: c, firePastePostProcess: s, firePastePlainTextToggle: l, firePaste: f }; const m = function (e, t) { t.pasteFormat.get() === 'text' ? (t.pasteFormat.set('html'), d.firePastePlainTextToggle(e, !1)) : (t.pasteFormat.set('text'), d.firePastePlainTextToggle(e, !0)), e.focus() }; const g = { togglePlainTextPaste: m }; const h = function (e, t) { e.addCommand('mceTogglePlainTextPaste', function () { g.togglePlainTextPaste(e, t) }), e.addCommand('mceInsertClipboardContent', function (e, n) { n.content && t.pasteHtml(n.content, n.internal), n.text && t.pasteText(n.text) }) }; const p = { register: h }; const v = function () {}; const b = function (e) { return function () { return e } }; const y = b(!1); const w = b(!0); const x = function () { return C }; var C = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const r = { fold (e, t) { return e() }, is: y, isSome: y, isNone: w, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: b(null), getOrUndefined: b(void 0), or: n, orThunk: t, map: x, each: v, bind: x, exists: y, forall: w, filter: x, equals: e, equals_: e, toArray () { return [] }, toString: b('none()') }; return Object.freeze && Object.freeze(r), r }()); var S = function (e) { const t = b(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: w, isNone: y, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return S(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : C }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(y, function (t) { return n(e, t) }) } }; return o }; const k = function (e) { return e === null || void 0 === e ? C : S(e) }; const T = { some: S, none: x, from: k }; const E = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const O = function (e) { return function (t) { return E(t) === e } }; const N = O('function'); const _ = Array.prototype.slice; const D = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const A = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const R = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const B = function (e, t, n) { return A(e, function (e) { n = t(n, e) }), n }; const M = N(Array.from) ? Array.from : function (e) { return _.call(e) }; const P = {}; const z = { exports: P }; (function (t, n, r, o) { (function (o) { if (typeof n === 'object' && typeof r !== 'undefined') { r.exports = o() } else if (typeof t === 'function' && t.amd) { t([], o) } else { let i; i = typeof window !== 'undefined' ? window : typeof e !== 'undefined' ? e : typeof self !== 'undefined' ? self : this, i.EphoxContactWrapper = o() } })(function () { return (function () { function e (t, n, r) { function i (a, c) { if (!n[a]) { if (!t[a]) { const s = typeof o === 'function' && o; if (!c && s) { return s(a, !0) } if (u) { return u(a, !0) } const l = new Error("Cannot find module '" + a + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const f = n[a] = { exports: {} }; t[a][0].call(f.exports, function (e) { const n = t[a][1][e]; return i(n || e) }, f, f.exports, e, t, n, r) } return n[a].exports } for (var u = typeof o === 'function' && o, a = 0; a < r.length; a++) { i(r[a]) } return i } return e }())({ 1: [function (e, t, n) { let r; let o; const i = t.exports = {}; function u () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function c (e) { if (r === setTimeout) { return setTimeout(e, 0) } if ((r === u || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0) } try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function s (e) { if (o === clearTimeout) { return clearTimeout(e) } if ((o === a || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e) } try { return o(e) } catch (t) { try { return o.call(null, e) } catch (t) { return o.call(this, e) } } }(function () { try { r = typeof setTimeout === 'function' ? setTimeout : u } catch (e) { r = u } try { o = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { o = a } })(); let l; let f = []; let d = !1; let m = -1; function g () { d && l && (d = !1, l.length ? f = l.concat(f) : m = -1, f.length && h()) } function h () { if (!d) { const e = c(g); d = !0; let t = f.length; while (t) { l = f, f = []; while (++m < t) { l && l[m].run() }m = -1, t = f.length }l = null, d = !1, s(e) } } function p (e, t) { this.fun = e, this.array = t } function v () {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } }f.push(new p(e, t)), f.length !== 1 || d || c(h) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.prependListener = v, i.prependOnceListener = v, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, {}], 2: [function (e, t, n) { (function (e) { (function (n) { const r = setTimeout; function o () {} function i (e, t) { return function () { e.apply(t, arguments) } } function u (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(e, this) } function a (e, t) { while (e._state === 3) { e = e._value }e._state !== 0 ? (e._handled = !0, u._immediateFn(function () { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let r; try { r = n(e._value) } catch (o) { return void s(t.promise, o) }c(t.promise, r) } else { (e._state === 1 ? c : s)(t.promise, e._value) } })) : e._deferreds.push(t) } function c (e, t) { try { if (t === e) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof u) { return e._state = 3, e._value = t, void l(e) } if (typeof n === 'function') { return void d(i(n, t), e) } }e._state = 1, e._value = t, l(e) } catch (r) { s(e, r) } } function s (e, t) { e._state = 2, e._value = t, l(e) } function l (e) { e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function () { e._handled || u._unhandledRejectionFn(e._value) }); for (let t = 0, n = e._deferreds.length; t < n; t++) { a(e, e._deferreds[t]) }e._deferreds = null } function f (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n } function d (e, t) { let n = !1; try { e(function (e) { n || (n = !0, c(t, e)) }, function (e) { n || (n = !0, s(t, e)) }) } catch (r) { if (n) { return } n = !0, s(t, r) } }u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { const n = new this.constructor(o); return a(this, new f(e, t, n)), n }, u.all = function (e) { const t = Array.prototype.slice.call(e); return new u(function (e, n) { if (t.length === 0) { return e([]) } let r = t.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }t[i] = u, --r === 0 && e(t) } catch (c) { n(c) } } for (let i = 0; i < t.length; i++) { o(i, t[i]) } }) }, u.resolve = function (e) { return e && typeof e === 'object' && e.constructor === u ? e : new u(function (t) { t(e) }) }, u.reject = function (e) { return new u(function (t, n) { n(e) }) }, u.race = function (e) { return new u(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, u._immediateFn = typeof e === 'function' ? function (t) { e(t) } : function (e) { r(e, 0) }, u._unhandledRejectionFn = function (e) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', e) }, u._setImmediateFn = function (e) { u._immediateFn = e }, u._setUnhandledRejectionFn = function (e) { u._unhandledRejectionFn = e }, typeof t !== 'undefined' && t.exports ? t.exports = u : n.Promise || (n.Promise = u) })(this) }).call(this, e('timers').setImmediate) }, { timers: 3 }], 3: [function (e, t, n) { (function (t, r) { const o = e('process/browser.js').nextTick; const i = Function.prototype.apply; const u = Array.prototype.slice; const a = {}; let c = 0; function s (e, t) { this._id = e, this._clearFn = t }n.setTimeout = function () { return new s(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function () { return new s(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function (e) { e.close() }, s.prototype.unref = s.prototype.ref = function () {}, s.prototype.close = function () { this._clearFn.call(window, this._id) }, n.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, n.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, n._unrefActive = n.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(function () { e._onTimeout && e._onTimeout() }, t)) }, n.setImmediate = typeof t === 'function' ? t : function (e) { const t = c++; const r = !(arguments.length < 2) && u.call(arguments, 1); return a[t] = !0, o(function () { a[t] && (r ? e.apply(null, r) : e.call(null), n.clearImmediate(t)) }), t }, n.clearImmediate = typeof r === 'function' ? r : function (e) { delete a[e] } }).call(this, e('timers').setImmediate, e('timers').clearImmediate) }, { 'process/browser.js': 1, timers: 3 }], 4: [function (e, t, n) { const r = e('promise-polyfill'); const o = (function () { return typeof window !== 'undefined' ? window : Function('return this;')() }()); t.exports = { boltExport: o.Promise || r } }, { 'promise-polyfill': 2 }] }, {}, [4])(4) }) })(void 0, P, z, void 0); const I = z.exports.boltExport; var L = function (e) { let n = T.none(); let r = []; const o = function (e) { return L(function (t) { i(function (n) { t(e(n)) }) }) }; var i = function (e) { a() ? s(e) : r.push(e) }; const u = function (e) { n = T.some(e), c(r), r = [] }; var a = function () { return n.isSome() }; var c = function (e) { A(e, s) }; var s = function (e) { n.each(function (n) { t.setTimeout(function () { e(n) }, 0) }) }; return e(u), { get: i, map: o, isReady: a } }; const H = function (e) { return L(function (t) { t(e) }) }; const F = { nu: L, pure: H }; const V = function (e) { t.setTimeout(function () { throw e }, 0) }; var U = function (e) { const t = function (t) { e().then(t, V) }; const n = function (t) { return U(function () { return e().then(t) }) }; const r = function (t) { return U(function () { return e().then(function (e) { return t(e).toPromise() }) }) }; const o = function (t) { return U(function () { return e().then(function () { return t.toPromise() }) }) }; const i = function () { return F.nu(t) }; const u = function () { let t = null; return U(function () { return t === null && (t = e()), t }) }; const a = e; return { map: n, bind: r, anonBind: o, toLazy: i, toCached: u, toPromise: a, get: t } }; const j = function (e) { return U(function () { return new I(e) }) }; const W = function (e) { return U(function () { return I.resolve(e) }) }; const q = { nu: j, pure: W }; const $ = function (e, t) { return t(function (t) { const n = []; let r = 0; const o = function (o) { return function (i) { n[o] = i, r++, r >= e.length && t(n) } }; e.length === 0 ? t([]) : A(e, function (e, t) { e.get(o(t)) }) }) }; const G = function (e) { return $(e, q.nu) }; const X = function (e, t) { return G(D(e, t)) }; const Y = function () { const e = n(T.none()); const t = function () { e.set(T.none()) }; const r = function (t) { e.set(T.some(t)) }; const o = function (t) { e.get().each(t) }; const i = function () { return e.get().isSome() }; return { clear: t, set: r, isSet: i, on: o } }; const K = tinymce.util.Tools.resolve('tinymce.Env'); const J = tinymce.util.Tools.resolve('tinymce.util.Delay'); const Z = tinymce.util.Tools.resolve('tinymce.util.Tools'); const Q = tinymce.util.Tools.resolve('tinymce.util.VK'); const ee = 'x-tinymce/html'; const te = '\x3C!-- ' + ee + ' --\x3E'; const ne = function (e) { return te + e }; const re = function (e) { return e.replace(te, '') }; const oe = function (e) { return e.includes(te) }; const ie = { mark: ne, unmark: re, isMarked: oe, internalHtmlMime () { return ee } }; const ue = tinymce.util.Tools.resolve('tinymce.html.Entities'); const ae = function (e) { return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e) }; const ce = function (e) { return e.replace(/\r?\n/g, '<br>') }; const se = function (e, t) { let n; const r = []; let o = '<' + e; if (typeof t === 'object') { for (n in t) { t.hasOwnProperty(n) && r.push(n + '="' + ue.encodeAllRaw(t[n]) + '"') }r.length && (o += ' ' + r.join(' ')) } return o + '>' }; const le = function (e, t, n) { const r = e.split(/\n\n/); const o = se(t, n); const i = '</' + t + '>'; const u = Z.map(r, function (e) { return e.split(/\n/).join('<br />') }); const a = function (e) { return o + e + i }; return u.length === 1 ? u[0] : Z.map(u, a).join('') }; const fe = function (e, t, n) { return t ? le(e, !0 === t ? 'p' : t, n) : ce(e) }; const de = { isPlainText: ae, convert: fe, toBRs: ce, toBlockElements: le }; const me = tinymce.util.Tools.resolve('tinymce.html.DomParser'); const ge = tinymce.util.Tools.resolve('tinymce.html.Serializer'); const he = tinymce.util.Tools.resolve('tinymce.html.Node'); const pe = tinymce.util.Tools.resolve('tinymce.html.Schema'); const ve = function (e) { return e.getParam('paste_block_drop', !1) }; const be = function (e) { return e.getParam('paste_data_images', !1) }; const ye = function (e) { return e.getParam('paste_filter_drop', !0) }; const we = function (e) { return e.getParam('paste_preprocess') }; const xe = function (e) { return e.getParam('paste_postprocess') }; const Ce = function (e) { return e.getParam('paste_webkit_styles') }; const Se = function (e) { return e.getParam('paste_remove_styles_if_webkit', !0) }; const ke = function (e) { return e.getParam('paste_merge_formats', !0) }; const Te = function (e) { return e.getParam('smart_paste', !0) }; const Ee = function (e) { return e.getParam('paste_as_text', !1) }; const Oe = function (e) { return e.getParam('paste_retain_style_properties') }; const Ne = function (e) { const t = '-strong/b,-em/i,-u,-span,-p,-ol,-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,-p/div,-a[href|name],sub,sup,strike,br,del,table[width],tr,td[colspan|rowspan|width],th[colspan|rowspan|width],thead,tfoot,tbody'; return e.getParam('paste_word_valid_elements', t) }; const _e = function (e) { return e.getParam('paste_convert_word_fake_lists', !0) }; const De = function (e) { return e.getParam('paste_enable_default_filters', !0) }; const Ae = { shouldBlockDrop: ve, shouldPasteDataImages: be, shouldFilterDrop: ye, getPreProcess: we, getPostProcess: xe, getWebkitStyles: Ce, shouldRemoveWebKitStyles: Se, shouldMergeFormats: ke, isSmartPasteEnabled: Te, isPasteAsTextEnabled: Ee, getRetainStyleProps: Oe, getWordValidElements: Ne, shouldConvertWordFakeLists: _e, shouldUseDefaultFilters: De }; const Re = ' '; function Be (e, t) { return Z.each(t, function (t) { e = t.constructor === RegExp ? e.replace(t, '') : e.replace(t[0], t[1]) }), e } function Me (e) { const t = pe(); const n = me({}, t); let r = ''; const o = t.getShortEndedElements(); const i = Z.makeMap('script noscript style textarea video audio iframe object', ' '); const u = t.getBlockElements(); function a (e) { const t = e.name; const n = e; if (t !== 'br') { if (t !== 'wbr') { if (o[t] && (r += ' '), i[t]) { r += ' ' } else { if (e.type === 3 && (r += e.value), !e.shortEnded && (e = e.firstChild)) { do { a(e) } while (e = e.next) } u[t] && n.next && (r += '\n', t === 'p' && (r += '\n')) } } } else { r += '\n' } } return e = Be(e, [/<!\[[^\]]+\]>/g]), a(n.parse(e)), r } function Pe (e) { function t (e, t, n) { return t || n ? Re : ' ' } return e = Be(e, [/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class="Apple-converted-space">\u00A0<\/span>( ?)/g, t], /<br class="Apple-interchange-newline">/g, /<br>$/i]), e } function ze (e) { let t = 0; return function () { return e + t++ } } const Ie = function () { return t.navigator.userAgent.includes(' Edge/') }; const Le = { filter: Be, innerText: Me, trimHtml: Pe, createIdGenerator: ze, isMsEdge: Ie }; function He (e) { return /<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i.test(e) || /class="OutlineElement/.test(e) || /id="?docs\-internal\-guid\-/.test(e) } function Fe (e) { let t, n; return n = [/^[IVXLMCD]{1,2}\.[ \u00A0]/, /^[ivxlmcd]{1,2}\.[ \u00A0]/, /^[a-z]{1,2}[\.\)][ \u00A0]/, /^[A-Z]{1,2}[\.\)][ \u00A0]/, /^[0-9]+\.[ \u00A0]/, /^[\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D]+\.[ \u00A0]/, /^[\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D\u62FE]+\.[ \u00A0]/], e = e.replace(/^[\u00A0 ]+/, ''), Z.each(n, function (n) { if (n.test(e)) { return t = !0, !1 } }), t } function Ve (e) { return /^[\s\u00A0]*[\u2022\u00B7\u00A7\u25CF]\s*/.test(e) } function Ue (e) { let t; let n; let r = 1; function o (e) { let t = ''; if (e.type === 3) { return e.value } if (e = e.firstChild) { do { t += o(e) } while (e = e.next) } return t } function i (e, t) { if (e.type === 3 && t.test(e.value)) { return e.value = e.value.replace(t, ''), !1 } if (e = e.firstChild) { do { if (!i(e, t)) { return !1 } } while (e = e.next) } return !0 } function u (e) { if (e._listIgnore) { e.remove() } else if (e = e.firstChild) { do { u(e) } while (e = e.next) } } function a (e, o, a) { const c = e._listLevel || r; c !== r && (c < r ? t && (t = t.parent.parent) : (n = t, t = null)), t && t.name === o ? t.append(e) : (n = n || t, t = new he(o, 1), a > 1 && t.attr('start', '' + a), e.wrap(t)), e.name = 'li', c > r && n && n.lastChild.append(t), r = c, u(e), i(e, /^\u00A0+/), i(e, /^\s*([\u2022\u00B7\u00A7\u25CF]|\w+\.)/), i(e, /^\u00A0+/) } const c = []; let s = e.firstChild; while (typeof s !== 'undefined' && s !== null) { if (c.push(s), s = s.walk(), s !== null) { while (typeof s !== 'undefined' && s.parent !== e) { s = s.walk() } } } for (let l = 0; l < c.length; l++) { if (e = c[l], e.name === 'p' && e.firstChild) { const f = o(e); if (Ve(f)) { a(e, 'ul'); continue } if (Fe(f)) { const d = /([0-9]+)\./.exec(f); let m = 1; d && (m = parseInt(d[1], 10)), a(e, 'ol', m); continue } if (e._listLevel) { a(e, 'ul', 1); continue }t = null } else { n = t, t = null } } } function je (e, t, n, r) { let o; let i = {}; const u = e.dom.parseStyle(r); return Z.each(u, function (u, a) { switch (a) { case 'mso-list':o = /\w+ \w+([0-9]+)/i.exec(r), o && (n._listLevel = parseInt(o[1], 10)), /Ignore/i.test(u) && n.firstChild && (n._listIgnore = !0, n.firstChild._listIgnore = !0); break; case 'horiz-align':a = 'text-align'; break; case 'vert-align':a = 'vertical-align'; break; case 'font-color':case 'mso-foreground':a = 'color'; break; case 'mso-background':case 'mso-highlight':a = 'background'; break; case 'font-weight':case 'font-style':return void (u !== 'normal' && (i[a] = u)); case 'mso-element':if (/^(comment|comment-list)$/i.test(u)) { return void n.remove() } break }a.indexOf('mso-comment') !== 0 ? a.indexOf('mso-') !== 0 && (Ae.getRetainStyleProps(e) === 'all' || t && t[a]) && (i[a] = u) : n.remove() }), /(bold)/i.test(i['font-weight']) && (delete i['font-weight'], n.wrap(new he('b', 1))), /(italic)/i.test(i['font-style']) && (delete i['font-style'], n.wrap(new he('i', 1))), i = e.dom.serializeStyle(i, n.name), i || null } const We = function (e, t) { let n, r; n = Ae.getRetainStyleProps(e), n && (r = Z.makeMap(n.split(/[, ]/))), t = Le.filter(t, [/<br class="?Apple-interchange-newline"?>/gi, /<b[^>]+id="?docs-internal-[^>]*>/gi, /<!--[\s\S]+?-->/gi, /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, [/<(\/?)s>/gi, '<$1strike>'], [/&nbsp;/gi, Re], [/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00A0]*)<\/span>/gi, function (e, t) { return t.length > 0 ? t.replace(/./, ' ').slice(Math.floor(t.length / 2)).split('').join(Re) : '' }]]); const o = Ae.getWordValidElements(e); const i = pe({ valid_elements: o, valid_children: '-li[p]' }); Z.each(i.elements, function (e) { e.attributes.class || (e.attributes.class = {}, e.attributesOrder.push('class')), e.attributes.style || (e.attributes.style = {}, e.attributesOrder.push('style')) }); const u = me({}, i); u.addAttributeFilter('style', function (t) { let n; let o = t.length; while (o--) { n = t[o], n.attr('style', je(e, r, n, n.attr('style'))), n.name === 'span' && n.parent && !n.attributes.length && n.unwrap() } }), u.addAttributeFilter('class', function (e) { let t; let n; let r = e.length; while (r--) { t = e[r], n = t.attr('class'), /^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(n) && t.remove(), t.attr('class', null) } }), u.addNodeFilter('del', function (e) { let t = e.length; while (t--) { e[t].remove() } }), u.addNodeFilter('a', function (e) { let t; let n; let r; let o = e.length; while (o--) { if (t = e[o], n = t.attr('href'), r = t.attr('name'), n && n.includes('#_msocom_')) { t.remove() } else if (n && n.indexOf('file://') === 0 && (n = n.split('#')[1], n && (n = '#' + n)), n || r) { if (r && !/^_?(?:toc|edn|ftn)/i.test(r)) { t.unwrap(); continue }t.attr({ href: n, name: r }) } else { t.unwrap() } } }); const a = u.parse(t); return Ae.shouldConvertWordFakeLists(e) && Ue(a), t = ge({ validate: e.settings.validate }, i).serialize(a), t }; const qe = function (e, t) { return Ae.shouldUseDefaultFilters(e) ? We(e, t) : t }; const $e = { preProcess: qe, isWordContent: He }; const Ge = function (e, t) { const n = me({}, e.schema); n.addNodeFilter('meta', function (e) { Z.each(e, function (e) { return e.remove() }) }); const r = n.parse(t, { forced_root_block: !1, isRootContent: !0 }); return ge({ validate: e.settings.validate }, e.schema).serialize(r) }; const Xe = function (e, t) { return { content: e, cancelled: t } }; const Ye = function (e, t, n, r) { const o = e.dom.create('div', { style: 'display:none' }, t); const i = d.firePastePostProcess(e, o, n, r); return Xe(i.node.innerHTML, i.isDefaultPrevented()) }; const Ke = function (e, t, n, r) { const o = d.firePastePreProcess(e, t, n, r); const i = Ge(e, o.content); return e.hasEventListeners('PastePostProcess') && !o.isDefaultPrevented() ? Ye(e, i, n, r) : Xe(i, o.isDefaultPrevented()) }; const Je = function (e, t, n) { const r = $e.isWordContent(t); const o = r ? $e.preProcess(e, t) : t; return Ke(e, o, n, r) }; const Ze = { process: Je }; const Qe = function (e, t) { return e.insertContent(t, { merge: Ae.shouldMergeFormats(e), paste: !0 }), !0 }; const et = function (e) { return /^https?:\/\/[\w\?\-\/+=.&%@~#]+$/i.test(e) }; const tt = function (e) { return et(e) && /.(gif|jpe?g|png)$/.test(e) }; const nt = function (e, t, n) { return e.undoManager.extra(function () { n(e, t) }, function () { e.insertContent('<img src="' + t + '">') }), !0 }; const rt = function (e, t, n) { return e.undoManager.extra(function () { n(e, t) }, function () { e.execCommand('mceInsertLink', !1, t) }), !0 }; const ot = function (e, t, n) { return !(!1 !== e.selection.isCollapsed() || !et(t)) && rt(e, t, n) }; const it = function (e, t, n) { return !!tt(t) && nt(e, t, n) }; const ut = function (e, t) { Z.each([ot, it, Qe], function (n) { return !0 !== n(e, t, Qe) }) }; const at = function (e, t, n) { n || !1 === Ae.isSmartPasteEnabled(e) ? Qe(e, t) : ut(e, t) }; const ct = { isImageUrl: tt, isAbsoluteUrl: et, insertContent: at }; const st = function (e) { return ' \f\t\v'.includes(e) }; const lt = function (e) { return e === '\n' || e === '\r' }; const ft = function (e, t) { return t < e.length && t >= 0 && lt(e[t]) }; const dt = function (e) { const t = B(e, function (t, n) { return st(n) || n === Re ? t.pcIsSpace || t.str === '' || t.str.length === e.length - 1 || ft(e, t.str.length + 1) ? { pcIsSpace: !1, str: t.str + Re } : { pcIsSpace: !0, str: t.str + ' ' } : { pcIsSpace: lt(n), str: t.str + n } }, { pcIsSpace: !1, str: '' }); return t.str }; const mt = function (e, t, n, r) { const o = Ze.process(e, t, n); !1 === o.cancelled && ct.insertContent(e, o.content, r) }; const gt = function (e, t, n) { const r = n || ie.isMarked(t); mt(e, ie.unmark(t), r, !1) }; const ht = function (e, t) { const n = e.dom.encode(t).replace(/\r\n/g, '\n'); const r = dt(n); const o = de.convert(r, e.settings.forced_root_block, e.settings.forced_root_block_attrs); mt(e, o, !1, !0) }; const pt = function (e) { const t = {}; const n = 'data:text/mce-internal,'; if (e) { if (e.getData) { const r = e.getData('Text'); r && r.length > 0 && !r.includes(n) && (t['text/plain'] = r) } if (e.types) { for (let o = 0; o < e.types.length; o++) { const i = e.types[o]; try { t[i] = e.getData(i) } catch (u) { t[i] = '' } } } } return t }; const vt = function (e, t) { const n = pt(t.clipboardData || e.getDoc().dataTransfer); return Le.isMsEdge() ? Z.extend(n, { 'text/html': '' }) : n }; const bt = function (e, t) { return t in e && e[t].length > 0 }; const yt = function (e) { return bt(e, 'text/html') || bt(e, 'text/plain') }; const wt = function (e) { let t; return t = e.indexOf(','), t !== -1 ? e.substr(t + 1) : null }; const xt = function (e, t) { return !e.images_dataimg_filter || e.images_dataimg_filter(t) }; const Ct = function (e, t) { const n = t.match(/([\s\S]+?)\.(?:jpeg|jpg|png|gif)$/i); return n ? e.dom.encode(n[1]) : null }; const St = Le.createIdGenerator('mceclip'); const kt = function (e, n) { const r = wt(n.uri); const o = St(); const i = e.settings.images_reuse_filename && n.blob.name ? Ct(e, n.blob.name) : o; const u = new t.Image(); if (u.src = n.uri, xt(e.settings, u)) { const a = e.editorUpload.blobCache; let c = void 0; let s = void 0; s = a.findFirst(function (e) { return e.base64() === r }), s ? c = s : (c = a.create(o, n.blob, r, i), a.add(c)), gt(e, '<img src="' + c.blobUri() + '">', !1) } else { gt(e, '<img src="' + n.uri + '">', !1) } }; const Tt = function (e) { return e.type === 'paste' }; const Et = function (e) { return X(e, function (e) { return q.nu(function (t) { const n = e.getAsFile ? e.getAsFile() : e; const r = new window.FileReader(); r.onload = function () { t({ blob: n, uri: r.result }) }, r.readAsDataURL(n) }) }) }; const Ot = function (e) { const t = e.items ? D(M(e.items), function (e) { return e.getAsFile() }) : []; const n = e.files ? M(e.files) : []; const r = R(t.length > 0 ? t : n, function (e) { return /^image\/(jpeg|png|gif|bmp)$/.test(e.type) }); return r }; const Nt = function (e, t, n) { const r = Tt(t) ? t.clipboardData : t.dataTransfer; if (e.settings.paste_data_images && r) { const o = Ot(r); if (o.length > 0) { return t.preventDefault(), Et(o).get(function (t) { n && e.selection.setRng(n), A(t, function (t) { kt(e, t) }) }), !0 } } return !1 }; const _t = function (e) { const n = e.clipboardData; return t.navigator.userAgent.includes('Android') && n && n.items && n.items.length === 0 }; const Dt = function (e) { return Q.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45 }; const At = function (e, n, r) { let o; const i = Y(); function u (t, r, o, i) { let u, a, c; bt(t, 'text/html') ? u = t['text/html'] : (u = n.getHtml(), i = i || ie.isMarked(u), n.isDefaultContent(u) && (o = !0)), u = Le.trimHtml(u), n.remove(), a = !1 === i && de.isPlainText(u), c = ct.isImageUrl(u), (!u.length || a && !c) && (o = !0), (o || c) && (u = bt(t, 'text/plain') && a ? t['text/plain'] : Le.textContent(u)), n.isDefaultContent(u) ? r || e.windowManager.alert('Please use Ctrl+V/Cmd+V keyboard shortcuts to paste contents.') : o ? ht(e, u) : gt(e, u, i) }e.on('keydown', function (r) { function u (e) { Dt(e) && !e.isDefaultPrevented() && n.remove() } if (Dt(r) && !r.isDefaultPrevented()) { if (o = r.shiftKey && r.keyCode === 86, o && K.webkit && t.navigator.userAgent.includes('Version/')) { return } if (r.stopImmediatePropagation(), i.set(r), window.setTimeout(function () { i.clear() }, 100), K.ie && o) { return r.preventDefault(), void d.firePaste(e, !0) } n.remove(), n.create(), e.once('keyup', u), e.once('paste', function () { e.off('keyup', u) }) } }); const a = function () { return n.getLastRng() || e.selection.getRng() }; e.on('paste', function (t) { const c = i.isSet(); const s = vt(e, t); const l = r.get() === 'text' || o; let f = bt(s, ie.internalHtmlMime()); o = !1, t.isDefaultPrevented() || _t(t) ? n.remove() : yt(s) || !Nt(e, t, a()) ? (c || t.preventDefault(), !K.ie || c && !t.ieFake || bt(s, 'text/html') || (n.create(), e.dom.bind(n.getEl(), 'paste', function (e) { e.stopPropagation() }), e.getDoc().execCommand('Paste', !1, null), s['text/html'] = n.getHtml()), bt(s, 'text/html') ? (t.preventDefault(), f || (f = ie.isMarked(s['text/html'])), u(s, c, l, f)) : J.setEditorTimeout(e, function () { u(s, c, l, f) }, 0)) : n.remove() }) }; const Rt = function (e, t, n) { let r; At(e, t, n), e.parser.addNodeFilter('img', function (t, n, o) { const i = function (e) { return e.data && !0 === e.data.paste }; const u = function (e) { e.attr('data-mce-object') || r === K.transparentSrc || e.remove() }; const a = function (e) { return e.indexOf('webkit-fake-url') === 0 }; const c = function (e) { return e.indexOf('data:') === 0 }; if (!e.settings.paste_data_images && i(o)) { let s = t.length; while (s--) { r = t[s].attr('src'), r && (a(r) ? u(t[s]) : !e.settings.allow_html_data_urls && c(r) && u(t[s])) } } }) }; const Bt = function (e) { return K.ie && e.inline ? t.document.body : e.getBody() }; const Mt = function (e) { return Bt(e) !== e.getBody() }; const Pt = function (e, t, n) { Mt(e) && e.dom.bind(t, 'paste keyup', function (t) { jt(e, n) || e.fire('paste') }) }; const zt = function (e, t, n) { let r; const o = e.dom; const i = e.getBody(); t.set(e.selection.getRng()), r = e.dom.add(Bt(e), 'div', { id: 'mcepastebin', class: 'mce-pastebin', contentEditable: !0, 'data-mce-bogus': 'all', style: 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0' }, n), (K.ie || K.gecko) && o.setStyle(r, 'left', o.getStyle(i, 'direction', !0) === 'rtl' ? 65535 : -65535), o.bind(r, 'beforedeactivate focusin focusout', function (e) { e.stopPropagation() }), Pt(e, r, n), r.focus(), e.selection.select(r, !0) }; const It = function (e, t) { if (Lt(e)) { let n = void 0; const r = t.get(); while (n = e.dom.get('mcepastebin')) { e.dom.remove(n), e.dom.unbind(n) }r && e.selection.setRng(r) }t.set(null) }; var Lt = function (e) { return e.dom.get('mcepastebin') }; const Ht = function (e) { let t; let n; let r; let o; let i; const u = function (t, n) { t.appendChild(n), e.dom.remove(n, !0) }; for (n = Z.grep(Bt(e).childNodes, function (e) { return e.id === 'mcepastebin' }), t = n.shift(), Z.each(n, function (e) { u(t, e) }), o = e.dom.select('div[id=mcepastebin]', t), r = o.length - 1; r >= 0; r--) { i = e.dom.create('div'), t.insertBefore(i, o[r]), u(i, o[r]) } return t ? t.innerHTML : '' }; const Ft = function (e) { return e.get() }; const Vt = function (e, t) { return t === e }; const Ut = function (e) { return e && e.id === 'mcepastebin' }; var jt = function (e, t) { const n = Lt(e); return Ut(n) && Vt(t, n.innerHTML) }; const Wt = function (e) { const t = n(null); const r = '%MCEPASTEBIN%'; return { create () { return zt(e, t, r) }, remove () { return It(e, t) }, getEl () { return Lt(e) }, getHtml () { return Ht(e) }, getLastRng () { return Ft(t) }, isDefault () { return jt(e, r) }, isDefaultContent (e) { return Vt(r, e) } } }; const qt = function (e, t) { const n = Wt(e); return e.on('PreInit', function () { return Rt(e, n, t) }), { pasteFormat: t, pasteHtml (t, n) { return gt(e, t, n) }, pasteText (t) { return ht(e, t) }, pasteImageData (t, n) { return Nt(e, t, n) }, getDataTransferItems: pt, hasHtmlOrText: yt, hasContentType: bt } }; const $t = function (e) { return !1 === K.iOS && void 0 !== e && typeof e.setData === 'function' && !0 !== Le.isMsEdge() }; const Gt = function (e, t, n) { if (!$t(e)) { return !1 } try { return e.clearData(), e.setData('text/html', t), e.setData('text/plain', n), e.setData(ie.internalHtmlMime(), t), !0 } catch (r) { return !1 } }; const Xt = function (e, t, n, r) { Gt(e.clipboardData, t.html, t.text) ? (e.preventDefault(), r()) : n(t.html, r) }; const Yt = function (e) { return function (t, n) { const r = ie.mark(t); const o = e.dom.create('div', { contenteditable: 'false', 'data-mce-bogus': 'all' }); const i = e.dom.create('div', { contenteditable: 'true' }, r); e.dom.setStyles(o, { position: 'fixed', top: '0', left: '-3000px', width: '1000px', overflow: 'hidden' }), o.appendChild(i), e.dom.add(e.getBody(), o); const u = e.selection.getRng(); i.focus(); const a = e.dom.createRng(); a.selectNodeContents(i), e.selection.setRng(a), J.setTimeout(function () { e.selection.setRng(u), o.parentNode.removeChild(o), n() }, 0) } }; const Kt = function (e) { return { html: e.selection.getContent({ contextual: !0 }), text: e.selection.getContent({ format: 'text' }) } }; const Jt = function (e) { return !!e.dom.getParent(e.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', e.getBody()) }; const Zt = function (e) { return !e.selection.isCollapsed() || Jt(e) }; const Qt = function (e) { return function (t) { Zt(e) && Xt(t, Kt(e), Yt(e), function () { if (K.browser.isChrome()) { const t = e.selection.getRng(); J.setEditorTimeout(e, function () { e.selection.setRng(t), e.execCommand('Delete') }, 0) } else { e.execCommand('Delete') } }) } }; const en = function (e) { return function (t) { Zt(e) && Xt(t, Kt(e), Yt(e), function () {}) } }; const tn = function (e) { e.on('cut', Qt(e)), e.on('copy', en(e)) }; const nn = { register: tn }; const rn = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils'); const on = function (e, t) { return rn.getCaretRangeFromPoint(t.clientX, t.clientY, e.getDoc()) }; const un = function (e) { const t = e['text/plain']; return !!t && t.indexOf('file://') === 0 }; const an = function (e, t) { e.focus(), e.selection.setRng(t) }; const cn = function (e, t, n) { Ae.shouldBlockDrop(e) && e.on('dragend dragover draggesture dragdrop drop drag', function (e) { e.preventDefault(), e.stopPropagation() }), Ae.shouldPasteDataImages(e) || e.on('drop', function (e) { const t = e.dataTransfer; t && t.files && t.files.length > 0 && e.preventDefault() }), e.on('drop', function (r) { let o, i; if (i = on(e, r), !r.isDefaultPrevented() && !n.get()) { o = t.getDataTransferItems(r.dataTransfer); const u = t.hasContentType(o, ie.internalHtmlMime()); if ((t.hasHtmlOrText(o) && !un(o) || !t.pasteImageData(r, i)) && i && Ae.shouldFilterDrop(e)) { let a = o['mce-internal'] || o['text/html'] || o['text/plain']; a && (r.preventDefault(), J.setEditorTimeout(e, function () { e.undoManager.transact(function () { o['mce-internal'] && e.execCommand('Delete'), an(e, i), a = Le.trimHtml(a), o['text/html'] ? t.pasteHtml(a, u) : t.pasteText(a) }) })) } } }), e.on('dragstart', function (e) { n.set(!0) }), e.on('dragover dragend', function (t) { Ae.shouldPasteDataImages(e) && !1 === n.get() && (t.preventDefault(), an(e, on(e, t))), t.type === 'dragend' && n.set(!1) }) }; const sn = { setup: cn }; const ln = function (e) { const t = e.plugins.paste; const n = Ae.getPreProcess(e); n && e.on('PastePreProcess', function (e) { n.call(t, t, e) }); const r = Ae.getPostProcess(e); r && e.on('PastePostProcess', function (e) { r.call(t, t, e) }) }; const fn = { setup: ln }; function dn (e, t) { e.on('PastePreProcess', function (n) { n.content = t(e, n.content, n.internal, n.wordContent) }) } function mn (e, t) { e.on('PastePostProcess', function (n) { t(e, n.node) }) } function gn (e, t) { if (!$e.isWordContent(t)) { return t } const n = []; Z.each(e.schema.getBlockElements(), function (e, t) { n.push(t) }); const r = new RegExp('(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(' + n.join('|') + ')[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*', 'g'); return t = Le.filter(t, [[r, '$1']]), t = Le.filter(t, [[/<br><br>/g, '<BR><BR>'], [/<br>/g, ' '], [/<BR><BR>/g, '<br>']]), t } function hn (e, t, n, r) { if (r || n) { return t } let o; const i = Ae.getWebkitStyles(e); if (!1 === Ae.shouldRemoveWebKitStyles(e) || i === 'all') { return t } if (i && (o = i.split(/[, ]/)), o) { const u = e.dom; const a = e.selection.getNode(); t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, function (e, t, n, r) { const i = u.parseStyle(u.decode(n)); let c = {}; if (o === 'none') { return t + r } for (let s = 0; s < o.length; s++) { let l = i[o[s]]; let f = u.getStyle(a, o[s], !0); /color/.test(o[s]) && (l = u.toHex(l), f = u.toHex(f)), f !== l && (c[o[s]] = l) } return c = u.serializeStyle(c, 'span'), c ? t + ' style="' + c + '"' + r : t + r }) } else { t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3') } return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, function (e, t, n, r) { return t + ' style="' + n + '"' + r }), t } function pn (e, t) { e.$('a', t).find('font,u').each(function (t, n) { e.dom.remove(n, !0) }) } const vn = function (e) { K.webkit && dn(e, hn), K.ie && (dn(e, gn), mn(e, pn)) }; const bn = { setup: vn }; const yn = function (e, t) { return function (n) { n.setActive(t.pasteFormat.get() === 'text'); const r = function (e) { return n.setActive(e.state) }; return e.on('PastePlainTextToggle', r), function () { return e.off('PastePlainTextToggle', r) } } }; const wn = function (e, t) { e.ui.registry.addToggleButton('pastetext', { active: !1, icon: 'paste-text', tooltip: 'Paste as text', onAction () { return e.execCommand('mceTogglePlainTextPaste') }, onSetup: yn(e, t) }), e.ui.registry.addToggleMenuItem('pastetext', { text: 'Paste as text', onAction () { return e.execCommand('mceTogglePlainTextPaste') }, onSetup: yn(e, t) }) }; const xn = { register: wn }; function Cn () { r.add('paste', function (e) { if (!1 === i.hasProPlugin(e)) { const t = n(!1); const r = n(Ae.isPasteAsTextEnabled(e) ? 'text' : 'html'); const o = qt(e, r); const u = bn.setup(e); return xn.register(e, o), p.register(e, o), fn.setup(e), nn.register(e), sn.setup(e, o, t), a.get(o, u) } }) }Cn() })(window) }).call(this, n('c8ba')) }, '876f' (e, t, n) {}, '8db2' (e, t) { e.exports = { props: { id: { type: String, required: !0 }, name: { type: String, required: !0 }, value: { type: null, default: null }, type: { type: String, required: !0 }, length: { type: [String, Number], default: null }, readonly: { type: Boolean, default: !1 }, collection: { type: String, default: null }, primaryKey: { type: [Number, String], default: null }, required: { type: Boolean, default: !1 }, options: { type: Object, default: () => ({}) }, newItem: { type: Boolean, default: !1 }, relation: { type: Object, default: null }, fields: { type: Object, default: null }, values: { type: Object, default: null }, width: { type: String, default: null, validator (e) { return ['half', 'half-left', 'half-right', 'full', 'fill'].includes(e) } } } } }, '94ce' (e, t) { (function (e) { 'use strict'; var t = function (e) { let n = e; const r = function () { return n }; const o = function (e) { n = e }; const i = function () { return t(r()) }; return { get: r, set: o, clone: i } }; const n = function () {}; const r = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return e(t.apply(null, n)) } }; const o = function (e) { return function () { return e } }; const i = function (e) { return e }; function u (e) { for (var t = [], n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } const o = t.concat(n); return e.apply(null, o) } } const a = function (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } return !e.apply(null, t) } }; const c = function (e) { return function () { throw new Error(e) } }; const s = o(!1); const l = o(!0); const f = function () { return d }; var d = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const r = function (e) { return e }; const i = { fold (e, t) { return e() }, is: s, isSome: s, isNone: l, getOr: r, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: o(null), getOrUndefined: o(void 0), or: r, orThunk: t, map: f, each: n, bind: f, exists: s, forall: l, filter: f, equals: e, equals_: e, toArray () { return [] }, toString: o('none()') }; return Object.freeze && Object.freeze(i), i }()); var m = function (e) { const t = o(e); const n = function () { return i }; const r = function (t) { return t(e) }; var i = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: l, isNone: s, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return m(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? i : d }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(s, function (t) { return n(e, t) }) } }; return i }; const g = function (e) { return e === null || void 0 === e ? d : m(e) }; const h = { some: m, none: f, from: g }; const p = tinymce.util.Tools.resolve('tinymce.PluginManager'); const v = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const b = function (e) { return function (t) { return v(t) === e } }; const y = b('string'); const w = b('array'); const x = b('boolean'); const C = b('function'); const S = b('number'); const k = Array.prototype.slice; const T = Array.prototype.indexOf; const E = Array.prototype.push; const O = function (e, t) { return T.call(e, t) }; const N = function (e, t) { return O(e, t) > -1 }; const _ = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return !0 } } return !1 }; const D = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const A = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const R = function (e, t) { for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; t(r, n) } }; const B = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const M = function (e, t, n) { return R(e, function (e) { n = t(n, e) }), n }; const P = function (e, t, n) { return A(e, function (e) { n = t(n, e) }), n }; const z = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return h.some(o) } } return h.none() }; const I = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return h.some(n) } } return h.none() }; const L = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!w(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } E.apply(t, e[n]) } return t }; const H = function (e, t) { return L(D(e, t)) }; const F = function (e, t) { for (let n = 0, r = e.length; n < r; ++n) { const o = e[n]; if (!0 !== t(o, n)) { return !1 } } return !0 }; const V = function (e) { const t = k.call(e, 0); return t.reverse(), t }; const U = function (e) { return e.length === 0 ? h.none() : h.some(e[e.length - 1]) }; const j = (C(Array.from) && Array.from, function (e, t) { for (let n = 0; n < e.length; n++) { const r = t(e[n], n); if (r.isSome()) { return r } } return h.none() }); const W = Object.keys; const q = Object.hasOwnProperty; const $ = function (e, t) { for (let n = W(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; t(u, i) } }; const G = function (e, t) { return X(e, function (e, n) { return { k: n, v: t(e, n) } }) }; var X = function (e, t) { const n = {}; return $(e, function (e, r) { const o = t(e, r); n[o.k] = o.v }), n }; const Y = function (e, t) { return K(e, t) ? h.from(e[t]) : h.none() }; var K = function (e, t) { return q.call(e, t) }; const J = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } if (e.length !== t.length) { throw new Error('Wrong number of arguments to struct. Expected "[' + e.length + ']", got ' + t.length + ' arguments') } const r = {}; return A(e, function (e, n) { r[e] = o(t[n]) }), r } }; const Z = function (e) { return e.slice(0).sort() }; const Q = function (e, t) { throw new Error('All required keys (' + Z(e).join(', ') + ') were not specified. Specified keys were: ' + Z(t).join(', ') + '.') }; const ee = function (e) { throw new Error('Unsupported keys for object: ' + Z(e).join(', ')) }; const te = function (e, t) { if (!w(t)) { throw new Error('The ' + e + ' fields must be an array. Was: ' + t + '.') } A(t, function (t) { if (!y(t)) { throw new Error('The value ' + t + ' in the ' + e + ' fields was not a string.') } }) }; const ne = function (e, t) { throw new Error('All values need to be of type: ' + t + '. Keys (' + Z(e).join(', ') + ') were not.') }; const re = function (e) { const t = Z(e); const n = z(t, function (e, n) { return n < t.length - 1 && e === t[n + 1] }); n.each(function (e) { throw new Error('The field: ' + e + ' occurs more than once in the combined fields: [' + t.join(', ') + '].') }) }; const oe = function (e, t) { const n = e.concat(t); if (n.length === 0) { throw new Error('You must specify at least one required or optional field.') } return te('required', e), te('optional', t), re(n), function (r) { const i = W(r); const u = F(e, function (e) { return N(i, e) }); u || Q(e, i); const a = B(i, function (e) { return !N(n, e) }); a.length > 0 && ee(a); const c = {}; return A(e, function (e) { c[e] = o(r[e]) }), A(t, function (e) { c[e] = o(Object.prototype.hasOwnProperty.call(r, e) ? h.some(r[e]) : h.none()) }), c } }; const ie = (e.Node.ATTRIBUTE_NODE, e.Node.CDATA_SECTION_NODE, e.Node.COMMENT_NODE); const ue = e.Node.DOCUMENT_NODE; const ae = (e.Node.DOCUMENT_TYPE_NODE, e.Node.DOCUMENT_FRAGMENT_NODE, e.Node.ELEMENT_NODE); const ce = e.Node.TEXT_NODE; const se = (e.Node.PROCESSING_INSTRUCTION_NODE, e.Node.ENTITY_REFERENCE_NODE, e.Node.ENTITY_NODE, e.Node.NOTATION_NODE, typeof e.window !== 'undefined' ? e.window : Function('return this;')(), function (e) { const t = e.dom().nodeName; return t.toLowerCase() }); const le = function (e) { return e.dom().nodeType }; const fe = function (e) { return function (t) { return le(t) === e } }; const de = function (e) { return le(e) === ie || se(e) === '#comment' }; const me = fe(ae); const ge = fe(ce); const he = function (t, n, r) { if (!(y(r) || x(r) || S(r))) { throw e.console.error('Invalid call to Attr.set. Key ', n, ':: Value ', r, ':: Element ', t), new Error('Attribute value was not simple') } t.setAttribute(n, r + '') }; const pe = function (e, t, n) { he(e.dom(), t, n) }; const ve = function (e, t) { const n = e.dom(); $(t, function (e, t) { he(n, t, e) }) }; const be = function (e, t) { const n = e.dom().getAttribute(t); return n === null ? void 0 : n }; const ye = function (e, t) { const n = e.dom(); return !(!n || !n.hasAttribute) && n.hasAttribute(t) }; const we = function (e, t) { e.dom().removeAttribute(t) }; const xe = function (e) { return P(e.dom().attributes, function (e, t) { return e[t.name] = t.value, e }, {}) }; const Ce = function (e, t, n) { if (t === '') { return !0 } if (e.length < t.length) { return !1 } const r = e.substr(n, n + t.length); return r === t }; const Se = function (e, t) { return e.includes(t) }; const ke = function (e, t) { return Ce(e, t, 0) }; const Te = function (e, t) { return Ce(e, t, e.length - t.length) }; const Ee = function (e) { return e.replace(/^\s+|\s+$/g, '') }; const Oe = function (e) { return void 0 !== e.style && C(e.style.getPropertyValue) }; const Ne = function (e) { let t; let n = !1; return function () { for (var r = [], o = 0; o < arguments.length; o++) { r[o] = arguments[o] } return n || (n = !0, t = e.apply(null, r)), t } }; const _e = function (t, n) { const r = n || e.document; const o = r.createElement('div'); if (o.innerHTML = t, !o.hasChildNodes() || o.childNodes.length > 1) { throw e.console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node') } return Re(o.childNodes[0]) }; const De = function (t, n) { const r = n || e.document; const o = r.createElement(t); return Re(o) }; const Ae = function (t, n) { const r = n || e.document; const o = r.createTextNode(t); return Re(o) }; var Re = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: o(e) } }; const Be = function (e, t, n) { const r = e.dom(); return h.from(r.elementFromPoint(t, n)).map(Re) }; const Me = { fromHtml: _e, fromTag: De, fromText: Ae, fromDom: Re, fromPoint: Be }; const Pe = function (e) { const t = ge(e) ? e.dom().parentNode : e.dom(); return void 0 !== t && t !== null && t.ownerDocument.body.contains(t) }; const ze = Ne(function () { return Ie(Me.fromDom(e.document)) }); var Ie = function (e) { const t = e.dom().body; if (t === null || void 0 === t) { throw new Error('Body is not available yet') } return Me.fromDom(t) }; const Le = function (t, n, r) { if (!y(r)) { throw e.console.error('Invalid call to CSS.set. Property ', n, ':: Value ', r, ':: Element ', t), new Error('CSS value must be a string: ' + r) } Oe(t) && t.style.setProperty(n, r) }; const He = function (e, t) { Oe(e) && e.style.removeProperty(t) }; const Fe = function (e, t, n) { const r = e.dom(); Le(r, t, n) }; const Ve = function (e, t) { const n = e.dom(); $(t, function (e, t) { Le(n, t, e) }) }; const Ue = function (t, n) { const r = t.dom(); const o = e.window.getComputedStyle(r); const i = o.getPropertyValue(n); const u = i !== '' || Pe(t) ? i : je(r, n); return u === null ? void 0 : u }; var je = function (e, t) { return Oe(e) ? e.style.getPropertyValue(t) : '' }; const We = function (e, t) { const n = e.dom(); const r = je(n, t); return h.from(r).filter(function (e) { return e.length > 0 }) }; const qe = function (e, t) { const n = e.dom(); He(n, t), ye(e, 'style') && Ee(be(e, 'style')) === '' && we(e, 'style') }; const $e = function (e, t) { const n = e.dom(); const r = t.dom(); Oe(n) && Oe(r) && (r.style.cssText = n.style.cssText) }; const Ge = function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }; const Xe = function (t, n) { return Ge(t, n, e.Node.DOCUMENT_POSITION_PRECEDING) }; const Ye = function (t, n) { return Ge(t, n, e.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const Ke = { documentPositionPreceding: Xe, documentPositionContainedBy: Ye }; var Je = function () { return Je = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, Je.apply(this, arguments) }; const Ze = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const Qe = function (e, t) { const n = Ze(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return nt(r(1), r(2)) }; const et = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? tt() : Qe(e, n) }; var tt = function () { return nt(0, 0) }; var nt = function (e, t) { return { major: e, minor: t } }; const rt = { nu: nt, detect: et, unknown: tt }; const ot = 'Edge'; const it = 'Chrome'; const ut = 'IE'; const at = 'Opera'; const ct = 'Firefox'; const st = 'Safari'; const lt = function (e, t) { return function () { return t === e } }; const ft = function () { return dt({ current: void 0, version: rt.unknown() }) }; var dt = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: lt(ot, t), isChrome: lt(it, t), isIE: lt(ut, t), isOpera: lt(at, t), isFirefox: lt(ct, t), isSafari: lt(st, t) } }; const mt = { unknown: ft, nu: dt, edge: o(ot), chrome: o(it), ie: o(ut), opera: o(at), firefox: o(ct), safari: o(st) }; const gt = 'Windows'; const ht = 'iOS'; const pt = 'Android'; const vt = 'Linux'; const bt = 'OSX'; const yt = 'Solaris'; const wt = 'FreeBSD'; const xt = 'ChromeOS'; const Ct = function (e, t) { return function () { return t === e } }; const St = function () { return kt({ current: void 0, version: rt.unknown() }) }; var kt = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: Ct(gt, t), isiOS: Ct(ht, t), isAndroid: Ct(pt, t), isOSX: Ct(bt, t), isLinux: Ct(vt, t), isSolaris: Ct(yt, t), isFreeBSD: Ct(wt, t), isChromeOS: Ct(xt, t) } }; const Tt = { unknown: St, nu: kt, windows: o(gt), ios: o(ht), android: o(pt), linux: o(vt), osx: o(bt), solaris: o(yt), freebsd: o(wt), chromeos: o(xt) }; const Et = function (e, t, n, r) { const i = e.isiOS() && !0 === /ipad/i.test(n); const u = e.isiOS() && !i; const a = e.isiOS() || e.isAndroid(); const c = a || r('(pointer:coarse)'); const s = i || !u && a && r('(min-device-width:768px)'); const l = u || a && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: o(i), isiPhone: o(u), isTablet: o(s), isPhone: o(l), isTouch: o(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: o(f), isDesktop: o(d) } }; const Ot = function (e, t) { const n = String(t).toLowerCase(); return z(e, function (e) { return e.search(n) }) }; const Nt = function (e, t) { return Ot(e, t).map(function (e) { const n = rt.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const _t = function (e, t) { return Ot(e, t).map(function (e) { const n = rt.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Dt = { detectBrowser: Nt, detectOs: _t }; const At = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const Rt = function (e) { return function (t) { return Se(t, e) } }; const Bt = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return Se(e, 'edge/') && Se(e, 'chrome') && Se(e, 'safari') && Se(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, At], search (e) { return Se(e, 'chrome') && !Se(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return Se(e, 'msie') || Se(e, 'trident') } }, { name: 'Opera', versionRegexes: [At, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Rt('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Rt('firefox') }, { name: 'Safari', versionRegexes: [At, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (Se(e, 'safari') || Se(e, 'mobile/')) && Se(e, 'applewebkit') } }]; const Mt = [{ name: 'Windows', search: Rt('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return Se(e, 'iphone') || Se(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: Rt('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: Rt('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: Rt('linux'), versionRegexes: [] }, { name: 'Solaris', search: Rt('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: Rt('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: Rt('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const Pt = { browsers: o(Bt), oses: o(Mt) }; const zt = function (e, t) { const n = Pt.browsers(); const r = Pt.oses(); const o = Dt.detectBrowser(n, e).fold(mt.unknown, mt.nu); const i = Dt.detectOs(r, e).fold(Tt.unknown, Tt.nu); const u = Et(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const It = { detect: zt }; const Lt = function (t) { return e.window.matchMedia(t).matches }; const Ht = t(It.detect(e.navigator.userAgent, Lt)); const Ft = function () { return Ht.get() }; const Vt = ae; const Ut = ue; const jt = function (e, t) { const n = e.dom(); if (n.nodeType !== Vt) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const Wt = function (e) { return e.nodeType !== Vt && e.nodeType !== Ut || e.childElementCount === 0 }; const qt = function (t, n) { const r = void 0 === n ? e.document : n.dom(); return Wt(r) ? [] : D(r.querySelectorAll(t), Me.fromDom) }; const $t = function (t, n) { const r = void 0 === n ? e.document : n.dom(); return Wt(r) ? h.none() : h.from(r.querySelector(t)).map(Me.fromDom) }; const Gt = function (e, t) { return e.dom() === t.dom() }; const Xt = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const Yt = function (e, t) { return Ke.documentPositionContainedBy(e.dom(), t.dom()) }; const Kt = Ft().browser; const Jt = Kt.isIE() ? Yt : Xt; const Zt = jt; const Qt = function (e) { return Me.fromDom(e.dom().ownerDocument) }; const en = function (e) { return Me.fromDom(e.dom().ownerDocument.defaultView) }; const tn = function (e) { return h.from(e.dom().parentNode).map(Me.fromDom) }; const nn = function (e, t) { const n = C(t) ? t : s; let r = e.dom(); const o = []; while (r.parentNode !== null && void 0 !== r.parentNode) { const i = r.parentNode; const u = Me.fromDom(i); if (o.push(u), !0 === n(u)) { break } r = i } return o }; const rn = function (e) { return h.from(e.dom().previousSibling).map(Me.fromDom) }; const on = function (e) { return h.from(e.dom().nextSibling).map(Me.fromDom) }; const un = function (e) { return D(e.dom().childNodes, Me.fromDom) }; const an = function (e, t) { const n = e.dom().childNodes; return h.from(n[t]).map(Me.fromDom) }; const cn = function (e) { return an(e, 0) }; const sn = (J('element', 'offset'), function (e, t) { const n = tn(e); n.each(function (n) { n.dom().insertBefore(t.dom(), e.dom()) }) }); const ln = function (e, t) { const n = on(e); n.fold(function () { const n = tn(e); n.each(function (e) { dn(e, t) }) }, function (e) { sn(e, t) }) }; const fn = function (e, t) { const n = cn(e); n.fold(function () { dn(e, t) }, function (n) { e.dom().insertBefore(t.dom(), n.dom()) }) }; var dn = function (e, t) { e.dom().appendChild(t.dom()) }; const mn = function (e, t) { sn(e, t), dn(t, e) }; const gn = function (e, t) { A(t, function (t) { sn(e, t) }) }; const hn = function (e, t) { A(t, function (n, r) { const o = r === 0 ? e : t[r - 1]; ln(o, n) }) }; const pn = function (e, t) { A(t, function (t) { dn(e, t) }) }; const vn = function (e) { e.dom().textContent = '', A(un(e), function (e) { bn(e) }) }; var bn = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const yn = function (e) { const t = un(e); t.length > 0 && gn(e, t), bn(e) }; const wn = (J('width', 'height'), J('width', 'height'), J('rows', 'columns')); const xn = J('row', 'column'); const Cn = (J('x', 'y'), J('element', 'rowspan', 'colspan')); const Sn = J('element', 'rowspan', 'colspan', 'isNew'); const kn = J('element', 'rowspan', 'colspan', 'row', 'column'); const Tn = J('element', 'cells', 'section'); const En = J('element', 'isNew'); const On = J('element', 'cells', 'section', 'isNew'); const Nn = J('cells', 'section'); const _n = J('details', 'section'); const Dn = J('startRow', 'startCol', 'finishRow', 'finishCol'); const An = function (e, t, n) { return B(nn(e, n), t) }; const Rn = function (e, t) { return B(un(e), t) }; var Bn = function (e, t) { let n = []; return A(un(e), function (e) { t(e) && (n = n.concat([e])), n = n.concat(Bn(e, t)) }), n }; const Mn = function (e, t, n) { return An(e, function (e) { return jt(e, t) }, n) }; const Pn = function (e, t) { return Rn(e, function (e) { return jt(e, t) }) }; const zn = function (e, t) { return qt(t, e) }; function In (e, t, n, r, o) { return e(n, r) ? h.some(n) : C(o) && o(n) ? h.none() : t(n, r, o) } const Ln = function (e, t, n) { let r = e.dom(); const i = C(n) ? n : o(!1); while (r.parentNode) { r = r.parentNode; const u = Me.fromDom(r); if (t(u)) { return h.some(u) } if (i(u)) { break } } return h.none() }; const Hn = function (e, t, n) { const r = function (e, t) { return t(e) }; return In(r, Ln, e, t, n) }; const Fn = function (e, t) { const n = function (e) { return t(Me.fromDom(e)) }; const r = z(e.dom().childNodes, n); return r.map(Me.fromDom) }; const Vn = function (e, t) { var n = function (e) { for (let r = 0; r < e.childNodes.length; r++) { const o = Me.fromDom(e.childNodes[r]); if (t(o)) { return h.some(o) } const i = n(e.childNodes[r]); if (i.isSome()) { return i } } return h.none() }; return n(e.dom()) }; const Un = function (e, t, n) { return Ln(e, function (e) { return jt(e, t) }, n) }; const jn = function (e, t) { return Fn(e, function (e) { return jt(e, t) }) }; const Wn = function (e, t) { return $t(t, e) }; const qn = function (e, t, n) { return In(jt, Un, e, t, n) }; const $n = function (e, t) { return Gn(e, t, o(!0)) }; var Gn = function (e, t, n) { return H(un(e), function (e) { return jt(e, t) ? n(e) ? [e] : [] : Gn(e, t, n) }) }; const Xn = { firstLayer: $n, filterFirstLayer: Gn }; const Yn = function (e, t, n) { if (void 0 === n && (n = s), n(t)) { return h.none() } if (N(e, se(t))) { return h.some(t) } const r = function (e) { return jt(e, 'table') || n(e) }; return Un(t, e.join(','), r) }; const Kn = function (e, t) { return Yn(['td', 'th'], e, t) }; const Jn = function (e) { return Xn.firstLayer(e, 'th,td') }; const Zn = function (e, t) { return Yn(['caption', 'tr', 'tbody', 'tfoot', 'thead'], e, t) }; const Qn = function (e, t) { return tn(t).map(function (t) { return Pn(t, e) }) }; const er = u(Qn, 'th,td'); const tr = u(Qn, 'tr'); const nr = function (e) { return Wn(e, 'th,td') }; const rr = function (e, t) { return qn(e, 'table', t) }; const or = function (e, t) { return Yn(['tr'], e, t) }; const ir = function (e) { return Xn.firstLayer(e, 'tr') }; const ur = function (e, t) { return parseInt(be(e, t), 10) }; const ar = function (e, t, n) { const r = ur(e, t); const o = ur(e, n); return wn(r, o) }; const cr = { cell: Kn, firstCell: nr, cells: Jn, neighbourCells: er, table: rr, row: or, rows: ir, notCell: Zn, neighbourRows: tr, attr: ur, grid: ar }; const sr = function (e) { const t = cr.rows(e); return D(t, function (e) { const t = e; const n = tn(t); const r = n.map(function (e) { const t = se(e); return t === 'tfoot' || t === 'thead' || t === 'tbody' ? t : 'tbody' }).getOr('tbody'); const o = D(cr.cells(e), function (e) { const t = ye(e, 'rowspan') ? parseInt(be(e, 'rowspan'), 10) : 1; const n = ye(e, 'colspan') ? parseInt(be(e, 'colspan'), 10) : 1; return Cn(e, t, n) }); return Tn(t, o, r) }) }; const lr = function (e, t) { return D(e, function (e) { const n = D(cr.cells(e), function (e) { const t = ye(e, 'rowspan') ? parseInt(be(e, 'rowspan'), 10) : 1; const n = ye(e, 'colspan') ? parseInt(be(e, 'colspan'), 10) : 1; return Cn(e, t, n) }); return Tn(e, n, t.section()) }) }; const fr = { fromTable: sr, fromPastedRows: lr }; const dr = function (e, t) { return e + ',' + t }; const mr = function (e, t, n) { const r = e.access()[dr(t, n)]; return void 0 !== r ? h.some(r) : h.none() }; const gr = function (e, t, n) { const r = hr(e, function (e) { return n(t, e.element()) }); return r.length > 0 ? h.some(r[0]) : h.none() }; var hr = function (e, t) { const n = H(e.all(), function (e) { return e.cells() }); return B(n, t) }; const pr = function (e) { const t = {}; const n = []; const r = e.length; let i = 0; A(e, function (e, r) { const o = []; A(e.cells(), function (e) { let n = 0; while (void 0 !== t[dr(r, n)]) { n++ } for (var u = kn(e.element(), e.rowspan(), e.colspan(), r, n), a = 0; a < e.colspan(); a++) { for (let c = 0; c < e.rowspan(); c++) { const s = r + c; const l = n + a; const f = dr(s, l); t[f] = u, i = Math.max(i, l + 1) } }o.push(u) }), n.push(Tn(e.element(), o, e.section())) }); const u = wn(r, i); return { grid: o(u), access: o(t), all: o(n) } }; const vr = function (e) { const t = D(e.all(), function (e) { return e.cells() }); return L(t) }; const br = { generate: pr, getAt: mr, findItem: gr, filterItems: hr, justCells: vr }; const yr = J('minRow', 'minCol', 'maxRow', 'maxCol'); const wr = function (e, t) { const n = e.grid().columns(); const r = e.grid().rows(); let o = r; let i = n; let u = 0; let a = 0; return $(e.access(), function (e) { if (t(e)) { const n = e.row(); const r = n + e.rowspan() - 1; const c = e.column(); const s = c + e.colspan() - 1; n < o ? o = n : r > u && (u = r), c < i ? i = c : s > a && (a = s) } }), yr(o, i, u, a) }; const xr = function (e, t, n) { const r = e[n].element(); const o = Me.fromTag('td'); dn(o, Me.fromTag('br')); const i = t ? dn : fn; i(r, o) }; const Cr = function (e, t, n, r) { for (let o = t.grid().columns(), i = t.grid().rows(), u = 0; u < i; u++) { for (let a = !1, c = 0; c < o; c++) { if (!(u < n.minRow() || u > n.maxRow() || c < n.minCol() || c > n.maxCol())) { const s = br.getAt(t, u, c).filter(r).isNone(); s ? xr(e, a, u) : a = !0 } } } }; const Sr = function (e, t) { const n = B(Xn.firstLayer(e, 'tr'), function (e) { return e.dom().childElementCount === 0 }); A(n, bn), t.minCol() !== t.maxCol() && t.minRow() !== t.maxRow() || A(Xn.firstLayer(e, 'th,td'), function (e) { we(e, 'rowspan'), we(e, 'colspan') }), we(e, 'width'), we(e, 'height'), qe(e, 'width'), qe(e, 'height') }; const kr = function (e, t) { const n = function (e) { return jt(e.element(), t) }; const r = fr.fromTable(e); const o = br.generate(r); const i = wr(o, n); const u = 'th:not(' + t + '),td:not(' + t + ')'; const a = Xn.filterFirstLayer(e, 'th,td', function (e) { return jt(e, u) }); return A(a, bn), Cr(r, o, i, n), Sr(e, i), e }; const Tr = { extract: kr }; const Er = ' '; function Or (e, t) { const n = function (n) { if (!e(n)) { throw new Error('Can only get ' + t + ' value of a ' + t + ' node') } return r(n).getOr('') }; var r = function (t) { return e(t) ? h.from(t.dom().nodeValue) : h.none() }; const o = function (n, r) { if (!e(n)) { throw new Error('Can only set raw ' + t + ' value of a ' + t + ' node') } n.dom().nodeValue = r }; return { get: n, getOption: r, set: o } } const Nr = Or(ge, 'text'); const _r = function (e) { return Nr.get(e) }; const Dr = function (e) { return Nr.getOption(e) }; const Ar = function (e, t) { Nr.set(e, t) }; const Rr = function (e) { return se(e) === 'img' ? 1 : Dr(e).fold(function () { return un(e).length }, function (e) { return e.length }) }; const Br = function (e) { return Dr(e).filter(function (e) { return e.trim().length !== 0 || e.includes(Er) }).isSome() }; const Mr = ['img', 'br']; const Pr = function (e) { const t = Br(e); return t || N(Mr, se(e)) }; const zr = function (e) { return Vn(e, Pr) }; const Ir = function (e) { return Lr(e, Pr) }; var Lr = function (e, t) { var n = function (e) { for (let r = un(e), o = r.length - 1; o >= 0; o--) { const i = r[o]; if (t(i)) { return h.some(i) } const u = n(i); if (u.isSome()) { return u } } return h.none() }; return n(e) }; const Hr = function (e, t) { return Me.fromDom(e.dom().cloneNode(t)) }; const Fr = function (e) { return Hr(e, !1) }; const Vr = function (e) { return Hr(e, !0) }; const Ur = function (e, t) { const n = Me.fromTag(t); const r = xe(e); return ve(n, r), n }; const jr = function (e, t) { const n = Ur(e, t); const r = un(Vr(e)); return pn(n, r), n }; const Wr = function () { const e = Me.fromTag('td'); return dn(e, Me.fromTag('br')), e }; const qr = function (e, t, n) { const r = jr(e, t); return $(n, function (e, t) { e === null ? we(r, t) : pe(r, t, e) }), r }; const $r = function (e) { return e }; const Gr = function (e) { return function () { return Me.fromTag('tr', e.dom()) } }; const Xr = function (e, t, n) { const r = zr(e); return r.map(function (r) { const o = n.join(','); const i = Mn(r, o, function (t) { return Gt(t, e) }); return M(i, function (e, t) { const n = Fr(t); return we(n, 'contenteditable'), dn(e, n), n }, t) }).getOr(t) }; const Yr = function (e, t, n) { const r = function (t) { const r = Qt(t.element()); const o = Me.fromTag(se(t.element()), r.dom()); const i = n.getOr(['strong', 'em', 'b', 'i', 'span', 'font', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div']); const u = i.length > 0 ? Xr(t.element(), o, i) : o; return dn(u, Me.fromTag('br')), $e(t.element(), o), qe(o, 'height'), t.colspan() !== 1 && qe(t.element(), 'width'), e(t.element(), o), o }; return { row: Gr(t), cell: r, replace: qr, gap: Wr } }; const Kr = function (e) { return { row: Gr(e), cell: Wr, replace: $r, gap: Wr } }; const Jr = { cellOperations: Yr, paste: Kr }; const Zr = function (t, n) { const r = n || e.document; const o = r.createElement('div'); return o.innerHTML = t, un(Me.fromDom(o)) }; const Qr = function (e, t) { const n = t.column(); const r = t.column() + t.colspan() - 1; const o = t.row(); const i = t.row() + t.rowspan() - 1; return n <= e.finishCol() && r >= e.startCol() && o <= e.finishRow() && i >= e.startRow() }; const eo = function (e, t) { return t.column() >= e.startCol() && t.column() + t.colspan() - 1 <= e.finishCol() && t.row() >= e.startRow() && t.row() + t.rowspan() - 1 <= e.finishRow() }; const to = function (e, t) { for (var n = !0, r = u(eo, t), o = t.startRow(); o <= t.finishRow(); o++) { for (let i = t.startCol(); i <= t.finishCol(); i++) { n = n && br.getAt(e, o, i).exists(r) } } return n ? h.some(t) : h.none() }; const no = { inSelection: Qr, isWithin: eo, isRectangular: to }; const ro = function (e, t) { return Dn(Math.min(e.row(), t.row()), Math.min(e.column(), t.column()), Math.max(e.row() + e.rowspan() - 1, t.row() + t.rowspan() - 1), Math.max(e.column() + e.colspan() - 1, t.column() + t.colspan() - 1)) }; const oo = function (e, t, n) { const r = br.findItem(e, t, Gt); const o = br.findItem(e, n, Gt); return r.bind(function (e) { return o.map(function (t) { return ro(e, t) }) }) }; const io = function (e, t, n) { return oo(e, t, n).bind(function (t) { return no.isRectangular(e, t) }) }; const uo = { getAnyBox: oo, getBox: io }; const ao = function (e, t, n, r) { return br.findItem(e, t, Gt).bind(function (t) { const o = n > 0 ? t.row() + t.rowspan() - 1 : t.row(); const i = r > 0 ? t.column() + t.colspan() - 1 : t.column(); const u = br.getAt(e, o + n, i + r); return u.map(function (e) { return e.element() }) }) }; const co = function (e, t, n) { return uo.getAnyBox(e, t, n).map(function (t) { const n = br.filterItems(e, u(no.inSelection, t)); return D(n, function (e) { return e.element() }) }) }; const so = function (e, t) { const n = function (e, t) { return Jt(t, e) }; return br.findItem(e, t, n).map(function (e) { return e.element() }) }; const lo = { moveBy: ao, intercepts: co, parentCell: so }; const fo = function (e, t, n) { return cr.table(e).bind(function (r) { const o = po(r); return lo.moveBy(o, e, t, n) }) }; const mo = function (e, t, n) { const r = po(e); return lo.intercepts(r, t, n) }; const go = function (e, t, n, r, o) { const i = po(e); const u = Gt(e, n) ? h.some(t) : lo.parentCell(i, t); const a = Gt(e, o) ? h.some(r) : lo.parentCell(i, r); return u.bind(function (e) { return a.bind(function (t) { return lo.intercepts(i, e, t) }) }) }; const ho = function (e, t, n) { const r = po(e); return uo.getBox(r, t, n) }; var po = function (e) { const t = fr.fromTable(e); return br.generate(t) }; const vo = { moveBy: fo, intercepts: mo, nestedIntercepts: go, getBox: ho }; const bo = ['body', 'p', 'div', 'article', 'aside', 'figcaption', 'figure', 'footer', 'header', 'nav', 'section', 'ol', 'ul', 'li', 'table', 'thead', 'tbody', 'tfoot', 'caption', 'tr', 'td', 'th', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'address']; function yo () { const e = function (e) { return Me.fromDom(e.dom().cloneNode(!1)) }; const t = function (e) { return e.dom().ownerDocument }; const n = function (e) { return !!me(e) && (se(e) === 'body' || N(bo, se(e))) }; const r = function (e) { return !!me(e) && N(['br', 'img', 'hr', 'input'], se(e)) }; const i = function (e) { return me(e) && be(e, 'contenteditable') === 'false' }; const u = function (e, t) { return e.dom().compareDocumentPosition(t.dom()) }; const a = function (e, t) { const n = xe(e); ve(t, n) }; return { up: o({ selector: Un, closest: qn, predicate: Ln, all: nn }), down: o({ selector: zn, predicate: Bn }), styles: o({ get: Ue, getRaw: We, set: Fe, remove: qe }), attrs: o({ get: be, set: pe, remove: we, copyTo: a }), insert: o({ before: sn, after: ln, afterAll: hn, append: dn, appendAll: pn, prepend: fn, wrap: mn }), remove: o({ unwrap: yn, remove: bn }), create: o({ nu: Me.fromTag, clone: e, text: Me.fromText }), query: o({ comparePosition: u, prevSibling: rn, nextSibling: on }), property: o({ children: un, name: se, parent: tn, document: t, isText: ge, isComment: de, isElement: me, getText: _r, setText: Ar, isBoundary: n, isEmptyTag: r, isNonEditable: i }), eq: Gt, is: Zt } } const wo = J('left', 'right'); const xo = J('first', 'second', 'splits'); const Co = function (e, t, n) { const r = e.property().children(t); const i = I(r, u(e.eq, n)); return i.map(function (e) { return { before: o(r.slice(0, e)), after: o(r.slice(e + 1)) } }) }; const So = function (e, t, n) { return Co(e, t, n).map(function (n) { const r = e.create().clone(t); return e.insert().appendAll(r, n.after()), e.insert().after(t, r), wo(t, r) }) }; const ko = function (e, t, n) { return Co(e, t, n).map(function (r) { const o = e.create().clone(t); return e.insert().appendAll(o, r.before().concat([n])), e.insert().appendAll(t, r.after()), e.insert().before(t, o), wo(o, t) }) }; const To = function (e, t, n, r) { var o = function (t, i, u) { const a = xo(t, h.none(), u); return n(t) ? xo(t, i, u) : e.property().parent(t).bind(function (i) { return r(e, i, t).map(function (e) { const t = [{ first: e.left, second: e.right }]; const r = n(i) ? i : e.left(); return o(r, h.some(e.right()), u.concat(t)) }) }).getOr(a) }; return o(t, h.none(), []) }; const Eo = function (e, t, n, r) { const o = n[0]; const i = n.slice(1); return r(e, t, o, i) }; const Oo = function (e, t, n) { return n.length > 0 ? Eo(e, t, n, No) : h.none() }; var No = function (e, t, n, r) { const o = t(e, n); return M(r, function (n, r) { const o = t(e, r); return _o(e, n, o) }, o) }; var _o = function (e, t, n) { return t.bind(function (t) { return n.filter(u(e.eq, t)) }) }; const Do = function (e, t) { return u(e.eq, t) }; const Ao = function (e, t, n, r) { const o = e.property().children(t); if (e.eq(t, n[0])) { return h.some([n[0]]) } if (e.eq(t, r[0])) { return h.some([r[0]]) } const i = function (n) { const r = V(n); const i = I(r, Do(e, t)).getOr(-1); const u = i < r.length - 1 ? r[i + 1] : r[i]; return I(o, Do(e, u)) }; const u = i(n); const a = i(r); return u.bind(function (e) { return a.map(function (t) { const n = Math.min(e, t); const r = Math.max(e, t); return o.slice(n, r + 1) }) }) }; const Ro = function (e, t, n, r) { void 0 === r && (r = s); const i = [t].concat(e.up().all(t)); const u = [n].concat(e.up().all(n)); const a = function (e) { const t = I(e, r); return t.fold(function () { return e }, function (t) { return e.slice(0, t + 1) }) }; const c = a(i); const l = a(u); const f = z(c, function (t) { return _(l, Do(e, t)) }); return { firstpath: o(c), secondpath: o(l), shared: o(f) } }; const Bo = function (e, t, n) { const r = Ro(e, t, n); return r.shared().bind(function (t) { return Ao(e, t, r.firstpath(), r.secondpath()) }) }; const Mo = { subset: Bo, ancestors: Ro }; const Po = Oo; const zo = Mo.subset; const Io = Mo.ancestors; const Lo = ko; const Ho = So; const Fo = To; const Vo = { sharedOne: Po, subset: zo, ancestors: Io, breakToLeft: Lo, breakToRight: Ho, breakPath: Fo }; const Uo = yo(); const jo = function (e, t) { return Vo.sharedOne(Uo, function (t, n) { return e(n) }, t) }; const Wo = function (e, t) { return Vo.subset(Uo, e, t) }; const qo = function (e, t, n) { return Vo.ancestors(Uo, e, t, n) }; const $o = function (e, t) { return Vo.breakToLeft(Uo, e, t) }; const Go = function (e, t) { return Vo.breakToRight(Uo, e, t) }; const Xo = function (e, t, n) { return Vo.breakPath(Uo, e, t, function (e, t, r) { return n(t, r) }) }; const Yo = { sharedOne: jo, subset: Wo, ancestors: qo, breakToLeft: $o, breakToRight: Go, breakPath: Xo }; const Ko = oe(['boxes', 'start', 'finish'], []); const Jo = { create: Ko }; const Zo = function (e) { return Un(e, 'table') }; const Qo = function (e, t, n) { const r = function (e) { return function (t) { return void 0 !== n && n(t) || Gt(t, e) } }; return Gt(e, t) ? h.some(Jo.create({ boxes: h.some([e]), start: e, finish: t })) : Zo(e).bind(function (o) { return Zo(t).bind(function (i) { if (Gt(o, i)) { return h.some(Jo.create({ boxes: vo.intercepts(o, e, t), start: e, finish: t })) } if (Jt(o, i)) { var u = Mn(t, 'td,th', r(o)); const a = u.length > 0 ? u[u.length - 1] : t; return h.some(Jo.create({ boxes: vo.nestedIntercepts(o, e, o, t, i), start: e, finish: a })) } if (Jt(i, o)) { u = Mn(e, 'td,th', r(i)); const c = u.length > 0 ? u[u.length - 1] : e; return h.some(Jo.create({ boxes: vo.nestedIntercepts(i, e, o, t, i), start: e, finish: c })) } return Yo.ancestors(e, t).shared().bind(function (u) { return qn(u, 'table', n).bind(function (n) { const u = Mn(t, 'td,th', r(n)); const a = u.length > 0 ? u[u.length - 1] : t; const c = Mn(e, 'td,th', r(n)); const s = c.length > 0 ? c[c.length - 1] : e; return h.some(Jo.create({ boxes: vo.nestedIntercepts(n, e, o, t, i), start: s, finish: a })) }) }) }) }) }; const ei = function (e, t) { const n = zn(e, t); return n.length > 0 ? h.some(n) : h.none() }; const ti = function (e, t) { return z(e, function (e) { return jt(e, t) }) }; const ni = function (e, t, n) { return Wn(e, t).bind(function (t) { return Wn(e, n).bind(function (e) { return Yo.sharedOne(Zo, [t, e]).map(function (n) { return { first: o(t), last: o(e), table: o(n) } }) }) }) }; const ri = function (e, t) { return Un(e, 'table').bind(function (n) { return Wn(n, t).bind(function (t) { return Qo(t, e).bind(function (e) { return e.boxes().map(function (t) { return { boxes: o(t), start: o(e.start()), finish: o(e.finish()) } }) }) }) }) }; const oi = function (e, t, n, r, o) { return ti(e, o).bind(function (e) { return vo.moveBy(e, t, n).bind(function (e) { return ri(e, r) }) }) }; const ii = { identify: Qo, retrieve: ei, shiftSelection: oi, getEdges: ni }; const ui = function (e, t) { return ii.retrieve(e, t) }; const ai = function (e, t, n) { return ii.getEdges(e, t, n).bind(function (t) { const n = function (t) { return Gt(e, t) }; const r = Un(t.first(), 'thead,tfoot,tbody,table', n); const o = Un(t.last(), 'thead,tfoot,tbody,table', n); return r.bind(function (e) { return o.bind(function (n) { return Gt(e, n) ? vo.getBox(t.table(), t.first(), t.last()) : h.none() }) }) }) }; const ci = { retrieve: ui, retrieveBox: ai }; const si = 'data-mce-selected'; const li = 'td[' + si + '],th[' + si + ']'; const fi = '[' + si + ']'; const di = 'data-mce-first-selected'; const mi = 'td[' + di + '],th[' + di + ']'; const gi = 'data-mce-last-selected'; const hi = 'td[' + gi + '],th[' + gi + ']'; const pi = { selected: o(si), selectedSelector: o(li), attributeSelector: o(fi), firstSelected: o(di), firstSelectedSelector: o(mi), lastSelected: o(gi), lastSelectedSelector: o(hi) }; const vi = function (t) { if (!w(t)) { throw new Error('cases must be an array') } if (t.length === 0) { throw new Error('there must be at least one case') } const n = []; const r = {}; return A(t, function (o, i) { const u = W(o); if (u.length !== 1) { throw new Error('one and only one name per case') } const a = u[0]; const c = o[a]; if (void 0 !== r[a]) { throw new Error('duplicate key detected:' + a) } if (a === 'cata') { throw new Error('cannot have a case named cata (sorry)') } if (!w(c)) { throw new Error('case arguments must be an array') } n.push(a), r[a] = function () { const r = arguments.length; if (r !== c.length) { throw new Error('Wrong number of arguments to case ' + a + '. Expected ' + c.length + ' (' + c + '), got ' + r) } for (var o = new Array(r), u = 0; u < o.length; u++) { o[u] = arguments[u] } const s = function (e) { const t = W(e); if (n.length !== t.length) { throw new Error('Wrong number of arguments to match. Expected: ' + n.join(',') + '\nActual: ' + t.join(',')) } const r = F(n, function (e) { return N(t, e) }); if (!r) { throw new Error('Not all branches were specified when using match. Specified: ' + t.join(', ') + '\nRequired: ' + n.join(', ')) } return e[a].apply(null, o) }; return { fold () { if (arguments.length !== t.length) { throw new Error('Wrong number of arguments to fold. Expected ' + t.length + ', got ' + arguments.length) } const e = arguments[i]; return e.apply(null, o) }, match: s, log (t) { e.console.log(t, { constructors: n, constructor: a, params: o }) } } } }), r }; const bi = { generate: vi }; const yi = bi.generate([{ none: [] }, { multiple: ['elements'] }, { single: ['selection'] }]); const wi = function (e, t, n, r) { return e.fold(t, n, r) }; const xi = { cata: wi, none: yi.none, multiple: yi.multiple, single: yi.single }; const Ci = function (e, t) { return xi.cata(t.get(), o([]), i, o([e])) }; const Si = function (e, t) { const n = function (e) { return ye(e, 'rowspan') && parseInt(be(e, 'rowspan'), 10) > 1 || ye(e, 'colspan') && parseInt(be(e, 'colspan'), 10) > 1 }; const r = Ci(e, t); return r.length > 0 && F(r, n) ? h.some(r) : h.none() }; const ki = function (e, t) { return xi.cata(t.get(), h.none, function (t, n) { return t.length === 0 ? h.none() : ci.retrieveBox(e, pi.firstSelectedSelector(), pi.lastSelectedSelector()).bind(function (e) { return t.length > 1 ? h.some({ bounds: o(e), cells: o(t) }) : h.none() }) }, h.none) }; const Ti = { mergable: ki, unmergable: Si, selection: Ci }; const Ei = function (e) { return { element: o(e), mergable: h.none, unmergable: h.none, selection: o([e]) } }; const Oi = function (e, t, n) { return { element: o(n), mergable: o(Ti.mergable(t, e)), unmergable: o(Ti.unmergable(n, e)), selection: o(Ti.selection(n, e)) } }; const Ni = function (e) { return Ei(e) }; const _i = J('element', 'clipboard', 'generators'); const Di = function (e, t, n, r, i) { return { element: o(n), mergable: h.none, unmergable: h.none, selection: o(Ti.selection(n, e)), clipboard: o(r), generators: o(i) } }; const Ai = { noMenu: Ei, forMenu: Oi, notCell: Ni, paste: _i, pasteRows: Di }; const Ri = function (e) { return cr.table(e[0]).map(Vr).map(function (e) { return [Tr.extract(e, pi.attributeSelector())] }) }; const Bi = function (e, t) { return D(t, function (t) { return e.selection.serializer.serialize(t.dom(), {}) }).join('') }; const Mi = function (e) { return D(e, function (e) { return e.dom().textContent }).join('') }; const Pi = function (e, t, r, o) { e.on('BeforeGetContent', function (r) { const o = function (t) { r.preventDefault(), Ri(t).each(function (t) { r.content = r.format === 'text' ? Mi(t) : Bi(e, t) }) }; !0 === r.selection && xi.cata(t.get(), n, o, n) }), e.on('BeforeSetContent', function (t) { if (!0 === t.selection && !0 === t.paste) { const n = h.from(e.dom.getParent(e.selection.getStart(), 'th,td')); n.each(function (n) { const i = Me.fromDom(n); cr.table(i).each(function (n) { const u = B(Zr(t.content), function (e) { return se(e) !== 'meta' }); if (u.length === 1 && se(u[0]) === 'table') { t.preventDefault(); const a = Me.fromDom(e.getDoc()); const c = Jr.paste(a); const s = Ai.paste(i, u[0], c); r.pasteCells(n, s).each(function (t) { e.selection.setRng(t), e.focus(), o.clear(n) }) } }) }) } }) }; const zi = { registerEvents: Pi }; function Ii (e, t) { const n = function (t, n) { if (!S(n) && !n.match(/^[0-9]+$/)) { throw new Error(e + '.set accepts only positive integer values. Value was ' + n) } const r = t.dom(); Oe(r) && (r.style[e] = n + 'px') }; const r = function (n) { const r = t(n); if (r <= 0 || r === null) { const o = Ue(n, e); return parseFloat(o) || 0 } return r }; const o = r; const i = function (e, t) { return P(t, function (t, n) { const r = Ue(e, n); const o = void 0 === r ? 0 : parseInt(r, 10); return isNaN(o) ? t : t + o }, 0) }; const u = function (e, t, n) { const r = i(e, n); const o = t > r ? t - r : 0; return o }; return { set: n, get: r, getOuter: o, aggregate: i, max: u } } const Li = Ii('height', function (e) { const t = e.dom(); return Pe(e) ? t.getBoundingClientRect().height : t.offsetHeight }); const Hi = function (e) { return Li.get(e) }; const Fi = function (e) { return Li.getOuter(e) }; const Vi = Ii('width', function (e) { return e.dom().offsetWidth }); const Ui = function (e) { return Vi.get(e) }; const ji = function (e) { return Vi.getOuter(e) }; const Wi = Ft(); const qi = function () { return Wi.browser.isIE() || Wi.browser.isEdge() }; const $i = function (e, t) { const n = parseFloat(e); return isNaN(n) ? t : n }; const Gi = function (e, t, n) { return $i(Ue(e, t), n) }; const Xi = function (e) { const t = Gi(e, 'padding-top', 0); const n = Gi(e, 'padding-bottom', 0); const r = Gi(e, 'border-top-width', 0); const o = Gi(e, 'border-bottom-width', 0); const i = e.dom().getBoundingClientRect().height; const u = Ue(e, 'box-sizing'); const a = r + o; return u === 'border-box' ? i : i - t - n - a }; const Yi = function (e) { return Gi(e, 'width', Ui(e)) }; const Ki = function (e) { return qi() ? Xi(e) : Gi(e, 'height', Hi(e)) }; const Ji = { getWidth: Yi, getHeight: Ki }; const Zi = /(\d+(\.\d+)?)(\w|%)*/; const Qi = /(\d+(\.\d+)?)%/; const eu = /(\d+(\.\d+)?)px|em/; const tu = function (e, t) { Fe(e, 'width', t + 'px') }; const nu = function (e, t) { Fe(e, 'width', t + '%') }; const ru = function (e, t) { Fe(e, 'height', t + 'px') }; const ou = function (e) { return We(e, 'height').getOrThunk(function () { return Ji.getHeight(e) + 'px' }) }; const iu = function (e, t, n, r) { const o = cr.table(e).map(function (e) { const r = n(e); return Math.floor(t / 100 * r) }).getOr(t); return r(e, o), o }; const uu = function (e, t, n, r) { const o = parseInt(e, 10); return Te(e, '%') && se(t) !== 'table' ? iu(t, o, n, r) : o }; const au = function (e) { const t = ou(e); return t ? uu(t, e, Hi, ru) : Hi(e) }; const cu = function (e, t, n) { const r = n(e); const o = su(e, t); return r / o }; var su = function (e, t) { return ye(e, t) ? parseInt(be(e, t), 10) : 1 }; const lu = function (e) { const t = We(e, 'width'); return t.fold(function () { return h.from(be(e, 'width')) }, function (e) { return h.some(e) }) }; const fu = function (e, t) { return e / t.pixelWidth() * 100 }; const du = function (e, t, n) { const r = Qi.exec(t); if (r !== null) { return parseFloat(r[1]) } const o = Ui(e); return fu(o, n) }; const mu = function (e, t) { const n = lu(e); return n.fold(function () { const n = Ui(e); return fu(n, t) }, function (n) { return du(e, n, t) }) }; const gu = function (e, t) { return e / 100 * t.pixelWidth() }; const hu = function (e, t, n) { const r = eu.exec(t); if (r !== null) { return parseInt(r[1], 10) } const o = Qi.exec(t); if (o !== null) { const i = parseFloat(o[1]); return gu(i, n) } return Ui(e) }; const pu = function (e, t) { const n = lu(e); return n.fold(function () { return Ui(e) }, function (n) { return hu(e, n, t) }) }; const vu = function (e) { return cu(e, 'rowspan', au) }; const bu = function (e) { const t = lu(e); return t.bind(function (e) { const t = Zi.exec(e); return t !== null ? h.some({ width: o(parseFloat(t[1])), unit: o(t[3]) }) : h.none() }) }; const yu = function (e, t, n) { Fe(e, 'width', t + n) }; const wu = { percentageBasedSizeRegex: o(Qi), pixelBasedSizeRegex: o(eu), setPixelWidth: tu, setPercentageWidth: nu, setHeight: ru, getPixelWidth: pu, getPercentageWidth: mu, getGenericWidth: bu, setGenericWidth: yu, getHeight: vu, getRawWidth: lu }; const xu = function (e, t) { const n = wu.getGenericWidth(e); n.each(function (n) { const r = n.width() / 2; wu.setGenericWidth(e, r, n.unit()), wu.setGenericWidth(t, r, n.unit()) }) }; const Cu = { halve: xu }; var Su = function (e, t) { const n = function (n, r) { return Su(e + n, t + r) }; return { left: o(e), top: o(t), translate: n } }; const ku = Su; const Tu = function (e) { const t = e.getBoundingClientRect(); return ku(t.left, t.top) }; const Eu = function (e, t) { return void 0 !== e ? e : void 0 !== t ? t : 0 }; const Ou = function (e) { const t = e.dom().ownerDocument; const n = t.body; const r = t.defaultView; const o = t.documentElement; if (n === e.dom()) { return ku(n.offsetLeft, n.offsetTop) } const i = Eu(r.pageYOffset, o.scrollTop); const u = Eu(r.pageXOffset, o.scrollLeft); const a = Eu(o.clientTop, n.clientTop); const c = Eu(o.clientLeft, n.clientLeft); return Nu(e).translate(u - c, i - a) }; var Nu = function (e) { const t = e.dom(); const n = t.ownerDocument; const r = n.body; return r === t ? ku(r.offsetLeft, r.offsetTop) : Pe(e) ? Tu(t) : ku(0, 0) }; const _u = J('row', 'y'); const Du = J('col', 'x'); const Au = function (e) { const t = Ou(e); return t.left() + ji(e) }; const Ru = function (e) { return Ou(e).left() }; const Bu = function (e, t) { return Du(e, Ru(t)) }; const Mu = function (e, t) { return Du(e, Au(t)) }; const Pu = function (e) { return Ou(e).top() }; const zu = function (e, t) { return _u(e, Pu(t)) }; const Iu = function (e, t) { return _u(e, Pu(t) + Fi(t)) }; const Lu = function (e, t, n) { if (n.length === 0) { return [] } const r = D(n.slice(1), function (t, n) { return t.map(function (t) { return e(n, t) }) }); const o = n[n.length - 1].map(function (e) { return t(n.length - 1, e) }); return r.concat([o]) }; const Hu = function (e) { return -e }; const Fu = { delta: i, positions (e) { return Lu(zu, Iu, e) }, edge: Pu }; const Vu = { delta: i, edge: Ru, positions (e) { return Lu(Bu, Mu, e) } }; const Uu = { delta: Hu, edge: Au, positions (e) { return Lu(Mu, Bu, e) } }; const ju = { height: Fu, rtl: Uu, ltr: Vu }; const Wu = { ltr: ju.ltr, rtl: ju.rtl }; function qu (e) { const t = function (t) { return e(t).isRtl() ? Wu.rtl : Wu.ltr }; const n = function (e, n) { return t(n).delta(e, n) }; const r = function (e, n) { return t(n).positions(e, n) }; const o = function (e) { return t(e).edge(e) }; return { delta: n, edge: o, positions: r } } const $u = function (e) { const t = fr.fromTable(e); const n = br.generate(t); return n.grid() }; const Gu = { getGridSize: $u }; const Xu = function (e) { for (var t = [], n = function (e) { t.push(e) }, r = 0; r < e.length; r++) { e[r].each(n) } return t }; const Yu = function (e, t, n, r) { n === r ? we(e, t) : pe(e, t, n) }; const Ku = function (e, t) { const n = []; const r = []; const i = function (t, o) { const i = jn(e, o).getOrThunk(function () { const t = Me.fromTag(o, Qt(e).dom()); return dn(e, t), t }); vn(i); const u = D(t, function (e) { e.isNew() && n.push(e.element()); const t = e.element(); return vn(t), A(e.cells(), function (e) { e.isNew() && r.push(e.element()), Yu(e.element(), 'colspan', e.colspan(), 1), Yu(e.element(), 'rowspan', e.rowspan(), 1), dn(t, e.element()) }), t }); pn(i, u) }; const u = function (t) { jn(e, t).each(bn) }; const a = function (e, t) { e.length > 0 ? i(e, t) : u(t) }; const c = []; const s = []; const l = []; return A(t, function (e) { switch (e.section()) { case 'thead':c.push(e); break; case 'tbody':s.push(e); break; case 'tfoot':l.push(e); break } }), a(c, 'thead'), a(s, 'tbody'), a(l, 'tfoot'), { newRows: o(n), newCells: o(r) } }; const Ju = function (e) { const t = D(e, function (e) { const t = Fr(e.element()); return A(e.cells(), function (e) { const n = Vr(e.element()); Yu(n, 'colspan', e.colspan(), 1), Yu(n, 'rowspan', e.rowspan(), 1), dn(t, n) }), t }); return t }; const Zu = { render: Ku, copy: Ju }; const Qu = function (e, t) { const n = be(e, t); return void 0 === n || n === '' ? [] : n.split(' ') }; const ea = function (e, t, n) { const r = Qu(e, t); const o = r.concat([n]); return pe(e, t, o.join(' ')), !0 }; const ta = function (e, t, n) { const r = B(Qu(e, t), function (e) { return e !== n }); return r.length > 0 ? pe(e, t, r.join(' ')) : we(e, t), !1 }; const na = function (e) { return void 0 !== e.dom().classList }; const ra = function (e) { return Qu(e, 'class') }; const oa = function (e, t) { return ea(e, 'class', t) }; const ia = function (e, t) { return ta(e, 'class', t) }; const ua = function (e, t) { na(e) ? e.dom().classList.add(t) : oa(e, t) }; const aa = function (e) { const t = na(e) ? e.dom().classList : ra(e); t.length === 0 && we(e, 'class') }; const ca = function (e, t) { if (na(e)) { const n = e.dom().classList; n.remove(t) } else { ia(e, t) }aa(e) }; const sa = function (e, t) { return na(e) && e.dom().classList.contains(t) }; const la = function (e, t) { for (var n = [], r = 0; r < e; r++) { n.push(t(r)) } return n }; const fa = function (e, t) { for (var n = [], r = e; r < t; r++) { n.push(r) } return n }; const da = function (e, t) { if (t < 0 || t >= e.length - 1) { return h.none() } const n = e[t].fold(function () { const n = V(e.slice(0, t)); return j(n, function (e, t) { return e.map(function (e) { return { value: e, delta: t + 1 } }) }) }, function (e) { return h.some({ value: e, delta: 0 }) }); const r = e[t + 1].fold(function () { const n = e.slice(t + 1); return j(n, function (e, t) { return e.map(function (e) { return { value: e, delta: t + 1 } }) }) }, function (e) { return h.some({ value: e, delta: 1 }) }); return n.bind(function (e) { return r.map(function (t) { const n = t.delta + e.delta; return Math.abs(t.value - e.value) / n }) }) }; const ma = function (e) { const t = e.grid(); const n = fa(0, t.columns()); const r = fa(0, t.rows()); return D(n, function (t) { const n = function () { return H(r, function (n) { return br.getAt(e, n, t).filter(function (e) { return e.column() === t }).fold(o([]), function (e) { return [e] }) }) }; const i = function (e) { return e.colspan() === 1 }; const u = function () { return br.getAt(e, 0, t) }; return ga(n, i, u) }) }; var ga = function (e, t, n) { const r = e(); const o = z(r, t); const i = o.orThunk(function () { return h.from(r[0]).orThunk(n) }); return i.map(function (e) { return e.element() }) }; const ha = function (e) { const t = e.grid(); const n = fa(0, t.rows()); const r = fa(0, t.columns()); return D(n, function (t) { const n = function () { return H(r, function (n) { return br.getAt(e, t, n).filter(function (e) { return e.row() === t }).fold(o([]), function (e) { return [e] }) }) }; const i = function (e) { return e.rowspan() === 1 }; const u = function () { return br.getAt(e, t, 0) }; return ga(n, i, u) }) }; const pa = { columns: ma, rows: ha }; const va = function (e) { const t = e.replace(/\./g, '-'); const n = function (e) { return t + '-' + e }; return { resolve: n } }; const ba = va('ephox-snooker'); const ya = { resolve: ba.resolve }; const wa = function (e, t, n, r, o) { const i = Me.fromTag('div'); return Ve(i, { position: 'absolute', left: t - r / 2 + 'px', top: n + 'px', height: o + 'px', width: r + 'px' }), ve(i, { 'data-column': e, role: 'presentation' }), i }; const xa = function (e, t, n, r, o) { const i = Me.fromTag('div'); return Ve(i, { position: 'absolute', left: t + 'px', top: n - o / 2 + 'px', height: o + 'px', width: r + 'px' }), ve(i, { 'data-row': e, role: 'presentation' }), i }; const Ca = { col: wa, row: xa }; const Sa = ya.resolve('resizer-bar'); const ka = ya.resolve('resizer-rows'); const Ta = ya.resolve('resizer-cols'); const Ea = 7; const Oa = function (e) { const t = zn(e.parent(), '.' + Sa); A(t, bn) }; const Na = function (e, t, n) { const r = e.origin(); A(t, function (t, o) { t.each(function (t) { const o = n(r, t); ua(o, Sa), dn(e.parent(), o) }) }) }; const _a = function (e, t, n, r) { Na(e, t, function (e, t) { const o = Ca.col(t.col(), t.x() - e.left(), n.top() - e.top(), Ea, r); return ua(o, Ta), o }) }; const Da = function (e, t, n, r) { Na(e, t, function (e, t) { const o = Ca.row(t.row(), n.left() - e.left(), t.y() - e.top(), r, Ea); return ua(o, ka), o }) }; const Aa = function (e, t, n, r, o, i) { const u = Ou(t); const a = n.length > 0 ? o.positions(n, t) : []; Da(e, a, u, ji(t)); const c = r.length > 0 ? i.positions(r, t) : []; _a(e, c, u, Fi(t)) }; const Ra = function (e, t, n, r) { Oa(e); const o = fr.fromTable(t); const i = br.generate(o); const u = pa.rows(i); const a = pa.columns(i); Aa(e, t, u, a, n, r) }; const Ba = function (e, t) { const n = zn(e.parent(), '.' + Sa); A(n, t) }; const Ma = function (e) { Ba(e, function (e) { Fe(e, 'display', 'none') }) }; const Pa = function (e) { Ba(e, function (e) { Fe(e, 'display', 'block') }) }; const za = function (e) { return sa(e, ka) }; const Ia = function (e) { return sa(e, Ta) }; const La = { refresh: Ra, hide: Ma, show: Pa, destroy: Oa, isRowBar: za, isColBar: Ia }; const Ha = function (e, t, n) { const r = e.cells(); const o = r.slice(0, t); const i = r.slice(t); const u = o.concat([n]).concat(i); return Va(e, u) }; const Fa = function (e, t, n) { const r = e.cells(); r[t] = n }; var Va = function (e, t) { return Nn(t, e.section()) }; const Ua = function (e, t) { const n = e.cells(); const r = D(n, t); return Nn(r, e.section()) }; const ja = function (e, t) { return e.cells()[t] }; const Wa = function (e, t) { return ja(e, t).element() }; const qa = function (e) { return e.cells().length }; const $a = { addCell: Ha, setCells: Va, mutateCell: Fa, getCell: ja, getCellElement: Wa, mapCells: Ua, cellLength: qa }; const Ga = function (e, t) { return D(e, function (e) { return $a.getCell(e, t) }) }; const Xa = function (e, t) { return e[t] }; const Ya = function (e, t) { if (e.length === 0) { return 0 } const n = e[0]; const r = I(e, function (e) { return !t(n.element(), e.element()) }); return r.fold(function () { return e.length }, function (e) { return e }) }; const Ka = function (e, t, n, r) { const i = Xa(e, t).cells().slice(n); const u = Ya(i, r); const a = Ga(e, n).slice(t); const c = Ya(a, r); return { colspan: o(u), rowspan: o(c) } }; const Ja = { subgrid: Ka }; const Za = function (e, t) { const n = D(e, function (e, t) { return D(e.cells(), function (e, t) { return !1 }) }); const r = function (e, t, r, o) { for (let i = e; i < e + r; i++) { for (let u = t; u < t + o; u++) { n[i][u] = !0 } } }; return D(e, function (o, i) { const u = H(o.cells(), function (o, u) { if (!1 === n[i][u]) { const a = Ja.subgrid(e, i, u, t); return r(i, u, a.rowspan(), a.colspan()), [Sn(o.element(), a.rowspan(), a.colspan(), o.isNew())] } return [] }); return _n(u, o.section()) }) }; const Qa = function (e, t, n) { for (var r = [], o = 0; o < e.grid().rows(); o++) { for (var i = [], u = 0; u < e.grid().columns(); u++) { const a = br.getAt(e, o, u).map(function (e) { return En(e.element(), n) }).getOrThunk(function () { return En(t.gap(), !0) }); i.push(a) } const c = Nn(i, e.all()[o].section()); r.push(c) } return r }; const ec = { toDetails: Za, toGrid: Qa }; const tc = function (e, t) { return ec.toGrid(e, t, !1) }; const nc = function (e, t) { const n = function (e) { const n = j(e, function (e) { return tn(e.element()).map(function (e) { const t = tn(e).isNone(); return En(e, t) }) }); return n.getOrThunk(function () { return En(t.row(), !0) }) }; return D(e, function (e) { const t = n(e.details()); return On(t.element(), e.details(), e.section(), t.isNew()) }) }; const rc = function (e, t) { const n = ec.toDetails(e, Gt); return nc(n, t) }; const oc = function (e, t) { const n = L(D(e.all(), function (e) { return e.cells() })); return z(n, function (e) { return Gt(t, e.element()) }) }; const ic = function (e, t, n, r, i) { return function (u, a, c, s, l) { const f = fr.fromTable(a); const d = br.generate(f); const m = t(d, c).map(function (t) { const n = tc(d, s); const r = e(n, t, Gt, i(s)); const u = rc(r.grid(), s); return { grid: o(u), cursor: r.cursor } }); return m.fold(function () { return h.none() }, function (e) { const t = Zu.render(a, e.grid()); return n(a, e.grid(), l), r(a), La.refresh(u, a, ju.height, l), h.some({ cursor: e.cursor, newRows: t.newRows, newCells: t.newCells }) }) } }; const uc = function (e, t) { return cr.cell(t.element()).bind(function (t) { return oc(e, t) }) }; const ac = function (e, t) { return cr.cell(t.element()).bind(function (n) { return oc(e, n).map(function (e) { const n = Je(Je({}, e), { generators: t.generators, clipboard: t.clipboard }); return n }) }) }; const cc = function (e, t) { const n = D(t.selection(), function (t) { return cr.cell(t).bind(function (t) { return oc(e, t) }) }); const r = Xu(n); return r.length > 0 ? h.some({ cells: r, generators: t.generators, clipboard: t.clipboard }) : h.none() }; const sc = function (e, t) { return t.mergable() }; const lc = function (e, t) { return t.unmergable() }; const fc = function (e, t) { const n = D(t.selection(), function (t) { return cr.cell(t).bind(function (t) { return oc(e, t) }) }); const r = Xu(n); return r.length > 0 ? h.some(r) : h.none() }; var dc = function (e) { const t = function (t) { return e === t }; const n = function (t) { return dc(e) }; const r = function (t) { return dc(e) }; const i = function (t) { return dc(t(e)) }; const u = function (t) { return dc(e) }; const a = function (t) { t(e) }; const c = function (t) { return t(e) }; const f = function (t, n) { return n(e) }; const d = function (t) { return t(e) }; const m = function (t) { return t(e) }; const g = function () { return h.some(e) }; return { is: t, isValue: l, isError: s, getOr: o(e), getOrThunk: o(e), getOrDie: o(e), or: n, orThunk: r, fold: f, map: i, mapError: u, each: a, bind: c, exists: d, forall: m, toOption: g } }; var mc = function (e) { const t = function (e) { return e() }; const r = function () { return c(String(e))() }; const o = function (e) { return e }; const u = function (e) { return e() }; const a = function (t) { return mc(e) }; const f = function (t) { return mc(t(e)) }; const d = function (t) { return mc(e) }; const m = function (t, n) { return t(e) }; return { is: s, isValue: s, isError: l, getOr: i, getOrThunk: t, getOrDie: r, or: o, orThunk: u, fold: m, map: a, mapError: f, each: n, bind: d, exists: s, forall: l, toOption: h.none } }; const gc = function (e, t) { return e.fold(function () { return mc(t) }, dc) }; const hc = { value: dc, error: mc, fromOption: gc }; const pc = function (e, t, n) { if (e.row() >= t.length || e.column() > $a.cellLength(t[0])) { return hc.error('invalid start address out of table bounds, row: ' + e.row() + ', column: ' + e.column()) } const r = t.slice(e.row()); const i = r[0].cells().slice(e.column()); const u = $a.cellLength(n[0]); const a = n.length; return hc.value({ rowDelta: o(r.length - a), colDelta: o(i.length - u) }) }; const vc = function (e, t) { const n = $a.cellLength(e[0]); const r = $a.cellLength(t[0]); return { rowDelta: o(0), colDelta: o(n - r) } }; const bc = function (e, t) { return D(e, function () { return En(t.cell(), !0) }) }; const yc = function (e, t, n) { return e.concat(la(t, function (t) { return $a.setCells(e[e.length - 1], bc(e[e.length - 1].cells(), n)) })) }; const wc = function (e, t, n) { return D(e, function (e) { return $a.setCells(e, e.cells().concat(bc(fa(0, t), n))) }) }; const xc = function (e, t, n) { const r = t.colDelta() < 0 ? wc : i; const o = t.rowDelta() < 0 ? yc : i; const u = r(e, Math.abs(t.colDelta()), n); const a = o(u, Math.abs(t.rowDelta()), n); return a }; const Cc = { measure: pc, measureWidth: vc, tailor: xc }; const Sc = function (e, t, n, r) { if (e.length === 0) { return e } for (let o = t.startRow(); o <= t.finishRow(); o++) { for (let i = t.startCol(); i <= t.finishCol(); i++) { $a.mutateCell(e[o], i, En(r(), !1)) } } return e }; const kc = function (e, t, n, r) { for (let o = !0, i = 0; i < e.length; i++) { for (let u = 0; u < $a.cellLength(e[0]); u++) { const a = $a.getCellElement(e[i], u); const c = n(a, t); !0 === c && !1 === o ? $a.mutateCell(e[i], u, En(r(), !0)) : !0 === c && (o = !1) } } return e }; const Tc = function (e, t) { return P(e, function (e, n) { return _(e, function (e) { return t(e.element(), n.element()) }) ? e : e.concat([n]) }, []) }; const Ec = function (e, t, n, r) { if (t > 0 && t < e.length) { const o = e[t - 1].cells(); const i = Tc(o, n); A(i, function (o) { for (var i = h.none(), u = function (t) { for (let u = function (u) { const a = e[t].cells()[u]; const c = n(a.element(), o.element()); c && (i.isNone() && (i = h.some(r())), i.each(function (n) { $a.mutateCell(e[t], u, En(n, !0)) })) }, a = 0; a < $a.cellLength(e[0]); a++) { u(a) } }, a = t; a < e.length; a++) { u(a) } }) } return e }; const Oc = { merge: Sc, unmerge: kc, splitRows: Ec }; const Nc = function (e, t, n, r) { const o = $a.getCell(e[t], n); const i = u(r, o.element()); const a = e[t]; return e.length > 1 && $a.cellLength(a) > 1 && (n > 0 && i($a.getCellElement(a, n - 1)) || n < a.cells().length - 1 && i($a.getCellElement(a, n + 1)) || t > 0 && i($a.getCellElement(e[t - 1], n)) || t < e.length - 1 && i($a.getCellElement(e[t + 1], n))) }; const _c = function (e, t, n, r, o) { for (let i = e.row(), u = e.column(), a = n.length, c = $a.cellLength(n[0]), s = i + a, l = u + c, f = i; f < s; f++) { for (let d = u; d < l; d++) { Nc(t, f, d, o) && Oc.unmerge(t, $a.getCellElement(t[f], d), o, r.cell); const m = $a.getCellElement(n[f - i], d - u); const g = r.replace(m); $a.mutateCell(t[f], d, En(g, !0)) } } return t }; const Dc = function (e, t, n, r, o) { const i = Cc.measure(e, t, n); return i.map(function (i) { const u = Cc.tailor(t, i, r); return _c(e, u, n, r, o) }) }; const Ac = function (e, t, n, r, o) { Oc.splitRows(t, e, o, r.cell); const i = Cc.measureWidth(n, t); const u = Cc.tailor(n, i, r); const a = Cc.measureWidth(t, u); const c = Cc.tailor(t, a, r); return c.slice(0, e).concat(u).concat(c.slice(e, c.length)) }; const Rc = { merge: Dc, insert: Ac }; const Bc = function (e, t, n, r, o) { const i = e.slice(0, t); const u = e.slice(t); const a = $a.mapCells(e[n], function (n, i) { const u = t > 0 && t < e.length && r($a.getCellElement(e[t - 1], i), $a.getCellElement(e[t], i)); const a = u ? $a.getCell(e[t], i) : En(o(n.element(), r), !0); return a }); return i.concat([a]).concat(u) }; const Mc = function (e, t, n, r, o) { return D(e, function (e) { const i = t > 0 && t < $a.cellLength(e) && r($a.getCellElement(e, t - 1), $a.getCellElement(e, t)); const u = i ? $a.getCell(e, t) : En(o($a.getCellElement(e, n), r), !0); return $a.addCell(e, t, u) }) }; const Pc = function (e, t, n, r, o) { const i = n + 1; return D(e, function (e, u) { const a = u === t; const c = a ? En(o($a.getCellElement(e, n), r), !0) : $a.getCell(e, n); return $a.addCell(e, i, c) }) }; const zc = function (e, t, n, r, o) { const i = t + 1; const u = e.slice(0, i); const a = e.slice(i); const c = $a.mapCells(e[t], function (e, t) { const i = t === n; return i ? En(o(e.element(), r), !0) : e }); return u.concat([c]).concat(a) }; const Ic = function (e, t, n) { const r = D(e, function (e) { const r = e.cells().slice(0, t).concat(e.cells().slice(n + 1)); return Nn(r, e.section()) }); return B(r, function (e) { return e.cells().length > 0 }) }; const Lc = function (e, t, n) { return e.slice(0, t).concat(e.slice(n + 1)) }; const Hc = { insertRowAt: Bc, insertColumnAt: Mc, splitCellIntoColumns: Pc, splitCellIntoRows: zc, deleteRowsAt: Lc, deleteColumnsAt: Ic }; const Fc = function (e, t, n, r) { const o = function (e) { return _(t, function (t) { return n(e.element(), t.element()) }) }; return D(e, function (e) { return $a.mapCells(e, function (e) { return o(e) ? En(r(e.element(), n), !0) : e }) }) }; const Vc = function (e, t, n, r) { return void 0 !== $a.getCellElement(e[t], n) && t > 0 && r($a.getCellElement(e[t - 1], n), $a.getCellElement(e[t], n)) }; const Uc = function (e, t, n) { return t > 0 && n($a.getCellElement(e, t - 1), $a.getCellElement(e, t)) }; const jc = function (e, t, n, r) { const o = H(e, function (r, o) { const i = Vc(e, o, t, n) || Uc(r, t, n); return i ? [] : [$a.getCell(r, t)] }); return Fc(e, o, n, r) }; const Wc = function (e, t, n, r) { const o = e[t]; const i = H(o.cells(), function (r, i) { const u = Vc(e, t, i, n) || Uc(o, i, n); return u ? [] : [r] }); return Fc(e, i, n, r) }; const qc = { replaceColumn: jc, replaceRow: Wc }; const $c = bi.generate([{ none: [] }, { only: ['index'] }, { left: ['index', 'next'] }, { middle: ['prev', 'index', 'next'] }, { right: ['prev', 'index'] }]); const Gc = Je({}, $c); const Xc = function (e, t) { return e.length === 0 ? Gc.none() : e.length === 1 ? Gc.only(0) : t === 0 ? Gc.left(0, 1) : t === e.length - 1 ? Gc.right(t - 1, t) : t > 0 && t < e.length - 1 ? Gc.middle(t - 1, t, t + 1) : Gc.none() }; const Yc = function (e, t, n, r) { const i = e.slice(0); const u = Xc(e, t); const a = function (e) { return D(e, o(0)) }; const c = o(a(i)); const s = function (e) { return r.singleColumnWidth(i[e], n) }; const l = function (e, t) { if (n >= 0) { const o = Math.max(r.minCellWidth(), i[t] - n); return a(i.slice(0, e)).concat([n, o - i[t]]).concat(a(i.slice(t + 1))) } const u = Math.max(r.minCellWidth(), i[e] + n); const c = i[e] - u; return a(i.slice(0, e)).concat([u - i[e], c]).concat(a(i.slice(t + 1))) }; const f = l; const d = function (e, t, n) { return l(t, n) }; const m = function (e, t) { if (n >= 0) { return a(i.slice(0, t)).concat([n]) } const o = Math.max(r.minCellWidth(), i[t] + n); return a(i.slice(0, t)).concat([o - i[t]]) }; return u.fold(c, s, f, d, m) }; const Kc = { determine: Yc }; const Jc = function (e, t) { return ye(e, t) && parseInt(be(e, t), 10) > 1 }; const Zc = function (e) { return Jc(e, 'colspan') }; const Qc = function (e) { return Jc(e, 'rowspan') }; const es = function (e, t) { return parseInt(Ue(e, t), 10) }; const ts = { hasColspan: Zc, hasRowspan: Qc, minWidth: o(10), minHeight: o(10), getInt: es }; const ns = function (e, t, n) { return We(e, t).fold(function () { return n(e) + 'px' }, function (e) { return e }) }; const rs = function (e, t) { return ns(e, 'width', function (e) { return wu.getPixelWidth(e, t) }) }; const os = function (e) { return ns(e, 'height', wu.getHeight) }; const is = function (e, t, n, r, o) { const i = pa.columns(e); const u = D(i, function (e) { return e.map(t.edge) }); return D(i, function (e, t) { const i = e.filter(a(ts.hasColspan)); return i.fold(function () { const e = da(u, t); return r(e) }, function (e) { return n(e, o) }) }) }; const us = function (e) { return e.map(function (e) { return e + 'px' }).getOr('') }; const as = function (e, t, n) { return is(e, t, rs, us, n) }; const cs = function (e, t, n) { return is(e, t, wu.getPercentageWidth, function (e) { return e.fold(function () { return n.minCellWidth() }, function (e) { return e / n.pixelWidth() * 100 }) }, n) }; const ss = function (e, t, n) { return is(e, t, wu.getPixelWidth, function (e) { return e.getOrThunk(n.minCellWidth) }, n) }; const ls = function (e, t, n, r) { const o = pa.rows(e); const i = D(o, function (e) { return e.map(t.edge) }); return D(o, function (e, t) { const o = e.filter(a(ts.hasRowspan)); return o.fold(function () { const e = da(i, t); return r(e) }, function (e) { return n(e) }) }) }; const fs = function (e, t) { return ls(e, t, wu.getHeight, function (e) { return e.getOrThunk(ts.minHeight) }) }; const ds = function (e, t) { return ls(e, t, os, us) }; const ms = { getRawWidths: as, getPixelWidths: ss, getPercentageWidths: cs, getPixelHeights: fs, getRawHeights: ds }; const gs = function (e, t, n) { for (var r = 0, o = e; o < t; o++) { r += void 0 !== n[o] ? n[o] : 0 } return r }; const hs = function (e, t) { const n = br.justCells(e); return D(n, function (e) { const n = gs(e.column(), e.column() + e.colspan(), t); return { element: e.element, width: o(n), colspan: e.colspan } }) }; const ps = function (e, t) { const n = br.justCells(e); return D(n, function (e) { const n = gs(e.row(), e.row() + e.rowspan(), t); return { element: e.element, height: o(n), rowspan: e.rowspan } }) }; const vs = function (e, t) { return D(e.all(), function (e, n) { return { element: e.element, height: o(t[n]) } }) }; const bs = { recalculateWidth: hs, recalculateHeight: ps, matchRowHeight: vs }; const ys = function (e, t) { const n = parseFloat(e); const r = Ui(t); const i = function (e) { return e / r * 100 }; const u = function (e, t) { return [100 - e] }; const a = function () { return ts.minWidth() / r * 100 }; const c = function (e, t, r) { const o = r / 100; const i = o * n; wu.setPercentageWidth(e, n + i) }; return { width: o(n), pixelWidth: o(r), getWidths: ms.getPercentageWidths, getCellDelta: i, singleColumnWidth: u, minCellWidth: a, setElementWidth: wu.setPercentageWidth, setTableWidth: c } }; const ws = function (e) { const t = i; const n = function (e, t) { const n = Math.max(ts.minWidth(), e + t); return [n - e] }; const r = function (e, t, n) { const r = M(t, function (e, t) { return e + t }, 0); wu.setPixelWidth(e, r) }; return { width: o(e), pixelWidth: o(e), getWidths: ms.getPixelWidths, getCellDelta: t, singleColumnWidth: n, minCellWidth: ts.minWidth, setElementWidth: wu.setPixelWidth, setTableWidth: r } }; const xs = function (e, t) { const n = wu.percentageBasedSizeRegex().exec(t); if (n !== null) { return ys(n[1], e) } const r = wu.pixelBasedSizeRegex().exec(t); if (r !== null) { const o = parseInt(r[1], 10); return ws(o) } const i = Ui(e); return ws(i) }; const Cs = function (e) { const t = wu.getRawWidth(e); return t.fold(function () { const t = Ui(e); return ws(t) }, function (t) { return xs(e, t) }) }; const Ss = { getTableSize: Cs }; const ks = function (e) { return br.generate(e) }; const Ts = function (e) { return M(e, function (e, t) { return e + t }, 0) }; const Es = function (e) { const t = fr.fromTable(e); return ks(t) }; const Os = function (e, t, n, r) { const o = Ss.getTableSize(e); const i = o.getCellDelta(t); const u = Es(e); const a = o.getWidths(u, r, o); const c = Kc.determine(a, n, i, o); const s = D(c, function (e, t) { return e + a[t] }); const l = bs.recalculateWidth(u, s); A(l, function (e) { o.setElementWidth(e.element(), e.width()) }), n === u.grid().columns() - 1 && o.setTableWidth(e, s, i) }; const Ns = function (e, t, n, r) { const o = Es(e); const i = ms.getPixelHeights(o, r); const u = D(i, function (e, r) { return n === r ? Math.max(t + e, ts.minHeight()) : e }); const a = bs.recalculateHeight(o, u); const c = bs.matchRowHeight(o, u); A(c, function (e) { wu.setHeight(e.element(), e.height()) }), A(a, function (e) { wu.setHeight(e.element(), e.height()) }); const s = Ts(u); wu.setHeight(e, s) }; const _s = function (e, t, n) { const r = Ss.getTableSize(e); const o = ks(t); const i = r.getWidths(o, n, r); const u = bs.recalculateWidth(o, i); A(u, function (e) { r.setElementWidth(e.element(), e.width()) }), u.length > 0 && r.setTableWidth(e, i, r.getCellDelta(0)) }; const Ds = { adjustWidth: Os, adjustHeight: Ns, adjustWidthTo: _s }; const As = function (e, t) { return Rs(e, t, { validate: C, label: 'function' }) }; var Rs = function (e, t, n) { if (t.length === 0) { throw new Error('You must specify at least one required field.') } return te('required', t), re(t), function (r) { const o = W(r); const i = F(t, function (e) { return N(o, e) }); i || Q(t, o), e(t, o); const u = B(t, function (e) { return !n.validate(r[e], e) }); return u.length > 0 && ne(u, n.label), r } }; const Bs = function (e, t) { const n = B(t, function (t) { return !N(e, t) }); n.length > 0 && ee(n) }; const Ms = function (e) { return As(Bs, e) }; const Ps = Ms(['cell', 'row', 'replace', 'gap']); const zs = function (e) { const t = ye(e, 'colspan') ? parseInt(be(e, 'colspan'), 10) : 1; const n = ye(e, 'rowspan') ? parseInt(be(e, 'rowspan'), 10) : 1; return { element: o(e), colspan: o(t), rowspan: o(n) } }; const Is = function (e, n) { void 0 === n && (n = zs), Ps(e); const r = t(h.none()); const o = function (t) { return e.cell(t) }; const i = function (e) { const t = n(e); return o(t) }; const u = function (e) { const t = i(e); return r.get().isNone() && r.set(h.some(t)), a = h.some({ item: e, replacement: t }), t }; var a = h.none(); const c = function (e, t) { return a.fold(function () { return u(e) }, function (n) { return t(e, n.item) ? n.replacement : u(e) }) }; return { getOrInit: c, cursor: r.get } }; const Ls = function (e, n) { return function (r) { const o = t(h.none()); Ps(r); const i = []; const u = function (e, t) { return z(i, function (n) { return t(n.item, e) }) }; const a = function (t) { const u = { scope: e }; const a = r.replace(t, n, u); return i.push({ item: t, sub: a }), o.get().isNone() && o.set(h.some(a)), a }; const c = function (e, t) { return u(e, t).fold(function () { return a(e) }, function (n) { return t(e, n.item) ? n.sub : a(e) }) }; return { replaceOrInit: c, cursor: o.get } } }; const Hs = function (e) { Ps(e); const n = t(h.none()); const r = function (t) { return n.get().isNone() && n.set(h.some(t)), function () { const n = e.cell({ element: o(t), colspan: o(1), rowspan: o(1) }); return qe(n, 'width'), qe(t, 'width'), n } }; return { combine: r, cursor: n.get } }; const Fs = { modification: Is, transform: Ls, merging: Hs }; const Vs = ['body', 'p', 'div', 'article', 'aside', 'figcaption', 'figure', 'footer', 'header', 'nav', 'section', 'ol', 'ul', 'table', 'thead', 'tfoot', 'tbody', 'caption', 'tr', 'td', 'th', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'address']; const Us = function (e, t) { const n = e.property().name(t); return N(['ol', 'ul'], n) }; const js = function (e, t) { const n = e.property().name(t); return N(Vs, n) }; const Ws = function (e, t) { const n = e.property().name(t); return N(['address', 'pre', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'], n) }; const qs = function (e, t) { const n = e.property().name(t); return N(['h1', 'h2', 'h3', 'h4', 'h5', 'h6'], n) }; const $s = function (e, t) { return N(['div', 'li', 'td', 'th', 'blockquote', 'body', 'caption'], e.property().name(t)) }; const Gs = function (e, t) { return N(['br', 'img', 'hr', 'input'], e.property().name(t)) }; const Xs = function (e, t) { return e.property().name(t) === 'iframe' }; const Ys = function (e, t) { return !(js(e, t) || Gs(e, t)) && e.property().name(t) !== 'li' }; const Ks = { isBlock: js, isList: Us, isFormatting: Ws, isHeading: qs, isContainer: $s, isEmptyTag: Gs, isFrame: Xs, isInline: Ys }; const Js = yo(); const Zs = function (e) { return Ks.isBlock(Js, e) }; const Qs = function (e) { return Ks.isList(Js, e) }; const el = function (e) { return Ks.isFormatting(Js, e) }; const tl = function (e) { return Ks.isHeading(Js, e) }; const nl = function (e) { return Ks.isContainer(Js, e) }; const rl = function (e) { return Ks.isEmptyTag(Js, e) }; const ol = function (e) { return Ks.isFrame(Js, e) }; const il = function (e) { return Ks.isInline(Js, e) }; const ul = { isBlock: Zs, isList: Qs, isFormatting: el, isHeading: tl, isContainer: nl, isEmptyTag: rl, isFrame: ol, isInline: il }; const al = function (e) { const t = function (e) { return se(e) === 'br' }; const n = function (e) { return F(e, function (e) { return t(e) || ge(e) && _r(e).trim().length === 0 }) }; const r = function (e) { return se(e) === 'li' || Ln(e, ul.isList).isSome() }; const o = function (e) { return on(e).map(function (e) { return !!ul.isBlock(e) || !!ul.isEmptyTag(e) && se(e) !== 'img' }).getOr(!1) }; const i = function (e) { return Ir(e).bind(function (n) { const i = o(n); return tn(n).map(function (o) { return !0 === i || r(o) || t(n) || ul.isBlock(o) && !Gt(e, o) ? [] : [Me.fromTag('br')] }) }).getOr([]) }; const u = function () { const t = H(e, function (e) { const t = un(e); return n(t) ? [] : t.concat(i(e)) }); return t.length === 0 ? [Me.fromTag('br')] : t }; const a = u(); vn(e[0]), pn(e[0], a) }; const cl = { merge: al }; const sl = function (e) { const t = cr.cells(e); t.length === 0 && bn(e) }; const ll = J('grid', 'cursor'); const fl = function (e, t, n) { return dl(e, t, n).orThunk(function () { return dl(e, 0, 0) }) }; var dl = function (e, t, n) { return h.from(e[t]).bind(function (e) { return h.from(e.cells()[n]).bind(function (e) { return h.from(e.element()) }) }) }; const ml = function (e, t, n) { return ll(e, dl(e, t, n)) }; const gl = function (e) { return P(e, function (e, t) { return _(e, function (e) { return e.row() === t.row() }) ? e : e.concat([t]) }, []).sort(function (e, t) { return e.row() - t.row() }) }; const hl = function (e) { return P(e, function (e, t) { return _(e, function (e) { return e.column() === t.column() }) ? e : e.concat([t]) }, []).sort(function (e, t) { return e.column() - t.column() }) }; const pl = function (e, t, n, r) { const o = t.row(); const i = t.row(); const u = Hc.insertRowAt(e, i, o, n, r.getOrInit); return ml(u, i, t.column()) }; const vl = function (e, t, n, r) { const o = t[0].row(); const i = t[0].row(); const u = gl(t); const a = P(u, function (e, t) { return Hc.insertRowAt(e, i, o, n, r.getOrInit) }, e); return ml(a, i, t[0].column()) }; const bl = function (e, t, n, r) { const o = t.row(); const i = t.row() + t.rowspan(); const u = Hc.insertRowAt(e, i, o, n, r.getOrInit); return ml(u, i, t.column()) }; const yl = function (e, t, n, r) { const o = gl(t); const i = o[o.length - 1].row(); const u = o[o.length - 1].row() + o[o.length - 1].rowspan(); const a = P(o, function (e, t) { return Hc.insertRowAt(e, u, i, n, r.getOrInit) }, e); return ml(a, u, t[0].column()) }; const wl = function (e, t, n, r) { const o = t.column(); const i = t.column(); const u = Hc.insertColumnAt(e, i, o, n, r.getOrInit); return ml(u, t.row(), i) }; const xl = function (e, t, n, r) { const o = hl(t); const i = o[0].column(); const u = o[0].column(); const a = P(o, function (e, t) { return Hc.insertColumnAt(e, u, i, n, r.getOrInit) }, e); return ml(a, t[0].row(), u) }; const Cl = function (e, t, n, r) { const o = t.column(); const i = t.column() + t.colspan(); const u = Hc.insertColumnAt(e, i, o, n, r.getOrInit); return ml(u, t.row(), i) }; const Sl = function (e, t, n, r) { const o = t[t.length - 1].column(); const i = t[t.length - 1].column() + t[t.length - 1].colspan(); const u = hl(t); const a = P(u, function (e, t) { return Hc.insertColumnAt(e, i, o, n, r.getOrInit) }, e); return ml(a, t[0].row(), i) }; const kl = function (e, t, n, r) { const o = qc.replaceRow(e, t.row(), n, r.replaceOrInit); return ml(o, t.row(), t.column()) }; const Tl = function (e, t, n, r) { const o = qc.replaceColumn(e, t.column(), n, r.replaceOrInit); return ml(o, t.row(), t.column()) }; const El = function (e, t, n, r) { const o = qc.replaceRow(e, t.row(), n, r.replaceOrInit); return ml(o, t.row(), t.column()) }; const Ol = function (e, t, n, r) { const o = qc.replaceColumn(e, t.column(), n, r.replaceOrInit); return ml(o, t.row(), t.column()) }; const Nl = function (e, t, n, r) { const o = Hc.splitCellIntoColumns(e, t.row(), t.column(), n, r.getOrInit); return ml(o, t.row(), t.column()) }; const _l = function (e, t, n, r) { const o = Hc.splitCellIntoRows(e, t.row(), t.column(), n, r.getOrInit); return ml(o, t.row(), t.column()) }; const Dl = function (e, t, n, r) { const o = hl(t); const i = Hc.deleteColumnsAt(e, o[0].column(), o[o.length - 1].column()); const u = fl(i, t[0].row(), t[0].column()); return ll(i, u) }; const Al = function (e, t, n, r) { const o = gl(t); const i = Hc.deleteRowsAt(e, o[0].row(), o[o.length - 1].row()); const u = fl(i, t[0].row(), t[0].column()); return ll(i, u) }; const Rl = function (e, t, n, r) { const i = t.cells(); cl.merge(i); const u = Oc.merge(e, t.bounds(), n, o(i[0])); return ll(u, h.from(i[0])) }; const Bl = function (e, t, n, r) { const o = M(t, function (e, t) { return Oc.unmerge(e, t, n, r.combine(t)) }, e); return ll(o, h.from(t[0])) }; const Ml = function (e, t, n, r) { const o = function (e, t) { const n = fr.fromTable(e); const r = br.generate(n); return ec.toGrid(r, t, !0) }; const i = o(t.clipboard(), t.generators()); const u = xn(t.row(), t.column()); const a = Rc.merge(u, e, i, t.generators(), n); return a.fold(function () { return ll(e, h.some(t.element())) }, function (e) { const n = fl(e, t.row(), t.column()); return ll(e, n) }) }; const Pl = function (e, t, n) { const r = fr.fromPastedRows(e, n); const o = br.generate(r); return ec.toGrid(o, t, !0) }; const zl = function (e, t, n, r) { const o = e[t.cells[0].row()]; const i = t.cells[0].row(); const u = Pl(t.clipboard(), t.generators(), o); const a = Rc.insert(i, e, u, t.generators(), n); const c = fl(a, t.cells[0].row(), t.cells[0].column()); return ll(a, c) }; const Il = function (e, t, n, r) { const o = e[t.cells[0].row()]; const i = t.cells[t.cells.length - 1].row() + t.cells[t.cells.length - 1].rowspan(); const u = Pl(t.clipboard(), t.generators(), o); const a = Rc.insert(i, e, u, t.generators(), n); const c = fl(a, t.cells[0].row(), t.cells[0].column()); return ll(a, c) }; const Ll = Ds.adjustWidthTo; const Hl = { insertRowBefore: ic(pl, uc, n, n, Fs.modification), insertRowsBefore: ic(vl, fc, n, n, Fs.modification), insertRowAfter: ic(bl, uc, n, n, Fs.modification), insertRowsAfter: ic(yl, fc, n, n, Fs.modification), insertColumnBefore: ic(wl, uc, Ll, n, Fs.modification), insertColumnsBefore: ic(xl, fc, Ll, n, Fs.modification), insertColumnAfter: ic(Cl, uc, Ll, n, Fs.modification), insertColumnsAfter: ic(Sl, fc, Ll, n, Fs.modification), splitCellIntoColumns: ic(Nl, uc, Ll, n, Fs.modification), splitCellIntoRows: ic(_l, uc, n, n, Fs.modification), eraseColumns: ic(Dl, fc, Ll, sl, Fs.modification), eraseRows: ic(Al, fc, n, sl, Fs.modification), makeColumnHeader: ic(Tl, uc, n, n, Fs.transform('row', 'th')), unmakeColumnHeader: ic(Ol, uc, n, n, Fs.transform(null, 'td')), makeRowHeader: ic(kl, uc, n, n, Fs.transform('col', 'th')), unmakeRowHeader: ic(El, uc, n, n, Fs.transform(null, 'td')), mergeCells: ic(Rl, sc, n, n, Fs.merging), unmergeCells: ic(Bl, lc, Ll, n, Fs.merging), pasteCells: ic(Ml, ac, Ll, n, Fs.modification), pasteRowsBefore: ic(zl, cc, n, n, Fs.modification), pasteRowsAfter: ic(Il, cc, n, n, Fs.modification) }; const Fl = function (e) { return Me.fromDom(e.getBody()) }; const Vl = function (e) { return e.getBoundingClientRect().width }; const Ul = function (e) { return e.getBoundingClientRect().height }; const jl = function (e) { return function (t) { return Gt(t, Fl(e)) } }; const Wl = function (e) { return e ? e.replace(/px$/, '') : '' }; const ql = function (e) { return /^[0-9]+$/.test(e) && (e += 'px'), e }; const $l = function (e) { const t = zn(e, 'td[data-mce-style],th[data-mce-style]'); we(e, 'data-mce-style'), A(t, function (e) { we(e, 'data-mce-style') }) }; const Gl = function (e) { return Ue(e, 'direction') === 'rtl' ? 'rtl' : 'ltr' }; const Xl = { isRtl: o(!1) }; const Yl = { isRtl: o(!0) }; const Kl = function (e) { const t = Gl(e); return t === 'rtl' ? Yl : Xl }; const Jl = { directionAt: Kl }; const Zl = 'tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol'; const Ql = { 'border-collapse': 'collapse', width: '100%' }; const ef = { border: '1' }; const tf = function (e) { return e.getParam('table_default_attributes', ef, 'object') }; const nf = function (e) { return e.getParam('table_default_styles', Ql, 'object') }; const rf = function (e) { return e.getParam('table_resize_bars', !0, 'boolean') }; const of = function (e) { return e.getParam('table_tab_navigation', !0, 'boolean') }; const uf = function (e) { return e.getParam('table_cell_advtab', !0, 'boolean') }; const af = function (e) { return e.getParam('table_row_advtab', !0, 'boolean') }; const cf = function (e) { return e.getParam('table_advtab', !0, 'boolean') }; const sf = function (e) { return e.getParam('table_appearance_options', !0, 'boolean') }; const lf = function (e) { return e.getParam('table_grid', !0, 'boolean') }; const ff = function (e) { return e.getParam('table_style_by_css', !1, 'boolean') }; const df = function (e) { return e.getParam('table_cell_class_list', [], 'array') }; const mf = function (e) { return e.getParam('table_row_class_list', [], 'array') }; const gf = function (e) { return e.getParam('table_class_list', [], 'array') }; const hf = function (e) { return !0 === e.getParam('table_responsive_width') }; const pf = function (e) { return !1 === e.getParam('table_responsive_width') }; const vf = function (e) { return e.getParam('table_toolbar', Zl) }; const bf = function (e) { const t = e.getParam('table_clone_elements'); return y(t) ? h.some(t.split(/[ ,]/)) : Array.isArray(t) ? h.some(t) : h.none() }; const yf = function (e) { const t = e.getParam('object_resizing', !0); return y(t) ? t === 'table' : t }; const wf = function (e, t) { return e.fire('newrow', { node: t }) }; const xf = function (e, t) { return e.fire('newcell', { node: t }) }; const Cf = function (e, t, n, r) { e.fire('ObjectResizeStart', { target: t, width: n, height: r }) }; const Sf = function (e, t, n, r) { e.fire('ObjectResized', { target: t, width: n, height: r }) }; const kf = function (e, t, n, r, o) { e.fire('TableSelectionChange', { cells: t, start: n, finish: r, otherCells: o }) }; const Tf = function (e) { e.fire('TableSelectionClear') }; const Ef = J('element', 'offset'); var Of = (J('element', 'deltaOffset'), J('element', 'start', 'finish'), J('begin', 'end'), J('element', 'text'), function (e, t, n) { return e.property().isText(t) && e.property().getText(t).trim().length === 0 || e.property().isComment(t) ? n(t).bind(function (t) { return Of(e, t, n).orThunk(function () { return h.some(t) }) }) : h.none() }); const Nf = function (e, t) { if (e.property().isText(t)) { return e.property().getText(t).length } const n = e.property().children(t); return n.length }; var _f = function (e, t) { const n = Of(e, t, e.query().prevSibling).getOr(t); if (e.property().isText(n)) { return Ef(n, Nf(e, n)) } const r = e.property().children(n); return r.length > 0 ? _f(e, r[r.length - 1]) : Ef(n, Nf(e, n)) }; const Df = _f; const Af = yo(); const Rf = function (e) { return Df(Af, e) }; const Bf = function (e, t) { const r = function (e) { return se(Fl(e)) === 'table' }; const o = function (t) { const n = Gu.getGridSize(t); return !1 === r(e) || n.rows() > 1 }; const i = function (t) { const n = Gu.getGridSize(t); return !1 === r(e) || n.columns() > 1 }; const u = bf(e); const a = function (t, n, r, o) { return function (i, a) { $l(i); const c = o(); const s = Me.fromDom(e.getDoc()); const l = qu(Jl.directionAt); const f = Jr.cellOperations(r, s, u); return n(i) ? t(c, i, a, f, l).bind(function (t) { return A(t.newRows(), function (t) { wf(e, t.dom()) }), A(t.newCells(), function (t) { xf(e, t.dom()) }), t.cursor().map(function (t) { const n = Rf(t); const r = e.dom.createRng(); return r.setStart(n.element().dom(), n.offset()), r.setEnd(n.element().dom(), n.offset()), r }) }) : h.none() } }; const c = a(Hl.eraseRows, o, n, t); const s = a(Hl.eraseColumns, i, n, t); const f = a(Hl.insertRowsBefore, l, n, t); const d = a(Hl.insertRowsAfter, l, n, t); const m = a(Hl.insertColumnsBefore, l, Cu.halve, t); const g = a(Hl.insertColumnsAfter, l, Cu.halve, t); const p = a(Hl.mergeCells, l, n, t); const v = a(Hl.unmergeCells, l, n, t); const b = a(Hl.pasteRowsBefore, l, n, t); const y = a(Hl.pasteRowsAfter, l, n, t); const w = a(Hl.pasteCells, l, n, t); return { deleteRow: c, deleteColumn: s, insertRowsBefore: f, insertRowsAfter: d, insertColumnsBefore: m, insertColumnsAfter: g, mergeCells: p, unmergeCells: v, pasteRowsBefore: b, pasteRowsAfter: y, pasteCells: w } }; const Mf = function (e, t, n) { const r = fr.fromTable(e); const o = br.generate(r); const i = fc(o, t); return i.map(function (e) { const t = ec.toGrid(o, n, !1); const r = t.slice(e[0].row(), e[e.length - 1].row() + e[e.length - 1].rowspan()); const i = rc(r, n); return Zu.copy(i) }) }; const Pf = { copyRows: Mf }; const zf = tinymce.util.Tools.resolve('tinymce.util.Tools'); const If = function (e, t, n) { let r; const o = e.select('td,th', t); const i = function (t, r) { for (let o = 0; o < r.length; o++) { const i = e.getStyle(r[o], n); if (typeof t === 'undefined' && (t = i), t !== i) { return '' } } return t }; return r = i(r, o), r }; const Lf = function (e, t, n) { n && e.formatter.apply('align' + n, {}, t) }; const Hf = function (e, t, n) { n && e.formatter.apply('valign' + n, {}, t) }; const Ff = function (e, t) { zf.each('left center right'.split(' '), function (n) { e.formatter.remove('align' + n, {}, t) }) }; const Vf = function (e, t) { zf.each('top middle bottom'.split(' '), function (n) { e.formatter.remove('valign' + n, {}, t) }) }; const Uf = { applyAlign: Lf, applyVAlign: Hf, unApplyAlign: Ff, unApplyVAlign: Vf, getTDTHOverallStyle: If }; const jf = function (e, t, n) { var r = function (e, n) { return n = n || [], zf.each(e, function (e) { const o = { text: e.text || e.title }; e.menu ? o.menu = r(e.menu) : (o.value = e.value, t && t(o)), n.push(o) }), n }; return r(e, n || []) }; const Wf = function (e, t) { const n = function (t) { return ke(t, 'rgb') ? e.toHex(t) : t }; const r = We(Me.fromDom(t), 'border-width').getOr(''); const o = We(Me.fromDom(t), 'border-style').getOr(''); const i = We(Me.fromDom(t), 'border-color').map(n).getOr(''); const u = We(Me.fromDom(t), 'background-color').map(n).getOr(''); return { borderwidth: r, borderstyle: o, bordercolor: i, backgroundcolor: u } }; const qf = function (e) { const t = e[0]; const n = e.slice(1); const r = W(t); return A(n, function (e) { A(r, function (n) { $(e, function (e, r) { const o = t[n]; o !== '' && n === r && o !== e && (t[n] = '') }) }) }), t }; const $f = function (e) { const t = [{ name: 'borderstyle', type: 'selectbox', label: 'Border style', items: [{ text: 'Select...', value: '' }, { text: 'Solid', value: 'solid' }, { text: 'Dotted', value: 'dotted' }, { text: 'Dashed', value: 'dashed' }, { text: 'Double', value: 'double' }, { text: 'Groove', value: 'groove' }, { text: 'Ridge', value: 'ridge' }, { text: 'Inset', value: 'inset' }, { text: 'Outset', value: 'outset' }, { text: 'None', value: 'none' }, { text: 'Hidden', value: 'hidden' }] }, { name: 'bordercolor', type: 'colorinput', label: 'Border color' }, { name: 'backgroundcolor', type: 'colorinput', label: 'Background color' }]; const n = { name: 'borderwidth', type: 'input', label: 'Border width' }; const r = e === 'cell' ? [n].concat(t) : t; return { title: 'Advanced', name: 'advanced', items: r } }; const Gf = function (e, t, n, r, o) { const i = {}; return zf.each(e.split(' '), function (e) { r.formatter.matchNode(o, t + e) && (i[n] = e) }), i[n] || (i[n] = ''), i }; const Xf = u(Gf, 'left center right'); const Yf = u(Gf, 'top middle bottom'); const Kf = function (e, t) { const n = nf(e); const r = tf(e); const o = function (e) { const t = function (t) { return ke(t, 'rgb') ? e.toHex(t) : t }; const r = Y(n, 'border-style').getOr(''); const o = Y(n, 'border-color').getOr(''); const i = Y(n, 'background-color').getOr(''); return { borderstyle: r, bordercolor: t(o), backgroundcolor: t(i) } }; const i = { height: '', width: '100%', cellspacing: '', cellpadding: '', caption: !1, class: '', align: '', border: '' }; const u = function () { const t = n['border-width']; return ff(e) && t ? { border: t } : Y(r, 'border').fold(function () { return {} }, function (e) { return { border: e } }) }; const a = e.dom; const c = t ? o(a) : {}; const s = function () { const e = Y(n, 'border-spacing').or(Y(r, 'cellspacing')).fold(function () { return {} }, function (e) { return { cellspacing: e } }); const t = Y(n, 'border-padding').or(Y(r, 'cellpadding')).fold(function () { return {} }, function (e) { return { cellpadding: e } }); return Je(Je({}, e), t) }; const l = Je(Je(Je(Je(Je(Je({}, i), n), r), c), u()), s()); return l }; const Jf = function (e, t, n) { const r = function (t, n) { const r = We(Me.fromDom(n), 'border-width'); return ff(e) && r.isSome() ? r.getOr('') : t.getAttrib(n, 'border') || Uf.getTDTHOverallStyle(e.dom, n, 'border-width') || Uf.getTDTHOverallStyle(e.dom, n, 'border') }; const o = e.dom; const i = Je(Je({ width: o.getStyle(t, 'width') || o.getAttrib(t, 'width'), height: o.getStyle(t, 'height') || o.getAttrib(t, 'height'), cellspacing: o.getStyle(t, 'border-spacing') || o.getAttrib(t, 'cellspacing'), cellpadding: o.getAttrib(t, 'cellpadding') || Uf.getTDTHOverallStyle(e.dom, t, 'padding'), border: r(o, t), caption: !!o.select('caption', t)[0], class: o.getAttrib(t, 'class', '') }, Xf('align', 'align', e, t)), n ? Wf(o, t) : {}); return i }; const Zf = function (e, t, n) { const r = e.dom; const o = Je(Je({ height: r.getStyle(t, 'height') || r.getAttrib(t, 'height'), scope: r.getAttrib(t, 'scope'), class: r.getAttrib(t, 'class', ''), align: '', type: t.parentNode.nodeName.toLowerCase() }, Xf('align', 'align', e, t)), n ? Wf(r, t) : {}); return o }; const Qf = function (e, t, n) { const r = e.dom; const o = Je(Je(Je({ width: r.getStyle(t, 'width') || r.getAttrib(t, 'width'), height: r.getStyle(t, 'height') || r.getAttrib(t, 'height'), scope: r.getAttrib(t, 'scope'), celltype: t.nodeName.toLowerCase(), class: r.getAttrib(t, 'class', '') }, Xf('align', 'halign', e, t)), Yf('valign', 'valign', e, t)), n ? Wf(r, t) : {}); return o }; const ed = { buildListItems: jf, extractAdvancedStyles: Wf, getSharedValues: qf, getAdvancedTab: $f, extractDataFromTableElement: Jf, extractDataFromRowElement: Zf, extractDataFromCellElement: Qf, extractDataFromSettings: Kf }; const td = function (e) { const t = df(e); const n = ed.buildListItems(t, function (t) { t.value && (t.textStyle = function () { return e.formatter.getCssText({ block: 'tr', classes: [t.value] }) }) }); return t.length > 0 ? h.some({ name: 'class', type: 'selectbox', label: 'Class', items: n }) : h.none() }; const nd = [{ name: 'width', type: 'input', label: 'Width' }, { name: 'height', type: 'input', label: 'Height' }, { name: 'celltype', type: 'selectbox', label: 'Cell type', items: [{ text: 'Cell', value: 'td' }, { text: 'Header cell', value: 'th' }] }, { name: 'scope', type: 'selectbox', label: 'Scope', items: [{ text: 'None', value: '' }, { text: 'Row', value: 'row' }, { text: 'Column', value: 'col' }, { text: 'Row group', value: 'rowgroup' }, { text: 'Column group', value: 'colgroup' }] }, { name: 'halign', type: 'selectbox', label: 'H Align', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }, { name: 'valign', type: 'selectbox', label: 'V Align', items: [{ text: 'None', value: '' }, { text: 'Top', value: 'top' }, { text: 'Middle', value: 'middle' }, { text: 'Bottom', value: 'bottom' }] }]; const rd = function (e) { return td(e).fold(function () { return nd }, function (e) { return nd.concat(e) }) }; const od = { getItems: rd }; const id = function (e, t) { const n = function (n, r) { e.setAttrib(t, n, r) }; const r = function (n, r) { e.setStyle(t, n, r) }; return { setAttrib: n, setStyle: r } }; const ud = function (e, t) { const n = function (n, r) { r && e.setAttrib(t, n, r) }; const r = function (n, r) { r && e.setStyle(t, n, r) }; return { setAttrib: n, setStyle: r } }; const ad = { normal: id, ifTruthy: ud }; const cd = function (e, t) { e.setAttrib('scope', t.scope), e.setAttrib('class', t.class), e.setStyle('width', ql(t.width)), e.setStyle('height', ql(t.height)) }; const sd = function (e, t) { e.setStyle('background-color', t.backgroundcolor), e.setStyle('border-color', t.bordercolor), e.setStyle('border-style', t.borderstyle), e.setStyle('border-width', ql(t.borderwidth)) }; const ld = function (e, t, n) { const r = e.dom; const o = n.celltype && t[0].nodeName.toLowerCase() !== n.celltype ? r.rename(t[0], n.celltype) : t[0]; const i = ad.normal(r, o); cd(i, n), uf(e) && sd(i, n), Uf.unApplyAlign(e, o), Uf.unApplyVAlign(e, o), n.halign && Uf.applyAlign(e, o, n.halign), n.valign && Uf.applyVAlign(e, o, n.valign) }; const fd = function (e, t, n) { const r = e.dom; zf.each(t, function (t) { n.celltype && t.nodeName.toLowerCase() !== n.celltype && (t = r.rename(t, n.celltype)); const o = ad.ifTruthy(r, t); cd(o, n), uf(e) && sd(o, n), n.halign && Uf.applyAlign(e, t, n.halign), n.valign && Uf.applyVAlign(e, t, n.valign) }) }; const dd = function (e, t, n) { const r = n.getData(); n.close(), e.undoManager.transact(function () { const n = t.length === 1 ? ld : fd; n(e, t, r), e.focus() }) }; const md = function (e) { let t; let n = []; if (n = e.dom.select('td[data-mce-selected],th[data-mce-selected]'), t = e.dom.getParent(e.selection.getStart(), 'td,th'), !n.length && t && n.push(t), t = t || n[0], t) { const r = zf.map(n, function (t) { return ed.extractDataFromCellElement(e, t, uf(e)) }); const o = ed.getSharedValues(r); const i = { type: 'tabpanel', tabs: [{ title: 'General', name: 'general', items: od.getItems(e) }, ed.getAdvancedTab('cell')] }; const a = { type: 'panel', items: [{ type: 'grid', columns: 2, items: od.getItems(e) }] }; e.windowManager.open({ title: 'Cell Properties', size: 'normal', body: uf(e) ? i : a, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: o, onSubmit: u(dd, e, n) }) } }; const gd = { open: md }; const hd = function (e) { const t = mf(e); const n = ed.buildListItems(t, function (t) { t.value && (t.textStyle = function () { return e.formatter.getCssText({ block: 'tr', classes: [t.value] }) }) }); return t.length > 0 ? h.some({ name: 'class', type: 'selectbox', label: 'Class', items: n }) : h.none() }; const pd = [{ type: 'selectbox', name: 'type', label: 'Row type', items: [{ text: 'Header', value: 'thead' }, { text: 'Body', value: 'tbody' }, { text: 'Footer', value: 'tfoot' }] }, { type: 'selectbox', name: 'align', label: 'Alignment', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }, { label: 'Height', name: 'height', type: 'input' }]; const vd = function (e) { return hd(e).fold(function () { return pd }, function (e) { return pd.concat(e) }) }; const bd = { getItems: vd }; const yd = function (e, t, n) { const r = e.getParent(t, 'table'); const o = t.parentNode; let i = e.select(n, r)[0]; i || (i = e.create(n), r.firstChild ? r.firstChild.nodeName === 'CAPTION' ? e.insertAfter(i, r.firstChild) : r.insertBefore(i, r.firstChild) : r.appendChild(i)), n === 'tbody' && o.nodeName === 'THEAD' && i.firstChild ? i.insertBefore(t, i.firstChild) : i.appendChild(t), o.hasChildNodes() || e.remove(o) }; const wd = function (e, t) { e.setStyle('background-color', t.backgroundcolor), e.setStyle('border-color', t.bordercolor), e.setStyle('border-style', t.borderstyle) }; const xd = function (e, t, n, r) { const o = e.dom; const i = r.getData(); r.close(); const u = t.length === 1 ? ad.normal : ad.ifTruthy; e.undoManager.transact(function () { zf.each(t, function (t) { i.type !== t.parentNode.nodeName.toLowerCase() && yd(e.dom, t, i.type); const r = u(o, t); r.setAttrib('scope', i.scope), r.setAttrib('class', i.class), r.setStyle('height', ql(i.height)), af(e) && wd(r, i), i.align !== n.align && (Uf.unApplyAlign(e, t), Uf.applyAlign(e, t, i.align)) }), e.focus() }) }; const Cd = function (e) { let t; let n; let r; const o = e.dom; const i = []; if (t = o.getParent(e.selection.getStart(), 'table'), t && (n = o.getParent(e.selection.getStart(), 'td,th'), zf.each(t.rows, function (e) { zf.each(e.cells, function (t) { if ((o.getAttrib(t, 'data-mce-selected') || t === n) && !i.includes(e)) { return i.push(e), !1 } }) }), r = i[0], r)) { const a = zf.map(i, function (t) { return ed.extractDataFromRowElement(e, t, af(e)) }); const c = ed.getSharedValues(a); const s = { type: 'tabpanel', tabs: [{ title: 'General', name: 'general', items: bd.getItems(e) }, ed.getAdvancedTab('row')] }; const l = { type: 'panel', items: [{ type: 'grid', columns: 2, items: bd.getItems(e) }] }; e.windowManager.open({ title: 'Row Properties', size: 'normal', body: af(e) ? s : l, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: c, onSubmit: u(xd, e, i, c) }) } }; const Sd = { open: Cd }; const kd = tinymce.util.Tools.resolve('tinymce.Env'); const Td = { styles: { 'border-collapse': 'collapse', width: '100%' }, attributes: { border: '1' }, percentages: !0 }; const Ed = function () { return Me.fromTag('table') }; const Od = function () { return Me.fromTag('tbody') }; const Nd = function () { return Me.fromTag('tr') }; const _d = function () { return Me.fromTag('th') }; const Dd = function () { return Me.fromTag('td') }; const Ad = function (e, t, n, r, o) { void 0 === o && (o = Td); const i = Ed(); Ve(i, o.styles), ve(i, o.attributes); const u = Od(); dn(i, u); for (var a = [], c = 0; c < e; c++) { for (var s = Nd(), l = 0; l < t; l++) { const f = c < n || l < r ? _d() : Dd(); l < r && pe(f, 'scope', 'row'), c < n && pe(f, 'scope', 'col'), dn(f, Me.fromTag('br')), o.percentages && Fe(f, 'width', 100 / t + '%'), dn(s, f) }a.push(s) } return pn(u, a), i }; const Rd = function (e) { return e.dom().innerHTML }; const Bd = function (e) { const t = Me.fromTag('div'); const n = Me.fromDom(e.dom().cloneNode(!0)); return dn(t, n), Rd(t) }; const Md = function (e, t) { e.selection.select(t.dom(), !0), e.selection.collapse(!0) }; const Pd = function (e, t) { Wn(t, 'td,th').each(u(Md, e)) }; const zd = function (e, t) { A(zn(t, 'tr'), function (t) { wf(e, t.dom()), A(zn(t, 'th,td'), function (t) { xf(e, t.dom()) }) }) }; const Id = function (e) { return y(e) && e.includes('%') }; const Ld = function (e, t, n) { const r = nf(e); const o = { styles: r, attributes: tf(e), percentages: Id(r.width) && !pf(e) }; const i = Ad(n, t, 0, 0, o); pe(i, 'data-mce-id', '__mce'); const u = Bd(i); return e.insertContent(u), Wn(Fl(e), 'table[data-mce-id="__mce"]').map(function (t) { return pf(e) && Fe(t, 'width', Ue(t, 'width')), we(t, 'data-mce-id'), zd(e, t), Pd(e, t), t.dom() }).getOr(null) }; const Hd = { insert: Ld }; const Fd = function (e, t, n) { const r = n ? [{ type: 'input', name: 'cols', label: 'Cols', inputMode: 'numeric' }, { type: 'input', name: 'rows', label: 'Rows', inputMode: 'numeric' }] : []; const o = [{ type: 'input', name: 'width', label: 'Width' }, { type: 'input', name: 'height', label: 'Height' }]; const i = sf(e) ? [{ type: 'input', name: 'cellspacing', label: 'Cell spacing', inputMode: 'numeric' }, { type: 'input', name: 'cellpadding', label: 'Cell padding', inputMode: 'numeric' }, { type: 'input', name: 'border', label: 'Border width' }, { type: 'label', label: 'Caption', items: [{ type: 'checkbox', name: 'caption', label: 'Show caption' }] }] : []; const u = [{ type: 'selectbox', name: 'align', label: 'Alignment', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }]; const a = t ? [{ type: 'selectbox', name: 'class', label: 'Class', items: ed.buildListItems(gf(e), function (t) { t.value && (t.textStyle = function () { return e.formatter.getCssText({ block: 'table', classes: [t.value] }) }) }) }] : []; return r.concat(o).concat(i).concat(u).concat(a) }; const Vd = { getItems: Fd }; var Ud = function (e, t, n, r) { if (t.tagName === 'TD' || t.tagName === 'TH') { y(n) ? e.setStyle(t, n, r) : e.setStyle(t, n) } else if (t.children) { for (let o = 0; o < t.children.length; o++) { Ud(e, t.children[o], n, r) } } }; const jd = function (e, t, n) { const r = e.dom; const o = {}; const i = {}; if (o.class = n.class, i.height = ql(n.height), r.getAttrib(t, 'width') && !ff(e) ? o.width = Wl(n.width) : i.width = ql(n.width), ff(e) ? (i['border-width'] = ql(n.border), i['border-spacing'] = ql(n.cellspacing)) : (o.border = n.border, o.cellpadding = n.cellpadding, o.cellspacing = n.cellspacing), ff(e) && t.children) { for (let u = 0; u < t.children.length; u++) { Ud(r, t.children[u], { 'border-width': ql(n.border), padding: ql(n.cellpadding) }), cf(e) && Ud(r, t.children[u], { 'border-color': n.bordercolor }) } }cf(e) && (i['background-color'] = n.backgroundcolor, i['border-color'] = n.bordercolor, i['border-style'] = n.borderstyle), o.style = r.serializeStyle(Je(Je({}, nf(e)), i)), r.setAttribs(t, Je(Je({}, tf(e)), o)) }; const Wd = function (e, t, n) { let r; const o = e.dom; const i = n.getData(); n.close(), i.class === '' && delete i.class, e.undoManager.transact(function () { if (!t) { const n = parseInt(i.cols, 10) || 1; const u = parseInt(i.rows, 10) || 1; t = Hd.insert(e, n, u) }jd(e, t, i), r = o.select('caption', t)[0], r && !i.caption && o.remove(r), !r && i.caption && (r = o.create('caption'), r.innerHTML = kd.ie ? Er : '<br data-mce-bogus="1"/>', t.insertBefore(r, t.firstChild)), i.align === '' ? Uf.unApplyAlign(e, t) : Uf.applyAlign(e, t, i.align), e.focus(), e.addVisual() }) }; const qd = function (e, t) { let n; const r = e.dom; let o = ed.extractDataFromSettings(e, cf(e)); !1 === t ? (n = r.getParent(e.selection.getStart(), 'table'), n ? o = ed.extractDataFromTableElement(e, n, cf(e)) : cf(e) && (o.borderstyle = '', o.bordercolor = '', o.backgroundcolor = '')) : (o.cols = '1', o.rows = '1', cf(e) && (o.borderstyle = '', o.bordercolor = '', o.backgroundcolor = '')); const i = gf(e).length > 0; i && o.class && (o.class = o.class.replace(/\s*mce\-item\-table\s*/g, '')); const a = { type: 'grid', columns: 2, items: Vd.getItems(e, i, t) }; const c = function () { return { type: 'panel', items: [a] } }; const s = function () { return { type: 'tabpanel', tabs: [{ title: 'General', name: 'general', items: [a] }, ed.getAdvancedTab('table')] } }; const l = cf(e) ? s() : c(); e.windowManager.open({ title: 'Table Properties', size: 'normal', body: l, onSubmit: u(Wd, e, n), buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: o }) }; const $d = { open: qd }; const Gd = function (e) { return function (t) { return h.from(t.dom.getParent(t.selection.getStart(), e)).map(Me.fromDom) } }; const Xd = Gd('th,td'); const Yd = Gd('th,td,caption'); const Kd = zf.each; const Jd = function (e, t, r, o, i) { const c = jl(e); const s = function () { Yd(e).each(function (t) { const n = cr.table(t, c); n.filter(a(c)).each(function (t) { const n = Me.fromText(''); if (ln(t, n), bn(t), e.dom.isEmpty(e.getBody())) { e.setContent(''), e.selection.setCursorLocation() } else { const r = e.dom.createRng(); r.setStart(n.dom(), 0), r.setEnd(n.dom(), 0), e.selection.setRng(r), e.nodeChanged() } }) }) }; const l = function (e) { return cr.table(e, c) }; const f = function (e) { return { width: Vl(e.dom()), height: Vl(e.dom()) } }; const d = function (e, t, n) { const r = f(n); t.width === r.width && t.height === r.height || (Cf(e, n.dom(), t.width, t.height), Sf(e, n.dom(), r.width, r.height)) }; const m = function (t) { Xd(e).each(function (n) { l(n).each(function (i) { const u = Ai.forMenu(o, i, n); const a = f(i); t(i, u).each(function (t) { d(e, a, i), e.selection.setRng(t), e.focus(), r.clear(i), $l(i) }) }) }) }; const g = function (t) { return Xd(e).map(function (t) { return l(t).bind(function (r) { const i = Me.fromDom(e.getDoc()); const u = Ai.forMenu(o, r, t); const a = Jr.cellOperations(n, i, h.none()); return Pf.copyRows(r, u, a) }) }) }; const p = function (t) { i.get().each(function (n) { const i = D(n, function (e) { return Vr(e) }); Xd(e).each(function (n) { l(n).each(function (u) { const a = Me.fromDom(e.getDoc()); const c = Jr.paste(a); const s = Ai.pasteRows(o, u, n, i, c); t(u, s).each(function (t) { e.selection.setRng(t), e.focus(), r.clear(u) }) }) }) }) }; Kd({ mceTableSplitCells () { m(t.unmergeCells) }, mceTableMergeCells () { m(t.mergeCells) }, mceTableInsertRowBefore () { m(t.insertRowsBefore) }, mceTableInsertRowAfter () { m(t.insertRowsAfter) }, mceTableInsertColBefore () { m(t.insertColumnsBefore) }, mceTableInsertColAfter () { m(t.insertColumnsAfter) }, mceTableDeleteCol () { m(t.deleteColumn) }, mceTableDeleteRow () { m(t.deleteRow) }, mceTableCutRow (e) { g().each(function (e) { i.set(e), m(t.deleteRow) }) }, mceTableCopyRow (e) { g().each(function (e) { i.set(e) }) }, mceTablePasteRowBefore (e) { p(t.pasteRowsBefore) }, mceTablePasteRowAfter (e) { p(t.pasteRowsAfter) }, mceTableDelete: s }, function (t, n) { e.addCommand(n, t) }), Kd({ mceInsertTable: u($d.open, e, !0), mceTableProps: u($d.open, e, !1), mceTableRowProps: u(Sd.open, e), mceTableCellProps: u(gd.open, e) }, function (t, n) { e.addCommand(n, function () { t() }) }) }; const Zd = { registerCommands: Jd }; const Qd = function (e) { const t = h.from(e.dom().documentElement).map(Me.fromDom).getOr(e); return { parent: o(t), view: o(e), origin: o(ku(0, 0)) } }; const em = function (e, t) { const n = function () { return Ou(t) }; return { parent: o(t), view: o(e), origin: n } }; const tm = function (e, t) { return { parent: o(t), view: o(e), origin: o(ku(0, 0)) } }; const nm = { only: Qd, detached: em, body: tm }; const rm = function (e) { const t = J.apply(null, e); let n = []; const r = function (e) { if (void 0 === e) { throw new Error('Event bind error: undefined handler') } n.push(e) }; const o = function (e) { n = B(n, function (t) { return t !== e }) }; const i = function () { for (var e = [], r = 0; r < arguments.length; r++) { e[r] = arguments[r] } const o = t.apply(null, e); A(n, function (e) { e(o) }) }; return { bind: r, unbind: o, trigger: i } }; const om = function (e) { const t = G(e, function (e) { return { bind: e.bind, unbind: e.unbind } }); const n = G(e, function (e) { return e.trigger }); return { registry: t, trigger: n } }; const im = { create: om }; const um = function (e, t, n, r, i, u, a) { return { target: o(e), x: o(t), y: o(n), stop: r, prevent: i, kill: u, raw: o(a) } }; const am = function (e) { const t = Me.fromDom(e.target); const n = function () { e.stopPropagation() }; const o = function () { e.preventDefault() }; const i = r(o, n); return um(t, e.clientX, e.clientY, n, o, i, e) }; const cm = function (e, t) { return function (n) { e(n) && t(am(n)) } }; const sm = function (e, t, n, r, o) { const i = cm(n, r); return e.dom().addEventListener(t, i, o), { unbind: u(fm, e, t, i, o) } }; const lm = function (e, t, n, r) { return sm(e, t, n, r, !1) }; var fm = function (e, t, n, r) { e.dom().removeEventListener(t, n, r) }; const dm = o(!0); const mm = function (e, t, n) { return lm(e, t, dm, n) }; const gm = am; const hm = va('ephox-dragster'); const pm = { resolve: hm.resolve }; const vm = function (e) { const t = Je({ layerClass: pm.resolve('blocker') }, e); const n = Me.fromTag('div'); pe(n, 'role', 'presentation'), Ve(n, { position: 'fixed', left: '0px', top: '0px', width: '100%', height: '100%' }), ua(n, pm.resolve('blocker')), ua(n, t.layerClass); const r = function () { return n }; const o = function () { bn(n) }; return { element: r, destroy: o } }; const bm = Ms(['compare', 'extract', 'mutate', 'sink']); const ym = Ms(['element', 'start', 'stop', 'destroy']); const wm = Ms(['forceDrop', 'drop', 'move', 'delayDrop']); const xm = function (e, t) { return ku(t.left() - e.left(), t.top() - e.top()) }; const Cm = function (e) { return h.some(ku(e.x(), e.y())) }; const Sm = function (e, t) { e.mutate(t.left(), t.top()) }; const km = function (e, t) { const n = vm(t); const r = mm(n.element(), 'mousedown', e.forceDrop); const o = mm(n.element(), 'mouseup', e.drop); const i = mm(n.element(), 'mousemove', e.move); const u = mm(n.element(), 'mouseout', e.delayDrop); const a = function () { n.destroy(), o.unbind(), i.unbind(), u.unbind(), r.unbind() }; const c = function (e) { dn(e, n.element()) }; const s = function () { bn(n.element()) }; return ym({ element: n.element, start: c, stop: s, destroy: a }) }; const Tm = bm({ compare: xm, extract: Cm, sink: km, mutate: Sm }); const Em = function (t, n) { let r = null; const o = function () { r !== null && (e.clearTimeout(r), r = null) }; const i = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r !== null && e.clearTimeout(r), r = e.setTimeout(function () { t.apply(null, o), r = null }, n) }; return { cancel: o, throttle: i } }; function Om () { let e = h.none(); const t = function () { e = h.none() }; const n = function (t, n) { const r = e.map(function (e) { return t.compare(e, n) }); return e = h.some(n), r }; const r = function (e, t) { const r = t.extract(e); r.each(function (e) { const r = n(t, e); r.each(function (e) { o.trigger.move(e) }) }) }; var o = im.create({ move: rm(['info']) }); return { onEvent: r, reset: t, events: o.registry } } function Nm () { return { onEvent: n, reset: n } } function _m () { const e = Nm(); const t = Om(); let n = e; const r = function () { n.reset(), n = t }; const o = function () { n.reset(), n = e }; const i = function (e, t) { n.onEvent(e, t) }; const u = function () { return n === t }; return { on: r, off: o, isOn: u, onEvent: i, events: t.events } } const Dm = function (e, t, n) { let r = !1; const o = im.create({ start: rm([]), stop: rm([]) }); const i = _m(); const u = function () { m.stop(), i.isOn() && (i.off(), o.trigger.stop()) }; const a = Em(u, 200); const c = function (e) { m.start(e), i.on(), o.trigger.start() }; const s = function (e) { a.cancel(), i.onEvent(e, t) }; i.events.move.bind(function (n) { t.mutate(e, n.info()) }); const l = function () { r = !0 }; const f = function () { r = !1 }; const d = function (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] }r && e.apply(null, t) } }; var m = t.sink(wm({ forceDrop: u, drop: d(u), move: d(s), delayDrop: d(a.throttle) }), n); const g = function () { m.destroy() }; return { element: m.element, go: c, on: l, off: f, destroy: g, events: o.registry } }; const Am = { setup: Dm }; const Rm = function (e, t) { void 0 === t && (t = {}); const n = void 0 !== t.mode ? t.mode : Tm; return Am.setup(e, n, t) }; const Bm = { transform: Rm }; const Mm = function () { const e = im.create({ drag: rm(['xDelta', 'yDelta']) }); const t = function (t, n) { e.trigger.drag(t, n) }; return { mutate: t, events: e.registry } }; const Pm = function () { const e = im.create({ drag: rm(['xDelta', 'yDelta', 'target']) }); let t = h.none(); const n = Mm(); n.events.drag.bind(function (n) { t.each(function (t) { e.trigger.drag(n.xDelta(), n.yDelta(), t) }) }); const r = function (e) { t = h.some(e) }; const o = function () { return t }; return { assign: r, get: o, mutate: n.mutate, events: e.registry } }; const zm = function (e) { return be(e, 'contenteditable') === 'true' }; const Im = function (e, t) { return qn(e, '[contenteditable]', t) }; const Lm = ya.resolve('resizer-bar-dragging'); const Hm = function (e, t, n) { const r = Pm(); const o = Bm.transform(r, {}); let i = h.none(); const a = function (e, t) { return h.from(be(e, t)) }; r.events.drag.bind(function (e) { a(e.target(), 'data-row').each(function (t) { const n = ts.getInt(e.target(), 'top'); Fe(e.target(), 'top', n + e.yDelta() + 'px') }), a(e.target(), 'data-column').each(function (t) { const n = ts.getInt(e.target(), 'left'); Fe(e.target(), 'left', n + e.xDelta() + 'px') }) }); const c = function (e, t) { const n = ts.getInt(e, t); const r = parseInt(be(e, 'data-initial-' + t), 10); return n - r }; o.events.stop.bind(function () { r.get().each(function (r) { i.each(function (o) { a(r, 'data-row').each(function (e) { const t = c(r, 'top'); we(r, 'data-initial-top'), v.trigger.adjustHeight(o, t, parseInt(e, 10)) }), a(r, 'data-column').each(function (e) { const t = c(r, 'left'); we(r, 'data-initial-left'), v.trigger.adjustWidth(o, t, parseInt(e, 10)) }), La.refresh(e, o, n, t) }) }) }); const s = function (t, n) { v.trigger.startAdjust(), r.assign(t), pe(t, 'data-initial-' + n, parseInt(Ue(t, n), 10)), ua(t, Lm), Fe(t, 'opacity', '0.2'), o.go(e.parent()) }; const l = mm(e.parent(), 'mousedown', function (e) { La.isRowBar(e.target()) && s(e.target(), 'top'), La.isColBar(e.target()) && s(e.target(), 'left') }); const f = function (t) { return Gt(t, e.view()) }; const d = function (e) { return qn(e, 'table', f).filter(function (e) { return Im(e, f).exists(zm) }) }; const m = mm(e.view(), 'mouseover', function (r) { d(r.target()).fold(function () { Pe(r.target()) && La.destroy(e) }, function (r) { i = h.some(r), La.refresh(e, r, n, t) }) }); const g = function () { l.unbind(), m.unbind(), o.destroy(), La.destroy(e) }; const p = function (r) { La.refresh(e, r, n, t) }; var v = im.create({ adjustHeight: rm(['table', 'delta', 'row']), adjustWidth: rm(['table', 'delta', 'column']), startAdjust: rm([]) }); return { destroy: g, refresh: p, on: o.on, off: o.off, hideBars: u(La.hide, e), showBars: u(La.show, e), events: v.registry } }; const Fm = function (e, t) { const n = ju.height; const r = Hm(e, t, n); const o = im.create({ beforeResize: rm(['table']), afterResize: rm(['table']), startDrag: rm([]) }); return r.events.adjustHeight.bind(function (e) { o.trigger.beforeResize(e.table()); const t = n.delta(e.delta(), e.table()); Ds.adjustHeight(e.table(), t, e.row(), n), o.trigger.afterResize(e.table()) }), r.events.startAdjust.bind(function (e) { o.trigger.startDrag() }), r.events.adjustWidth.bind(function (e) { o.trigger.beforeResize(e.table()); const n = t.delta(e.delta(), e.table()); Ds.adjustWidth(e.table(), n, e.column(), t), o.trigger.afterResize(e.table()) }), { on: r.on, off: r.off, hideBars: r.hideBars, showBars: r.showBars, destroy: r.destroy, events: o.registry } }; const Vm = { create: Fm }; const Um = function () { const e = Me.fromTag('div'); return Ve(e, { position: 'static', height: '0', width: '0', padding: '0', margin: '0', border: '0' }), dn(ze(), e), e }; const jm = function (e, t) { return e.inline ? nm.body(Fl(e), Um()) : nm.only(Me.fromDom(e.getDoc())) }; const Wm = function (e, t) { e.inline && bn(t.parent()) }; const qm = { get: jm, remove: Wm }; const $m = function (e, t) { return Vl(e.dom()) / Vl(t.dom()) * 100 + '%' }; const Gm = function (e) { const t = Me.fromDom(e); tn(t).map(function (e) { return $m(t, e) }).each(function (e) { Fe(t, 'width', e), A(zn(t, 'tr'), function (e) { A(un(e), function (t) { Fe(t, 'width', $m(t, e)) }) }) }) }; const Xm = function (e) { Fe(Me.fromDom(e), 'width', Vl(e).toString() + 'px') }; const Ym = function (e) { let t; let n; let r = h.none(); let o = h.none(); let i = h.none(); const u = /(\d+(\.\d+)?)%/; const a = function (e) { return e.nodeName === 'TABLE' }; const c = function (t) { const n = e.dom.getStyle(t, 'width') || e.dom.getAttrib(t, 'width'); return h.from(n).filter(function (e) { return e.length > 0 }) }; const s = function () { return o }; const l = function () { return i.getOr(nm.only(Me.fromDom(e.getBody()))) }; const f = function () { o.each(function (e) { e.destroy() }), i.each(function (t) { qm.remove(e, t) }) }; return e.on('init', function () { const t = qu(Jl.directionAt); const n = qm.get(e); if (i = h.some(n), yf(e) && rf(e)) { const u = Vm.create(n, t); u.on(), u.events.startDrag.bind(function (t) { r = h.some(e.selection.getRng()) }), u.events.beforeResize.bind(function (t) { const n = t.table().dom(); Cf(e, n, Vl(n), Ul(n)) }), u.events.afterResize.bind(function (t) { const n = t.table(); const o = n.dom(); $l(n), r.each(function (t) { e.selection.setRng(t), e.focus() }), Sf(e, o, Vl(o), Ul(o)), e.undoManager.add() }), o = h.some(u) } }), e.on('ObjectResizeStart', function (r) { const o = r.target; if (a(o)) { const i = c(o).map(function (e) { return u.test(e) }).getOr(!1); i && pf(e) ? Xm(o) : !i && hf(e) && Gm(o), t = r.width, n = c(o).getOr('') } }), e.on('ObjectResized', function (r) { const o = r.target; if (a(o)) { const i = o; if (u.test(n)) { const c = parseFloat(u.exec(n)[1]); const s = r.width * c / t; e.dom.setStyle(i, 'width', s + '%') } else { const l = []; zf.each(i.rows, function (t) { zf.each(t.cells, function (t) { const n = e.dom.getStyle(t, 'width', !0); l.push({ cell: t, width: n }) }) }), zf.each(l, function (t) { e.dom.setStyle(t.cell, 'width', t.width), e.dom.setAttrib(t.cell, 'width', null) }) } } }), e.on('SwitchMode', function () { s().each(function (t) { e.mode.isReadOnly() ? t.hideBars() : t.showBars() }) }), { lazyResize: s, lazyWire: l, destroy: f } }; const Km = bi.generate([{ none: ['current'] }, { first: ['current'] }, { middle: ['current', 'target'] }, { last: ['current'] }]); const Jm = function (e) { return void 0 === e && (e = void 0), Km.none(e) }; const Zm = Je(Je({}, Km), { none: Jm }); const Qm = function (e, t) { return cr.table(e, t).bind(function (t) { const n = cr.cells(t); const r = I(n, function (t) { return Gt(e, t) }); return r.map(function (e) { return { index: o(e), all: o(n) } }) }) }; const eg = function (e, t) { const n = Qm(e, t); return n.fold(function () { return Zm.none(e) }, function (t) { return t.index() + 1 < t.all().length ? Zm.middle(e, t.all()[t.index() + 1]) : Zm.last(e) }) }; const tg = function (e, t) { const n = Qm(e, t); return n.fold(function () { return Zm.none() }, function (t) { return t.index() - 1 >= 0 ? Zm.middle(e, t.all()[t.index() - 1]) : Zm.first(e) }) }; const ng = { next: eg, prev: tg }; const rg = J('start', 'soffset', 'finish', 'foffset'); const og = { create: rg }; const ig = bi.generate([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]); const ug = function (e, t, n, r) { return e.fold(t, n, r) }; const ag = function (e) { return e.fold(i, i, i) }; const cg = ig.before; const sg = ig.on; const lg = ig.after; const fg = { before: cg, on: sg, after: lg, cata: ug, getStart: ag }; const dg = bi.generate([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }]); const mg = function (e) { return dg.exact(e.start(), e.soffset(), e.finish(), e.foffset()) }; const gg = function (e) { return e.match({ domRange (e) { return Me.fromDom(e.startContainer) }, relative (e, t) { return fg.getStart(e) }, exact (e, t, n, r) { return e } }) }; const hg = dg.domRange; const pg = dg.relative; const vg = dg.exact; const bg = function (e) { const t = gg(e); return en(t) }; const yg = og.create; const wg = { domRange: hg, relative: pg, exact: vg, exactFromRange: mg, getWin: bg, range: yg }; const xg = function (e, t) { const n = e.document.createRange(); return Cg(n, t), n }; var Cg = function (e, t) { e.selectNodeContents(t.dom()) }; const Sg = function (e, t) { t.fold(function (t) { e.setStartBefore(t.dom()) }, function (t, n) { e.setStart(t.dom(), n) }, function (t) { e.setStartAfter(t.dom()) }) }; const kg = function (e, t) { t.fold(function (t) { e.setEndBefore(t.dom()) }, function (t, n) { e.setEnd(t.dom(), n) }, function (t) { e.setEndAfter(t.dom()) }) }; const Tg = function (e, t, n) { const r = e.document.createRange(); return Sg(r, t), kg(r, n), r }; const Eg = function (e, t, n, r, o) { const i = e.document.createRange(); return i.setStart(t.dom(), n), i.setEnd(r.dom(), o), i }; const Og = function (e) { return { left: o(e.left), top: o(e.top), right: o(e.right), bottom: o(e.bottom), width: o(e.width), height: o(e.height) } }; const Ng = function (e) { const t = e.getClientRects(); const n = t.length > 0 ? t[0] : e.getBoundingClientRect(); return n.width > 0 || n.height > 0 ? h.some(n).map(Og) : h.none() }; const _g = bi.generate([{ ltr: ['start', 'soffset', 'finish', 'foffset'] }, { rtl: ['start', 'soffset', 'finish', 'foffset'] }]); const Dg = function (e, t, n) { return t(Me.fromDom(n.startContainer), n.startOffset, Me.fromDom(n.endContainer), n.endOffset) }; const Ag = function (e, t) { return t.match({ domRange (e) { return { ltr: o(e), rtl: h.none } }, relative (t, n) { return { ltr: Ne(function () { return Tg(e, t, n) }), rtl: Ne(function () { return h.some(Tg(e, n, t)) }) } }, exact (t, n, r, o) { return { ltr: Ne(function () { return Eg(e, t, n, r, o) }), rtl: Ne(function () { return h.some(Eg(e, r, o, t, n)) }) } } }) }; const Rg = function (e, t) { const n = t.ltr(); if (n.collapsed) { const r = t.rtl().filter(function (e) { return !1 === e.collapsed }); return r.map(function (e) { return _g.rtl(Me.fromDom(e.endContainer), e.endOffset, Me.fromDom(e.startContainer), e.startOffset) }).getOrThunk(function () { return Dg(e, _g.ltr, n) }) } return Dg(e, _g.ltr, n) }; const Bg = function (e, t) { const n = Ag(e, t); return Rg(e, n) }; const Mg = function (e, t) { const n = Bg(e, t); return n.match({ ltr (t, n, r, o) { const i = e.document.createRange(); return i.setStart(t.dom(), n), i.setEnd(r.dom(), o), i }, rtl (t, n, r, o) { const i = e.document.createRange(); return i.setStart(r.dom(), o), i.setEnd(t.dom(), n), i } }) }; const Pg = (_g.ltr, _g.rtl, function (e, t, n, r, o) { if (o === 0) { return 0 } if (t === r) { return o - 1 } for (let i = r, u = 1; u < o; u++) { const a = e(u); const c = Math.abs(t - a.left); if (n <= a.bottom) { if (n < a.top || c > i) { return u - 1 } i = c } } return 0 }); const zg = function (e, t, n) { return t >= e.left && t <= e.right && n >= e.top && n <= e.bottom }; const Ig = function (e, t, n, r, o) { const i = function (n) { const r = e.dom().createRange(); return r.setStart(t.dom(), n), r.collapse(!0), r }; const u = function (e) { const t = i(e); return t.getBoundingClientRect() }; const a = _r(t).length; const c = Pg(u, n, r, o.right, a); return i(c) }; const Lg = function (e, t, n, r) { const o = e.dom().createRange(); o.selectNode(t.dom()); const i = o.getClientRects(); const u = j(i, function (e) { return zg(e, n, r) ? h.some(e) : h.none() }); return u.map(function (o) { return Ig(e, t, n, r, o) }) }; const Hg = function (e, t, n, r) { const o = e.dom().createRange(); const i = un(t); return j(i, function (t) { return o.selectNode(t.dom()), zg(o.getBoundingClientRect(), n, r) ? Fg(e, t, n, r) : h.none() }) }; var Fg = function (e, t, n, r) { return ge(t) ? Lg(e, t, n, r) : Hg(e, t, n, r) }; const Vg = function (e, t, n, r) { const o = e.dom().createRange(); o.selectNode(t.dom()); const i = o.getBoundingClientRect(); const u = Math.max(i.left, Math.min(i.right, n)); const a = Math.max(i.top, Math.min(i.bottom, r)); return Fg(e, t, u, a) }; const Ug = !0; const jg = !1; const Wg = function (e, t) { return t - e.left < e.right - t ? Ug : jg }; const qg = function (e, t, n) { const r = e.dom().createRange(); return r.selectNode(t.dom()), r.collapse(n), r }; const $g = function (e, t, n) { const r = e.dom().createRange(); r.selectNode(t.dom()); const o = r.getBoundingClientRect(); const i = Wg(o, n); const u = i === Ug ? zr : Ir; return u(t).map(function (t) { return qg(e, t, i) }) }; const Gg = function (e, t, n) { const r = t.dom().getBoundingClientRect(); const o = Wg(r, n); return h.some(qg(e, t, o)) }; const Xg = function (e, t, n) { const r = un(t).length === 0 ? Gg : $g; return r(e, t, n) }; const Yg = function (e, t, n) { return h.from(e.dom().caretPositionFromPoint(t, n)).bind(function (t) { if (t.offsetNode === null) { return h.none() } const n = e.dom().createRange(); return n.setStart(t.offsetNode, t.offset), n.collapse(), h.some(n) }) }; const Kg = function (e, t, n) { return h.from(e.dom().caretRangeFromPoint(t, n)) }; const Jg = function (e, t, n, r) { const o = e.dom().createRange(); o.selectNode(t.dom()); const i = o.getBoundingClientRect(); const u = Math.max(i.left, Math.min(i.right, n)); const a = Math.max(i.top, Math.min(i.bottom, r)); return Vg(e, t, u, a) }; const Zg = function (e, t, n) { return Me.fromPoint(e, t, n).bind(function (r) { const o = function () { return Xg(e, r, t) }; return un(r).length === 0 ? o() : Jg(e, r, t, n).orThunk(o) }) }; const Qg = document.caretPositionFromPoint ? Yg : document.caretRangeFromPoint ? Kg : Zg; const eh = function (e, t, n) { const r = Me.fromDom(e.document); return Qg(r, t, n).map(function (e) { return og.create(Me.fromDom(e.startContainer), e.startOffset, Me.fromDom(e.endContainer), e.endOffset) }) }; const th = function (e, t) { const n = se(e); return n === 'input' ? fg.after(e) : N(['br', 'img'], n) ? t === 0 ? fg.before(e) : fg.after(e) : fg.on(e, t) }; const nh = function (e, t) { const n = e.fold(fg.before, th, fg.after); const r = t.fold(fg.before, th, fg.after); return wg.relative(n, r) }; const rh = function (e, t, n, r) { const o = th(e, t); const i = th(n, r); return wg.relative(o, i) }; const oh = function (e) { return e.match({ domRange (e) { const t = Me.fromDom(e.startContainer); const n = Me.fromDom(e.endContainer); return rh(t, e.startOffset, n, e.endOffset) }, relative: nh, exact: rh }) }; const ih = function (e, t, n, r) { const o = Qt(e); const i = o.dom().createRange(); return i.setStart(e.dom(), t), i.setEnd(n.dom(), r), i }; const uh = function (e, t, n, r) { const o = ih(e, t, n, r); const i = Gt(e, n) && t === r; return o.collapsed && !i }; const ah = function (e, t) { h.from(e.getSelection()).each(function (e) { e.removeAllRanges(), e.addRange(t) }) }; const ch = function (e, t, n, r, o) { const i = Eg(e, t, n, r, o); ah(e, i) }; const sh = function (e, t, n, r, o, i) { t.collapse(n.dom(), r), t.extend(o.dom(), i) }; const lh = function (e, t) { return Bg(e, t).match({ ltr (t, n, r, o) { ch(e, t, n, r, o) }, rtl (t, n, r, o) { const i = e.getSelection(); if (i.setBaseAndExtent) { i.setBaseAndExtent(t.dom(), n, r.dom(), o) } else if (i.extend) { try { sh(e, i, t, n, r, o) } catch (u) { ch(e, r, o, t, n) } } else { ch(e, r, o, t, n) } } }) }; const fh = function (e, t, n, r, o) { const i = rh(t, n, r, o); lh(e, i) }; const dh = function (e, t, n) { const r = nh(t, n); lh(e, r) }; const mh = function (e) { const t = wg.getWin(e).dom(); const n = function (e, n, r, o) { return Eg(t, e, n, r, o) }; const r = oh(e); return Bg(t, r).match({ ltr: n, rtl: n }) }; const gh = function (e) { if (e.rangeCount > 0) { const t = e.getRangeAt(0); const n = e.getRangeAt(e.rangeCount - 1); return h.some(og.create(Me.fromDom(t.startContainer), t.startOffset, Me.fromDom(n.endContainer), n.endOffset)) } return h.none() }; const hh = function (e) { const t = Me.fromDom(e.anchorNode); const n = Me.fromDom(e.focusNode); return uh(t, e.anchorOffset, n, e.focusOffset) ? h.some(og.create(t, e.anchorOffset, n, e.focusOffset)) : gh(e) }; const ph = function (e, t) { const n = xg(e, t); ah(e, n) }; const vh = function (e) { return h.from(e.getSelection()).filter(function (e) { return e.rangeCount > 0 }).bind(hh) }; const bh = function (e) { return vh(e).map(function (e) { return wg.exact(e.start(), e.soffset(), e.finish(), e.foffset()) }) }; const yh = function (e, t) { const n = Mg(e, t); return Ng(n) }; const wh = function (e, t, n) { return eh(e, t, n) }; const xh = function (e) { const t = e.getSelection(); t.removeAllRanges() }; const Ch = tinymce.util.Tools.resolve('tinymce.util.VK'); const Sh = function (e, t, n, r) { return Oh(e, t, ng.next(n), r) }; const kh = function (e, t, n, r) { return Oh(e, t, ng.prev(n), r) }; const Th = function (e, t) { const n = wg.exact(t, 0, t, 0); return mh(n) }; const Eh = function (e, t) { const n = zn(t, 'tr'); return U(n).bind(function (t) { return Wn(t, 'td,th').map(function (t) { return Th(e, t) }) }) }; var Oh = function (e, t, n, r, o) { return n.fold(h.none, h.none, function (t, n) { return zr(n).map(function (t) { return Th(e, t) }) }, function (n) { return cr.table(n, t).bind(function (t) { const o = Ai.noMenu(n); return e.undoManager.transact(function () { r.insertRowsAfter(t, o) }), Eh(e, t) }) }) }; const Nh = ['table', 'li', 'dl']; const _h = function (e, t, n, r) { if (e.keyCode === Ch.TAB) { const o = Fl(t); const i = function (e) { const t = se(e); return Gt(e, o) || N(Nh, t) }; const u = t.selection.getRng(); if (u.collapsed) { const a = Me.fromDom(u.startContainer); cr.cell(a, i).each(function (o) { e.preventDefault(); const u = e.shiftKey ? kh : Sh; const a = u(t, i, o, n, r); a.each(function (e) { t.selection.setRng(e) }) }) } } }; const Dh = { handle: _h }; const Ah = J('selection', 'kill'); const Rh = { create: Ah }; const Bh = function (e, t, n, r) { return { start: o(fg.on(e, t)), finish: o(fg.on(n, r)) } }; const Mh = { create: Bh }; const Ph = function (e, t) { const n = Mg(e, t); return og.create(Me.fromDom(n.startContainer), n.startOffset, Me.fromDom(n.endContainer), n.endOffset) }; const zh = Mh.create; const Ih = { convertToRange: Ph, makeSitus: zh }; const Lh = function (e, t, n, r, o, i, u) { return Gt(n, o) && r === i ? h.none() : qn(n, 'td,th', t).bind(function (n) { return qn(o, 'td,th', t).bind(function (r) { return Hh(e, t, n, r, u) }) }) }; var Hh = function (e, t, n, r, o) { return Gt(n, r) ? h.none() : ii.identify(n, r, t).bind(function (t) { const r = t.boxes().getOr([]); return r.length > 0 ? (o(e, r, t.start(), t.finish()), h.some(Rh.create(h.some(Ih.makeSitus(n, 0, n, Rr(n))), !0))) : h.none() }) }; const Fh = function (e, t, n, r, o) { const i = function (e) { return o.clearBeforeUpdate(n), o.selectRange(n, e.boxes(), e.start(), e.finish()), e.boxes() }; return ii.shiftSelection(r, e, t, o.firstSelectedSelector(), o.lastSelectedSelector()).map(i) }; const Vh = { sync: Lh, detect: Hh, update: Fh }; const Uh = J('item', 'mode'); const jh = function (e, t, n, r) { return void 0 === r && (r = Wh), e.property().parent(t).map(function (e) { return Uh(e, r) }) }; var Wh = function (e, t, n, r) { return void 0 === r && (r = qh), n.sibling(e, t).map(function (e) { return Uh(e, r) }) }; var qh = function (e, t, n, r) { void 0 === r && (r = qh); const o = e.property().children(t); const i = n.first(o); return i.map(function (e) { return Uh(e, r) }) }; const $h = [{ current: jh, next: Wh, fallback: h.none() }, { current: Wh, next: qh, fallback: h.some(jh) }, { current: qh, next: qh, fallback: h.some(Wh) }]; var Gh = function (e, t, n, r, o) { void 0 === o && (o = $h); const i = z(o, function (e) { return e.current === n }); return i.bind(function (n) { return n.current(e, t, r, n.next).orThunk(function () { return n.fallback.bind(function (n) { return Gh(e, t, n, r) }) }) }) }; const Xh = function () { const e = function (e, t) { return e.query().prevSibling(t) }; const t = function (e) { return e.length > 0 ? h.some(e[e.length - 1]) : h.none() }; return { sibling: e, first: t } }; const Yh = function () { const e = function (e, t) { return e.query().nextSibling(t) }; const t = function (e) { return e.length > 0 ? h.some(e[0]) : h.none() }; return { sibling: e, first: t } }; const Kh = { left: Xh, right: Yh }; var Jh = function (e, t, n, r, o, i) { const u = Gh(e, t, r, o); return u.bind(function (t) { return i(t.item()) ? h.none() : n(t.item()) ? h.some(t.item()) : Jh(e, t.item(), n, t.mode(), o, i) }) }; const Zh = function (e, t, n, r) { return Jh(e, t, n, Wh, Kh.left(), r) }; const Qh = function (e, t, n, r) { return Jh(e, t, n, Wh, Kh.right(), r) }; const ep = function (e) { return function (t) { return e.property().children(t).length === 0 } }; const tp = function (e, t, n) { return rp(e, t, ep(e), n) }; const np = function (e, t, n) { return op(e, t, ep(e), n) }; var rp = Zh; var op = Qh; const ip = yo(); const up = function (e, t) { return tp(ip, e, t) }; const ap = function (e, t) { return np(ip, e, t) }; const cp = function (e, t, n) { return rp(ip, e, t, n) }; const sp = function (e, t, n) { return op(ip, e, t, n) }; const lp = function (e, t, n) { return Ln(e, t, n).isSome() }; const fp = bi.generate([{ none: ['message'] }, { success: [] }, { failedUp: ['cell'] }, { failedDown: ['cell'] }]); const dp = function (e, t, n) { const r = e.getRect(t); const o = e.getRect(n); return o.right > r.left && o.left < r.right }; const mp = function (e) { return qn(e, 'tr') }; const gp = function (e, t, n, r, o, i, u) { return qn(r, 'td,th', u).bind(function (n) { return qn(t, 'td,th', u).map(function (t) { return Gt(n, t) ? Gt(r, n) && Rr(n) === o ? i(t) : fp.none('in same cell') : Yo.sharedOne(mp, [n, t]).fold(function () { return dp(e, t, n) ? fp.success() : i(t) }, function (e) { return i(t) }) }) }).getOr(fp.none('default')) }; const hp = function (e, t, n, r, o) { return e.fold(t, n, r, o) }; const pp = Je(Je({}, fp), { verify: gp, cata: hp }); const vp = (J('ancestor', 'descendants', 'element', 'index'), J('parent', 'children', 'element', 'index')); const bp = function (e) { return tn(e).bind(function (t) { const n = un(t); return yp(n, e).map(function (r) { return vp(t, n, e, r) }) }) }; var yp = function (e, t) { return I(e, u(Gt, t)) }; const wp = function (e) { return se(e) === 'br' }; var xp = function (e, t, n) { return t(e, n).bind(function (e) { return ge(e) && _r(e).trim().length === 0 ? xp(e, t, n) : h.some(e) }) }; const Cp = function (e, t, n) { return n.traverse(t).orThunk(function () { return xp(t, n.gather, e) }).map(n.relative) }; const Sp = function (e, t) { return an(e, t).filter(wp).orThunk(function () { return an(e, t - 1).filter(wp) }) }; const kp = function (e, t, n, r) { return Sp(t, n).bind(function (t) { return r.traverse(t).fold(function () { return xp(t, r.gather, e).map(r.relative) }, function (e) { return bp(e).map(function (e) { return fg.on(e.parent(), e.index()) }) }) }) }; const Tp = function (e, t, n, r) { const i = wp(t) ? Cp(e, t, r) : kp(e, t, n, r); return i.map(function (e) { return { start: o(e), finish: o(e) } }) }; const Ep = function (e) { return pp.cata(e, function (e) { return h.none() }, function () { return h.none() }, function (e) { return h.some(Ef(e, 0)) }, function (e) { return h.some(Ef(e, Rr(e))) }) }; const Op = { tryBr: Tp, process: Ep }; const Np = oe(['left', 'top', 'right', 'bottom'], []); const _p = function (e, t) { return Np({ left: e.left(), top: e.top() + t, right: e.right(), bottom: e.bottom() + t }) }; const Dp = function (e, t) { return Np({ left: e.left(), top: e.top() - t, right: e.right(), bottom: e.bottom() - t }) }; const Ap = function (e, t) { const n = e.bottom() - e.top(); return Np({ left: e.left(), top: t - n, right: e.right(), bottom: t }) }; const Rp = function (e, t) { const n = e.bottom() - e.top(); return Np({ left: e.left(), top: t, right: e.right(), bottom: t + n }) }; const Bp = function (e, t, n) { return Np({ left: e.left() + t, top: e.top() + n, right: e.right() + t, bottom: e.bottom() + n }) }; const Mp = function (e) { return e.top() }; const Pp = function (e) { return e.bottom() }; const zp = function (e) { return '(' + e.left() + ', ' + e.top() + ') -> (' + e.right() + ', ' + e.bottom() + ')' }; const Ip = { nu: Np, moveUp: Dp, moveDown: _p, moveBottomTo: Ap, moveTopTo: Rp, getTop: Mp, getBottom: Pp, translate: Bp, toString: zp }; const Lp = function (e, t, n) { return n >= 0 && n < Rr(t) ? e.getRangedRect(t, n, t, n + 1) : n > 0 ? e.getRangedRect(t, n - 1, t, n) : h.none() }; const Hp = function (e) { return Ip.nu({ left: e.left, top: e.top, right: e.right, bottom: e.bottom }) }; const Fp = function (e, t) { return h.some(e.getRect(t)) }; const Vp = function (e, t, n) { return me(t) ? Fp(e, t).map(Hp) : ge(t) ? Lp(e, t, n).map(Hp) : h.none() }; const Up = function (e, t) { return me(t) ? Fp(e, t).map(Hp) : ge(t) ? e.getRangedRect(t, 0, t, Rr(t)).map(Hp) : h.none() }; const jp = { getBoxAt: Vp, getEntireBox: Up }; const Wp = 5; const qp = 100; const $p = bi.generate([{ none: [] }, { retry: ['caret'] }]); const Gp = function (e, t) { return e.left() < t.left() || Math.abs(t.right() - e.left()) < 1 || e.left() > t.right() }; const Xp = function (e, t, n) { return Hn(t, ul.isBlock).fold(o(!1), function (t) { return jp.getEntireBox(e, t).exists(function (e) { return Gp(n, e) }) }) }; const Yp = function (e, t, n, r, o) { const i = Ip.moveDown(o, Wp); return Math.abs(n.bottom() - r.bottom()) < 1 ? $p.retry(i) : n.top() > o.bottom() ? $p.retry(i) : n.top() === o.bottom() ? $p.retry(Ip.moveDown(o, 1)) : Xp(e, t, o) ? $p.retry(Ip.translate(i, Wp, 0)) : $p.none() }; const Kp = function (e, t, n, r, o) { const i = Ip.moveUp(o, Wp); return Math.abs(n.top() - r.top()) < 1 ? $p.retry(i) : n.bottom() < o.top() ? $p.retry(i) : n.bottom() === o.top() ? $p.retry(Ip.moveUp(o, 1)) : Xp(e, t, o) ? $p.retry(Ip.translate(i, Wp, 0)) : $p.none() }; const Jp = { point: Ip.getTop, adjuster: Kp, move: Ip.moveUp, gather: up }; const Zp = { point: Ip.getBottom, adjuster: Yp, move: Ip.moveDown, gather: ap }; const Qp = function (e, t, n) { return e.elementFromPoint(t, n).filter(function (e) { return se(e) === 'table' }).isSome() }; const ev = function (e, t, n, r, o) { return tv(e, t, n, t.move(r, Wp), o) }; var tv = function (e, t, n, r, o) { return o === 0 ? h.some(r) : Qp(e, r.left(), t.point(r)) ? ev(e, t, n, r, o - 1) : e.situsFromPoint(r.left(), t.point(r)).bind(function (i) { return i.start().fold(h.none, function (i) { return jp.getEntireBox(e, i).bind(function (u) { return t.adjuster(e, i, u, n, r).fold(h.none, function (r) { return tv(e, t, n, r, o - 1) }) }).orThunk(function () { return h.some(r) }) }, h.none) }) }; const nv = function (e, t) { return e.situsFromPoint(t.left(), t.bottom() + Wp) }; const rv = function (e, t) { return e.situsFromPoint(t.left(), t.top() - Wp) }; const ov = function (e, t, n) { return e.point(t) > n.getInnerHeight() ? h.some(e.point(t) - n.getInnerHeight()) : e.point(t) < 0 ? h.some(-e.point(t)) : h.none() }; const iv = function (e, t, n) { const r = e.move(n, Wp); const o = tv(t, e, n, r, qp).getOr(r); return ov(e, o, t).fold(function () { return t.situsFromPoint(o.left(), e.point(o)) }, function (n) { return t.scrollBy(0, n), t.situsFromPoint(o.left(), e.point(o) - n) }) }; const uv = { tryUp: u(iv, Jp), tryDown: u(iv, Zp), ieTryUp: rv, ieTryDown: nv, getJumpSize: o(Wp) }; const av = 20; const cv = Ft(); const sv = function (e, t, n) { return e.getSelection().bind(function (r) { return Op.tryBr(t, r.finish(), r.foffset(), n).fold(function () { return h.some(Ef(r.finish(), r.foffset())) }, function (o) { const i = e.fromSitus(o); const u = pp.verify(e, r.finish(), r.foffset(), i.finish(), i.foffset(), n.failure, t); return Op.process(u) }) }) }; var lv = function (e, t, n, r, o, i) { return i === 0 ? h.none() : mv(e, t, n, r, o).bind(function (u) { const a = e.fromSitus(u); const c = pp.verify(e, n, r, a.finish(), a.foffset(), o.failure, t); return pp.cata(c, function () { return h.none() }, function () { return h.some(u) }, function (u) { return Gt(n, u) && r === 0 ? fv(e, n, r, Ip.moveUp, o) : lv(e, t, u, 0, o, i - 1) }, function (u) { return Gt(n, u) && r === Rr(u) ? fv(e, n, r, Ip.moveDown, o) : lv(e, t, u, Rr(u), o, i - 1) }) }) }; var fv = function (e, t, n, r, o) { return jp.getBoxAt(e, t, n).bind(function (t) { return dv(e, o, r(t, uv.getJumpSize())) }) }; var dv = function (e, t, n) { return cv.browser.isChrome() || cv.browser.isSafari() || cv.browser.isFirefox() || cv.browser.isEdge() ? t.otherRetry(e, n) : cv.browser.isIE() ? t.ieRetry(e, n) : h.none() }; var mv = function (e, t, n, r, o) { return jp.getBoxAt(e, n, r).bind(function (t) { return dv(e, o, t) }) }; const gv = function (e, t, n) { return sv(e, t, n).bind(function (r) { return lv(e, t, r.element(), r.offset(), n, av).map(e.fromSitus) }) }; const hv = { handle: gv }; const pv = Ft(); const vv = function (e, t) { return lp(e, function (e) { return tn(e).exists(function (e) { return Gt(e, t) }) }) }; const bv = function (e, t, n, r, i) { return qn(r, 'td,th', t).bind(function (r) { return qn(r, 'table', t).bind(function (u) { return vv(i, u) ? hv.handle(e, t, n).bind(function (e) { return qn(e.finish(), 'td,th', t).map(function (t) { return { start: o(r), finish: o(t), range: o(e) } }) }) : h.none() }) }) }; const yv = function (e, t, n, r, o, i) { return pv.browser.isIE() ? h.none() : i(r, t).orThunk(function () { return bv(e, t, n, r, o).map(function (e) { const t = e.range(); return Rh.create(h.some(Ih.makeSitus(t.start(), t.soffset(), t.finish(), t.foffset())), !0) }) }) }; const wv = function (e, t) { return qn(e, 'tr', t).bind(function (e) { return qn(e, 'table', t).bind(function (n) { const r = zn(n, 'tr'); return Gt(e, r[0]) ? cp(n, function (e) { return Ir(e).isSome() }, t).map(function (e) { const t = Rr(e); return Rh.create(h.some(Ih.makeSitus(e, t, e, t)), !0) }) : h.none() }) }) }; const xv = function (e, t) { return qn(e, 'tr', t).bind(function (e) { return qn(e, 'table', t).bind(function (n) { const r = zn(n, 'tr'); return Gt(e, r[r.length - 1]) ? sp(n, function (e) { return zr(e).isSome() }, t).map(function (e) { return Rh.create(h.some(Ih.makeSitus(e, 0, e, 0)), !0) }) : h.none() }) }) }; const Cv = function (e, t, n, r, o, i, u) { return bv(e, n, r, o, i).bind(function (e) { return Vh.detect(t, n, e.start(), e.finish(), u) }) }; const Sv = { navigate: yv, select: Cv, firstUpCheck: wv, lastDownCheck: xv }; const kv = function (e, t) { return qn(e, 'td,th', t) }; function Tv (e, t, n, r) { let o = h.none(); const i = function () { o = h.none() }; const u = function (e) { r.clear(t), o = kv(e.target(), n) }; const a = function (i) { o.each(function (o) { r.clearBeforeUpdate(t), kv(i.target(), n).each(function (i) { ii.identify(o, i, n).each(function (n) { const u = n.boxes().getOr([]); (u.length > 1 || u.length === 1 && !Gt(o, i)) && (r.selectRange(t, u, n.start(), n.finish()), e.selectContents(i)) }) }) }) }; const c = function (e) { o.each(i) }; return { mousedown: u, mouseover: a, mouseup: c } } const Ev = { traverse: on, gather: ap, relative: fg.before, otherRetry: uv.tryDown, ieRetry: uv.ieTryDown, failure: pp.failedDown }; const Ov = { traverse: rn, gather: up, relative: fg.before, otherRetry: uv.tryUp, ieRetry: uv.ieTryUp, failure: pp.failedUp }; const Nv = { down: Ev, up: Ov }; const _v = function (e) { return function (t) { return t === e } }; const Dv = _v(38); const Av = _v(40); const Rv = function (e) { return e >= 37 && e <= 40 }; const Bv = { ltr: { isBackward: _v(37), isForward: _v(39) }, rtl: { isBackward: _v(39), isForward: _v(37) }, isUp: Dv, isDown: Av, isNavigation: Rv }; const Mv = function (e) { return { left: e.left(), top: e.top(), right: e.right(), bottom: e.bottom(), width: e.width(), height: e.height() } }; const Pv = { toRaw: Mv }; const zv = (Ft().browser.isSafari(), function (t) { const n = void 0 !== t ? t.dom() : e.document; const r = n.body.scrollLeft || n.documentElement.scrollLeft; const o = n.body.scrollTop || n.documentElement.scrollTop; return ku(r, o) }); const Iv = function (t, n, r) { const o = void 0 !== r ? r.dom() : e.document; const i = o.defaultView; i.scrollBy(t, n) }; const Lv = function (e) { const t = function (t, n) { return Me.fromPoint(Me.fromDom(e.document), t, n) }; const n = function (e) { return e.dom().getBoundingClientRect() }; const r = function (t, n, r, o) { const i = wg.exact(t, n, r, o); return yh(e, i).map(Pv.toRaw) }; const o = function () { return bh(e).map(function (t) { return Ih.convertToRange(e, t) }) }; const i = function (t) { const n = wg.relative(t.start(), t.finish()); return Ih.convertToRange(e, n) }; const u = function (t, n) { return wh(e, t, n).map(function (e) { return Mh.create(e.start(), e.soffset(), e.finish(), e.foffset()) }) }; const a = function () { xh(e) }; const c = function (t) { void 0 === t && (t = !1), bh(e).each(function (n) { return n.fold(function (e) { return e.collapse(t) }, function (n, r) { const o = t ? n : r; dh(e, o, o) }, function (n, r, o, i) { const u = t ? n : o; const a = t ? r : i; fh(e, u, a, u, a) }) }) }; const s = function (t) { ph(e, t) }; const l = function (t) { fh(e, t.start(), t.soffset(), t.finish(), t.foffset()) }; const f = function (t, n) { dh(e, t, n) }; const d = function () { return e.innerHeight }; const m = function () { const t = zv(Me.fromDom(e.document)); return t.top() }; const g = function (t, n) { Iv(t, n, Me.fromDom(e.document)) }; return { elementFromPoint: t, getRect: n, getRangedRect: r, getSelection: o, fromSitus: i, situsFromPoint: u, clearSelection: a, collapseSelection: c, setSelection: l, setRelativeSelection: f, selectContents: s, getInnerHeight: d, getScrollY: m, scrollBy: g } }; const Hv = J('rows', 'cols'); const Fv = function (e, t, n, r) { const o = Lv(e); const i = Tv(o, t, n, r); return { mousedown: i.mousedown, mouseover: i.mouseover, mouseup: i.mouseup } }; const Vv = function (e, t, n, r) { const o = Lv(e); const i = function () { return r.clear(t), h.none() }; const a = function (e, a, c, s, l, f) { const d = e.raw(); const m = d.which; const g = !0 === d.shiftKey; const p = ii.retrieve(t, r.selectedSelector()).fold(function () { return Bv.isDown(m) && g ? u(Sv.select, o, t, n, Nv.down, s, a, r.selectRange) : Bv.isUp(m) && g ? u(Sv.select, o, t, n, Nv.up, s, a, r.selectRange) : Bv.isDown(m) ? u(Sv.navigate, o, n, Nv.down, s, a, Sv.lastDownCheck) : Bv.isUp(m) ? u(Sv.navigate, o, n, Nv.up, s, a, Sv.firstUpCheck) : h.none }, function (e) { const n = function (n) { return function () { const i = j(n, function (n) { return Vh.update(n.rows(), n.cols(), t, e, r) }); return i.fold(function () { return ii.getEdges(t, r.firstSelectedSelector(), r.lastSelectedSelector()).map(function (e) { const n = Bv.isDown(m) || f.isForward(m) ? fg.after : fg.before; return o.setRelativeSelection(fg.on(e.first(), 0), n(e.table())), r.clear(t), Rh.create(h.none(), !0) }) }, function (e) { return h.some(Rh.create(h.none(), !0)) }) } }; return Bv.isDown(m) && g ? n([Hv(1, 0)]) : Bv.isUp(m) && g ? n([Hv(-1, 0)]) : f.isBackward(m) && g ? n([Hv(0, -1), Hv(-1, 0)]) : f.isForward(m) && g ? n([Hv(0, 1), Hv(1, 0)]) : Bv.isNavigation(m) && !1 === g ? i : h.none }); return p() }; const c = function (e, o, i, u, a) { return ii.retrieve(t, r.selectedSelector()).fold(function () { const c = e.raw(); const s = c.which; const l = !0 === c.shiftKey; return !1 === l ? h.none() : Bv.isNavigation(s) ? Vh.sync(t, n, o, i, u, a, r.selectRange) : h.none() }, h.none) }; return { keydown: a, keyup: c } }; const Uv = function (e, t, n, r) { const o = Lv(e); return function (e, i) { r.clearBeforeUpdate(t), ii.identify(e, i, n).each(function (e) { const n = e.boxes().getOr([]); r.selectRange(t, n, e.start(), e.finish()), o.selectContents(i), o.collapseSelection() }) } }; const jv = { mouse: Fv, keyboard: Vv, external: Uv }; const Wv = function (e, t) { A(t, function (t) { ca(e, t) }) }; const qv = function (e) { return function (t) { ua(t, e) } }; const $v = function (e) { return function (t) { Wv(t, e) } }; const Gv = function (e) { const t = qv(e.selected()); const n = $v([e.selected(), e.lastSelected(), e.firstSelected()]); const r = function (t) { const r = zn(t, e.selectedSelector()); A(r, n) }; const o = function (n, o, i, u) { r(n), A(o, t), ua(i, e.firstSelected()), ua(u, e.lastSelected()) }; return { clearBeforeUpdate: r, clear: r, selectRange: o, selectedSelector: e.selectedSelector, firstSelectedSelector: e.firstSelectedSelector, lastSelectedSelector: e.lastSelectedSelector } }; const Xv = function (e, t, n) { const r = function (t) { we(t, e.selected()), we(t, e.firstSelected()), we(t, e.lastSelected()) }; const o = function (t) { pe(t, e.selected(), '1') }; const i = function (e) { u(e), n() }; var u = function (t) { const n = zn(t, e.selectedSelector()); A(n, r) }; const a = function (n, r, u, a) { i(n), A(r, o), pe(u, e.firstSelected(), '1'), pe(a, e.lastSelected(), '1'), t(r, u, a) }; return { clearBeforeUpdate: u, clear: i, selectRange: a, selectedSelector: e.selectedSelector, firstSelectedSelector: e.firstSelectedSelector, lastSelectedSelector: e.lastSelectedSelector } }; const Yv = { byClass: Gv, byAttr: Xv }; const Kv = function (e, t, n) { const r = e.slice(0, t[t.length - 1].row() + 1); const o = rc(r, n); return H(o, function (e) { const n = e.cells().slice(0, t[t.length - 1].column() + 1); return D(n, function (e) { return e.element() }) }) }; const Jv = function (e, t, n) { const r = e.slice(t[0].row() + t[0].rowspan() - 1, e.length); const o = rc(r, n); return H(o, function (e) { const n = e.cells().slice(t[0].column() + t[0].colspan() - 1, +e.cells().length); return D(n, function (e) { return e.element() }) }) }; const Zv = function (e, t, n) { const r = fr.fromTable(e); const o = br.generate(r); const i = fc(o, t); return i.map(function (e) { const t = ec.toGrid(o, n, !1); const r = Kv(t, e, n); const i = Jv(t, e, n); return { upOrLeftCells: r, downOrRightCells: i } }) }; const Qv = { getOtherCells: Zv }; const eb = function (e) { return !1 === sa(Me.fromDom(e.target), 'ephox-snooker-resizer-bar') }; function tb (e, r, o) { const i = oe(['mousedown', 'mouseover', 'mouseup', 'keyup', 'keydown'], []); let u = h.none(); const a = bf(e); const c = function (t, r, i) { o.targets().each(function (o) { const u = cr.table(r); u.each(function (u) { const c = Me.fromDom(e.getDoc()); const s = Jr.cellOperations(n, c, a); const l = Qv.getOtherCells(u, o, s); kf(e, t, r, i, l) }) }) }; const s = function () { Tf(e) }; const l = Yv.byAttr(pi, c, s); e.on('init', function (o) { const a = e.getWin(); const c = Fl(e); const s = jl(e); const f = function () { const t = e.selection; const r = Me.fromDom(t.getStart()); const o = Me.fromDom(t.getEnd()); const i = Yo.sharedOne(cr.table, [r, o]); i.fold(function () { l.clear(c) }, n) }; const d = jv.mouse(a, c, s, l); const m = jv.keyboard(a, c, s, l); const g = jv.external(a, c, s, l); const p = function (e) { return !0 === e.raw().shiftKey }; e.on('TableSelectorChange', function (e) { g(e.start, e.finish) }); const v = function (t, n) { p(t) && (n.kill() && t.kill(), n.selection().each(function (t) { const n = wg.relative(t.start(), t.finish()); const r = Mg(a, n); e.selection.setRng(r) })) }; const b = function (t) { const n = gm(t); if (n.raw().shiftKey && Bv.isNavigation(n.raw().which)) { const r = e.selection.getRng(); const o = Me.fromDom(r.startContainer); const i = Me.fromDom(r.endContainer); m.keyup(n, o, r.startOffset, i, r.endOffset).each(function (e) { v(n, e) }) } }; const y = function (t) { const n = gm(t); r().each(function (e) { e.hideBars() }); const o = e.selection.getRng(); const i = Me.fromDom(e.selection.getStart()); const u = Me.fromDom(o.startContainer); const a = Me.fromDom(o.endContainer); const c = Jl.directionAt(i).isRtl() ? Bv.rtl : Bv.ltr; m.keydown(n, u, o.startOffset, a, o.endOffset, c).each(function (e) { v(n, e) }), r().each(function (e) { e.showBars() }) }; const w = function (e) { return e.button === 0 }; const x = function (e) { return void 0 === e.buttons || (!(!kd.browser.isEdge() || e.buttons !== 0) || (1 & e.buttons) !== 0) }; const C = function (e) { w(e) && eb(e) && d.mousedown(gm(e)) }; const S = function (e) { x(e) && eb(e) && d.mouseover(gm(e)) }; const k = function (e) { w(e) && eb(e) && d.mouseup(gm(e)) }; const T = function () { const e = t(Me.fromDom(c)); const n = t(0); const r = function (t) { const r = Me.fromDom(t.target); if (se(r) === 'td' || se(r) === 'th') { const o = e.get(); const i = n.get(); Gt(o, r) && t.timeStamp - i < 300 && (t.preventDefault(), g(r, r)) }e.set(r), n.set(t.timeStamp) }; return { touchEnd: r } }; const E = T(); e.on('mousedown', C), e.on('mouseover', S), e.on('mouseup', k), e.on('touchend', E.touchEnd), e.on('keyup', b), e.on('keydown', y), e.on('NodeChange', f), u = h.some(i({ mousedown: C, mouseover: S, mouseup: k, keyup: b, keydown: y })) }); const f = function () { u.each(function (e) {}) }; return { clear: l.clear, destroy: f } } const nb = function (e) { const t = function () { const t = Fl(e); return ci.retrieve(t, pi.selectedSelector()).fold(function () { return void 0 === e.selection.getStart() ? xi.none() : xi.single(e.selection) }, function (e) { return xi.multiple(e) }) }; return { get: t } }; const rb = function (e, n) { const r = t(h.none()); const o = t([]); const i = function () { return Yd(e).bind(function (e) { const t = cr.table(e); return t.map(function (t) { return se(e) === 'caption' ? Ai.notCell(e) : Ai.forMenu(n, t, e) }) }) }; const u = function () { r.set(Ne(i)()), A(o.get(), function (e) { return e() }) }; const a = function (e, t) { const n = function () { return r.get().fold(function () { e.setDisabled(!0) }, function (n) { e.setDisabled(t(n)) }) }; return n(), o.set(o.get().concat([n])), function () { o.set(B(o.get(), function (e) { return e !== n })) } }; const c = function (e) { return a(e, function (e) { return !1 }) }; const s = function (e) { return a(e, function (e) { return se(e.element()) === 'caption' }) }; const l = function (e) { return a(e, function (e) { return e.mergable().isNone() }) }; const f = function (e) { return a(e, function (e) { return e.unmergable().isNone() }) }; return e.on('NodeChange TableSelectorChange', u), { onSetupTable: c, onSetupCellOrRow: s, onSetupMergeable: l, onSetupUnmergeable: f, resetTargets: u, targets () { return r.get() } } }; const ob = function (e, t) { e.ui.registry.addMenuButton('table', { tooltip: 'Table', icon: 'table', fetch (e) { return e('inserttable | cell row column | advtablesort | tableprops deletetable') } }); const n = function (t) { return function () { return e.execCommand(t) } }; e.ui.registry.addButton('tableprops', { tooltip: 'Table properties', onAction: n('mceTableProps'), icon: 'table', onSetup: t.onSetupTable }), e.ui.registry.addButton('tabledelete', { tooltip: 'Delete table', onAction: n('mceTableDelete'), icon: 'table-delete-table', onSetup: t.onSetupTable }), e.ui.registry.addButton('tablecellprops', { tooltip: 'Cell properties', onAction: n('mceTableCellProps'), icon: 'table-cell-properties', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablemergecells', { tooltip: 'Merge cells', onAction: n('mceTableMergeCells'), icon: 'table-merge-cells', onSetup: t.onSetupMergeable }), e.ui.registry.addButton('tablesplitcells', { tooltip: 'Split cell', onAction: n('mceTableSplitCells'), icon: 'table-split-cells', onSetup: t.onSetupUnmergeable }), e.ui.registry.addButton('tableinsertrowbefore', { tooltip: 'Insert row before', onAction: n('mceTableInsertRowBefore'), icon: 'table-insert-row-above', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tableinsertrowafter', { tooltip: 'Insert row after', onAction: n('mceTableInsertRowAfter'), icon: 'table-insert-row-after', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tabledeleterow', { tooltip: 'Delete row', onAction: n('mceTableDeleteRow'), icon: 'table-delete-row', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablerowprops', { tooltip: 'Row properties', onAction: n('mceTableRowProps'), icon: 'table-row-properties', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tableinsertcolbefore', { tooltip: 'Insert column before', onAction: n('mceTableInsertColBefore'), icon: 'table-insert-column-before', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tableinsertcolafter', { tooltip: 'Insert column after', onAction: n('mceTableInsertColAfter'), icon: 'table-insert-column-after', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tabledeletecol', { tooltip: 'Delete column', onAction: n('mceTableDeleteCol'), icon: 'table-delete-column', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablecutrow', { tooltip: 'Cut row', onAction: n('mceTableCutRow'), icon: 'temporary-placeholder', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablecopyrow', { tooltip: 'Copy row', onAction: n('mceTableCopyRow'), icon: 'temporary-placeholder', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablepasterowbefore', { tooltip: 'Paste row before', onAction: n('mceTablePasteRowBefore'), icon: 'temporary-placeholder', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tablepasterowafter', { tooltip: 'Paste row after', onAction: n('mceTablePasteRowAfter'), icon: 'temporary-placeholder', onSetup: t.onSetupCellOrRow }), e.ui.registry.addButton('tableinsertdialog', { tooltip: 'Insert table', onAction: n('mceInsertTable'), icon: 'table' }) }; const ib = function (e) { const t = function (t) { return e.dom.is(t, 'table') && e.getBody().contains(t) }; const n = vf(e); n.length > 0 && e.ui.registry.addContextToolbar('table', { predicate: t, items: n, scope: 'node', position: 'node' }) }; const ub = { addButtons: ob, addToolbars: ib }; const ab = function (e, t) { const n = function (t) { return function () { return e.execCommand(t) } }; const r = function (t) { const n = t.numRows; const r = t.numColumns; e.undoManager.transact(function () { Hd.insert(e, r, n) }), e.addVisual() }; const o = { text: 'Table properties', onSetup: t.onSetupTable, onAction: n('mceTableProps') }; const i = { text: 'Delete table', icon: 'table-delete-table', onSetup: t.onSetupTable, onAction: n('mceTableDelete') }; const u = [{ type: 'menuitem', text: 'Insert row before', icon: 'table-insert-row-above', onAction: n('mceTableInsertRowBefore'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Insert row after', icon: 'table-insert-row-after', onAction: n('mceTableInsertRowAfter'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Delete row', icon: 'table-delete-row', onAction: n('mceTableDeleteRow'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Row properties', icon: 'table-row-properties', onAction: n('mceTableRowProps'), onSetup: t.onSetupCellOrRow }, { type: 'separator' }, { type: 'menuitem', text: 'Cut row', onAction: n('mceTableCutRow'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Copy row', onAction: n('mceTableCopyRow'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Paste row before', onAction: n('mceTablePasteRowBefore'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Paste row after', onAction: n('mceTablePasteRowAfter'), onSetup: t.onSetupCellOrRow }]; const a = { type: 'nestedmenuitem', text: 'Row', getSubmenuItems () { return u } }; const c = [{ type: 'menuitem', text: 'Insert column before', icon: 'table-insert-column-before', onAction: n('mceTableInsertColBefore'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Insert column after', icon: 'table-insert-column-after', onAction: n('mceTableInsertColAfter'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Delete column', icon: 'table-delete-column', onAction: n('mceTableDeleteCol'), onSetup: t.onSetupCellOrRow }]; const s = { type: 'nestedmenuitem', text: 'Column', getSubmenuItems () { return c } }; const l = [{ type: 'menuitem', text: 'Cell properties', icon: 'table-cell-properties', onAction: n('mceTableCellProps'), onSetup: t.onSetupCellOrRow }, { type: 'menuitem', text: 'Merge cells', icon: 'table-merge-cells', onAction: n('mceTableMergeCells'), onSetup: t.onSetupMergeable }, { type: 'menuitem', text: 'Split cell', icon: 'table-split-cells', onAction: n('mceTableSplitCells'), onSetup: t.onSetupUnmergeable }]; const f = { type: 'nestedmenuitem', text: 'Cell', getSubmenuItems () { return l } }; !1 === lf(e) ? e.ui.registry.addMenuItem('inserttable', { text: 'Table', icon: 'table', onAction: n('mceInsertTable') }) : e.ui.registry.addNestedMenuItem('inserttable', { text: 'Table', icon: 'table', getSubmenuItems () { return [{ type: 'fancymenuitem', fancytype: 'inserttable', onAction: r }] } }), e.ui.registry.addMenuItem('inserttabledialog', { text: 'Insert table', icon: 'table', onAction: n('mceInsertTable') }), e.ui.registry.addMenuItem('tableprops', o), e.ui.registry.addMenuItem('deletetable', i), e.ui.registry.addNestedMenuItem('row', a), e.ui.registry.addNestedMenuItem('column', s), e.ui.registry.addNestedMenuItem('cell', f), e.ui.registry.addContextMenu('table', { update () { return t.resetTargets(), t.targets().fold(function () { return '' }, function (e) { return se(e.element()) === 'caption' ? 'tableprops deletetable' : 'cell row column | advtablesort | tableprops deletetable' }) } }) }; const cb = { addMenuItems: ab }; const sb = function (e) { return e.get().fold(function () {}, function (e) { return D(e, function (e) { return e.dom() }) }) }; const lb = function (e, t) { const n = D(e, Me.fromDom); t.set(h.from(n)) }; const fb = function (e, t, n, r) { return { insertTable (t, n) { return Hd.insert(e, t, n) }, setClipboardRows (e) { return lb(e, t) }, getClipboardRows () { return sb(t) }, resizeHandler: n, selectionTargets: r } }; function db (e) { const n = nb(e); const r = rb(e, n); const o = Ym(e); const i = tb(e, o.lazyResize, r); const u = Bf(e, o.lazyWire); const a = t(h.none()); return Zd.registerCommands(e, u, i, n, a), zi.registerEvents(e, n, u, i), cb.addMenuItems(e, r), ub.addButtons(e, r), ub.addToolbars(e), e.on('PreInit', function () { e.serializer.addTempAttr(pi.firstSelected()), e.serializer.addTempAttr(pi.lastSelected()) }), of(e) && e.on('keydown', function (t) { Dh.handle(t, e, u, o.lazyWire) }), e.on('remove', function () { o.destroy(), i.destroy() }), fb(e, a, o, r) } function mb () { p.add('table', db) }mb() })(window) }, '9dd9' (e, t) { (function (e) { 'use strict'; var t = function (e) { let n = e; const r = function () { return n }; const o = function (e) { n = e }; const i = function () { return t(r()) }; return { get: r, set: o, clone: i } }; const n = tinymce.util.Tools.resolve('tinymce.PluginManager'); const r = tinymce.util.Tools.resolve('tinymce.util.Tools'); const o = function () {}; const i = function (e) { return function () { return e } }; const u = i(!1); const a = i(!0); const c = function () { return s }; var s = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const r = { fold (e, t) { return e() }, is: u, isSome: u, isNone: a, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: i(null), getOrUndefined: i(void 0), or: n, orThunk: t, map: c, each: o, bind: c, exists: u, forall: a, filter: c, equals: e, equals_: e, toArray () { return [] }, toString: i('none()') }; return Object.freeze && Object.freeze(r), r }()); var l = function (e) { const t = i(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: a, isNone: u, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return l(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : s }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(u, function (t) { return n(e, t) }) } }; return o }; const f = function (e) { return e === null || void 0 === e ? s : l(e) }; const d = { some: l, none: c, from: f }; function m (t, n) { return p(e.document.createElement('canvas'), t, n) } function g (e) { const t = m(e.width, e.height); const n = h(t); return n.drawImage(e, 0, 0), t } function h (e) { return e.getContext('2d') } function p (e, t, n) { return e.width = t, e.height = n, e } function v (e) { return e.naturalWidth || e.width } function b (e) { return e.naturalHeight || e.height } const y = function () { const t = function (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = null, this._value = null, this._deferreds = [], l(e, r(u, this), r(a, this)) }; const n = t.immediateFn || typeof window.setImmediate === 'function' && window.setImmediate || function (t) { e.setTimeout(t, 1) }; function r (e, t) { return function () { return e.apply(t, arguments) } } const o = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]' }; function i (e) { const t = this; this._state !== null ? n(function () { const n = t._state ? e.onFulfilled : e.onRejected; if (n !== null) { let r; try { r = n(t._value) } catch (o) { return void e.reject(o) }e.resolve(r) } else { (t._state ? e.resolve : e.reject)(t._value) } }) : this._deferreds.push(e) } function u (e) { try { if (e === this) { throw new TypeError('A promise cannot be resolved with itself.') } if (e && (typeof e === 'object' || typeof e === 'function')) { const t = e.then; if (typeof t === 'function') { return void l(r(t, e), r(u, this), r(a, this)) } } this._state = !0, this._value = e, c.call(this) } catch (n) { a.call(this, n) } } function a (e) { this._state = !1, this._value = e, c.call(this) } function c () { for (let e = 0, t = this._deferreds; e < t.length; e++) { const n = t[e]; i.call(this, n) } this._deferreds = [] } function s (e, t, n, r) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.resolve = n, this.reject = r } function l (e, t, n) { let r = !1; try { e(function (e) { r || (r = !0, t(e)) }, function (e) { r || (r = !0, n(e)) }) } catch (o) { if (r) { return } r = !0, n(o) } } return t.prototype.catch = function (e) { return this.then(null, e) }, t.prototype.then = function (e, n) { const r = this; return new t(function (t, o) { i.call(r, new s(e, n, t, o)) }) }, t.all = function () { for (var e = [], n = 0; n < arguments.length; n++) { e[n] = arguments[n] } const r = Array.prototype.slice.call(e.length === 1 && o(e[0]) ? e[0] : e); return new t(function (e, t) { if (r.length === 0) { return e([]) } let n = r.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, t) } }r[i] = u, --n === 0 && e(r) } catch (c) { t(c) } } for (let i = 0; i < r.length; i++) { o(i, r[i]) } }) }, t.resolve = function (e) { return e && typeof e === 'object' && e.constructor === t ? e : new t(function (t) { t(e) }) }, t.reject = function (e) { return new t(function (t, n) { n(e) }) }, t.race = function (e) { return new t(function (t, n) { for (let r = 0, o = e; r < o.length; r++) { const i = o[r]; i.then(t, n) } }) }, t }; const w = window.Promise ? window.Promise : y(); function x (e) { const t = e.src; return t.indexOf('data:') === 0 ? T(t) : S(t) } function C (t) { return new w(function (n, r) { const o = e.URL.createObjectURL(t); const i = new e.Image(); const u = function () { i.removeEventListener('load', a), i.removeEventListener('error', c) }; function a () { u(), n(i) } function c () { u(), r('Unable to load data of type ' + t.type + ': ' + o) }i.addEventListener('load', a), i.addEventListener('error', c), i.src = o, i.complete && a() }) } function S (t) { return new w(function (n, r) { const o = new e.XMLHttpRequest(); o.open('GET', t, !0), o.responseType = 'blob', o.onload = function () { this.status === 200 && n(this.response) }, o.onerror = function () { const e = this; const t = function () { const e = new Error('No access to download image'); return e.code = 18, e.name = 'SecurityError', e }; const n = function () { return new Error('Error ' + e.status + ' downloading image') }; r(this.status === 0 ? t() : n()) }, o.send() }) } function k (t) { const n = t.split(','); const r = /data:([^;]+)/.exec(n[0]); if (!r) { return d.none() } for (var o = r[1], i = n[1], u = 1024, a = e.atob(i), c = a.length, s = Math.ceil(c / u), l = new Array(s), f = 0; f < s; ++f) { for (var m = f * u, g = Math.min(m + u, c), h = new Array(g - m), p = m, v = 0; p < g; ++v, ++p) { h[v] = a[p].charCodeAt(0) }l[f] = new Uint8Array(h) } return d.some(new e.Blob(l, { type: o })) } function T (e) { return new w(function (t, n) { k(e).fold(function () { n('uri is not base64: ' + e) }, t) }) } function E (t, n, r) { return n = n || 'image/png', e.HTMLCanvasElement.prototype.toBlob ? new w(function (e, o) { t.toBlob(function (t) { t ? e(t) : o() }, n, r) }) : T(t.toDataURL(n, r)) } function O (e, t, n) { return t = t || 'image/png', e.toDataURL(t, n) } function N (e) { return C(e).then(function (e) { D(e); const t = m(v(e), b(e)); const n = h(t); return n.drawImage(e, 0, 0), t }) } function _ (t) { return new w(function (n) { const r = new e.FileReader(); r.onloadend = function () { n(r.result) }, r.readAsDataURL(t) }) } function D (t) { e.URL.revokeObjectURL(t.src) } const A = function (e) { return C(e) }; const R = function (e) { return x(e) }; function B (e, t, n) { const r = t.type; const o = i(r); function u () { return w.resolve(t) } function a () { return n } function c () { return n.split(',')[1] } function s (t, n) { return e.then(function (e) { return E(e, t, n) }) } function l (t, n) { return e.then(function (e) { return O(e, t, n) }) } function f (e, t) { return l(e, t).then(function (e) { return e.split(',')[1] }) } function d () { return e.then(g) } return { getType: o, toBlob: u, toDataURL: a, toBase64: c, toAdjustedBlob: s, toAdjustedDataURL: l, toAdjustedBase64: f, toCanvas: d } } function M (e) { return _(e).then(function (t) { return B(N(e), e, t) }) } function P (e, t) { return E(e, t).then(function (t) { return B(w.resolve(e), t, e.toDataURL()) }) } function z (e, t) { return e.toCanvas().then(function (n) { return I(n, e.getType(), t) }) } function I (e, t, n) { const r = m(e.width, e.height); const o = h(r); let i = 0; let u = 0; return n = n < 0 ? 360 + n : n, n !== 90 && n !== 270 || p(r, r.height, r.width), n !== 90 && n !== 180 || (i = r.width), n !== 270 && n !== 180 || (u = r.height), o.translate(i, u), o.rotate(n * Math.PI / 180), o.drawImage(e, 0, 0), P(r, t) } function L (e, t) { return e.toCanvas().then(function (n) { return H(n, e.getType(), t) }) } function H (e, t, n) { const r = m(e.width, e.height); const o = h(r); return n === 'v' ? (o.scale(1, -1), o.drawImage(e, 0, -r.height)) : (o.scale(-1, 1), o.drawImage(e, -r.width, 0)), P(r, t) } const F = function (e, t) { return L(e, t) }; const V = function (e, t) { return z(e, t) }; const U = function (e) { return M(e) }; const j = tinymce.util.Tools.resolve('tinymce.util.Delay'); const W = tinymce.util.Tools.resolve('tinymce.util.Promise'); const q = tinymce.util.Tools.resolve('tinymce.util.URI'); const $ = function (e) { return e.getParam('imagetools_toolbar', 'rotateleft rotateright flipv fliph editimage imageoptions') }; const G = function (e) { return e.getParam('imagetools_proxy') }; const X = function (e) { return e.getParam('imagetools_cors_hosts', [], 'string[]') }; const Y = function (e) { return e.getParam('imagetools_credentials_hosts', [], 'string[]') }; const K = function (e) { return d.from(e.getParam('imagetools_fetch_image', null, 'function')) }; const J = function (e) { return e.getParam('api_key', e.getParam('imagetools_api_key', '', 'string'), 'string') }; const Z = function (e) { return e.getParam('images_upload_timeout', 3e4, 'number') }; const Q = function (e) { return e.getParam('images_reuse_filename', !1, 'boolean') }; function ee (e) { let t, n; function r (e) { return /^[0-9\.]+px$/.test(e) } return t = e.style.width, n = e.style.height, t || n ? r(t) && r(n) ? { w: parseInt(t, 10), h: parseInt(n, 10) } : null : (t = e.width, n = e.height, t && n ? { w: parseInt(t, 10), h: parseInt(n, 10) } : null) } function te (e, t) { let n, r; t && (n = e.style.width, r = e.style.height, (n || r) && (e.style.width = t.w + 'px', e.style.height = t.h + 'px', e.removeAttribute('data-mce-style')), n = e.width, r = e.height, (n || r) && (e.setAttribute('width', t.w), e.setAttribute('height', t.h))) } function ne (e) { return { w: e.naturalWidth, h: e.naturalHeight } } const re = { getImageSize: ee, setImageSize: te, getNaturalImageSize: ne }; const oe = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const ie = function (e) { return function (t) { return oe(t) === e } }; const ue = ie('function'); const ae = Array.prototype.slice; const ce = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return d.some(o) } } return d.none() }; const se = (ue(Array.from) && Array.from, function (e) { return e !== null && void 0 !== e }); const le = function (e, t) { let n; return n = t.reduce(function (e, t) { return se(e) ? e[t] : void 0 }, e), se(n) ? n : null }; const fe = function (t, n, o) { return new W(function (i) { let u; u = new e.XMLHttpRequest(), u.onreadystatechange = function () { u.readyState === 4 && i({ status: u.status, blob: this.response }) }, u.open('GET', t, !0), u.withCredentials = o, r.each(n, function (e, t) { u.setRequestHeader(t, e) }), u.responseType = 'blob', u.send() }) }; const de = function (t) { return new W(function (n) { const r = new e.FileReader(); r.onload = function (e) { const t = e.target; n(t.result) }, r.readAsText(t) }) }; const me = function (e) { let t; try { t = JSON.parse(e) } catch (n) {} return t }; const ge = { traverse: le, readBlob: de, requestUrlAsBlob: fe, parseJson: me }; const he = [{ code: 404, message: 'Could not find Image Proxy' }, { code: 403, message: 'Rejected request' }, { code: 0, message: 'Incorrect Image Proxy URL' }]; const pe = [{ type: 'key_missing', message: 'The request did not include an api key.' }, { type: 'key_not_found', message: 'The provided api key could not be found.' }, { type: 'domain_not_trusted', message: 'The api key is not valid for the request origins.' }]; const ve = function (e) { return e === 400 || e === 403 || e === 500 }; const be = function (e) { const t = ce(he, function (t) { return e === t.code }).fold(i('Unknown ImageProxy error'), function (e) { return e.message }); return 'ImageProxy HTTP error: ' + t }; const ye = function (e) { const t = be(e); return W.reject(t) }; const we = function (e) { return ce(pe, function (t) { return t.type === e }).fold(i('Unknown service error'), function (e) { return e.message }) }; const xe = function (e) { const t = ge.parseJson(e); const n = ge.traverse(t, ['error', 'type']); const r = n ? we(n) : 'Invalid JSON in service error message'; return 'ImageProxy Service error: ' + r }; const Ce = function (e, t) { return ge.readBlob(t).then(function (e) { const t = xe(e); return W.reject(t) }) }; const Se = function (e, t) { return ve(e) ? Ce(e, t) : ye(e) }; const ke = { handleServiceErrorResponse: Se, handleHttpError: ye, getHttpErrorMsg: be, getServiceErrorMsg: we }; const Te = function (e, t) { const n = !e.includes('?') ? '?' : '&'; return /[?&]apiKey=/.test(e) || !t ? e : e + n + 'apiKey=' + encodeURIComponent(t) }; const Ee = function (e, t) { const n = { 'Content-Type': 'application/json;charset=UTF-8', 'tiny-api-key': t }; return ge.requestUrlAsBlob(Te(e, t), n, !1).then(function (e) { return e.status < 200 || e.status >= 300 ? ke.handleServiceErrorResponse(e.status, e.blob) : W.resolve(e.blob) }) }; function Oe (e, t) { return ge.requestUrlAsBlob(e, {}, t).then(function (e) { return e.status < 200 || e.status >= 300 ? ke.handleHttpError(e.status) : W.resolve(e.blob) }) } const Ne = function (e, t, n) { return t ? Ee(e, t) : Oe(e, n) }; const _e = function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }; const De = function (t, n) { return _e(t, n, e.Node.DOCUMENT_POSITION_PRECEDING) }; const Ae = function (t, n) { return _e(t, n, e.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const Re = { documentPositionPreceding: De, documentPositionContainedBy: Ae }; const Be = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const Me = function (e, t) { const n = Be(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return Ie(r(1), r(2)) }; const Pe = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? ze() : Me(e, n) }; var ze = function () { return Ie(0, 0) }; var Ie = function (e, t) { return { major: e, minor: t } }; const Le = { nu: Ie, detect: Pe, unknown: ze }; const He = 'Edge'; const Fe = 'Chrome'; const Ve = 'IE'; const Ue = 'Opera'; const je = 'Firefox'; const We = 'Safari'; const qe = function (e, t) { return function () { return t === e } }; const $e = function () { return Ge({ current: void 0, version: Le.unknown() }) }; var Ge = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: qe(He, t), isChrome: qe(Fe, t), isIE: qe(Ve, t), isOpera: qe(Ue, t), isFirefox: qe(je, t), isSafari: qe(We, t) } }; const Xe = { unknown: $e, nu: Ge, edge: i(He), chrome: i(Fe), ie: i(Ve), opera: i(Ue), firefox: i(je), safari: i(We) }; const Ye = 'Windows'; const Ke = 'iOS'; const Je = 'Android'; const Ze = 'Linux'; const Qe = 'OSX'; const et = 'Solaris'; const tt = 'FreeBSD'; const nt = 'ChromeOS'; const rt = function (e, t) { return function () { return t === e } }; const ot = function () { return it({ current: void 0, version: Le.unknown() }) }; var it = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: rt(Ye, t), isiOS: rt(Ke, t), isAndroid: rt(Je, t), isOSX: rt(Qe, t), isLinux: rt(Ze, t), isSolaris: rt(et, t), isFreeBSD: rt(tt, t), isChromeOS: rt(nt, t) } }; const ut = { unknown: ot, nu: it, windows: i(Ye), ios: i(Ke), android: i(Je), linux: i(Ze), osx: i(Qe), solaris: i(et), freebsd: i(tt), chromeos: i(nt) }; const at = function (e, t, n, r) { const o = e.isiOS() && !0 === /ipad/i.test(n); const u = e.isiOS() && !o; const a = e.isiOS() || e.isAndroid(); const c = a || r('(pointer:coarse)'); const s = o || !u && a && r('(min-device-width:768px)'); const l = u || a && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: i(o), isiPhone: i(u), isTablet: i(s), isPhone: i(l), isTouch: i(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: i(f), isDesktop: i(d) } }; const ct = function (e, t) { const n = String(t).toLowerCase(); return ce(e, function (e) { return e.search(n) }) }; const st = function (e, t) { return ct(e, t).map(function (e) { const n = Le.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const lt = function (e, t) { return ct(e, t).map(function (e) { const n = Le.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const ft = { detectBrowser: st, detectOs: lt }; const dt = function (e, t) { return e.includes(t) }; const mt = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const gt = function (e) { return function (t) { return dt(t, e) } }; const ht = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return dt(e, 'edge/') && dt(e, 'chrome') && dt(e, 'safari') && dt(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, mt], search (e) { return dt(e, 'chrome') && !dt(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return dt(e, 'msie') || dt(e, 'trident') } }, { name: 'Opera', versionRegexes: [mt, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: gt('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: gt('firefox') }, { name: 'Safari', versionRegexes: [mt, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (dt(e, 'safari') || dt(e, 'mobile/')) && dt(e, 'applewebkit') } }]; const pt = [{ name: 'Windows', search: gt('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return dt(e, 'iphone') || dt(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: gt('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: gt('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: gt('linux'), versionRegexes: [] }, { name: 'Solaris', search: gt('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: gt('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: gt('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const vt = { browsers: i(ht), oses: i(pt) }; const bt = function (e, t) { const n = vt.browsers(); const r = vt.oses(); const o = ft.detectBrowser(n, e).fold(Xe.unknown, Xe.nu); const i = ft.detectOs(r, e).fold(ut.unknown, ut.nu); const u = at(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const yt = { detect: bt }; const wt = function (t) { return e.window.matchMedia(t).matches }; const xt = t(yt.detect(e.navigator.userAgent, wt)); const Ct = function () { return xt.get() }; const St = function (t, n) { const r = n || e.document; const o = r.createElement('div'); if (o.innerHTML = t, !o.hasChildNodes() || o.childNodes.length > 1) { throw e.console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node') } return Et(o.childNodes[0]) }; const kt = function (t, n) { const r = n || e.document; const o = r.createElement(t); return Et(o) }; const Tt = function (t, n) { const r = n || e.document; const o = r.createTextNode(t); return Et(o) }; var Et = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: i(e) } }; const Ot = function (e, t, n) { const r = e.dom(); return d.from(r.elementFromPoint(t, n)).map(Et) }; const Nt = { fromHtml: St, fromTag: kt, fromText: Tt, fromDom: Et, fromPoint: Ot }; const _t = (e.Node.ATTRIBUTE_NODE, e.Node.CDATA_SECTION_NODE, e.Node.COMMENT_NODE, e.Node.DOCUMENT_NODE, e.Node.DOCUMENT_TYPE_NODE, e.Node.DOCUMENT_FRAGMENT_NODE, e.Node.ELEMENT_NODE); const Dt = (e.Node.TEXT_NODE, e.Node.PROCESSING_INSTRUCTION_NODE, e.Node.ENTITY_REFERENCE_NODE, e.Node.ENTITY_NODE, e.Node.NOTATION_NODE, _t); const At = function (e, t) { const n = e.dom(); if (n.nodeType !== Dt) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const Rt = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const Bt = function (e, t) { return Re.documentPositionContainedBy(e.dom(), t.dom()) }; const Mt = Ct().browser; const Pt = (Mt.isIE(), typeof e.window !== 'undefined' ? e.window : Function('return this;')(), function (e, t) { const n = function (e) { return t(Nt.fromDom(e)) }; const r = ce(e.dom().childNodes, n); return r.map(Nt.fromDom) }); const zt = function (e, t) { return Pt(e, function (e) { return At(e, t) }) }; let It = 0; const Lt = function (e) { return zt(Nt.fromDom(e), 'img') }; const Ht = function (e, t) { return e.dom.is(t, 'figure') }; const Ft = function (e, t) { const n = function (t) { return e.dom.is(t, 'img:not([data-mce-object],[data-mce-placeholder])') }; const r = function (t) { return n(t) && (qt(e, t) || $t(e, t) || e.settings.imagetools_proxy) }; if (Ht(e, t)) { const o = Lt(t); return o.map(function (e) { return r(e.dom()) ? d.some(e.dom()) : d.none() }) } return r(t) ? d.some(t) : d.none() }; const Vt = function (e, t) { e.notificationManager.open({ text: t, type: 'error' }) }; const Ut = function (e) { const t = e.selection.getNode(); return Ht(e, t) ? Lt(t) : d.some(Nt.fromDom(t)) }; const jt = function (e, t) { const n = t.match(/\/([^\/\?]+)?\.(?:jpeg|jpg|png|gif)(?:\?|$)/i); return n ? e.dom.encode(n[1]) : null }; const Wt = function () { return 'imagetools' + It++ }; var qt = function (e, t) { const n = t.src; return n.indexOf('data:') === 0 || n.indexOf('blob:') === 0 || new q(n).host === e.documentBaseURI.host }; var $t = function (e, t) { return r.inArray(X(e), new q(t.src).host) !== -1 }; const Gt = function (e, t) { return r.inArray(Y(e), new q(t.src).host) !== -1 }; const Xt = function (e, t) { let n; let r = t.src; return $t(e, t) ? Ne(t.src, null, Gt(e, t)) : qt(e, t) ? R(t) : (r = G(e), r += (!r.includes('?') ? '?' : '&') + 'url=' + encodeURIComponent(t.src), n = J(e), Ne(r, n, !1)) }; const Yt = function (e, t) { return K(e).fold(function () { return Xt(e, t) }, function (e) { return e(t) }) }; const Kt = function (e, t) { let n; return n = e.editorUpload.blobCache.getByUri(t.src), n ? W.resolve(n.blob()) : Yt(e, t) }; const Jt = function (e, t) { const n = j.setEditorTimeout(e, function () { e.editorUpload.uploadImagesAuto() }, Z(e)); t.set(n) }; const Zt = function (e) { j.clearTimeout(e.get()) }; const Qt = function (e, t, n, r, o, i) { return t.toBlob().then(function (u) { let a, c, s, l; return s = e.editorUpload.blobCache, a = o.src, Q(e) && (l = s.getByUri(a), l ? (a = l.uri(), c = l.name()) : c = jt(e, a)), l = s.create({ id: Wt(), blob: u, base64: t.toBase64(), uri: a, name: c }), s.add(l), e.undoManager.transact(function () { function t () { e.$(o).off('load', t), e.nodeChanged(), n ? e.editorUpload.uploadImagesAuto() : (Zt(r), Jt(e, r)) }e.$(o).on('load', t), i && e.$(o).attr({ width: i.w, height: i.h }), e.$(o).attr({ src: l.blobUri() }).removeAttr('data-mce-src') }), l }) }; const en = function (e, t, n, r) { return function () { const o = Ut(e); return o.fold(function () { Vt(e, 'Could not find selected image') }, function (o) { return e._scanForImages().then(function () { return Kt(e, o.dom()) }).then(U).then(n).then(function (n) { return Qt(e, n, !1, t, o.dom(), r) }, function (t) { Vt(e, t) }) }) } }; const tn = function (e, t, n) { return function () { const r = Ut(e); const o = r.fold(function () { return null }, function (e) { const t = re.getImageSize(e.dom()); return t ? { w: t.h, h: t.w } : null }); return en(e, t, function (e) { return V(e, n) }, o)() } }; const nn = function (e, t, n) { return function () { return en(e, t, function (e) { return F(e, n) })() } }; const rn = function (t, n, r, o, i) { return new W(function (u) { A(i).then(function (t) { const n = re.getNaturalImageSize(t); return o.w === n.w && o.h === n.h || re.getImageSize(r) && re.setImageSize(r, n), e.URL.revokeObjectURL(t.src), i }).then(U).then(function (e) { return Qt(t, e, !0, n, r) }, function () {}) }) }; const on = { rotate: tn, flip: nn, getEditableImage: Ft, cancelTimedUpload: Zt, findBlob: Kt, getSelectedImage: Ut, handleDialogBlob: rn }; const un = i('save-state'); const an = i('disable'); const cn = i('enable'); const sn = function (t) { return { blob: t, url: e.URL.createObjectURL(t) } }; const ln = function (e, t) { return function () { const n = function (n) { return { title: 'Edit Image', size: 'large', body: { type: 'panel', items: [{ type: 'imagetools', name: 'imagetools', label: 'Edit Image', currentState: n }] }, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0, disabled: !0 }], onSubmit (n) { const i = n.getData().imagetools.blob; r.each(function (n) { o.each(function (r) { on.handleDialogBlob(e, t, n.dom(), r, i) }) }), n.close() }, onCancel () {}, onAction (e, t) { switch (t.name) { case un():t.value ? e.enable('save') : e.disable('save'); break; case an():e.disable('save'), e.disable('cancel'); break; case cn():e.enable('cancel'); break } } } }; var r = on.getSelectedImage(e); var o = r.map(function (e) { return re.getNaturalImageSize(e.dom()) }); const i = on.getSelectedImage(e); i.each(function (t) { on.getEditableImage(e, t.dom()).each(function (r) { on.findBlob(e, t.dom()).then(function (t) { const r = sn(t); e.windowManager.open(n(r)) }) }) }) } }; const fn = { makeOpen: ln }; const dn = function (e, t) { r.each({ mceImageRotateLeft: on.rotate(e, t, -90), mceImageRotateRight: on.rotate(e, t, 90), mceImageFlipVertical: on.flip(e, t, 'v'), mceImageFlipHorizontal: on.flip(e, t, 'h'), mceEditImage: fn.makeOpen(e, t) }, function (t, n) { e.addCommand(n, t) }) }; const mn = { register: dn }; const gn = function (e, t, n) { e.on('NodeChange', function (r) { const o = n.get(); o && o.src !== r.element.src && (on.cancelTimedUpload(t), e.editorUpload.uploadImagesAuto(), n.set(null)), on.getEditableImage(e, r.element).each(n.set) }) }; const hn = { setup: gn }; const pn = function (e) { const t = function (t) { return function () { return e.execCommand(t) } }; e.ui.registry.addButton('rotateleft', { tooltip: 'Rotate counterclockwise', icon: 'rotate-left', onAction: t('mceImageRotateLeft') }), e.ui.registry.addButton('rotateright', { tooltip: 'Rotate clockwise', icon: 'rotate-right', onAction: t('mceImageRotateRight') }), e.ui.registry.addButton('flipv', { tooltip: 'Flip vertically', icon: 'flip-vertically', onAction: t('mceImageFlipVertical') }), e.ui.registry.addButton('fliph', { tooltip: 'Flip horizontally', icon: 'flip-horizontally', onAction: t('mceImageFlipHorizontal') }), e.ui.registry.addButton('editimage', { tooltip: 'Edit image', icon: 'edit-image', onAction: t('mceEditImage'), onSetup (t) { const n = function () { const n = on.getSelectedImage(e); n.each(function (n) { const r = on.getEditableImage(e, n.dom()).isNone(); t.setDisabled(r) }) }; return e.on('NodeChange', n), function () { e.off('NodeChange', n) } } }), e.ui.registry.addButton('imageoptions', { tooltip: 'Image options', icon: 'image-options', onAction: t('mceImage') }), e.ui.registry.addContextMenu('imagetools', { update (n) { return on.getEditableImage(e, n).fold(function () { return [] }, function (e) { return [{ text: 'Edit image', icon: 'edit-image', onAction: t('mceEditImage') }] }) } }) }; const vn = { register: pn }; const bn = function (e) { e.ui.registry.addContextToolbar('imagetools', { items: $(e), predicate (t) { return on.getEditableImage(e, t).isSome() }, position: 'node', scope: 'node' }) }; const yn = { register: bn }; function wn () { n.add('imagetools', function (e) { const n = t(0); const r = t(null); mn.register(e, n), vn.register(e), yn.register(e), hn.setup(e, n, r) }) }wn() })(window) }, a376 (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = function (e) { return e.getParam('insertdatetime_dateformat', e.translate('%Y-%m-%d')) }; const n = function (e) { return e.getParam('insertdatetime_timeformat', e.translate('%H:%M:%S')) }; const r = function (e) { return e.getParam('insertdatetime_formats', ['%H:%M:%S', '%Y-%m-%d', '%I:%M:%S %p', '%D']) }; const o = function (e) { const t = r(e); return t.length > 0 ? t[0] : n(e) }; const i = function (e) { return e.getParam('insertdatetime_element', !1) }; const u = { getDateFormat: t, getTimeFormat: n, getFormats: r, getDefaultDateTime: o, shouldInsertTimeElement: i }; const a = 'Sun Mon Tue Wed Thu Fri Sat Sun'.split(' '); const c = 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday'.split(' '); const s = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '); const l = 'January February March April May June July August September October November December'.split(' '); const f = function (e, t) { if (e = '' + e, e.length < t) { for (let n = 0; n < t - e.length; n++) { e = '0' + e } } return e }; const d = function (e, t, n) { return n = n || new Date(), t = t.replace('%D', '%m/%d/%Y'), t = t.replace('%r', '%I:%M:%S %p'), t = t.replace('%Y', '' + n.getFullYear()), t = t.replace('%y', '' + n.getYear()), t = t.replace('%m', f(n.getMonth() + 1, 2)), t = t.replace('%d', f(n.getDate(), 2)), t = t.replace('%H', '' + f(n.getHours(), 2)), t = t.replace('%M', '' + f(n.getMinutes(), 2)), t = t.replace('%S', '' + f(n.getSeconds(), 2)), t = t.replace('%I', '' + ((n.getHours() + 11) % 12 + 1)), t = t.replace('%p', n.getHours() < 12 ? 'AM' : 'PM'), t = t.replace('%B', '' + e.translate(l[n.getMonth()])), t = t.replace('%b', '' + e.translate(s[n.getMonth()])), t = t.replace('%A', '' + e.translate(c[n.getDay()])), t = t.replace('%a', '' + e.translate(a[n.getDay()])), t = t.replace('%%', '%'), t }; const m = function (e, t, n, r) { const o = e.dom.create('time', { datetime: n }, r); t.parentNode.insertBefore(o, t), e.dom.remove(t), e.selection.select(o, !0), e.selection.collapse(!1) }; const g = function (e, t) { if (u.shouldInsertTimeElement(e)) { const n = d(e, t); let r = void 0; r = /%[HMSIp]/.test(t) ? d(e, '%Y-%m-%dT%H:%M') : d(e, '%Y-%m-%d'); const o = e.dom.getParent(e.selection.getStart(), 'time'); o ? m(e, o, r, n) : e.insertContent('<time datetime="' + r + '">' + n + '</time>') } else { e.insertContent(d(e, t)) } }; const h = { insertDateTime: g, getDateTime: d }; const p = function (e) { e.addCommand('mceInsertDate', function () { h.insertDateTime(e, u.getDateFormat(e)) }), e.addCommand('mceInsertTime', function () { h.insertDateTime(e, u.getTimeFormat(e)) }) }; const v = { register: p }; const b = tinymce.util.Tools.resolve('tinymce.util.Tools'); var y = function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return y(n()) }; return { get: n, set: r, clone: o } }; const w = function (e) { const t = u.getFormats(e); const n = y(u.getDefaultDateTime(e)); e.ui.registry.addSplitButton('insertdatetime', { icon: 'insert-time', tooltip: 'Insert date/time', select (e) { return e === n.get() }, fetch (n) { n(b.map(t, function (t) { return { type: 'choiceitem', text: h.getDateTime(e, t), value: t } })) }, onAction () { for (let t = [], r = 0; r < arguments.length; r++) { t[r] = arguments[r] }h.insertDateTime(e, n.get()) }, onItemAction (t, r) { n.set(r), h.insertDateTime(e, r) } }); const r = function (t) { return function () { n.set(t), h.insertDateTime(e, t) } }; e.ui.registry.addNestedMenuItem('insertdatetime', { icon: 'insert-time', text: 'Date/time', getSubmenuItems () { return b.map(t, function (t) { return { type: 'menuitem', text: h.getDateTime(e, t), onAction: r(t) } }) } }) }; const x = { register: w }; function C () { e.add('insertdatetime', function (e) { v.register(e), x.register(e) }) }C() })() }, ae68 (e, t) { (function () { 'use strict'; var e = function (t) { let n = t; const r = function () { return n }; const o = function (e) { n = e }; const i = function () { return e(r()) }; return { get: r, set: o, clone: i } }; const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const n = tinymce.util.Tools.resolve('tinymce.Env'); const r = tinymce.util.Tools.resolve('tinymce.util.Delay'); const o = function (e) { return e.fire('ResizeEditor') }; const i = { fireResizeEditor: o }; const u = function (e) { return e.getParam('min_height', e.getElement().offsetHeight, 'number') }; const a = function (e) { return e.getParam('max_height', 0, 'number') }; const c = function (e) { return e.getParam('autoresize_overflow_padding', 1, 'number') }; const s = function (e) { return e.getParam('autoresize_bottom_margin', 50, 'number') }; const l = function (e) { return e.getParam('autoresize_on_init', !0, 'boolean') }; const f = { getAutoResizeMinHeight: u, getAutoResizeMaxHeight: a, getAutoResizeOverflowPadding: c, getAutoResizeBottomMargin: s, shouldAutoResizeOnInit: l }; const d = function (e) { return e.plugins.fullscreen && e.plugins.fullscreen.isFullscreen() }; var m = function (e, t, n, o, i) { r.setEditorTimeout(e, function () { p(e, t), n-- ? m(e, t, n, o, i) : i && i() }, o) }; const g = function (e, t) { const n = e.getBody(); n && (n.style.overflowY = t ? '' : 'hidden', t || (n.scrollTop = 0)) }; const h = function (e, t, n, r) { const o = parseInt(e.getStyle(t, n, r), 10); return isNaN(o) ? 0 : o }; var p = function (e, t) { let r; let o; let u; const a = e.dom; const c = e.getDoc(); if (c) { if (d(e)) { g(e, !0) } else { const s = c.documentElement; const l = f.getAutoResizeBottomMargin(e); o = f.getAutoResizeMinHeight(e); const m = h(a, s, 'margin-top', !0); const v = h(a, s, 'margin-bottom', !0); u = s.offsetHeight + m + v + l, u < 0 && (u = 0); const b = e.getContainer().offsetHeight; const y = e.getContentAreaContainer().offsetHeight; const w = b - y; u + w > f.getAutoResizeMinHeight(e) && (o = u + w); const x = f.getAutoResizeMaxHeight(e); if (x && o > x ? (o = x, g(e, !0)) : g(e, !1), o !== t.get()) { if (r = o - t.get(), a.setStyle(e.getContainer(), 'height', o + 'px'), t.set(o), i.fireResizeEditor(e), n.browser.isSafari() && n.mac) { const C = e.getWin(); C.scrollTo(C.pageXOffset, C.pageYOffset) }e.hasFocus() && e.selection.scrollIntoView(e.selection.getNode()), n.webkit && r < 0 && p(e, t) } } } }; const v = function (e, t) { e.on('init', function () { const t = f.getAutoResizeOverflowPadding(e); const n = e.dom; n.setStyles(e.getBody(), { paddingLeft: t, paddingRight: t, 'min-height': 0 }) }), e.on('NodeChange SetContent keyup FullscreenStateChanged ResizeContent', function () { p(e, t) }), f.shouldAutoResizeOnInit(e) && e.on('init', function () { m(e, t, 20, 100, function () { m(e, t, 5, 1e3) }) }) }; const b = { setup: v, resize: p }; const y = function (e, t) { e.addCommand('mceAutoResize', function () { b.resize(e, t) }) }; const w = { register: y }; function x () { t.add('autoresize', function (t) { if (t.settings.hasOwnProperty('resize') || (t.settings.resize = !1), !t.inline) { const n = e(0); w.register(t, n), b.setup(t, n) } }) }x() })() }, be7f (e, t, n) { (function (e) { (function (t) { 'use strict'; const n = tinymce.util.Tools.resolve('tinymce.PluginManager'); const r = tinymce.util.Tools.resolve('tinymce.util.VK'); const o = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const i = function (e) { return function (t) { return o(t) === e } }; const u = i('string'); const a = i('array'); const c = i('boolean'); const s = i('function'); const l = function (e) { const t = e.getParam('link_assume_external_targets', !1); return c(t) && t ? 1 : !u(t) || t !== 'http' && t !== 'https' ? 0 : t }; const f = function (e) { return e.getParam('link_context_toolbar', !1, 'boolean') }; const d = function (e) { return e.getParam('link_list') }; const m = function (e) { return e.getParam('default_link_target') }; const g = function (e) { return e.getParam('target_list', !0) }; const h = function (e) { return e.getParam('rel_list', [], 'array') }; const p = function (e) { return e.getParam('link_class_list', [], 'array') }; const v = function (e) { return e.getParam('link_title', !0, 'boolean') }; const b = function (e) { return e.getParam('allow_unsafe_link_target', !1, 'boolean') }; const y = function (e) { return e.getParam('link_quicklink', !1, 'boolean') }; const w = function (e) { return e.getParam('link_default_protocol', 'http', 'string') }; const x = { assumeExternalTargets: l, hasContextToolbar: f, getLinkList: d, getDefaultLinkTarget: m, getTargetList: g, getRelList: h, getLinkClassList: p, shouldShowLinkTitle: v, allowUnsafeLinkTarget: b, useQuickLink: y, getDefaultLinkProtocol: w }; const C = function (e, n) { t.document.body.appendChild(e), e.dispatchEvent(n), t.document.body.removeChild(e) }; const S = function (e) { const n = t.document.createElement('a'); n.target = '_blank', n.href = e, n.rel = 'noreferrer noopener'; const r = t.document.createEvent('MouseEvents'); r.initMouseEvent('click', !0, !0, t.window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), C(n, r) }; const k = { open: S }; var T = function () { return T = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, T.apply(this, arguments) }; const E = function () {}; const O = function (e) { return function () { return e } }; const N = O(!1); const _ = O(!0); const D = function () { return A }; var A = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const r = { fold (e, t) { return e() }, is: N, isSome: N, isNone: _, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: O(null), getOrUndefined: O(void 0), or: n, orThunk: t, map: D, each: E, bind: D, exists: N, forall: _, filter: D, equals: e, equals_: e, toArray () { return [] }, toString: O('none()') }; return Object.freeze && Object.freeze(r), r }()); var R = function (e) { const t = O(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: _, isNone: N, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return R(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : A }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(N, function (t) { return n(e, t) }) } }; return o }; const B = function (e) { return e === null || void 0 === e ? A : R(e) }; const M = { some: R, none: D, from: B }; const P = Array.prototype.slice; const z = Array.prototype.indexOf; const I = Array.prototype.push; const L = function (e, t) { return z.call(e, t) }; const H = function (e, t) { return L(e, t) > -1 }; const F = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const V = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const U = function (e, t, n) { return V(e, function (e) { n = t(n, e) }), n }; const j = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!a(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } I.apply(t, e[n]) } return t }; const W = function (e, t) { return j(F(e, t)) }; const q = (s(Array.from) && Array.from, function (e, t) { for (let n = 0; n < e.length; n++) { const r = t(e[n], n); if (r.isSome()) { return r } } return M.none() }); const $ = tinymce.util.Tools.resolve('tinymce.util.Tools'); const G = function (e) { return /^\w+:/i.test(e) }; const X = function (e) { const t = e.getAttribute('data-mce-href'); return t || e.getAttribute('href') }; const Y = function (e, t) { const n = ['noopener']; const r = e ? e.split(/\s+/) : []; const o = function (e) { return $.trim(e.sort().join(' ')) }; const i = function (e) { return e = u(e), e.length > 0 ? e.concat(n) : n }; var u = function (e) { return e.filter(function (e) { return $.inArray(n, e) === -1 }) }; const a = t ? i(r) : u(r); return a.length > 0 ? o(a) : '' }; const K = function (e) { return e.replace(/\uFEFF/g, '') }; const J = function (e, t) { return t = t || e.selection.getNode(), ne(t) ? e.dom.select('a[href]', t)[0] : e.dom.getParent(t, 'a[href]') }; const Z = function (e, t) { const n = t ? t.textContent || t.textContent : e.getContent({ format: 'text' }); return K(n) }; const Q = function (e) { return e && e.nodeName === 'A' && !!X(e) }; const ee = function (e) { return $.grep(e, Q).length > 0 }; const te = function (e) { return !(/</.test(e) && (!/^<a [^>]+>[^<]+<\/a>$/.test(e) || !e.includes('href='))) }; var ne = function (e) { return e && e.nodeName === 'FIGURE' && /\bimage\b/i.test(e.className) }; const re = function (e) { return U(['title', 'rel', 'class', 'target'], function (t, n) { return e[n].each(function (e) { t[n] = e.length > 0 ? e : null }), t }, { href: e.href }) }; const oe = function (e, t) { return t !== 'http' && t !== 'https' || G(e) ? e : t + '://' + e }; const ie = function (e, t) { const n = T({}, t); if (!(x.getRelList(e).length > 0) && !1 === x.allowUnsafeLinkTarget(e)) { const r = Y(n.rel, n.target === '_blank'); n.rel = r || null } return M.from(n.target).isNone() && !1 === x.getTargetList(e) && (n.target = x.getDefaultLinkTarget(e)), n.href = oe(n.href, x.assumeExternalTargets(e)), n }; const ue = function (e, t, n, r) { n.each(function (e) { t.hasOwnProperty('innerText') ? t.textContent = e : t.textContent = e }), e.dom.setAttribs(t, r), e.selection.select(t) }; const ae = function (e, t, n, r) { ne(t) ? fe(e, t, r) : n.fold(function () { e.execCommand('mceInsertLink', !1, r) }, function (t) { e.insertContent(e.dom.createHTML('a', r, e.dom.encode(t))) }) }; const ce = function (e, t, n) { const r = e.selection.getNode(); const o = J(e, r); const i = ie(e, re(n)); e.undoManager.transact(function () { n.href === t.href && t.attach(), o ? (e.focus(), ue(e, o, n.text, i)) : ae(e, r, n.text, i) }) }; const se = function (e) { e.undoManager.transact(function () { const t = e.selection.getNode(); if (ne(t)) { le(e, t) } else { const n = e.dom.getParent(t, 'a[href]', e.getBody()); n && e.dom.remove(n, !0) }e.focus() }) }; var le = function (e, t) { const n = e.dom.select('img', t)[0]; if (n) { const r = e.dom.getParents(n, 'a[href]', t)[0]; r && (r.parentNode.insertBefore(n, r), e.dom.remove(r)) } }; var fe = function (e, t, n) { const r = e.dom.select('img', t)[0]; if (r) { const o = e.dom.create('a', n); r.parentNode.insertBefore(o, r), o.appendChild(r) } }; const de = { link: ce, unlink: se, isLink: Q, hasLinks: ee, getHref: X, isOnlyTextSelected: te, getAnchorElement: J, getAnchorText: Z, applyRelTargetRules: Y, hasProtocol: G }; const me = function (e) { for (var t = [], n = function (e) { t.push(e) }, r = 0; r < e.length; r++) { e[r].each(n) } return t }; const ge = function (e) { return u(e.value) ? e.value : '' }; const he = function (e, t) { const n = []; return $.each(e, function (e) { const r = u(e.text) ? e.text : u(e.title) ? e.title : ''; if (void 0 !== e.menu) { ; } else { const o = t(e); n.push({ text: r, value: o }) } }), n }; const pe = function (e) { return void 0 === e && (e = ge), function (t) { return M.from(t).map(function (t) { return he(t, e) }) } }; const ve = function (e) { return pe(ge)(e) }; const be = function (e, t) { return function (n) { return { name: e, type: 'selectbox', label: t, items: n } } }; const ye = { sanitize: ve, sanitizeWith: pe, createUi: be, getValue: ge }; var we = function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return we(n()) }; return { get: n, set: r, clone: o } }; const xe = function (e, t) { return q(t, function (t) { return M.some(t).filter(function (t) { return t.value === e }) }) }; const Ce = function (e, t, n, r) { const o = r[t]; const i = e.length > 0; return void 0 !== o ? xe(o, n).map(function (t) { return { url: { value: t.value, meta: { text: i ? e : t.text, attach: E } }, text: i ? e : t.text } }) : M.none() }; const Se = function (e, t) { return t === 'link' ? e.catalogs.link : t === 'anchor' ? e.catalogs.anchor : M.none() }; const ke = function (e, t) { const n = we(e.text); const r = function (e) { if (n.get().length <= 0) { const t = void 0 !== e.url.meta.text ? e.url.meta.text : e.url.value; const r = void 0 !== e.url.meta.title ? e.url.meta.title : ''; return M.some({ text: t, title: r }) } return M.none() }; const o = function (e, r) { const o = Se(t, r.name).getOr([]); return Ce(n.get(), r.name, o, e) }; const i = function (e, t) { return t.name === 'url' ? r(e()) : H(['anchor', 'link'], t.name) ? o(e(), t) : t.name === 'text' ? (n.set(e().text), M.none()) : M.none() }; return { onChange: i } }; const Te = { init: ke, getDelta: Ce }; const Ee = {}; const Oe = { exports: Ee }; (function (t, n, r, o) { (function (o) { if (typeof n === 'object' && typeof r !== 'undefined') { r.exports = o() } else if (typeof t === 'function' && t.amd) { t([], o) } else { let i; i = typeof window !== 'undefined' ? window : typeof e !== 'undefined' ? e : typeof self !== 'undefined' ? self : this, i.EphoxContactWrapper = o() } })(function () { return (function () { function e (t, n, r) { function i (a, c) { if (!n[a]) { if (!t[a]) { const s = typeof o === 'function' && o; if (!c && s) { return s(a, !0) } if (u) { return u(a, !0) } const l = new Error("Cannot find module '" + a + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const f = n[a] = { exports: {} }; t[a][0].call(f.exports, function (e) { const n = t[a][1][e]; return i(n || e) }, f, f.exports, e, t, n, r) } return n[a].exports } for (var u = typeof o === 'function' && o, a = 0; a < r.length; a++) { i(r[a]) } return i } return e }())({ 1: [function (e, t, n) { let r; let o; const i = t.exports = {}; function u () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function c (e) { if (r === setTimeout) { return setTimeout(e, 0) } if ((r === u || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0) } try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function s (e) { if (o === clearTimeout) { return clearTimeout(e) } if ((o === a || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e) } try { return o(e) } catch (t) { try { return o.call(null, e) } catch (t) { return o.call(this, e) } } }(function () { try { r = typeof setTimeout === 'function' ? setTimeout : u } catch (e) { r = u } try { o = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { o = a } })(); let l; let f = []; let d = !1; let m = -1; function g () { d && l && (d = !1, l.length ? f = l.concat(f) : m = -1, f.length && h()) } function h () { if (!d) { const e = c(g); d = !0; let t = f.length; while (t) { l = f, f = []; while (++m < t) { l && l[m].run() }m = -1, t = f.length }l = null, d = !1, s(e) } } function p (e, t) { this.fun = e, this.array = t } function v () {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } }f.push(new p(e, t)), f.length !== 1 || d || c(h) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.prependListener = v, i.prependOnceListener = v, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, {}], 2: [function (e, t, n) { (function (e) { (function (n) { const r = setTimeout; function o () {} function i (e, t) { return function () { e.apply(t, arguments) } } function u (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(e, this) } function a (e, t) { while (e._state === 3) { e = e._value }e._state !== 0 ? (e._handled = !0, u._immediateFn(function () { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let r; try { r = n(e._value) } catch (o) { return void s(t.promise, o) }c(t.promise, r) } else { (e._state === 1 ? c : s)(t.promise, e._value) } })) : e._deferreds.push(t) } function c (e, t) { try { if (t === e) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof u) { return e._state = 3, e._value = t, void l(e) } if (typeof n === 'function') { return void d(i(n, t), e) } }e._state = 1, e._value = t, l(e) } catch (r) { s(e, r) } } function s (e, t) { e._state = 2, e._value = t, l(e) } function l (e) { e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function () { e._handled || u._unhandledRejectionFn(e._value) }); for (let t = 0, n = e._deferreds.length; t < n; t++) { a(e, e._deferreds[t]) }e._deferreds = null } function f (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n } function d (e, t) { let n = !1; try { e(function (e) { n || (n = !0, c(t, e)) }, function (e) { n || (n = !0, s(t, e)) }) } catch (r) { if (n) { return } n = !0, s(t, r) } }u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { const n = new this.constructor(o); return a(this, new f(e, t, n)), n }, u.all = function (e) { const t = Array.prototype.slice.call(e); return new u(function (e, n) { if (t.length === 0) { return e([]) } let r = t.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }t[i] = u, --r === 0 && e(t) } catch (c) { n(c) } } for (let i = 0; i < t.length; i++) { o(i, t[i]) } }) }, u.resolve = function (e) { return e && typeof e === 'object' && e.constructor === u ? e : new u(function (t) { t(e) }) }, u.reject = function (e) { return new u(function (t, n) { n(e) }) }, u.race = function (e) { return new u(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, u._immediateFn = typeof e === 'function' ? function (t) { e(t) } : function (e) { r(e, 0) }, u._unhandledRejectionFn = function (e) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', e) }, u._setImmediateFn = function (e) { u._immediateFn = e }, u._setUnhandledRejectionFn = function (e) { u._unhandledRejectionFn = e }, typeof t !== 'undefined' && t.exports ? t.exports = u : n.Promise || (n.Promise = u) })(this) }).call(this, e('timers').setImmediate) }, { timers: 3 }], 3: [function (e, t, n) { (function (t, r) { const o = e('process/browser.js').nextTick; const i = Function.prototype.apply; const u = Array.prototype.slice; const a = {}; let c = 0; function s (e, t) { this._id = e, this._clearFn = t }n.setTimeout = function () { return new s(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function () { return new s(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function (e) { e.close() }, s.prototype.unref = s.prototype.ref = function () {}, s.prototype.close = function () { this._clearFn.call(window, this._id) }, n.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, n.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, n._unrefActive = n.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(function () { e._onTimeout && e._onTimeout() }, t)) }, n.setImmediate = typeof t === 'function' ? t : function (e) { const t = c++; const r = !(arguments.length < 2) && u.call(arguments, 1); return a[t] = !0, o(function () { a[t] && (r ? e.apply(null, r) : e.call(null), n.clearImmediate(t)) }), t }, n.clearImmediate = typeof r === 'function' ? r : function (e) { delete a[e] } }).call(this, e('timers').setImmediate, e('timers').clearImmediate) }, { 'process/browser.js': 1, timers: 3 }], 4: [function (e, t, n) { const r = e('promise-polyfill'); const o = (function () { return typeof window !== 'undefined' ? window : Function('return this;')() }()); t.exports = { boltExport: o.Promise || r } }, { 'promise-polyfill': 2 }] }, {}, [4])(4) }) })(void 0, Ee, Oe, void 0); const Ne = Oe.exports.boltExport; var _e = function (e) { let n = M.none(); let r = []; const o = function (e) { return _e(function (t) { i(function (n) { t(e(n)) }) }) }; var i = function (e) { a() ? s(e) : r.push(e) }; const u = function (e) { n = M.some(e), c(r), r = [] }; var a = function () { return n.isSome() }; var c = function (e) { V(e, s) }; var s = function (e) { n.each(function (n) { t.setTimeout(function () { e(n) }, 0) }) }; return e(u), { get: i, map: o, isReady: a } }; const De = function (e) { return _e(function (t) { t(e) }) }; const Ae = { nu: _e, pure: De }; const Re = function (e) { t.setTimeout(function () { throw e }, 0) }; var Be = function (e) { const t = function (t) { e().then(t, Re) }; const n = function (t) { return Be(function () { return e().then(t) }) }; const r = function (t) { return Be(function () { return e().then(function (e) { return t(e).toPromise() }) }) }; const o = function (t) { return Be(function () { return e().then(function () { return t.toPromise() }) }) }; const i = function () { return Ae.nu(t) }; const u = function () { let t = null; return Be(function () { return t === null && (t = e()), t }) }; const a = e; return { map: n, bind: r, anonBind: o, toLazy: i, toCached: u, toPromise: a, get: t } }; const Me = function (e) { return Be(function () { return new Ne(e) }) }; const Pe = function (e) { return Be(function () { return Ne.resolve(e) }) }; const ze = { nu: Me, pure: Pe }; const Ie = tinymce.util.Tools.resolve('tinymce.util.Delay'); const Le = function (e, t, n) { const r = e.selection.getRng(); Ie.setEditorTimeout(e, function () { e.windowManager.confirm(t, function (t) { e.selection.setRng(r), n(t) }) }) }; const He = function (e) { const t = e.href; const n = t.indexOf('@') > 0 && !t.includes('//') && !t.includes('mailto:'); return n ? M.some({ message: 'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?', preprocess (e) { return T(T({}, e), { href: 'mailto:' + t }) } }) : M.none() }; const Fe = function (e, t) { return function (n) { const r = n.href; const o = e === 1 && !de.hasProtocol(r) || e === 0 && /^\s*www[\.|\d\.]/i.test(r); return o ? M.some({ message: 'The URL you entered seems to be an external link. Do you want to add the required ' + t + ':// prefix?', preprocess (e) { return T(T({}, e), { href: t + '://' + r }) } }) : M.none() } }; const Ve = function (e, t) { return q([He, Fe(x.assumeExternalTargets(e), x.getDefaultLinkProtocol(e))], function (e) { return e(t) }).fold(function () { return ze.pure(t) }, function (n) { return ze.nu(function (r) { Le(e, n.message, function (e) { r(e ? n.preprocess(t) : t) }) }) }) }; const Ue = { preprocess: Ve }; const je = function (e) { const t = e.dom.select('a:not([href])'); const n = W(t, function (e) { const t = e.name || e.id; return t ? [{ text: t, value: '#' + t }] : [] }); return n.length > 0 ? M.some([{ text: 'None', value: '' }].concat(n)) : M.none() }; const We = { getAnchors: je }; const qe = function (e) { const t = x.getLinkClassList(e); return t.length > 0 ? ye.sanitize(t) : M.none() }; const $e = { getClasses: qe }; const Ge = tinymce.util.Tools.resolve('tinymce.util.XHR'); const Xe = function (e) { try { return M.some(JSON.parse(e)) } catch (t) { return M.none() } }; const Ye = function (e) { const t = function (t) { return e.convertURL(t.value || t.url, 'href') }; const n = x.getLinkList(e); return ze.nu(function (e) { u(n) ? Ge.send({ url: n, success (t) { return e(Xe(t)) }, error (t) { return e(M.none()) } }) : s(n) ? n(function (t) { return e(M.some(t)) }) : e(M.from(n)) }).map(function (e) { return e.bind(ye.sanitizeWith(t)).map(function (e) { return e.length > 0 ? [{ text: 'None', value: '' }].concat(e) : e }) }) }; const Ke = { getLinks: Ye }; const Je = function (e, t) { const n = x.getRelList(e); if (n.length > 0) { const r = t.is('_blank'); const o = !1 === x.allowUnsafeLinkTarget(e); const i = function (e) { return de.applyRelTargetRules(ye.getValue(e), r) }; const u = o ? ye.sanitizeWith(i) : ye.sanitize; return u(n) } return M.none() }; const Ze = { getRels: Je }; const Qe = [{ text: 'Current window', value: '' }, { text: 'New window', value: '_blank' }]; const et = function (e) { const t = x.getTargetList(e); return a(t) ? ye.sanitize(t).orThunk(function () { return M.some(Qe) }) : !1 === t ? M.none() : M.some(Qe) }; const tt = { getTargets: et }; const nt = function (e, t, n) { const r = e.getAttrib(t, n); return r !== null && r.length > 0 ? M.some(r) : M.none() }; const rt = function (e, t) { const n = e.dom; const r = de.isOnlyTextSelected(e.selection.getContent()); const o = r ? M.some(de.getAnchorText(e.selection, t)) : M.none(); const i = t ? M.some(n.getAttrib(t, 'href')) : M.none(); const u = t ? M.from(n.getAttrib(t, 'target')) : M.none(); const a = nt(n, t, 'rel'); const c = nt(n, t, 'class'); const s = nt(n, t, 'title'); return { url: i, text: o, title: s, target: u, rel: a, linkClass: c } }; const ot = function (e, t) { return Ke.getLinks(e).map(function (n) { const r = rt(e, t); return { anchor: r, catalogs: { targets: tt.getTargets(e), rels: Ze.getRels(e, r.target), classes: $e.getClasses(e), anchor: We.getAnchors(e), link: n }, optNode: M.from(t), flags: { titleEnabled: x.shouldShowLinkTitle(e) } } }) }; const it = { collect: ot }; const ut = function (e, t) { return function (n) { const r = n.getData(); if (!r.url.value) { return de.unlink(e), void n.close() } const o = function (e) { return M.from(r[e]).filter(function (n) { return !t.anchor[e].is(n) }) }; const i = { href: r.url.value, text: o('text'), target: o('target'), rel: o('rel'), class: o('linkClass'), title: o('title') }; const u = { href: r.url.value, attach: void 0 !== r.url.meta && r.url.meta.attach ? r.url.meta.attach : function () {} }; Ue.preprocess(e, i).get(function (t) { de.link(e, u, t) }), n.close() } }; const at = function (e) { const t = de.getAnchorElement(e); return it.collect(e, t) }; const ct = function (e, t) { return { url: { value: e.anchor.url.getOr(''), meta: { attach () {}, text: e.anchor.url.fold(function () { return '' }, function () { return e.anchor.text.getOr('') }), original: { value: e.anchor.url.getOr('') } } }, text: e.anchor.text.getOr(''), title: e.anchor.title.getOr(''), anchor: e.anchor.url.getOr(''), link: e.anchor.url.getOr(''), rel: e.anchor.rel.getOr(''), target: e.anchor.target.or(t).getOr(''), linkClass: e.anchor.linkClass.getOr('') } }; const st = function (e, t, n) { const r = [{ name: 'url', type: 'urlinput', filetype: 'file', label: 'URL' }]; const o = e.anchor.text.map(function () { return { name: 'text', type: 'input', label: 'Text to display' } }).toArray(); const i = e.flags.titleEnabled ? [{ name: 'title', type: 'input', label: 'Title' }] : []; const u = M.from(x.getDefaultLinkTarget(n)); const a = ct(e, u); const c = Te.init(a, e); const s = e.catalogs; const l = { type: 'panel', items: j([r, o, i, me([s.anchor.map(ye.createUi('anchor', 'Anchors')), s.rels.map(ye.createUi('rel', 'Rel')), s.targets.map(ye.createUi('target', 'Open link in...')), s.link.map(ye.createUi('link', 'Link list')), s.classes.map(ye.createUi('linkClass', 'Class'))])]) }; return { title: 'Insert/Edit Link', size: 'normal', body: l, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: a, onChange (e, t) { const n = t.name; c.onChange(e.getData, { name: n }).each(function (t) { e.setData(t) }) }, onSubmit: t } }; const lt = function (e) { const t = at(e); t.map(function (t) { const n = ut(e, t); return st(t, n, e) }).get(function (t) { e.windowManager.open(t) }) }; const ft = { open: lt }; const dt = function (e, t) { return e.dom.getParent(t, 'a[href]') }; const mt = function (e) { return dt(e, e.selection.getStart()) }; const gt = function (e) { return !0 === e.altKey && !1 === e.shiftKey && !1 === e.ctrlKey && !1 === e.metaKey }; const ht = function (e, t) { if (t) { const n = de.getHref(t); if (n.startsWith('#')) { const r = e.$(n); r.length && e.selection.scrollIntoView(r[0], !0) } else { k.open(t.href) } } }; const pt = function (e) { return function () { ft.open(e) } }; const vt = function (e) { return function () { ht(e, mt(e)) } }; const bt = function (e) { return function (t) { let n, r, o; return !!(x.hasContextToolbar(e) && de.isLink(t) && (n = e.selection, r = n.getRng(), o = r.startContainer, o.nodeType === 3 && n.isCollapsed() && r.startOffset > 0 && r.startOffset < o.data.length)) } }; const yt = function (e) { e.on('click', function (t) { const n = dt(e, t.target); n && r.metaKeyPressed(t) && (t.preventDefault(), ht(e, n)) }), e.on('keydown', function (t) { const n = mt(e); n && t.keyCode === 13 && gt(t) && (t.preventDefault(), ht(e, n)) }) }; const wt = function (e) { return function (t) { const n = function (n) { return t.setActive(!e.mode.isReadOnly() && !!de.getAnchorElement(e, n.element)) }; return e.on('NodeChange', n), function () { return e.off('NodeChange', n) } } }; const xt = function (e) { return function (t) { const n = e.dom.getParents(e.selection.getStart()); t.setDisabled(!de.hasLinks(n)); const r = function (e) { return t.setDisabled(!de.hasLinks(e.parents)) }; return e.on('NodeChange', r), function () { return e.off('NodeChange', r) } } }; const Ct = { openDialog: pt, gotoSelectedLink: vt, leftClickedOnAHref: bt, setupGotoLinks: yt, toggleActiveState: wt, toggleEnabledState: xt }; const St = function (e) { e.addCommand('mceLink', function () { x.useQuickLink(e) ? e.fire('contexttoolbar-show', { toolbarKey: 'quicklink' }) : Ct.openDialog(e)() }) }; const kt = { register: St }; const Tt = function (e) { e.addShortcut('Meta+K', '', function () { e.execCommand('mceLink') }) }; const Et = { setup: Tt }; const Ot = function (e) { e.ui.registry.addToggleButton('link', { icon: 'link', tooltip: 'Insert/edit link', onAction: Ct.openDialog(e), onSetup: Ct.toggleActiveState(e) }), e.ui.registry.addButton('openlink', { icon: 'new-tab', tooltip: 'Open link', onAction: Ct.gotoSelectedLink(e), onSetup: Ct.toggleEnabledState(e) }), e.ui.registry.addButton('unlink', { icon: 'unlink', tooltip: 'Remove link', onAction () { return de.unlink(e) }, onSetup: Ct.toggleEnabledState(e) }) }; const Nt = function (e) { e.ui.registry.addMenuItem('openlink', { text: 'Open link', icon: 'new-tab', onAction: Ct.gotoSelectedLink(e), onSetup: Ct.toggleEnabledState(e) }), e.ui.registry.addMenuItem('link', { icon: 'link', text: 'Link...', shortcut: 'Meta+K', onAction: Ct.openDialog(e) }), e.ui.registry.addMenuItem('unlink', { icon: 'unlink', text: 'Remove link', onAction () { return de.unlink(e) }, onSetup: Ct.toggleEnabledState(e) }) }; const _t = function (e) { const t = 'link unlink openlink'; const n = 'link'; e.ui.registry.addContextMenu('link', { update (r) { return de.hasLinks(e.dom.getParents(r, 'a')) ? t : n } }) }; const Dt = function (e) { const t = function (e) { e.selection.collapse(!1) }; const n = function (t) { const n = e.selection.getNode(); return t.setDisabled(!de.getAnchorElement(e, n)), function () {} }; e.ui.registry.addContextForm('quicklink', { launch: { type: 'contextformtogglebutton', icon: 'link', tooltip: 'Link', onSetup: Ct.toggleActiveState(e) }, label: 'Link', predicate (t) { return !!de.getAnchorElement(e, t) && x.hasContextToolbar(e) }, initValue () { const t = de.getAnchorElement(e); return t ? de.getHref(t) : '' }, commands: [{ type: 'contextformtogglebutton', icon: 'link', tooltip: 'Link', primary: !0, onSetup (t) { const n = e.selection.getNode(); return t.setActive(!!de.getAnchorElement(e, n)), Ct.toggleActiveState(e)(t) }, onAction (n) { const r = de.getAnchorElement(e); const o = n.getValue(); if (r) { e.dom.setAttrib(r, 'href', o), t(e), n.hide() } else { const i = { href: o, attach () {} }; const u = de.isOnlyTextSelected(e.selection.getContent()); const a = u ? M.some(de.getAnchorText(e.selection, r)).filter(function (e) { return e.length > 0 }).or(M.from(o)) : M.none(); de.link(e, i, { href: o, text: a, title: M.none(), rel: M.none(), target: M.none(), class: M.none() }), n.hide() } } }, { type: 'contextformbutton', icon: 'unlink', tooltip: 'Remove link', onSetup: n, onAction (t) { de.unlink(e), t.hide() } }, { type: 'contextformbutton', icon: 'new-tab', tooltip: 'Open link', onSetup: n, onAction (t) { Ct.gotoSelectedLink(e)(), t.hide() } }] }) }; const At = { setupButtons: Ot, setupMenuItems: Nt, setupContextMenu: _t, setupContextToolbars: Dt }; function Rt () { n.add('link', function (e) { At.setupButtons(e), At.setupMenuItems(e), At.setupContextMenu(e), At.setupContextToolbars(e), Ct.setupGotoLinks(e), kt.register(e), Et.setup(e) }) }Rt() })(window) }).call(this, n('c8ba')) }, c4a9 (e, t, n) { 'use strict'; (function (e) { n.d(t, 'a', function () { return o }); const r = function () { return typeof window !== 'undefined' ? window : e }; var o = function () { const e = r(); return e && e.tinymce ? e.tinymce : null } }).call(this, n('c8ba')) }, cdd9 (e, t, n) { (function (e) { (function (t) { 'use strict'; const n = tinymce.util.Tools.resolve('tinymce.PluginManager'); const r = function () {}; const o = function (e) { return function () { return e } }; const i = function (e) { return e }; const u = function (e) { return function () { throw new Error(e) } }; const a = o(!1); const c = o(!0); const s = function () { return l }; var l = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const i = { fold (e, t) { return e() }, is: a, isSome: a, isNone: c, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: o(null), getOrUndefined: o(void 0), or: n, orThunk: t, map: s, each: r, bind: s, exists: a, forall: c, filter: s, equals: e, equals_: e, toArray () { return [] }, toString: o('none()') }; return Object.freeze && Object.freeze(i), i }()); var f = function (e) { const t = o(e); const n = function () { return i }; const r = function (t) { return t(e) }; var i = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: c, isNone: a, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return f(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? i : l }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(a, function (t) { return n(e, t) }) } }; return i }; const d = function (e) { return e === null || void 0 === e ? l : f(e) }; const m = { some: f, none: s, from: d }; const g = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const h = function (e) { return function (t) { return g(t) === e } }; const p = h('string'); const v = h('object'); const b = h('array'); const y = h('boolean'); const w = h('function'); const x = h('number'); const C = Array.prototype.slice; const S = Array.prototype.push; const k = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const T = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!b(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } S.apply(t, e[n]) } return t }; const E = function (e) { return e.length === 0 ? m.none() : m.some(e[0]) }; const O = (w(Array.from) && Array.from, function (e, t) { for (let n = 0; n < e.length; n++) { const r = t(e[n], n); if (r.isSome()) { return r } } return m.none() }); var N = function () { return N = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, N.apply(this, arguments) }; const _ = {}; const D = { exports: _ }; (function (t, n, r, o) { (function (o) { if (typeof n === 'object' && typeof r !== 'undefined') { r.exports = o() } else if (typeof t === 'function' && t.amd) { t([], o) } else { let i; i = typeof window !== 'undefined' ? window : typeof e !== 'undefined' ? e : typeof self !== 'undefined' ? self : this, i.EphoxContactWrapper = o() } })(function () { return (function () { function e (t, n, r) { function i (a, c) { if (!n[a]) { if (!t[a]) { const s = typeof o === 'function' && o; if (!c && s) { return s(a, !0) } if (u) { return u(a, !0) } const l = new Error("Cannot find module '" + a + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const f = n[a] = { exports: {} }; t[a][0].call(f.exports, function (e) { const n = t[a][1][e]; return i(n || e) }, f, f.exports, e, t, n, r) } return n[a].exports } for (var u = typeof o === 'function' && o, a = 0; a < r.length; a++) { i(r[a]) } return i } return e }())({ 1: [function (e, t, n) { let r; let o; const i = t.exports = {}; function u () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function c (e) { if (r === setTimeout) { return setTimeout(e, 0) } if ((r === u || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0) } try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function s (e) { if (o === clearTimeout) { return clearTimeout(e) } if ((o === a || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e) } try { return o(e) } catch (t) { try { return o.call(null, e) } catch (t) { return o.call(this, e) } } }(function () { try { r = typeof setTimeout === 'function' ? setTimeout : u } catch (e) { r = u } try { o = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { o = a } })(); let l; let f = []; let d = !1; let m = -1; function g () { d && l && (d = !1, l.length ? f = l.concat(f) : m = -1, f.length && h()) } function h () { if (!d) { const e = c(g); d = !0; let t = f.length; while (t) { l = f, f = []; while (++m < t) { l && l[m].run() }m = -1, t = f.length }l = null, d = !1, s(e) } } function p (e, t) { this.fun = e, this.array = t } function v () {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } }f.push(new p(e, t)), f.length !== 1 || d || c(h) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.prependListener = v, i.prependOnceListener = v, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, {}], 2: [function (e, t, n) { (function (e) { (function (n) { const r = setTimeout; function o () {} function i (e, t) { return function () { e.apply(t, arguments) } } function u (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(e, this) } function a (e, t) { while (e._state === 3) { e = e._value }e._state !== 0 ? (e._handled = !0, u._immediateFn(function () { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let r; try { r = n(e._value) } catch (o) { return void s(t.promise, o) }c(t.promise, r) } else { (e._state === 1 ? c : s)(t.promise, e._value) } })) : e._deferreds.push(t) } function c (e, t) { try { if (t === e) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof u) { return e._state = 3, e._value = t, void l(e) } if (typeof n === 'function') { return void d(i(n, t), e) } }e._state = 1, e._value = t, l(e) } catch (r) { s(e, r) } } function s (e, t) { e._state = 2, e._value = t, l(e) } function l (e) { e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function () { e._handled || u._unhandledRejectionFn(e._value) }); for (let t = 0, n = e._deferreds.length; t < n; t++) { a(e, e._deferreds[t]) }e._deferreds = null } function f (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n } function d (e, t) { let n = !1; try { e(function (e) { n || (n = !0, c(t, e)) }, function (e) { n || (n = !0, s(t, e)) }) } catch (r) { if (n) { return } n = !0, s(t, r) } }u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { const n = new this.constructor(o); return a(this, new f(e, t, n)), n }, u.all = function (e) { const t = Array.prototype.slice.call(e); return new u(function (e, n) { if (t.length === 0) { return e([]) } let r = t.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }t[i] = u, --r === 0 && e(t) } catch (c) { n(c) } } for (let i = 0; i < t.length; i++) { o(i, t[i]) } }) }, u.resolve = function (e) { return e && typeof e === 'object' && e.constructor === u ? e : new u(function (t) { t(e) }) }, u.reject = function (e) { return new u(function (t, n) { n(e) }) }, u.race = function (e) { return new u(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, u._immediateFn = typeof e === 'function' ? function (t) { e(t) } : function (e) { r(e, 0) }, u._unhandledRejectionFn = function (e) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', e) }, u._setImmediateFn = function (e) { u._immediateFn = e }, u._setUnhandledRejectionFn = function (e) { u._unhandledRejectionFn = e }, typeof t !== 'undefined' && t.exports ? t.exports = u : n.Promise || (n.Promise = u) })(this) }).call(this, e('timers').setImmediate) }, { timers: 3 }], 3: [function (e, t, n) { (function (t, r) { const o = e('process/browser.js').nextTick; const i = Function.prototype.apply; const u = Array.prototype.slice; const a = {}; let c = 0; function s (e, t) { this._id = e, this._clearFn = t }n.setTimeout = function () { return new s(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function () { return new s(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function (e) { e.close() }, s.prototype.unref = s.prototype.ref = function () {}, s.prototype.close = function () { this._clearFn.call(window, this._id) }, n.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, n.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, n._unrefActive = n.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(function () { e._onTimeout && e._onTimeout() }, t)) }, n.setImmediate = typeof t === 'function' ? t : function (e) { const t = c++; const r = !(arguments.length < 2) && u.call(arguments, 1); return a[t] = !0, o(function () { a[t] && (r ? e.apply(null, r) : e.call(null), n.clearImmediate(t)) }), t }, n.clearImmediate = typeof r === 'function' ? r : function (e) { delete a[e] } }).call(this, e('timers').setImmediate, e('timers').clearImmediate) }, { 'process/browser.js': 1, timers: 3 }], 4: [function (e, t, n) { const r = e('promise-polyfill'); const o = (function () { return typeof window !== 'undefined' ? window : Function('return this;')() }()); t.exports = { boltExport: o.Promise || r } }, { 'promise-polyfill': 2 }] }, {}, [4])(4) }) })(void 0, _, D, void 0); const A = D.exports.boltExport; var R = function (e) { let n = m.none(); let r = []; const o = function (e) { return R(function (t) { i(function (n) { t(e(n)) }) }) }; var i = function (e) { a() ? s(e) : r.push(e) }; const u = function (e) { n = m.some(e), c(r), r = [] }; var a = function () { return n.isSome() }; var c = function (e) { k(e, s) }; var s = function (e) { n.each(function (n) { t.setTimeout(function () { e(n) }, 0) }) }; return e(u), { get: i, map: o, isReady: a } }; const B = function (e) { return R(function (t) { t(e) }) }; const M = { nu: R, pure: B }; const P = function (e) { t.setTimeout(function () { throw e }, 0) }; var z = function (e) { const t = function (t) { e().then(t, P) }; const n = function (t) { return z(function () { return e().then(t) }) }; const r = function (t) { return z(function () { return e().then(function (e) { return t(e).toPromise() }) }) }; const o = function (t) { return z(function () { return e().then(function () { return t.toPromise() }) }) }; const i = function () { return M.nu(t) }; const u = function () { let t = null; return z(function () { return t === null && (t = e()), t }) }; const a = e; return { map: n, bind: r, anonBind: o, toLazy: i, toCached: u, toPromise: a, get: t } }; const I = function (e) { return z(function () { return new A(e) }) }; const L = function (e) { return z(function () { return A.resolve(e) }) }; const H = { nu: I, pure: L }; var F = function (e) { const t = function (t) { return e === t }; const n = function (t) { return F(e) }; const r = function (t) { return F(e) }; const i = function (t) { return F(t(e)) }; const u = function (t) { return F(e) }; const s = function (t) { t(e) }; const l = function (t) { return t(e) }; const f = function (t, n) { return n(e) }; const d = function (t) { return t(e) }; const g = function (t) { return t(e) }; const h = function () { return m.some(e) }; return { is: t, isValue: c, isError: a, getOr: o(e), getOrThunk: o(e), getOrDie: o(e), or: n, orThunk: r, fold: f, map: i, mapError: u, each: s, bind: l, exists: d, forall: g, toOption: h } }; var V = function (e) { const t = function (e) { return e() }; const n = function () { return u(String(e))() }; const o = function (e) { return e }; const s = function (e) { return e() }; const l = function (t) { return V(e) }; const f = function (t) { return V(t(e)) }; const d = function (t) { return V(e) }; const g = function (t, n) { return t(e) }; return { is: a, isValue: a, isError: c, getOr: i, getOrThunk: t, getOrDie: n, or: o, orThunk: s, fold: g, map: l, mapError: f, each: r, bind: d, exists: a, forall: c, toOption: m.none } }; const U = function (e, t) { return e.fold(function () { return V(t) }, F) }; const j = { value: F, error: V, fromOption: U }; var W = function (e) { const n = function () { return W(e.toCached()) }; const r = function (t) { return W(e.bind(function (e) { return e.fold(function (e) { return H.pure(j.error(e)) }, function (e) { return t(e) }) })) }; const o = function (t) { return W(e.map(function (e) { return e.bind(t) })) }; const i = function (t) { return W(e.map(function (e) { return e.map(t) })) }; const u = function (t) { return W(e.map(function (e) { return e.mapError(t) })) }; const a = function (t, n) { return e.map(function (e) { return e.fold(t, n) }) }; const c = function (n, r) { return W(H.nu(function (o) { let i = !1; const u = t.setTimeout(function () { i = !0, o(j.error(r())) }, n); e.get(function (e) { i || (t.clearTimeout(u), o(e)) }) })) }; return N(N({}, e), { toCached: n, bindFuture: r, bindResult: o, mapResult: i, mapError: u, foldResult: a, withTimeout: c }) }; const q = function (e) { return W(H.nu(e)) }; const $ = function (e) { return W(H.pure(j.value(e))) }; const G = function (e) { return W(H.pure(j.error(e))) }; const X = function (e) { return W(H.pure(e)) }; const Y = function (e) { return W(e.map(j.value)) }; const K = function (e) { return q(function (t) { e.then(function (e) { t(j.value(e)) }, function (e) { t(j.error(e)) }) }) }; const J = { nu: q, wrap: W, pure: $, value: $, error: G, fromResult: X, fromFuture: Y, fromPromise: K }; const Z = Object.prototype.hasOwnProperty; const Q = function (e, t) { const n = v(e) && v(t); return n ? te(e, t) : t }; const ee = function (e) { return function () { for (var t = new Array(arguments.length), n = 0; n < t.length; n++) { t[n] = arguments[n] } if (t.length === 0) { throw new Error("Can't merge zero objects") } for (var r = {}, o = 0; o < t.length; o++) { const i = t[o]; for (const u in i) { Z.call(i, u) && (r[u] = e(r[u], i[u])) } } return r } }; var te = ee(Q); const ne = (t.Node.ATTRIBUTE_NODE, t.Node.CDATA_SECTION_NODE, t.Node.COMMENT_NODE, t.Node.DOCUMENT_NODE, t.Node.DOCUMENT_TYPE_NODE, t.Node.DOCUMENT_FRAGMENT_NODE, t.Node.ELEMENT_NODE, t.Node.TEXT_NODE, t.Node.PROCESSING_INSTRUCTION_NODE, t.Node.ENTITY_REFERENCE_NODE, t.Node.ENTITY_NODE, t.Node.NOTATION_NODE, typeof t.window !== 'undefined' ? t.window : Function('return this;')(), function (e, n, r) { if (!(p(r) || y(r) || x(r))) { throw t.console.error('Invalid call to Attr.set. Key ', n, ':: Value ', r, ':: Element ', e), new Error('Attribute value was not simple') } e.setAttribute(n, r + '') }); const re = function (e, t, n) { ne(e.dom(), t, n) }; const oe = function (e, n) { const r = n || t.document; const o = r.createElement('div'); if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) { throw t.console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node') } return ae(o.childNodes[0]) }; const ie = function (e, n) { const r = n || t.document; const o = r.createElement(e); return ae(o) }; const ue = function (e, n) { const r = n || t.document; const o = r.createTextNode(e); return ae(o) }; var ae = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: o(e) } }; const ce = function (e, t, n) { const r = e.dom(); return m.from(r.elementFromPoint(t, n)).map(ae) }; const se = { fromHtml: oe, fromTag: ie, fromText: ue, fromDom: ae, fromPoint: ce }; const le = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const fe = tinymce.util.Tools.resolve('tinymce.util.Promise'); const de = tinymce.util.Tools.resolve('tinymce.util.XHR'); const me = function (e) { return e.getParam('image_dimensions', !0, 'boolean') }; const ge = function (e) { return e.getParam('image_advtab', !1, 'boolean') }; const he = function (e) { return e.getParam('image_uploadtab', !0, 'boolean') }; const pe = function (e) { return e.getParam('image_prepend_url', '', 'string') }; const ve = function (e) { return e.getParam('image_class_list') }; const be = function (e) { return e.getParam('image_description', !0, 'boolean') }; const ye = function (e) { return e.getParam('image_title', !1, 'boolean') }; const we = function (e) { return e.getParam('image_caption', !1, 'boolean') }; const xe = function (e) { return e.getParam('image_list', !1) }; const Ce = function (e) { return !!ke(e) }; const Se = function (e) { return !!Te(e) }; var ke = function (e) { return e.getParam('images_upload_url', '', 'string') }; var Te = function (e) { return e.getParam('images_upload_handler', void 0, 'function') }; const Ee = function (e) { return e.getParam('images_upload_base_path', void 0, 'string') }; const Oe = function (e) { return e.getParam('images_upload_credentials', !1, 'boolean') }; const Ne = function (e) { return e.getParam('a11y_advanced_options', !1, 'boolean') }; const _e = function (e) { return e.getParam('automatic_uploads', !0, 'boolean') }; const De = { hasDimensions: me, hasUploadTab: he, hasAdvTab: ge, getPrependUrl: pe, getClassList: ve, hasDescription: be, hasImageTitle: ye, hasImageCaption: we, getImageList: xe, hasUploadUrl: Ce, hasUploadHandler: Se, getUploadUrl: ke, getUploadHandler: Te, getUploadBasePath: Ee, getUploadCredentials: Oe, showAccessibilityOptions: Ne, isAutomaticUploadsEnabled: _e }; const Ae = function (e, t) { return Math.max(parseInt(e, 10), parseInt(t, 10)) }; const Re = function (e, n) { const r = t.document.createElement('img'); const o = function (e) { r.parentNode && r.parentNode.removeChild(r), n(e) }; r.onload = function () { const e = Ae(r.width, r.clientWidth); const t = Ae(r.height, r.clientHeight); const n = { width: e, height: t }; o(j.value(n)) }, r.onerror = function () { o(j.error('Failed to get image dimensions for: ' + e)) }; const i = r.style; i.visibility = 'hidden', i.position = 'fixed', i.bottom = i.left = '0px', i.width = i.height = 'auto', t.document.body.appendChild(r), r.src = e }; const Be = function (e) { return e && (e = e.replace(/px$/, '')), e }; const Me = function (e) { return e.length > 0 && /^[0-9]+$/.test(e) && (e += 'px'), e }; const Pe = function (e) { if (e.margin) { const t = String(e.margin).split(' '); switch (t.length) { case 1:e['margin-top'] = e['margin-top'] || t[0], e['margin-right'] = e['margin-right'] || t[0], e['margin-bottom'] = e['margin-bottom'] || t[0], e['margin-left'] = e['margin-left'] || t[0]; break; case 2:e['margin-top'] = e['margin-top'] || t[0], e['margin-right'] = e['margin-right'] || t[1], e['margin-bottom'] = e['margin-bottom'] || t[0], e['margin-left'] = e['margin-left'] || t[1]; break; case 3:e['margin-top'] = e['margin-top'] || t[0], e['margin-right'] = e['margin-right'] || t[1], e['margin-bottom'] = e['margin-bottom'] || t[2], e['margin-left'] = e['margin-left'] || t[1]; break; case 4:e['margin-top'] = e['margin-top'] || t[0], e['margin-right'] = e['margin-right'] || t[1], e['margin-bottom'] = e['margin-bottom'] || t[2], e['margin-left'] = e['margin-left'] || t[3] } delete e.margin } return e }; const ze = function (e, t) { const n = De.getImageList(e); typeof n === 'string' ? de.send({ url: n, success (e) { t(JSON.parse(e)) } }) : typeof n === 'function' ? n(t) : t(n) }; const Ie = function (e, t, n) { const r = function () { n.onload = n.onerror = null, e.selection && (e.selection.select(n), e.nodeChanged()) }; n.onload = function () { t.width || t.height || !De.hasDimensions(e) || e.dom.setAttribs(n, { width: String(n.clientWidth), height: String(n.clientHeight) }), r() }, n.onerror = r }; const Le = function (e) { return new fe(function (n, r) { const o = new t.FileReader(); o.onload = function () { n(o.result) }, o.onerror = function () { r(o.error.message) }, o.readAsDataURL(e) }) }; const He = function (e) { return e.nodeName === 'IMG' && (e.hasAttribute('data-mce-object') || e.hasAttribute('data-mce-placeholder')) }; const Fe = { getImageSize: Re, removePixelSuffix: Be, addPixelSuffix: Me, mergeMargins: Pe, createImageList: ze, waitLoadImage: Ie, blobToDataUri: Le, isPlaceholderImage: He }; const Ve = le.DOM; const Ue = function (e) { return e.style.marginLeft && e.style.marginRight && e.style.marginLeft === e.style.marginRight ? Fe.removePixelSuffix(e.style.marginLeft) : '' }; const je = function (e) { return e.style.marginTop && e.style.marginBottom && e.style.marginTop === e.style.marginBottom ? Fe.removePixelSuffix(e.style.marginTop) : '' }; const We = function (e) { return e.style.borderWidth ? Fe.removePixelSuffix(e.style.borderWidth) : '' }; const qe = function (e, t) { return e.hasAttribute(t) ? e.getAttribute(t) : '' }; const $e = function (e, t) { return e.style[t] ? e.style[t] : '' }; const Ge = function (e) { return e.parentNode !== null && e.parentNode.nodeName === 'FIGURE' }; const Xe = function (e, t, n) { e.setAttribute(t, n) }; const Ye = function (e) { const t = Ve.create('figure', { class: 'image' }); Ve.insertAfter(t, e), t.appendChild(e), t.appendChild(Ve.create('figcaption', { contentEditable: 'true' }, 'Caption')), t.contentEditable = 'false' }; const Ke = function (e) { const t = e.parentNode; Ve.insertAfter(e, t), Ve.remove(t) }; const Je = function (e) { Ge(e) ? Ke(e) : Ye(e) }; const Ze = function (e, t) { const n = e.getAttribute('style'); const r = t(n !== null ? n : ''); r.length > 0 ? (e.setAttribute('style', r), e.setAttribute('data-mce-style', r)) : e.removeAttribute('style') }; const Qe = function (e, t) { return function (e, n, r) { e.style[n] ? (e.style[n] = Fe.addPixelSuffix(r), Ze(e, t)) : Xe(e, n, r) } }; const et = function (e, t) { return e.style[t] ? Fe.removePixelSuffix(e.style[t]) : qe(e, t) }; const tt = function (e, t) { const n = Fe.addPixelSuffix(t); e.style.marginLeft = n, e.style.marginRight = n }; const nt = function (e, t) { const n = Fe.addPixelSuffix(t); e.style.marginTop = n, e.style.marginBottom = n }; const rt = function (e, t) { const n = Fe.addPixelSuffix(t); e.style.borderWidth = n }; const ot = function (e, t) { e.style.borderStyle = t }; const it = function (e) { return $e(e, 'borderStyle') }; const ut = function (e) { return e.nodeName === 'FIGURE' }; const at = function (e) { return e.nodeName === 'IMG' }; const ct = function (e) { return Ve.getAttrib(e, 'alt').length === 0 && Ve.getAttrib(e, 'role') === 'presentation' }; const st = function (e) { return ct(e) ? '' : qe(e, 'alt') }; const lt = function () { return { src: '', alt: '', title: '', width: '', height: '', class: '', style: '', caption: !1, hspace: '', vspace: '', border: '', borderStyle: '', isDecorative: !1 } }; const ft = function (e, n) { const r = t.document.createElement('img'); return Xe(r, 'style', n.style), (Ue(r) || n.hspace !== '') && tt(r, n.hspace), (je(r) || n.vspace !== '') && nt(r, n.vspace), (We(r) || n.border !== '') && rt(r, n.border), (it(r) || n.borderStyle !== '') && ot(r, n.borderStyle), e(r.getAttribute('style')) }; const dt = function (e, n, r) { const o = t.document.createElement('img'); if (bt(e, N(N({}, n), { caption: !1 }), o, r), ht(o, n.alt, n.isDecorative, r), n.caption) { const i = Ve.create('figure', { class: 'image' }); return i.appendChild(o), i.appendChild(Ve.create('figcaption', { contentEditable: 'true' }, 'Caption')), i.contentEditable = 'false', i } return o }; const mt = function (e, t) { return { src: qe(t, 'src'), alt: st(t), title: qe(t, 'title'), width: et(t, 'width'), height: et(t, 'height'), class: qe(t, 'class'), style: e(qe(t, 'style')), caption: Ge(t), hspace: Ue(t), vspace: je(t), border: We(t), borderStyle: $e(t, 'borderStyle'), isDecorative: ct(t) } }; const gt = function (e, t, n, r, o) { n[r] !== t[r] && o(e, r, n[r]) }; var ht = function (e, t, n, r) { if (n) { Ve.setAttrib(e, 'role', 'presentation'); var o = se.fromDom(e); re(o, 'alt', '') } else { if (r.hasAccessibilityOptions) { Ve.setAttrib(e, 'alt', t) } else { o = se.fromDom(e); re(o, 'alt', t) }Ve.getAttrib(e, 'role') === 'presentation' && Ve.setAttrib(e, 'role', '') } }; const pt = function (e, t, n, r) { n.alt === t.alt && n.isDecorative === t.isDecorative || ht(e, n.alt, n.isDecorative, r) }; const vt = function (e, t) { return function (n, r, o) { e(n, o), Ze(n, t) } }; var bt = function (e, t, n, r) { const o = mt(e, n); gt(n, o, t, 'caption', function (e, t, n) { return Je(e) }), gt(n, o, t, 'src', Xe), gt(n, o, t, 'title', Xe), gt(n, o, t, 'width', Qe('width', e)), gt(n, o, t, 'height', Qe('height', e)), gt(n, o, t, 'class', Xe), gt(n, o, t, 'style', vt(function (e, t) { return Xe(e, 'style', t) }, e)), gt(n, o, t, 'hspace', vt(tt, e)), gt(n, o, t, 'vspace', vt(nt, e)), gt(n, o, t, 'border', vt(rt, e)), gt(n, o, t, 'borderStyle', vt(ot, e)), pt(n, o, t, r) }; const yt = function (e, t) { const n = e.dom.styles.parse(t); const r = Fe.mergeMargins(n); const o = e.dom.styles.parse(e.dom.styles.serialize(r)); return e.dom.styles.serialize(o) }; const wt = function (e) { const t = e.selection.getNode(); const n = e.dom.getParent(t, 'figure.image'); return n ? e.dom.select('img', n)[0] : t && (t.nodeName !== 'IMG' || Fe.isPlaceholderImage(t)) ? null : t }; const xt = function (e, t) { const n = e.dom; const r = n.getParent(t.parentNode, function (t) { return !!e.schema.getTextBlockElements()[t.nodeName] }, e.getBody()); return r ? n.split(r, t) : t }; const Ct = function (e) { const t = wt(e); return t ? mt(function (t) { return yt(e, t) }, t) : lt() }; const St = function (e, t, n) { const r = dt(function (t) { return yt(e, t) }, t, n); e.dom.setAttrib(r, 'data-mce-id', '__mcenew'), e.focus(), e.selection.setContent(r.outerHTML); const o = e.dom.select('*[data-mce-id="__mcenew"]')[0]; if (e.dom.setAttrib(o, 'data-mce-id', null), ut(o)) { const i = xt(e, o); e.selection.select(i) } else { e.selection.select(o) } }; const kt = function (e, t) { e.dom.setAttrib(t, 'src', t.getAttribute('src')) }; const Tt = function (e, t) { if (t) { const n = e.dom.is(t.parentNode, 'figure.image') ? t.parentNode : t; e.dom.remove(n), e.focus(), e.nodeChanged(), e.dom.isEmpty(e.getBody()) && (e.setContent(''), e.selection.setCursorLocation()) } }; const Et = function (e, t, n) { const r = wt(e); if (bt(function (t) { return yt(e, t) }, t, r, n), kt(e, r), ut(r.parentNode)) { const o = r.parentNode; xt(e, o), e.selection.select(r.parentNode) } else { e.selection.select(r), Fe.waitLoadImage(e, t, r) } }; const Ot = function (e, t, n) { const r = wt(e); r ? t.src ? Et(e, t, n) : Tt(e, r) : t.src && St(e, t, n) }; const Nt = tinymce.util.Tools.resolve('tinymce.util.Tools'); const _t = function (e) { return p(e.value) ? e.value : '' }; var Dt = function (e, t) { const n = []; return Nt.each(e, function (e) { const r = p(e.text) ? e.text : p(e.title) ? e.title : ''; if (void 0 !== e.menu) { const o = Dt(e.menu, t); n.push({ text: r, items: o }) } else { const i = t(e); n.push({ text: r, value: i }) } }), n }; const At = function (e) { return void 0 === e && (e = _t), function (t) { return t ? m.from(t).map(function (t) { return Dt(t, e) }) : m.none() } }; const Rt = function (e) { return At(_t)(e) }; const Bt = function (e) { return Object.prototype.hasOwnProperty.call(e, 'items') }; var Mt = function (e, t) { return O(e, function (e) { return Bt(e) ? Mt(e.items, t) : e.value === t ? m.some(e) : m.none() }) }; const Pt = function (e, t) { return e.bind(function (e) { return Mt(e, t) }) }; const zt = { sanitizer: At, sanitize: Rt, findEntry: Pt }; const It = function (e, t) { return e ? e.replace(/\/$/, '') + '/' + t.replace(/^\//, '') : t }; function Lt (e) { const n = function (n, r, o, i) { let u, a; u = new t.XMLHttpRequest(), u.open('POST', e.url), u.withCredentials = e.credentials, u.upload.onprogress = function (e) { i(e.loaded / e.total * 100) }, u.onerror = function () { o('Image upload failed due to a XHR Transport error. Code: ' + u.status) }, u.onload = function () { let t; u.status < 200 || u.status >= 300 ? o('HTTP Error: ' + u.status) : (t = JSON.parse(u.responseText), t && typeof t.location === 'string' ? r(It(e.basePath, t.location)) : o('Invalid JSON: ' + u.responseText)) }, a = new t.FormData(), a.append('file', n.blob(), n.filename()), u.send(a) }; const o = function (e, t) { return new fe(function (n, o) { try { t(e, n, o, r) } catch (i) { o(i.message) } }) }; const i = function (e) { return e === n }; const u = function (t) { return !e.url && i(e.handler) ? fe.reject('Upload url missing from the settings.') : o(t, e.handler) }; return e = Nt.extend({ credentials: !1, handler: n }, e), { upload: u } } const Ht = function (e) { return { title: 'Advanced', name: 'advanced', items: [{ type: 'input', label: 'Style', name: 'style' }, { type: 'grid', columns: 2, items: [{ type: 'input', label: 'Vertical space', name: 'vspace', inputMode: 'numeric' }, { type: 'input', label: 'Horizontal space', name: 'hspace', inputMode: 'numeric' }, { type: 'input', label: 'Border width', name: 'border', inputMode: 'numeric' }, { type: 'selectbox', name: 'borderstyle', label: 'Border style', items: [{ text: 'Select...', value: '' }, { text: 'Solid', value: 'solid' }, { text: 'Dotted', value: 'dotted' }, { text: 'Dashed', value: 'dashed' }, { text: 'Double', value: 'double' }, { text: 'Groove', value: 'groove' }, { text: 'Ridge', value: 'ridge' }, { text: 'Inset', value: 'inset' }, { text: 'Outset', value: 'outset' }, { text: 'None', value: 'none' }, { text: 'Hidden', value: 'hidden' }] }] }] } }; const Ft = { makeTab: Ht }; const Vt = function (e) { const t = zt.sanitizer(function (t) { return e.convertURL(t.value || t.url, 'src') }); const n = H.nu(function (n) { Fe.createImageList(e, function (e) { n(t(e).map(function (e) { return T([[{ text: 'None', value: '' }], e]) })) }) }); const r = zt.sanitize(De.getClassList(e)); const o = De.hasAdvTab(e); const i = De.hasUploadTab(e); const u = De.hasUploadUrl(e); const a = De.hasUploadHandler(e); const c = Ct(e); const s = De.hasDescription(e); const l = De.hasImageTitle(e); const f = De.hasDimensions(e); const d = De.hasImageCaption(e); const g = De.showAccessibilityOptions(e); const h = De.getUploadUrl(e); const v = De.getUploadBasePath(e); const b = De.getUploadCredentials(e); const y = De.getUploadHandler(e); const w = De.isAutomaticUploadsEnabled(e); const x = m.some(De.getPrependUrl(e)).filter(function (e) { return p(e) && e.length > 0 }); return n.map(function (e) { return { image: c, imageList: e, classList: r, hasAdvTab: o, hasUploadTab: i, hasUploadUrl: u, hasUploadHandler: a, hasDescription: s, hasImageTitle: l, hasDimensions: f, hasImageCaption: d, url: h, basePath: v, credentials: b, handler: y, prependURL: x, hasAccessibilityOptions: g, automaticUploads: w } }) }; const Ut = function (e) { const t = { name: 'src', type: 'urlinput', filetype: 'image', label: 'Source' }; const n = e.imageList.map(function (e) { return { name: 'images', type: 'selectbox', label: 'Image list', items: e } }); const r = { name: 'alt', type: 'input', label: 'Alternative description', disabled: e.hasAccessibilityOptions && e.image.isDecorative }; const o = { name: 'title', type: 'input', label: 'Image title' }; const i = { name: 'dimensions', type: 'sizeinput' }; const u = { type: 'label', label: 'Accessibility', items: [{ name: 'isDecorative', type: 'checkbox', label: 'Image is decorative' }] }; const a = e.classList.map(function (e) { return { name: 'classes', type: 'selectbox', label: 'Class', items: e } }); const c = { type: 'label', label: 'Caption', items: [{ type: 'checkbox', name: 'caption', label: 'Show caption' }] }; return T([[t], n.toArray(), e.hasAccessibilityOptions && e.hasDescription ? [u] : [], e.hasDescription ? [r] : [], e.hasImageTitle ? [o] : [], e.hasDimensions ? [i] : [], [{ type: 'grid', columns: 2, items: T([a.toArray(), e.hasImageCaption ? [c] : []]) }]]) }; const jt = function (e) { return { title: 'General', name: 'general', items: Ut(e) } }; const Wt = { makeTab: jt, makeItems: Ut }; const qt = function (e) { const t = [{ type: 'dropzone', name: 'fileinput' }]; return { title: 'Upload', name: 'upload', items: t } }; const $t = { makeTab: qt }; const Gt = function (e) { return { prevImage: zt.findEntry(e.imageList, e.image.src), prevAlt: e.image.alt, open: !0 } }; const Xt = function (e) { return { src: { value: e.src, meta: {} }, images: e.src, alt: e.alt, title: e.title, dimensions: { width: e.width, height: e.height }, classes: e.class, caption: e.caption, style: e.style, vspace: e.vspace, border: e.border, hspace: e.hspace, borderstyle: e.borderStyle, fileinput: [], isDecorative: e.isDecorative } }; const Yt = function (e) { return { src: e.src.value, alt: e.alt, title: e.title, width: e.dimensions.width, height: e.dimensions.height, class: e.classes, style: e.style, caption: e.caption, hspace: e.hspace, vspace: e.vspace, border: e.border, borderStyle: e.borderstyle, isDecorative: e.isDecorative } }; const Kt = function (e, t) { return /^(?:[a-zA-Z]+:)?\/\//.test(t) ? m.none() : e.prependURL.bind(function (e) { return t.substring(0, e.length) !== e ? m.some(e + t) : m.none() }) }; const Jt = function (e, t) { const n = t.getData(); Kt(e, n.src.value).each(function (e) { t.setData({ src: { value: e, meta: n.src.meta } }) }) }; const Zt = function (e, t, n) { e.hasDescription && p(n.alt) && (t.alt = n.alt), e.hasAccessibilityOptions && (t.isDecorative = n.isDecorative || t.isDecorative || !1), e.hasImageTitle && p(n.title) && (t.title = n.title), e.hasDimensions && (p(n.width) && (t.dimensions.width = n.width), p(n.height) && (t.dimensions.height = n.height)), p(n.class) && zt.findEntry(e.classList, n.class).each(function (e) { t.classes = e.value }), e.hasImageCaption && y(n.caption) && (t.caption = n.caption), e.hasAdvTab && (p(n.style) && (t.style = n.style), p(n.vspace) && (t.vspace = n.vspace), p(n.border) && (t.border = n.border), p(n.hspace) && (t.hspace = n.hspace), p(n.borderstyle) && (t.borderstyle = n.borderstyle)) }; const Qt = function (e, t) { const n = t.getData(); const r = n.src.meta; if (void 0 !== r) { const o = te({}, n); Zt(e, o, r), t.setData(o) } }; const en = function (e, t, n, r) { const o = r.getData(); const i = o.src.value; const u = o.src.meta || {}; u.width || u.height || !t.hasDimensions || e.imageSize(i).get(function (e) { e.each(function (e) { n.open && r.setData({ dimensions: e }) }) }) }; const tn = function (e, t, n) { const r = n.getData(); const o = zt.findEntry(e.imageList, r.src.value); t.prevImage = o, n.setData({ images: o.map(function (e) { return e.value }).getOr('') }) }; const nn = function (e, t, n, r) { Jt(t, r), Qt(t, r), en(e, t, n, r), tn(t, n, r) }; const rn = function (e, t, n, r) { const o = r.getData(); const i = zt.findEntry(t.imageList, o.images); i.each(function (e) { const t = o.alt === '' || n.prevImage.map(function (e) { return e.text === o.alt }).getOr(!1); t ? e.value === '' ? r.setData({ src: e, alt: n.prevAlt }) : r.setData({ src: e, alt: e.text }) : r.setData({ src: e }) }), n.prevImage = i, nn(e, t, n, r) }; const on = function (e) { const t = e['margin-top'] && e['margin-bottom'] && e['margin-top'] === e['margin-bottom']; return t ? Fe.removePixelSuffix(String(e['margin-top'])) : '' }; const un = function (e) { const t = e['margin-right'] && e['margin-left'] && e['margin-right'] === e['margin-left']; return t ? Fe.removePixelSuffix(String(e['margin-right'])) : '' }; const an = function (e) { return e['border-width'] ? Fe.removePixelSuffix(String(e['border-width'])) : '' }; const cn = function (e) { return e['border-style'] ? String(e['border-style']) : '' }; const sn = function (e, t, n) { return t(e(t(n))) }; const ln = function (e, t, n) { const r = Fe.mergeMargins(e(n.style)); const o = te({}, n); return o.vspace = on(r), o.hspace = un(r), o.border = an(r), o.borderstyle = cn(r), o.style = sn(e, t, r), o }; const fn = function (e, t) { const n = t.getData(); const r = ln(e.parseStyle, e.serializeStyle, n); t.setData(r) }; const dn = function (e, t, n) { const r = te(Xt(t.image), n.getData()); const o = ft(e.normalizeCss, Yt(r)); n.setData({ style: o }) }; const mn = function (e, n, r, o) { const i = o.getData(); o.block('Uploading image'), E(i.fileinput).fold(function () { o.unblock() }, function (i) { const u = t.URL.createObjectURL(i); const a = Lt({ url: n.url, basePath: n.basePath, credentials: n.credentials, handler: n.handler }); const c = function () { o.unblock(), t.URL.revokeObjectURL(u) }; const s = function (t) { o.setData({ src: { value: t, meta: {} } }), o.showTab('general'), nn(e, n, r, o) }; Fe.blobToDataUri(i).then(function (t) { const r = e.createBlobCache(i, u, t); n.automaticUploads ? a.upload(r).then(function (e) { s(e), c() }).catch(function (t) { c(), e.alertErr(o, t) }) : (e.addToBlobCache(r), s(r.blobUri()), o.unblock()) }) }) }; const gn = function (e, t, n) { return function (r, o) { o.name === 'src' ? nn(e, t, n, r) : o.name === 'images' ? rn(e, t, n, r) : o.name === 'alt' ? n.prevAlt = r.getData().alt : o.name === 'style' ? fn(e, r) : o.name === 'vspace' || o.name === 'hspace' || o.name === 'border' || o.name === 'borderstyle' ? dn(e, t, r) : o.name === 'fileinput' ? mn(e, t, n, r) : o.name === 'isDecorative' && (r.getData().isDecorative ? r.disable('alt') : r.enable('alt')) } }; const hn = function (e) { return function () { e.open = !1 } }; const pn = function (e) { if (e.hasAdvTab || e.hasUploadUrl || e.hasUploadHandler) { const t = { type: 'tabpanel', tabs: T([[Wt.makeTab(e)], e.hasAdvTab ? [Ft.makeTab(e)] : [], e.hasUploadTab && (e.hasUploadUrl || e.hasUploadHandler) ? [$t.makeTab(e)] : []]) }; return t } const n = { type: 'panel', items: Wt.makeItems(e) }; return n }; const vn = function (e) { return function (t) { const n = Gt(t); return { title: 'Insert/Edit Image', size: 'normal', body: pn(t), buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: Xt(t.image), onSubmit: e.onSubmit(t), onChange: gn(e, t, n), onClose: hn(n) } } }; const bn = function (e) { return function (t) { return function (n) { const r = te(Xt(t.image), n.getData()); e.undoManager.transact(function () { Ot(e, Yt(r), t) }), e.editorUpload.uploadImagesAuto(), n.close() } } }; const yn = function (e) { return function (t) { return J.nu(function (n) { Fe.getImageSize(e.documentBaseURI.toAbsolute(t), function (e) { const t = e.map(function (e) { return { width: String(e.width), height: String(e.height) } }); n(t) }) }) } }; const wn = function (e) { return function (t, n, r) { return e.editorUpload.blobCache.create({ blob: t, blobUri: n, name: t.name ? t.name.replace(/\.[^\.]+$/, '') : null, base64: r.split(',')[1] }) } }; const xn = function (e) { return function (t) { e.editorUpload.blobCache.add(t) } }; const Cn = function (e) { return function (t, n) { e.windowManager.alert(n, t.close) } }; const Sn = function (e) { return function (t) { return yt(e, t) } }; const kn = function (e) { return function (t) { return e.dom.parseStyle(t) } }; const Tn = function (e) { return function (t, n) { return e.dom.serializeStyle(t, n) } }; const En = function (e) { const t = { onSubmit: bn(e), imageSize: yn(e), addToBlobCache: xn(e), createBlobCache: wn(e), alertErr: Cn(e), normalizeCss: Sn(e), parseStyle: kn(e), serializeStyle: Tn(e) }; const n = function () { return Vt(e).map(vn(t)).get(function (t) { e.windowManager.open(t) }) }; return { open: n } }; const On = function (e) { e.addCommand('mceImage', En(e).open) }; const Nn = { register: On }; const _n = function (e) { const t = e.attr('class'); return t && /\bimage\b/.test(t) }; const Dn = function (e) { return function (t) { let n = t.length; const r = function (t) { t.attr('contenteditable', e ? 'true' : null) }; while (n--) { const o = t[n]; _n(o) && (o.attr('contenteditable', e ? 'false' : null), Nt.each(o.getAll('figcaption'), r)) } } }; const An = function (e) { e.on('PreInit', function () { e.parser.addNodeFilter('figure', Dn(!0)), e.serializer.addNodeFilter('figure', Dn(!1)) }) }; const Rn = { setup: An }; const Bn = function (e) { e.ui.registry.addToggleButton('image', { icon: 'image', tooltip: 'Insert/edit image', onAction: En(e).open, onSetup (t) { return e.selection.selectorChangedWithUnbind('img:not([data-mce-object],[data-mce-placeholder]),figure.image', t.setActive).unbind } }), e.ui.registry.addMenuItem('image', { icon: 'image', text: 'Image...', onAction: En(e).open }), e.ui.registry.addContextMenu('image', { update (e) { return ut(e) || at(e) && !Fe.isPlaceholderImage(e) ? ['image'] : [] } }) }; const Mn = { register: Bn }; function Pn () { n.add('image', function (e) { Rn.setup(e), Mn.register(e), Nn.register(e) }) }Pn() })(window) }).call(this, n('c8ba')) }, dbbc (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = function (e) { e.addCommand('InsertHorizontalRule', function () { e.execCommand('mceInsertContent', !1, '<hr />') }) }; const n = { register: t }; const r = function (e) { e.ui.registry.addButton('hr', { icon: 'horizontal-rule', tooltip: 'Horizontal line', onAction () { return e.execCommand('InsertHorizontalRule') } }), e.ui.registry.addMenuItem('hr', { icon: 'horizontal-rule', text: 'Horizontal line', onAction () { return e.execCommand('InsertHorizontalRule') } }) }; const o = { register: r }; function i () { e.add('hr', function (e) { n.register(e), o.register(e) }) }i() })() }, e2d6 (e, t) { (function (e) { 'use strict'; const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const n = tinymce.util.Tools.resolve('tinymce.util.Tools'); const r = function (e, t) { let r; const o = e.dom; const i = e.selection.getSelectedBlocks(); i.length && (r = o.getAttrib(i[0], 'dir'), n.each(i, function (e) { o.getParent(e.parentNode, '*[dir="' + t + '"]', o.getRoot()) || o.setAttrib(e, 'dir', r !== t ? t : null) }), e.nodeChanged()) }; const o = { setDir: r }; const i = function (e) { e.addCommand('mceDirectionLTR', function () { o.setDir(e, 'ltr') }), e.addCommand('mceDirectionRTL', function () { o.setDir(e, 'rtl') }) }; const u = { register: i }; const a = function () {}; const c = function (e) { return function () { return e } }; const s = c(!1); const l = c(!0); const f = function () { return d }; var d = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const r = { fold (e, t) { return e() }, is: s, isSome: s, isNone: l, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: c(null), getOrUndefined: c(void 0), or: n, orThunk: t, map: f, each: a, bind: f, exists: s, forall: l, filter: f, equals: e, equals_: e, toArray () { return [] }, toString: c('none()') }; return Object.freeze && Object.freeze(r), r }()); var m = function (e) { const t = c(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: l, isNone: s, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return m(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : d }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(s, function (t) { return n(e, t) }) } }; return o }; const g = function (e) { return e === null || void 0 === e ? d : m(e) }; const h = { some: m, none: f, from: g }; const p = function (t, n) { const r = n || e.document; const o = r.createElement('div'); if (o.innerHTML = t, !o.hasChildNodes() || o.childNodes.length > 1) { throw e.console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node') } return y(o.childNodes[0]) }; const v = function (t, n) { const r = n || e.document; const o = r.createElement(t); return y(o) }; const b = function (t, n) { const r = n || e.document; const o = r.createTextNode(t); return y(o) }; var y = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: c(e) } }; const w = function (e, t, n) { const r = e.dom(); return h.from(r.elementFromPoint(t, n)).map(y) }; const x = { fromHtml: p, fromTag: v, fromText: b, fromDom: y, fromPoint: w }; const C = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const S = function (e) { return function (t) { return C(t) === e } }; const k = S('function'); const T = Array.prototype.slice; const E = (k(Array.from) && Array.from, function (e) { return void 0 !== e.style && k(e.style.getPropertyValue) }); const O = (e.Node.ATTRIBUTE_NODE, e.Node.CDATA_SECTION_NODE, e.Node.COMMENT_NODE, e.Node.DOCUMENT_NODE, e.Node.DOCUMENT_TYPE_NODE, e.Node.DOCUMENT_FRAGMENT_NODE, e.Node.ELEMENT_NODE, e.Node.TEXT_NODE); const N = (e.Node.PROCESSING_INSTRUCTION_NODE, e.Node.ENTITY_REFERENCE_NODE, e.Node.ENTITY_NODE, e.Node.NOTATION_NODE, typeof e.window !== 'undefined' ? e.window : Function('return this;')(), function (e) { return e.dom().nodeType }); const _ = function (e) { return function (t) { return N(t) === e } }; const D = _(O); const A = function (e) { const t = D(e) ? e.dom().parentNode : e.dom(); return void 0 !== t && t !== null && t.ownerDocument.body.contains(t) }; const R = function (t, n) { const r = t.dom(); const o = e.window.getComputedStyle(r); const i = o.getPropertyValue(n); const u = i !== '' || A(t) ? i : B(r, n); return u === null ? void 0 : u }; var B = function (e, t) { return E(e) ? e.style.getPropertyValue(t) : '' }; const M = function (e) { return R(e, 'direction') === 'rtl' ? 'rtl' : 'ltr' }; const P = function (e, t) { return function (n) { const r = function (e) { const r = x.fromDom(e.element); n.setActive(M(r) === t) }; return e.on('NodeChange', r), function () { return e.off('NodeChange', r) } } }; const z = function (e) { e.ui.registry.addToggleButton('ltr', { tooltip: 'Left to right', icon: 'ltr', onAction () { return e.execCommand('mceDirectionLTR') }, onSetup: P(e, 'ltr') }), e.ui.registry.addToggleButton('rtl', { tooltip: 'Right to left', icon: 'rtl', onAction () { return e.execCommand('mceDirectionRTL') }, onSetup: P(e, 'rtl') }) }; const I = { register: z }; function L () { t.add('directionality', function (e) { u.register(e), I.register(e) }) }L() })(window) }, e562 (e, t, n) { (function (t) { (function (n) { 'use strict'; const r = function () {}; const o = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return e(t.apply(null, n)) } }; const i = function (e) { return function () { return e } }; const u = function (e) { return e }; function a (e) { for (var t = [], n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } const o = t.concat(n); return e.apply(null, o) } } const c = function (e) { return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } return !e.apply(null, t) } }; const s = function (e) { return function () { throw new Error(e) } }; const l = i(!1); const f = i(!0); const d = function () { return m }; var m = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const o = { fold (e, t) { return e() }, is: l, isSome: l, isNone: f, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: i(null), getOrUndefined: i(void 0), or: n, orThunk: t, map: d, each: r, bind: d, exists: l, forall: f, filter: d, equals: e, equals_: e, toArray () { return [] }, toString: i('none()') }; return Object.freeze && Object.freeze(o), o }()); var g = function (e) { const t = i(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: f, isNone: l, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return g(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : m }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(l, function (t) { return n(e, t) }) } }; return o }; const h = function (e) { return e === null || void 0 === e ? m : g(e) }; const p = { some: g, none: d, from: h }; const v = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const b = function (e) { return function (t) { return v(t) === e } }; const y = b('string'); const w = b('object'); const x = b('array'); const C = b('null'); const S = b('boolean'); const k = b('function'); const T = b('number'); const E = Array.prototype.slice; const O = Array.prototype.indexOf; const N = Array.prototype.push; const _ = function (e, t) { return O.call(e, t) }; const D = function (e, t) { const n = _(e, t); return n === -1 ? p.none() : p.some(n) }; const A = function (e, t) { return _(e, t) > -1 }; const R = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return !0 } } return !1 }; const B = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const M = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const P = function (e, t) { for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; t(r, n) } }; const z = function (e, t) { for (var n = [], r = [], o = 0, i = e.length; o < i; o++) { const u = e[o]; const a = t(u, o) ? n : r; a.push(u) } return { pass: n, fail: r } }; const I = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const L = function (e, t, n) { return P(e, function (e) { n = t(n, e) }), n }; const H = function (e, t, n) { return M(e, function (e) { n = t(n, e) }), n }; const F = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return p.some(o) } } return p.none() }; const V = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return p.some(n) } } return p.none() }; const U = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!x(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } N.apply(t, e[n]) } return t }; const j = function (e, t) { return U(B(e, t)) }; const W = function (e, t) { for (let n = 0, r = e.length; n < r; ++n) { const o = e[n]; if (!0 !== t(o, n)) { return !1 } } return !0 }; const q = function (e) { const t = E.call(e, 0); return t.reverse(), t }; const $ = function (e, t) { return I(e, function (e) { return !A(t, e) }) }; const G = function (e, t) { for (var n = {}, r = 0, o = e.length; r < o; r++) { const i = e[r]; n[String(i)] = t(i, r) } return n }; const X = function (e, t) { const n = E.call(e, 0); return n.sort(t), n }; const Y = function (e) { return e.length === 0 ? p.none() : p.some(e[0]) }; const K = function (e) { return e.length === 0 ? p.none() : p.some(e[e.length - 1]) }; const J = k(Array.from) ? Array.from : function (e) { return E.call(e) }; const Z = Object.keys; const Q = Object.hasOwnProperty; const ee = function (e, t) { for (let n = Z(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; t(u, i) } }; const te = function (e, t) { return ne(e, function (e, n) { return { k: n, v: t(e, n) } }) }; var ne = function (e, t) { const n = {}; return ee(e, function (e, r) { const o = t(e, r); n[o.k] = o.v }), n }; const re = function (e) { return function (t, n) { e[n] = t } }; const oe = function (e, t, n, r) { const o = {}; return ee(e, function (e, o) { (t(e, o) ? n : r)(e, o) }), o }; const ie = function (e, t) { const n = {}; const r = {}; return oe(e, t, re(n), re(r)), { t: n, f: r } }; const ue = function (e, t) { const n = {}; return oe(e, t, re(n), r), n }; const ae = function (e, t) { return ce(e, t) ? p.from(e[t]) : p.none() }; var ce = function (e, t) { return Q.call(e, t) }; var se = function () { return se = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { for (const o in t = arguments[n], t) { Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]) } } return e }, se.apply(this, arguments) }; function le (e, t) { const n = {}; for (var r in e) { Object.prototype.hasOwnProperty.call(e, r) && !t.includes(r) && (n[r] = e[r]) } if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let o = 0; for (r = Object.getOwnPropertySymbols(e); o < r.length; o++) { !t.includes(r[o]) && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]) } } return n } function fe () { for (var e = 0, t = 0, n = arguments.length; t < n; t++) { e += arguments[t].length } const r = Array(e); let o = 0; for (t = 0; t < n; t++) { for (let i = arguments[t], u = 0, a = i.length; u < a; u++, o++) { r[o] = i[u] } } return r } const de = function (e, t) { const r = t || n.document; const o = r.createElement('div'); if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) { throw n.console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node') } return he(o.childNodes[0]) }; const me = function (e, t) { const r = t || n.document; const o = r.createElement(e); return he(o) }; const ge = function (e, t) { const r = t || n.document; const o = r.createTextNode(e); return he(o) }; var he = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: i(e) } }; const pe = function (e, t, n) { const r = e.dom(); return p.from(r.elementFromPoint(t, n)).map(he) }; const ve = { fromHtml: de, fromTag: me, fromText: ge, fromDom: he, fromPoint: pe }; var be = function (e) { let t = e; const n = function () { return t }; const r = function (e) { t = e }; const o = function () { return be(n()) }; return { get: n, set: r, clone: o } }; const ye = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const we = function (e, t) { const n = ye(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return Se(r(1), r(2)) }; const xe = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? Ce() : we(e, n) }; var Ce = function () { return Se(0, 0) }; var Se = function (e, t) { return { major: e, minor: t } }; const ke = { nu: Se, detect: xe, unknown: Ce }; const Te = 'Edge'; const Ee = 'Chrome'; const Oe = 'IE'; const Ne = 'Opera'; const _e = 'Firefox'; const De = 'Safari'; const Ae = function (e, t) { return function () { return t === e } }; const Re = function () { return Be({ current: void 0, version: ke.unknown() }) }; var Be = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: Ae(Te, t), isChrome: Ae(Ee, t), isIE: Ae(Oe, t), isOpera: Ae(Ne, t), isFirefox: Ae(_e, t), isSafari: Ae(De, t) } }; const Me = { unknown: Re, nu: Be, edge: i(Te), chrome: i(Ee), ie: i(Oe), opera: i(Ne), firefox: i(_e), safari: i(De) }; const Pe = 'Windows'; const ze = 'iOS'; const Ie = 'Android'; const Le = 'Linux'; const He = 'OSX'; const Fe = 'Solaris'; const Ve = 'FreeBSD'; const Ue = 'ChromeOS'; const je = function (e, t) { return function () { return t === e } }; const We = function () { return qe({ current: void 0, version: ke.unknown() }) }; var qe = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: je(Pe, t), isiOS: je(ze, t), isAndroid: je(Ie, t), isOSX: je(He, t), isLinux: je(Le, t), isSolaris: je(Fe, t), isFreeBSD: je(Ve, t), isChromeOS: je(Ue, t) } }; const $e = { unknown: We, nu: qe, windows: i(Pe), ios: i(ze), android: i(Ie), linux: i(Le), osx: i(He), solaris: i(Fe), freebsd: i(Ve), chromeos: i(Ue) }; const Ge = function (e, t, n, r) { const o = e.isiOS() && !0 === /ipad/i.test(n); const u = e.isiOS() && !o; const a = e.isiOS() || e.isAndroid(); const c = a || r('(pointer:coarse)'); const s = o || !u && a && r('(min-device-width:768px)'); const l = u || a && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: i(o), isiPhone: i(u), isTablet: i(s), isPhone: i(l), isTouch: i(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: i(f), isDesktop: i(d) } }; const Xe = function (e, t) { const n = String(t).toLowerCase(); return F(e, function (e) { return e.search(n) }) }; const Ye = function (e, t) { return Xe(e, t).map(function (e) { const n = ke.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Ke = function (e, t) { return Xe(e, t).map(function (e) { const n = ke.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Je = { detectBrowser: Ye, detectOs: Ke }; const Ze = function (e, t, n) { if (t === '') { return !0 } if (e.length < t.length) { return !1 } const r = e.substr(n, n + t.length); return r === t }; const Qe = function (e, t) { return e.includes(t) }; const et = function (e, t) { return Ze(e, t, 0) }; const tt = function (e) { return e.replace(/^\s+|\s+$/g, '') }; const nt = function (e) { return e.replace(/^\s+/g, '') }; const rt = function (e) { return e.replace(/\s+$/g, '') }; const ot = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const it = function (e) { return function (t) { return Qe(t, e) } }; const ut = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return Qe(e, 'edge/') && Qe(e, 'chrome') && Qe(e, 'safari') && Qe(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, ot], search (e) { return Qe(e, 'chrome') && !Qe(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return Qe(e, 'msie') || Qe(e, 'trident') } }, { name: 'Opera', versionRegexes: [ot, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: it('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: it('firefox') }, { name: 'Safari', versionRegexes: [ot, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (Qe(e, 'safari') || Qe(e, 'mobile/')) && Qe(e, 'applewebkit') } }]; const at = [{ name: 'Windows', search: it('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return Qe(e, 'iphone') || Qe(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: it('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: it('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: it('linux'), versionRegexes: [] }, { name: 'Solaris', search: it('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: it('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: it('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const ct = { browsers: i(ut), oses: i(at) }; const st = function (e, t) { const n = ct.browsers(); const r = ct.oses(); const o = Je.detectBrowser(n, e).fold(Me.unknown, Me.nu); const i = Je.detectOs(r, e).fold($e.unknown, $e.nu); const u = Ge(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const lt = { detect: st }; const ft = function (e) { return n.window.matchMedia(e).matches }; const dt = be(lt.detect(n.navigator.userAgent, ft)); const mt = function () { return dt.get() }; const gt = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } if (e.length !== t.length) { throw new Error('Wrong number of arguments to struct. Expected "[' + e.length + ']", got ' + t.length + ' arguments') } const r = {}; return M(e, function (e, n) { r[e] = i(t[n]) }), r } }; const ht = function (e, t) { const n = []; const r = function (e) { return n.push(e), t(e) }; let o = t(e); do { o = o.bind(r) } while (o.isSome()); return n }; const pt = { toArray: ht }; const vt = function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }; const bt = function (e, t) { return vt(e, t, n.Node.DOCUMENT_POSITION_PRECEDING) }; const yt = function (e, t) { return vt(e, t, n.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const wt = { documentPositionPreceding: bt, documentPositionContainedBy: yt }; const xt = (n.Node.ATTRIBUTE_NODE, n.Node.CDATA_SECTION_NODE, n.Node.COMMENT_NODE, n.Node.DOCUMENT_NODE); const Ct = (n.Node.DOCUMENT_TYPE_NODE, n.Node.DOCUMENT_FRAGMENT_NODE, n.Node.ELEMENT_NODE); const St = n.Node.TEXT_NODE; const kt = (n.Node.PROCESSING_INSTRUCTION_NODE, n.Node.ENTITY_REFERENCE_NODE, n.Node.ENTITY_NODE, n.Node.NOTATION_NODE, Ct); const Tt = xt; const Et = function (e, t) { const n = e.dom(); if (n.nodeType !== kt) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const Ot = function (e) { return e.nodeType !== kt && e.nodeType !== Tt || e.childElementCount === 0 }; const Nt = function (e, t) { const r = void 0 === t ? n.document : t.dom(); return Ot(r) ? [] : B(r.querySelectorAll(e), ve.fromDom) }; const _t = function (e, t) { const r = void 0 === t ? n.document : t.dom(); return Ot(r) ? p.none() : p.from(r.querySelector(e)).map(ve.fromDom) }; const Dt = function (e, t) { return e.dom() === t.dom() }; const At = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const Rt = function (e, t) { return wt.documentPositionContainedBy(e.dom(), t.dom()) }; const Bt = mt().browser; const Mt = Bt.isIE() ? Rt : At; const Pt = function (e) { return ve.fromDom(e.dom().ownerDocument) }; const zt = function (e) { return ve.fromDom(e.dom().ownerDocument.documentElement) }; const It = function (e) { return ve.fromDom(e.dom().ownerDocument.defaultView) }; const Lt = function (e) { return p.from(e.dom().parentNode).map(ve.fromDom) }; const Ht = function (e, t) { const n = k(t) ? t : l; let r = e.dom(); const o = []; while (r.parentNode !== null && void 0 !== r.parentNode) { const i = r.parentNode; const u = ve.fromDom(i); if (o.push(u), !0 === n(u)) { break } r = i } return o }; const Ft = function (e) { return p.from(e.dom().previousSibling).map(ve.fromDom) }; const Vt = function (e) { return p.from(e.dom().nextSibling).map(ve.fromDom) }; const Ut = function (e) { return q(pt.toArray(e, Ft)) }; const jt = function (e) { return pt.toArray(e, Vt) }; const Wt = function (e) { return B(e.dom().childNodes, ve.fromDom) }; const qt = function (e, t) { const n = e.dom().childNodes; return p.from(n[t]).map(ve.fromDom) }; const $t = function (e) { return qt(e, 0) }; const Gt = function (e) { return qt(e, e.dom().childNodes.length - 1) }; const Xt = function (e) { return e.dom().childNodes.length }; const Yt = (gt('element', 'offset'), function (e, t) { const n = Lt(e); n.each(function (n) { n.dom().insertBefore(t.dom(), e.dom()) }) }); const Kt = function (e, t) { const n = Vt(e); n.fold(function () { const n = Lt(e); n.each(function (e) { Zt(e, t) }) }, function (e) { Yt(e, t) }) }; const Jt = function (e, t) { const n = $t(e); n.fold(function () { Zt(e, t) }, function (n) { e.dom().insertBefore(t.dom(), n.dom()) }) }; var Zt = function (e, t) { e.dom().appendChild(t.dom()) }; const Qt = function (e, t) { Yt(e, t), Zt(t, e) }; const en = function (e, t) { M(t, function (t) { Yt(e, t) }) }; const tn = function (e, t) { M(t, function (t) { Zt(e, t) }) }; const nn = function (e) { e.dom().textContent = '', M(Wt(e), function (e) { rn(e) }) }; var rn = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const on = function (e) { const t = Wt(e); t.length > 0 && en(e, t), rn(e) }; const un = (typeof n.window !== 'undefined' ? n.window : Function('return this;')(), function (e) { const t = e.dom().nodeName; return t.toLowerCase() }); const an = function (e) { return e.dom().nodeType }; const cn = function (e) { return function (t) { return an(t) === e } }; const sn = cn(Ct); const ln = cn(St); const fn = function (e) { const t = ln(e) ? e.dom().parentNode : e.dom(); return void 0 !== t && t !== null && t.ownerDocument.body.contains(t) }; var dn = function (e, t) { const n = function (n, r) { return dn(e + n, t + r) }; return { left: i(e), top: i(t), translate: n } }; const mn = dn; const gn = function (e) { const t = e.getBoundingClientRect(); return mn(t.left, t.top) }; const hn = function (e, t) { return void 0 !== e ? e : void 0 !== t ? t : 0 }; const pn = function (e) { const t = e.dom().ownerDocument; const n = t.body; const r = t.defaultView; const o = t.documentElement; if (n === e.dom()) { return mn(n.offsetLeft, n.offsetTop) } const i = hn(r.pageYOffset, o.scrollTop); const u = hn(r.pageXOffset, o.scrollLeft); const a = hn(o.clientTop, n.clientTop); const c = hn(o.clientLeft, n.clientLeft); return vn(e).translate(u - c, i - a) }; var vn = function (e) { const t = e.dom(); const n = t.ownerDocument; const r = n.body; return r === t ? mn(r.offsetLeft, r.offsetTop) : fn(e) ? gn(t) : mn(0, 0) }; const bn = mt().browser.isSafari(); const yn = function (e) { const t = void 0 !== e ? e.dom() : n.document; const r = t.body.scrollLeft || t.documentElement.scrollLeft; const o = t.body.scrollTop || t.documentElement.scrollTop; return mn(r, o) }; const wn = function (e, t, r) { const o = void 0 !== r ? r.dom() : n.document; const i = o.defaultView; i.scrollTo(e, t) }; const xn = function (e, t) { bn && k(e.dom().scrollIntoViewIfNeeded) ? e.dom().scrollIntoViewIfNeeded(!1) : e.dom().scrollIntoView(t) }; const Cn = function (e) { const t = void 0 === e ? n.window : e; return p.from(t.visualViewport) }; const Sn = function (e, t, n, r) { return { x: i(e), y: i(t), width: i(n), height: i(r), right: i(e + n), bottom: i(t + r) } }; const kn = function (e) { const t = void 0 === e ? n.window : e; const r = t.document; const o = yn(ve.fromDom(r)); return Cn(t).fold(function () { const e = t.document.documentElement; const n = e.clientWidth; const r = e.clientHeight; return Sn(o.left(), o.top(), n, r) }, function (e) { return Sn(Math.max(e.pageLeft, o.left()), Math.max(e.pageTop, o.top()), e.width, e.height) }) }; const Tn = function (e) { return function (t) { return !!t && t.nodeType === e } }; const En = function (e) { return !!e && !Object.getPrototypeOf(e) }; const On = Tn(1); const Nn = function (e) { const t = e.map(function (e) { return e.toLowerCase() }); return function (e) { if (e && e.nodeName) { const n = e.nodeName.toLowerCase(); return A(t, n) } return !1 } }; const _n = function (e, t) { const n = t.toLowerCase().split(' '); return function (t) { let r, o; if (On(t)) { for (r = 0; r < n.length; r++) { const i = t.ownerDocument.defaultView.getComputedStyle(t, null); if (o = i ? i.getPropertyValue(e) : null, o === n[r]) { return !0 } } } return !1 } }; const Dn = function (e, t) { return function (n) { return On(n) && n[e] === t } }; const An = function (e, t) { return function (t) { return On(t) && t.hasAttribute(e) } }; const Rn = function (e, t) { return function (n) { return On(n) && n.getAttribute(e) === t } }; const Bn = function (e) { return On(e) && e.hasAttribute('data-mce-bogus') }; const Mn = function (e) { return On(e) && e.getAttribute('data-mce-bogus') === 'all' }; const Pn = function (e) { return On(e) && e.tagName === 'TABLE' }; const zn = function (e) { return function (t) { if (On(t)) { if (t.contentEditable === e) { return !0 } if (t.getAttribute('data-mce-contenteditable') === e) { return !0 } } return !1 } }; const In = Nn(['textarea', 'input']); const Ln = Tn(3); const Hn = Tn(8); const Fn = Tn(9); const Vn = Tn(11); const Un = Nn(['br']); const jn = zn('true'); const Wn = zn('false'); const qn = { isText: Ln, isElement: On, isComment: Hn, isDocument: Fn, isDocumentFragment: Vn, isBr: Un, isContentEditableTrue: jn, isContentEditableFalse: Wn, isRestrictedNode: En, matchNodeNames: Nn, hasPropValue: Dn, hasAttribute: An, hasAttributeValue: Rn, matchStyleValues: _n, isBogus: Bn, isBogusAll: Mn, isTable: Pn, isTextareaOrInput: In }; const $n = function (e) { return void 0 !== e.style && k(e.style.getPropertyValue) }; const Gn = function (e, t, r) { if (!(y(r) || S(r) || T(r))) { throw n.console.error('Invalid call to Attr.set. Key ', t, ':: Value ', r, ':: Element ', e), new Error('Attribute value was not simple') } e.setAttribute(t, r + '') }; const Xn = function (e, t, n) { Gn(e.dom(), t, n) }; const Yn = function (e, t) { const n = e.dom(); ee(t, function (e, t) { Gn(n, t, e) }) }; const Kn = function (e, t) { const n = e.dom().getAttribute(t); return n === null ? void 0 : n }; const Jn = function (e, t) { return p.from(Kn(e, t)) }; const Zn = function (e, t) { const n = e.dom(); return !(!n || !n.hasAttribute) && n.hasAttribute(t) }; const Qn = function (e, t) { e.dom().removeAttribute(t) }; const er = function (e, t) { const r = e.dom(); const o = n.window.getComputedStyle(r); const i = o.getPropertyValue(t); const u = i !== '' || fn(e) ? i : tr(r, t); return u === null ? void 0 : u }; var tr = function (e, t) { return $n(e) ? e.style.getPropertyValue(t) : '' }; const nr = function (e, t) { const n = e.dom(); const r = tr(n, t); return p.from(r).filter(function (e) { return e.length > 0 }) }; const rr = function (e) { const t = {}; const n = e.dom(); if ($n(n)) { for (let r = 0; r < n.style.length; r++) { const o = n.style.item(r); t[o] = n.style[o] } } return t }; const or = function (e) { return e.dom().offsetWidth }; const ir = mt().browser; const ur = function (e) { return F(e, sn) }; const ar = function (e) { return ir.isFirefox() && un(e) === 'table' ? ur(Wt(e)).filter(function (e) { return un(e) === 'caption' }).bind(function (e) { return ur(jt(e)).map(function (t) { const n = t.dom().offsetTop; const r = e.dom().offsetTop; const o = e.dom().offsetHeight; return n <= r ? -o : 0 }) }).getOr(0) : 0 }; const cr = function (e, t) { return e.children && A(e.children, t) }; const sr = function (e, t, n) { let r; let o; let i = 0; let u = 0; const a = e.ownerDocument; if (n = n || e, t) { if (n === e && t.getBoundingClientRect && er(ve.fromDom(e), 'position') === 'static') { return o = t.getBoundingClientRect(), i = o.left + (a.documentElement.scrollLeft || e.scrollLeft) - a.documentElement.clientLeft, u = o.top + (a.documentElement.scrollTop || e.scrollTop) - a.documentElement.clientTop, { x: i, y: u } } r = t; while (r && r !== n && r.nodeType && !cr(r, n)) { i += r.offsetLeft || 0, u += r.offsetTop || 0, r = r.offsetParent }r = t.parentNode; while (r && r !== n && r.nodeType && !cr(r, n)) { i -= r.scrollLeft || 0, u -= r.scrollTop || 0, r = r.parentNode }u += ar(ve.fromDom(t)) } return { x: i, y: u } }; const lr = { getPos: sr }; const fr = {}; const dr = { exports: fr }; (function (e, n, r, o) { (function (o) { if (typeof n === 'object' && typeof r !== 'undefined') { r.exports = o() } else if (typeof e === 'function' && e.amd) { e([], o) } else { let i; i = typeof window !== 'undefined' ? window : typeof t !== 'undefined' ? t : typeof self !== 'undefined' ? self : this, i.EphoxContactWrapper = o() } })(function () { return (function () { function e (t, n, r) { function i (a, c) { if (!n[a]) { if (!t[a]) { const s = typeof o === 'function' && o; if (!c && s) { return s(a, !0) } if (u) { return u(a, !0) } const l = new Error("Cannot find module '" + a + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const f = n[a] = { exports: {} }; t[a][0].call(f.exports, function (e) { const n = t[a][1][e]; return i(n || e) }, f, f.exports, e, t, n, r) } return n[a].exports } for (var u = typeof o === 'function' && o, a = 0; a < r.length; a++) { i(r[a]) } return i } return e }())({ 1: [function (e, t, n) { let r; let o; const i = t.exports = {}; function u () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function c (e) { if (r === setTimeout) { return setTimeout(e, 0) } if ((r === u || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0) } try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function s (e) { if (o === clearTimeout) { return clearTimeout(e) } if ((o === a || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e) } try { return o(e) } catch (t) { try { return o.call(null, e) } catch (t) { return o.call(this, e) } } }(function () { try { r = typeof setTimeout === 'function' ? setTimeout : u } catch (e) { r = u } try { o = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { o = a } })(); let l; let f = []; let d = !1; let m = -1; function g () { d && l && (d = !1, l.length ? f = l.concat(f) : m = -1, f.length && h()) } function h () { if (!d) { const e = c(g); d = !0; let t = f.length; while (t) { l = f, f = []; while (++m < t) { l && l[m].run() }m = -1, t = f.length }l = null, d = !1, s(e) } } function p (e, t) { this.fun = e, this.array = t } function v () {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } }f.push(new p(e, t)), f.length !== 1 || d || c(h) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = v, i.addListener = v, i.once = v, i.off = v, i.removeListener = v, i.removeAllListeners = v, i.emit = v, i.prependListener = v, i.prependOnceListener = v, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, {}], 2: [function (e, t, n) { (function (e) { (function (n) { const r = setTimeout; function o () {} function i (e, t) { return function () { e.apply(t, arguments) } } function u (e) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof e !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], d(e, this) } function a (e, t) { while (e._state === 3) { e = e._value }e._state !== 0 ? (e._handled = !0, u._immediateFn(function () { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let r; try { r = n(e._value) } catch (o) { return void s(t.promise, o) }c(t.promise, r) } else { (e._state === 1 ? c : s)(t.promise, e._value) } })) : e._deferreds.push(t) } function c (e, t) { try { if (t === e) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof u) { return e._state = 3, e._value = t, void l(e) } if (typeof n === 'function') { return void d(i(n, t), e) } }e._state = 1, e._value = t, l(e) } catch (r) { s(e, r) } } function s (e, t) { e._state = 2, e._value = t, l(e) } function l (e) { e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function () { e._handled || u._unhandledRejectionFn(e._value) }); for (let t = 0, n = e._deferreds.length; t < n; t++) { a(e, e._deferreds[t]) }e._deferreds = null } function f (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n } function d (e, t) { let n = !1; try { e(function (e) { n || (n = !0, c(t, e)) }, function (e) { n || (n = !0, s(t, e)) }) } catch (r) { if (n) { return } n = !0, s(t, r) } }u.prototype.catch = function (e) { return this.then(null, e) }, u.prototype.then = function (e, t) { const n = new this.constructor(o); return a(this, new f(e, t, n)), n }, u.all = function (e) { const t = Array.prototype.slice.call(e); return new u(function (e, n) { if (t.length === 0) { return e([]) } let r = t.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }t[i] = u, --r === 0 && e(t) } catch (c) { n(c) } } for (let i = 0; i < t.length; i++) { o(i, t[i]) } }) }, u.resolve = function (e) { return e && typeof e === 'object' && e.constructor === u ? e : new u(function (t) { t(e) }) }, u.reject = function (e) { return new u(function (t, n) { n(e) }) }, u.race = function (e) { return new u(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, u._immediateFn = typeof e === 'function' ? function (t) { e(t) } : function (e) { r(e, 0) }, u._unhandledRejectionFn = function (e) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', e) }, u._setImmediateFn = function (e) { u._immediateFn = e }, u._setUnhandledRejectionFn = function (e) { u._unhandledRejectionFn = e }, typeof t !== 'undefined' && t.exports ? t.exports = u : n.Promise || (n.Promise = u) })(this) }).call(this, e('timers').setImmediate) }, { timers: 3 }], 3: [function (e, t, n) { (function (t, r) { const o = e('process/browser.js').nextTick; const i = Function.prototype.apply; const u = Array.prototype.slice; const a = {}; let c = 0; function s (e, t) { this._id = e, this._clearFn = t }n.setTimeout = function () { return new s(i.call(setTimeout, window, arguments), clearTimeout) }, n.setInterval = function () { return new s(i.call(setInterval, window, arguments), clearInterval) }, n.clearTimeout = n.clearInterval = function (e) { e.close() }, s.prototype.unref = s.prototype.ref = function () {}, s.prototype.close = function () { this._clearFn.call(window, this._id) }, n.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, n.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, n._unrefActive = n.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(function () { e._onTimeout && e._onTimeout() }, t)) }, n.setImmediate = typeof t === 'function' ? t : function (e) { const t = c++; const r = !(arguments.length < 2) && u.call(arguments, 1); return a[t] = !0, o(function () { a[t] && (r ? e.apply(null, r) : e.call(null), n.clearImmediate(t)) }), t }, n.clearImmediate = typeof r === 'function' ? r : function (e) { delete a[e] } }).call(this, e('timers').setImmediate, e('timers').clearImmediate) }, { 'process/browser.js': 1, timers: 3 }], 4: [function (e, t, n) { const r = e('promise-polyfill'); const o = (function () { return typeof window !== 'undefined' ? window : Function('return this;')() }()); t.exports = { boltExport: o.Promise || r } }, { 'promise-polyfill': 2 }] }, {}, [4])(4) }) })(void 0, fr, dr, void 0); let mr; const gr = dr.exports.boltExport; var hr = function (e) { let t = p.none(); let r = []; const o = function (e) { return hr(function (t) { i(function (n) { t(e(n)) }) }) }; var i = function (e) { a() ? s(e) : r.push(e) }; const u = function (e) { t = p.some(e), c(r), r = [] }; var a = function () { return t.isSome() }; var c = function (e) { M(e, s) }; var s = function (e) { t.each(function (t) { n.setTimeout(function () { e(t) }, 0) }) }; return e(u), { get: i, map: o, isReady: a } }; const pr = function (e) { return hr(function (t) { t(e) }) }; const vr = { nu: hr, pure: pr }; const br = function (e) { n.setTimeout(function () { throw e }, 0) }; var yr = function (e) { const t = function (t) { e().then(t, br) }; const n = function (t) { return yr(function () { return e().then(t) }) }; const r = function (t) { return yr(function () { return e().then(function (e) { return t(e).toPromise() }) }) }; const o = function (t) { return yr(function () { return e().then(function () { return t.toPromise() }) }) }; const i = function () { return vr.nu(t) }; const u = function () { let t = null; return yr(function () { return t === null && (t = e()), t }) }; const a = e; return { map: n, bind: r, anonBind: o, toLazy: i, toCached: u, toPromise: a, get: t } }; const wr = function (e) { return yr(function () { return new gr(e) }) }; const xr = function (e) { return yr(function () { return gr.resolve(e) }) }; const Cr = { nu: wr, pure: xr }; const Sr = function (e, t) { return t(function (t) { const n = []; let r = 0; const o = function (o) { return function (i) { n[o] = i, r++, r >= e.length && t(n) } }; e.length === 0 ? t([]) : M(e, function (e, t) { e.get(o(t)) }) }) }; const kr = function (e) { return Sr(e, Cr.nu) }; var Tr = function (e) { const t = function (t) { return e === t }; const n = function (t) { return Tr(e) }; const r = function (t) { return Tr(e) }; const o = function (t) { return Tr(t(e)) }; const u = function (t) { return Tr(e) }; const a = function (t) { t(e) }; const c = function (t) { return t(e) }; const s = function (t, n) { return n(e) }; const d = function (t) { return t(e) }; const m = function (t) { return t(e) }; const g = function () { return p.some(e) }; return { is: t, isValue: f, isError: l, getOr: i(e), getOrThunk: i(e), getOrDie: i(e), or: n, orThunk: r, fold: s, map: o, mapError: u, each: a, bind: c, exists: d, forall: m, toOption: g } }; var Er = function (e) { const t = function (e) { return e() }; const n = function () { return s(String(e))() }; const o = function (e) { return e }; const i = function (e) { return e() }; const a = function (t) { return Er(e) }; const c = function (t) { return Er(t(e)) }; const d = function (t) { return Er(e) }; const m = function (t, n) { return t(e) }; return { is: l, isValue: l, isError: f, getOr: u, getOrThunk: t, getOrDie: n, or: o, orThunk: i, fold: m, map: a, mapError: c, each: r, bind: d, exists: l, forall: f, toOption: p.none } }; const Or = function (e, t) { return e.fold(function () { return Er(t) }, Tr) }; const Nr = { value: Tr, error: Er, fromOption: Or }; const _r = function () { function e (e, t) { return function () { e.apply(t, arguments) } } const t = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]' }; const r = function (t) { if (typeof this !== 'object') { throw new TypeError('Promises must be constructed via new') } if (typeof t !== 'function') { throw new TypeError('not a function') } this._state = null, this._value = null, this._deferreds = [], l(t, e(u, this), e(a, this)) }; const o = r.immediateFn || typeof n.setImmediate === 'function' && n.setImmediate || function (e) { n.setTimeout(e, 1) }; function i (e) { const t = this; this._state !== null ? o(function () { const n = t._state ? e.onFulfilled : e.onRejected; if (n !== null) { let r; try { r = n(t._value) } catch (o) { return void e.reject(o) }e.resolve(r) } else { (t._state ? e.resolve : e.reject)(t._value) } }) : this._deferreds.push(e) } function u (t) { try { if (t === this) { throw new TypeError('A promise cannot be resolved with itself.') } if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (typeof n === 'function') { return void l(e(n, t), e(u, this), e(a, this)) } } this._state = !0, this._value = t, c.call(this) } catch (r) { a.call(this, r) } } function a (e) { this._state = !1, this._value = e, c.call(this) } function c () { for (let e = 0, t = this._deferreds.length; e < t; e++) { i.call(this, this._deferreds[e]) } this._deferreds = null } function s (e, t, n, r) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.resolve = n, this.reject = r } function l (e, t, n) { let r = !1; try { e(function (e) { r || (r = !0, t(e)) }, function (e) { r || (r = !0, n(e)) }) } catch (o) { if (r) { return } r = !0, n(o) } } return r.prototype.catch = function (e) { return this.then(null, e) }, r.prototype.then = function (e, t) { const n = this; return new r(function (r, o) { i.call(n, new s(e, t, r, o)) }) }, r.all = function () { const e = Array.prototype.slice.call(arguments.length === 1 && t(arguments[0]) ? arguments[0] : arguments); return new r(function (t, n) { if (e.length === 0) { return t([]) } let r = e.length; function o (i, u) { try { if (u && (typeof u === 'object' || typeof u === 'function')) { const a = u.then; if (typeof a === 'function') { return void a.call(u, function (e) { o(i, e) }, n) } }e[i] = u, --r === 0 && t(e) } catch (c) { n(c) } } for (let i = 0; i < e.length; i++) { o(i, e[i]) } }) }, r.resolve = function (e) { return e && typeof e === 'object' && e.constructor === r ? e : new r(function (t) { t(e) }) }, r.reject = function (e) { return new r(function (t, n) { n(e) }) }, r.race = function (e) { return new r(function (t, n) { for (let r = 0, o = e.length; r < o; r++) { e[r].then(t, n) } }) }, r }; const Dr = window.Promise ? window.Promise : _r(); const Ar = function (e, t) { let r; let o = n.window.requestAnimationFrame; const i = ['ms', 'moz', 'webkit']; const u = function (e) { n.window.setTimeout(e, 0) }; for (r = 0; r < i.length && !o; r++) { o = n.window[i[r] + 'RequestAnimationFrame'] }o || (o = u), o(e, t) }; const Rr = function (e, t) { return typeof t !== 'number' && (t = 0), n.setTimeout(e, t) }; const Br = function (e, t) { return typeof t !== 'number' && (t = 1), n.setInterval(e, t) }; const Mr = function (e) { return n.clearTimeout(e) }; const Pr = function (e) { return n.clearInterval(e) }; const zr = function (e, t) { let r, o; return o = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }n.clearTimeout(r), r = Rr(function () { e.apply(this, o) }, t) }, o.stop = function () { n.clearTimeout(r) }, o }; const Ir = { requestAnimationFrame (e, t) { mr ? mr.then(e) : mr = new Dr(function (e) { t || (t = n.document.body), Ar(e, t) }).then(e) }, setTimeout: Rr, setInterval: Br, setEditorTimeout (e, t, n) { return Rr(function () { e.removed || t() }, n) }, setEditorInterval (e, t, r) { let o; return o = Br(function () { e.removed ? n.clearInterval(o) : t() }, r), o }, debounce: zr, throttle: zr, clearInterval: Pr, clearTimeout: Mr }; const Lr = n.navigator.userAgent; const Hr = mt(); const Fr = Hr.browser; const Vr = Hr.os; const Ur = Hr.deviceType; const jr = /WebKit/.test(Lr) && !Fr.isEdge(); const Wr = 'FormData' in n.window && 'FileReader' in n.window && 'URL' in n.window && !!n.URL.createObjectURL; const qr = Lr.includes('Windows Phone'); const $r = { opera: Fr.isOpera(), webkit: jr, ie: !(!Fr.isIE() && !Fr.isEdge()) && Fr.version.major, gecko: Fr.isFirefox(), mac: Vr.isOSX() || Vr.isiOS(), iOS: Ur.isiPad() || Ur.isiPhone(), android: Vr.isAndroid(), contentEditable: !0, transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', caretAfter: !0, range: n.window.getSelection && 'Range' in n.window, documentMode: Fr.isIE() ? n.document.documentMode || 7 : 10, fileApi: Wr, ceFalse: !0, cacheSuffix: null, container: null, experimentalShadowDom: !1, canHaveCSP: !Fr.isIE(), desktop: Ur.isDesktop(), windowsPhone: qr, browser: { current: Fr.current, version: Fr.version, isChrome: Fr.isChrome, isEdge: Fr.isEdge, isFirefox: Fr.isFirefox, isIE: Fr.isIE, isOpera: Fr.isOpera, isSafari: Fr.isSafari }, os: { current: Vr.current, version: Vr.version, isAndroid: Vr.isAndroid, isChromeOS: Vr.isChromeOS, isFreeBSD: Vr.isFreeBSD, isiOS: Vr.isiOS, isLinux: Vr.isLinux, isOSX: Vr.isOSX, isSolaris: Vr.isSolaris, isWindows: Vr.isWindows }, deviceType: { isDesktop: Ur.isDesktop, isiPad: Ur.isiPad, isiPhone: Ur.isiPhone, isPhone: Ur.isPhone, isTablet: Ur.isTablet, isTouch: Ur.isTouch, isWebView: Ur.isWebView } }; const Gr = Array.isArray; const Xr = function (e) { let t; let n; let r = e; if (!Gr(e)) { for (r = [], t = 0, n = e.length; t < n; t++) { r[t] = e[t] } } return r }; const Yr = function (e, t, n) { let r, o; if (!e) { return 0 } if (n = n || e, void 0 !== e.length) { for (r = 0, o = e.length; r < o; r++) { if (!1 === t.call(n, e[r], r, e)) { return 0 } } } else { for (r in e) { if (e.hasOwnProperty(r) && !1 === t.call(n, e[r], r, e)) { return 0 } } } return 1 }; const Kr = function (e, t) { const n = []; return Yr(e, function (r, o) { n.push(t(r, o, e)) }), n }; const Jr = function (e, t) { const n = []; return Yr(e, function (r, o) { t && !t(r, o, e) || n.push(r) }), n }; const Zr = function (e, t) { let n, r; if (e) { for (n = 0, r = e.length; n < r; n++) { if (e[n] === t) { return n } } } return -1 }; const Qr = function (e, t, n, r) { let o = 0; for (arguments.length < 3 && (n = e[0]); o < e.length; o++) { n = t.call(r, n, e[o], o) } return n }; const eo = function (e, t, n) { let r, o; for (r = 0, o = e.length; r < o; r++) { if (t.call(n, e[r], r, e)) { return r } } return -1 }; const to = function (e, t, n) { const r = eo(e, t, n); if (r !== -1) { return e[r] } }; const no = function (e) { return e[e.length - 1] }; const ro = { isArray: Gr, toArray: Xr, each: Yr, map: Kr, filter: Jr, indexOf: Zr, reduce: Qr, findIndex: eo, find: to, last: no }; const oo = /^\s*|\s*$/g; const io = function (e) { return e === null || void 0 === e ? '' : ('' + e).replace(oo, '') }; const uo = function (e, t) { return t ? !(t !== 'array' || !ro.isArray(e)) || typeof e === t : void 0 !== e }; const ao = function (e, t, n) { let r; e = e || [], t = t || ',', typeof e === 'string' && (e = e.split(t)), n = n || {}, r = e.length; while (r--) { n[e[r]] = {} } return n }; const co = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }; const so = function (e, t, n) { let r; let o; let i; let u; let a; const c = this; let s = 0; if (e = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(e), i = e[3].match(/(^|\.)(\w+)$/i)[2], o = c.createNS(e[3].replace(/\.\w+$/, ''), n), !o[i]) { if (e[2] === 'static') { return o[i] = t, void (this.onCreate && this.onCreate(e[2], e[3], o[i])) } t[i] || (t[i] = function () {}, s = 1), o[i] = t[i], c.extend(o[i].prototype, t), e[5] && (r = c.resolve(e[5]).prototype, u = e[5].match(/\.(\w+)$/i)[1], a = o[i], o[i] = s ? function () { return r[u].apply(this, arguments) } : function () { return this.parent = r[u], a.apply(this, arguments) }, o[i].prototype[i] = o[i], c.each(r, function (e, t) { o[i].prototype[t] = r[t] }), c.each(t, function (e, t) { r[t] ? o[i].prototype[t] = function () { return this.parent = r[t], e.apply(this, arguments) } : t !== i && (o[i].prototype[t] = e) })), c.each(t.static, function (e, t) { o[i][t] = e }) } }; const lo = function (e, t) { for (var n, r, o, i = [], u = 2; u < arguments.length; u++) { i[u - 2] = arguments[u] } let a; const c = arguments; for (n = 1, r = c.length; n < r; n++) { for (o in t = c[n], t) { t.hasOwnProperty(o) && (a = t[o], void 0 !== a && (e[o] = a)) } } return e }; var fo = function (e, t, n, r) { r = r || this, e && (n && (e = e[n]), ro.each(e, function (e, o) { if (!1 === t.call(r, e, o, n)) { return !1 } fo(e, t, n, r) })) }; const mo = function (e, t) { let r, o; for (t = t || n.window, e = e.split('.'), r = 0; r < e.length; r++) { o = e[r], t[o] || (t[o] = {}), t = t[o] } return t }; const go = function (e, t) { let r, o; for (t = t || n.window, e = e.split('.'), r = 0, o = e.length; r < o; r++) { if (t = t[e[r]], !t) { break } } return t }; const ho = function (e, t) { return !e || uo(e, 'array') ? e : ro.map(e.split(t || ','), io) }; const po = function (e) { const t = $r.cacheSuffix; return t && (e += (!e.includes('?') ? '?' : '&') + t), e }; const vo = { trim: io, isArray: ro.isArray, is: uo, toArray: ro.toArray, makeMap: ao, each: ro.each, map: ro.map, grep: ro.filter, inArray: ro.indexOf, hasOwn: co, extend: lo, create: so, walk: fo, createNS: mo, resolve: go, explode: ho, _addCacheSuffix: po }; function bo (e, t) { void 0 === t && (t = {}); let r; let a = 0; const c = {}; r = t.maxLoadTime || 5e3; const s = function (e) { t.referrerPolicy = e }; const l = function (t) { e.getElementsByTagName('head')[0].appendChild(t) }; const f = function (o, i, u) { let s; let f; let d; let m; const g = function (e) { m.status = e, m.passed = [], m.failed = [], s && (s.onload = null, s.onerror = null, s = null) }; const h = function () { const e = m.passed; let t = e.length; while (t--) { e[t]() }g(2) }; const p = function () { const e = m.failed; let t = e.length; while (t--) { e[t]() }g(3) }; const v = function () { const e = n.navigator.userAgent.match(/WebKit\/(\d*)/); return !!(e && parseInt(e[1], 10) < 536) }; const b = function (e, t) { e() || ((new Date()).getTime() - d < r ? Ir.setTimeout(t) : p()) }; var y = function () { b(function () { let t; let n; const r = e.styleSheets; let o = r.length; while (o--) { if (t = r[o], n = t.ownerNode ? t.ownerNode : t.owningElement, n && n.id === s.id) { return h(), !0 } } }, y) }; var w = function () { b(function () { try { const e = f.sheet.cssRules; return h(), !!e } catch (t) {} }, w) }; if (o = vo._addCacheSuffix(o), c[o] ? m = c[o] : (m = { passed: [], failed: [] }, c[o] = m), i && m.passed.push(i), u && m.failed.push(u), m.status !== 1) { if (m.status !== 2) { if (m.status !== 3) { if (m.status = 1, s = e.createElement('link'), s.rel = 'stylesheet', s.type = 'text/css', s.id = 'u' + a++, s.async = !1, s.defer = !1, d = (new Date()).getTime(), t.contentCssCors && (s.crossOrigin = 'anonymous'), t.referrerPolicy && Xn(ve.fromDom(s), 'referrerpolicy', t.referrerPolicy), 'onload' in s && !v()) { s.onload = y, s.onerror = p } else { if (n.navigator.userAgent.indexOf('Firefox') > 0) { return f = e.createElement('style'), f.textContent = '@import "' + o + '"', w(), void l(f) } y() }l(s), s.href = o } else { p() } } else { h() } } }; const d = function (e) { return Cr.nu(function (t) { f(e, o(t, i(Nr.value(e))), o(t, i(Nr.error(e)))) }) }; const m = function (e) { return e.fold(u, u) }; const g = function (e, t, n) { kr(B(e, d)).get(function (e) { const r = z(e, function (e) { return e.isValue() }); r.fail.length > 0 ? n(r.fail.map(m)) : t(r.pass.map(m)) }) }; return { load: f, loadAll: g, _setReferrerPolicy: s } } let yo; let wo; let xo; const Co = ['article', 'aside', 'details', 'div', 'dt', 'figcaption', 'footer', 'form', 'fieldset', 'header', 'hgroup', 'html', 'main', 'nav', 'section', 'summary', 'body', 'p', 'dl', 'multicol', 'dd', 'figure', 'address', 'center', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'listing', 'xmp', 'pre', 'plaintext', 'menu', 'dir', 'ul', 'ol', 'li', 'hr', 'table', 'tbody', 'thead', 'tfoot', 'th', 'tr', 'td', 'caption']; const So = ['area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'img', 'input', 'isindex', 'link', 'meta', 'param', 'embed', 'source', 'wbr', 'track']; const ko = ['td', 'th']; const To = ['thead', 'tbody', 'tfoot']; const Eo = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form', 'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article', 'section', 'hgroup', 'aside', 'nav', 'figure']; const Oo = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']; const No = ['li', 'dd', 'dt']; const _o = ['ul', 'ol', 'dl']; const Do = ['pre', 'script', 'textarea', 'style']; const Ao = function (e) { let t; return function (n) { return t = t || G(e, i(!0)), t.hasOwnProperty(un(n)) } }; const Ro = Ao(Oo); const Bo = Ao(Co); const Mo = function (e) { return un(e) === 'table' }; const Po = function (e) { return sn(e) && !Bo(e) }; const zo = function (e) { return sn(e) && un(e) === 'br' }; const Io = Ao(Eo); const Lo = Ao(_o); const Ho = Ao(No); const Fo = Ao(So); const Vo = Ao(To); const Uo = Ao(ko); const jo = Ao(Do); const Wo = function (e) { const t = e.previousSibling && e.previousSibling.nodeName === 'SPAN'; const n = e.nextSibling && e.nextSibling.nodeName === 'SPAN'; return t && n }; const qo = function (e) { return e && e.tagName === 'SPAN' && e.getAttribute('data-mce-type') === 'bookmark' }; var $o = function (e, t) { let n; let r = t.childNodes; if (!qn.isElement(t) || !qo(t)) { for (n = r.length - 1; n >= 0; n--) { $o(e, r[n]) } if (!1 === qn.isDocument(t)) { if (qn.isText(t) && t.nodeValue.length > 0) { const o = vo.trim(t.nodeValue).length; if (e.isBlock(t.parentNode) || o > 0) { return } if (o === 0 && Wo(t)) { return } } else if (qn.isElement(t) && (r = t.childNodes, r.length === 1 && qo(r[0]) && t.parentNode.insertBefore(r[0], t), r.length || Fo(ve.fromDom(t)))) { return } e.remove(t) } return t } }; const Go = { trimNode: $o }; const Xo = vo.makeMap; const Yo = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g; const Ko = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g; const Jo = /[<>&\"\']/g; const Zo = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi; const Qo = { 128: '€', 130: '‚', 131: 'ƒ', 132: '„', 133: '…', 134: '†', 135: '‡', 136: 'ˆ', 137: '‰', 138: 'Š', 139: '‹', 140: 'Œ', 142: 'Ž', 145: '‘', 146: '’', 147: '“', 148: '”', 149: '•', 150: '–', 151: '—', 152: '˜', 153: '™', 154: 'š', 155: '›', 156: 'œ', 158: 'ž', 159: 'Ÿ' }; wo = { '"': '&quot;', "'": '&#39;', '<': '&lt;', '>': '&gt;', '&': '&amp;', '`': '&#96;' }, xo = { '&lt;': '<', '&gt;': '>', '&amp;': '&', '&quot;': '"', '&apos;': "'" }; const ei = function (e) { let t; return t = ve.fromTag('div').dom(), t.innerHTML = e, t.textContent || t.textContent || e }; const ti = function (e, t) { let n; let r; let o; const i = {}; if (e) { for (e = e.split(','), t = t || 10, n = 0; n < e.length; n += 2) { r = String.fromCharCode(parseInt(e[n], t)), wo[r] || (o = '&' + e[n + 1] + ';', i[r] = o, i[o] = r) } return i } }; yo = ti('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32); const ni = function (e, t) { return e.replace(t ? Yo : Ko, function (e) { return wo[e] || e }) }; const ri = function (e) { return ('' + e).replace(Jo, function (e) { return wo[e] || e }) }; const oi = function (e, t) { return e.replace(t ? Yo : Ko, function (e) { return e.length > 1 ? '&#' + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ';' : wo[e] || '&#' + e.charCodeAt(0) + ';' }) }; const ii = function (e, t, n) { return n = n || yo, e.replace(t ? Yo : Ko, function (e) { return wo[e] || n[e] || e }) }; const ui = function (e, t) { const n = ti(t) || yo; const r = function (e, t) { return e.replace(t ? Yo : Ko, function (e) { return void 0 !== wo[e] ? wo[e] : void 0 !== n[e] ? n[e] : e.length > 1 ? '&#' + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ';' : '&#' + e.charCodeAt(0) + ';' }) }; const o = function (e, t) { return ii(e, t, n) }; const i = Xo(e.replace(/\+/g, ',')); return i.named && i.numeric ? r : i.named ? t ? o : ii : i.numeric ? oi : ni }; const ai = function (e) { return e.replace(Zo, function (e, t) { return t ? (t = t.charAt(0).toLowerCase() === 'x' ? parseInt(t.substr(1), 16) : parseInt(t, 10), t > 65535 ? (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) : Qo[t] || String.fromCharCode(t)) : xo[e] || yo[e] || ei(e) }) }; const ci = { encodeRaw: ni, encodeAllRaw: ri, encodeNumeric: oi, encodeNamed: ii, getEncodeFunc: ui, decode: ai }; const si = {}; const li = {}; const fi = vo.makeMap; const di = vo.each; const mi = vo.extend; const gi = vo.explode; const hi = vo.inArray; const pi = function (e, t) { return e = vo.trim(e), e ? e.split(t || ' ') : [] }; const vi = function (e) { let t; let n; let r; let o; let i; let u; const a = {}; const c = function (e, n, r) { let o; let i; let u; const c = function (e, t) { let n; let r; const o = {}; for (n = 0, r = e.length; n < r; n++) { o[e[n]] = t || {} } return o }; r = r || [], n = n || '', typeof r === 'string' && (r = pi(r)), e = pi(e), o = e.length; while (o--) { i = pi([t, n].join(' ')), u = { attributes: c(i), attributesOrder: i, children: c(r, li) }, a[e[o]] = u } }; const s = function (e, t) { let n, r, o, i; e = pi(e), n = e.length, t = pi(t); while (n--) { for (r = a[e[n]], o = 0, i = t.length; o < i; o++) { r.attributes[t[o]] = {}, r.attributesOrder.push(t[o]) } } }; return si[e] ? si[e] : (t = 'id accesskey class dir lang style tabindex title role', n = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul', r = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment', e !== 'html4' && (t += ' contenteditable contextmenu draggable dropzone hidden spellcheck translate', n += ' article aside details dialog figure main header footer hgroup section nav', r += ' audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen'), e !== 'html5-strict' && (t += ' xml:lang', u = 'acronym applet basefont big font strike tt', r = [r, u].join(' '), di(pi(u), function (e) { c(e, '', r) }), i = 'center dir isindex noframes', n = [n, i].join(' '), o = [n, r].join(' '), di(pi(i), function (e) { c(e, '', o) })), o = o || [n, r].join(' '), c('html', 'manifest', 'head body'), c('head', '', 'base command link meta noscript script style title'), c('title hr noscript br'), c('base', 'href target'), c('link', 'href rel media hreflang type sizes hreflang'), c('meta', 'name http-equiv content charset'), c('style', 'media type scoped'), c('script', 'src async defer type charset'), c('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload', o), c('address dt dd div caption', '', o), c('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', r), c('blockquote', 'cite', o), c('ol', 'reversed start type', 'li'), c('ul', '', 'li'), c('li', 'value', o), c('dl', '', 'dt dd'), c('a', 'href target rel media hreflang type', r), c('q', 'cite', r), c('ins del', 'cite datetime', o), c('img', 'src sizes srcset alt usemap ismap width height'), c('iframe', 'src name width height', o), c('embed', 'src type width height'), c('object', 'data type typemustmatch name usemap form width height', [o, 'param'].join(' ')), c('param', 'name value'), c('map', 'name', [o, 'area'].join(' ')), c('area', 'alt coords shape href target rel media hreflang type'), c('table', 'border', 'caption colgroup thead tfoot tbody tr' + (e === 'html4' ? ' col' : '')), c('colgroup', 'span', 'col'), c('col', 'span'), c('tbody thead tfoot', '', 'tr'), c('tr', '', 'td th'), c('td', 'colspan rowspan headers', o), c('th', 'colspan rowspan headers scope abbr', o), c('form', 'accept-charset action autocomplete enctype method name novalidate target', o), c('fieldset', 'disabled form name', [o, 'legend'].join(' ')), c('label', 'form for', r), c('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width'), c('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', e === 'html4' ? o : r), c('select', 'disabled form multiple name required size', 'option optgroup'), c('optgroup', 'disabled label', 'option'), c('option', 'disabled label selected value'), c('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap'), c('menu', 'type label', [o, 'li'].join(' ')), c('noscript', '', o), e !== 'html4' && (c('wbr'), c('ruby', '', [r, 'rt rp'].join(' ')), c('figcaption', '', o), c('mark rt rp summary bdi', '', r), c('canvas', 'width height', o), c('video', 'src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered', [o, 'track source'].join(' ')), c('audio', 'src crossorigin preload autoplay mediagroup loop muted controls buffered volume', [o, 'track source'].join(' ')), c('picture', '', 'img source'), c('source', 'src srcset type media sizes'), c('track', 'kind src srclang label default'), c('datalist', '', [r, 'option'].join(' ')), c('article section nav aside main header footer', '', o), c('hgroup', '', 'h1 h2 h3 h4 h5 h6'), c('figure', '', [o, 'figcaption'].join(' ')), c('time', 'datetime', r), c('dialog', 'open', o), c('command', 'type label icon disabled checked radiogroup command'), c('output', 'for form name', r), c('progress', 'value max', r), c('meter', 'value min max low high optimum', r), c('details', 'open', [o, 'summary'].join(' ')), c('keygen', 'autofocus challenge disabled form keytype name')), e !== 'html5-strict' && (s('script', 'language xml:space'), s('style', 'xml:space'), s('object', 'declare classid code codebase codetype archive standby align border hspace vspace'), s('embed', 'align name hspace vspace'), s('param', 'valuetype type'), s('a', 'charset name rev shape coords'), s('br', 'clear'), s('applet', 'codebase archive code object alt name width height align hspace vspace'), s('img', 'name longdesc align border hspace vspace'), s('iframe', 'longdesc frameborder marginwidth marginheight scrolling align'), s('font basefont', 'size color face'), s('input', 'usemap align'), s('select'), s('textarea'), s('h1 h2 h3 h4 h5 h6 div p legend caption', 'align'), s('ul', 'type compact'), s('li', 'type'), s('ol dl menu dir', 'compact'), s('pre', 'width xml:space'), s('hr', 'align noshade size width'), s('isindex', 'prompt'), s('table', 'summary width frame rules cellspacing cellpadding align bgcolor'), s('col', 'width align char charoff valign'), s('colgroup', 'width align char charoff valign'), s('thead', 'align char charoff valign'), s('tr', 'align char charoff valign bgcolor'), s('th', 'axis align char charoff valign nowrap bgcolor width height'), s('form', 'accept'), s('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height'), s('tfoot', 'align char charoff valign'), s('tbody', 'align char charoff valign'), s('area', 'nohref'), s('body', 'background bgcolor text link vlink alink')), e !== 'html4' && (s('input button select textarea', 'autofocus'), s('input textarea', 'placeholder'), s('a', 'download'), s('link script img', 'crossorigin'), s('img', 'loading'), s('iframe', 'sandbox seamless allowfullscreen loading')), di(pi('a form meter progress dfn'), function (e) { a[e] && delete a[e].children[e] }), delete a.caption.children.table, delete a.script, si[e] = a, a) }; const bi = function (e, t) { let n; return e && (n = {}, typeof e === 'string' && (e = { '*': e }), di(e, function (e, r) { n[r] = n[r.toUpperCase()] = t === 'map' ? fi(e, /[, ]/) : gi(e, /[, ]/) })), n }; function yi (e) { let t; let n; let r; let o; let i; let u; let a; let c; let s; let l; let f; let d; let m; let g = {}; const h = {}; let p = []; const v = {}; const b = {}; const y = function (t, n, r) { let o = e[t]; return o ? o = fi(o, /[, ]/, fi(o.toUpperCase(), /[, ]/)) : (o = si[t], o || (o = fi(n, ' ', fi(n.toUpperCase(), ' ')), o = mi(o, r), si[t] = o)), o }; e = e || {}, r = vi(e.schema), !1 === e.verify_html && (e.valid_elements = '*[*]'), t = bi(e.valid_styles), n = bi(e.invalid_styles, 'map'), c = bi(e.valid_classes, 'map'), o = y('whitespace_elements', 'pre script noscript style textarea video audio iframe object code'), i = y('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr'), u = y('short_ended_elements', 'area base basefont br col frame hr img input isindex link meta param embed source wbr track'), a = y('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls'), l = y('non_empty_elements', 'td th iframe video audio object script pre code', u), f = y('move_caret_before_on_enter_elements', 'table', l), d = y('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure'), s = y('block_elements', 'hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary', d), m = y('text_inline_elements', 'span strong b em i font strike u var cite dfn code mark q sup sub samp'), di((e.special || 'script noscript noframes noembed title style textarea xmp').split(' '), function (e) { b[e] = new RegExp('</' + e + '[^>]*>', 'gi') }); const w = function (e) { return new RegExp('^' + e.replace(/([?+*])/g, '.$1') + '$') }; const x = function (e) { let t; let n; let r; let o; let i; let u; let a; let c; let s; let l; let f; let d; let m; let h; let v; let b; let y; let x; let C; const S = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/; const k = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/; const T = /[*?+]/; if (e) { for (e = pi(e, ','), g['@'] && (b = g['@'].attributes, y = g['@'].attributesOrder), t = 0, n = e.length; t < n; t++) { if (i = S.exec(e[t]), i) { if (h = i[1], s = i[2], v = i[3], c = i[5], d = {}, m = [], u = { attributes: d, attributesOrder: m }, h === '#' && (u.paddEmpty = !0), h === '-' && (u.removeEmpty = !0), i[4] === '!' && (u.removeEmptyAttrs = !0), b) { for (x in b) { d[x] = b[x] }m.push.apply(m, y) } if (c) { for (c = pi(c, '|'), r = 0, o = c.length; r < o; r++) { if (i = k.exec(c[r]), i) { if (a = {}, f = i[1], l = i[2].replace(/[\\:]:/g, ':'), h = i[3], C = i[4], f === '!' && (u.attributesRequired = u.attributesRequired || [], u.attributesRequired.push(l), a.required = !0), f === '-') { delete d[l], m.splice(hi(m, l), 1); continue }h && (h === '=' && (u.attributesDefault = u.attributesDefault || [], u.attributesDefault.push({ name: l, value: C }), a.defaultValue = C), h === ':' && (u.attributesForced = u.attributesForced || [], u.attributesForced.push({ name: l, value: C }), a.forcedValue = C), h === '<' && (a.validValues = fi(C, '?'))), T.test(l) ? (u.attributePatterns = u.attributePatterns || [], a.pattern = w(l), u.attributePatterns.push(a)) : (d[l] || m.push(l), d[l] = a) } } }b || s !== '@' || (b = d, y = m), v && (u.outputName = s, g[v] = u), T.test(s) ? (u.pattern = w(s), p.push(u)) : g[s] = u } } } }; const C = function (e) { g = {}, p = [], x(e), di(r, function (e, t) { h[t] = e.children }) }; const S = function (e) { const t = /^(~)?(.+)$/; e && (si.text_block_elements = si.block_elements = null, di(pi(e, ','), function (e) { const n = t.exec(e); const r = n[1] === '~'; const o = r ? 'span' : 'div'; const i = n[2]; if (h[i] = h[o], v[i] = o, r || (s[i.toUpperCase()] = {}, s[i] = {}), !g[i]) { let u = g[o]; u = mi({}, u), delete u.removeEmptyAttrs, delete u.removeEmpty, g[i] = u }di(h, function (e, t) { e[o] && (h[t] = e = mi({}, h[t]), e[i] = e[o]) }) })) }; const k = function (t) { const n = /^([+\-]?)(\w+)\[([^\]]+)\]$/; si[e.schema] = null, t && di(pi(t, ','), function (e) { let t; let r; const o = n.exec(e); o && (r = o[1], t = r ? h[o[2]] : h[o[2]] = { '#comment': {} }, t = h[o[2]], di(pi(o[3], '|'), function (e) { r === '-' ? delete t[e] : t[e] = {} })) }) }; const T = function (e) { let t; let n = g[e]; if (n) { return n } t = p.length; while (t--) { if (n = p[t], n.pattern.test(e)) { return n } } }; e.valid_elements ? C(e.valid_elements) : (di(r, function (e, t) { g[t] = { attributes: e.attributes, attributesOrder: e.attributesOrder }, h[t] = e.children }), e.schema !== 'html5' && di(pi('strong/b em/i'), function (e) { e = pi(e, '/'), g[e[1]].outputName = e[0] }), di(pi('ol ul sub sup blockquote span font a table tbody tr strong em b i'), function (e) { g[e] && (g[e].removeEmpty = !0) }), di(pi('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), function (e) { g[e].paddEmpty = !0 }), di(pi('span'), function (e) { g[e].removeEmptyAttrs = !0 })), S(e.custom_elements), k(e.valid_children), x(e.extended_valid_elements), k('+ol[ul|ol],+ul[ul|ol]'), di({ dd: 'dl', dt: 'dl', li: 'ul ol', td: 'tr', th: 'tr', tr: 'tbody thead tfoot', tbody: 'table', thead: 'table', tfoot: 'table', legend: 'fieldset', area: 'map', param: 'video audio object' }, function (e, t) { g[t] && (g[t].parentsRequired = pi(e)) }), e.invalid_elements && di(gi(e.invalid_elements), function (e) { g[e] && delete g[e] }), T('span') || x('span[!data-mce-type|*]'); const E = function () { return t }; const O = function () { return n }; const N = function () { return c }; const _ = function () { return a }; const D = function () { return s }; const A = function () { return d }; const R = function () { return m }; const B = function () { return u }; const M = function () { return i }; const P = function () { return l }; const z = function () { return f }; const I = function () { return o }; const L = function () { return b }; const H = function (e, t) { const n = h[e.toLowerCase()]; return !(!n || !n[t.toLowerCase()]) }; const F = function (e, t) { let n; let r; const o = T(e); if (o) { if (!t) { return !0 } if (o.attributes[t]) { return !0 } if (n = o.attributePatterns, n) { r = n.length; while (r--) { if (n[r].pattern.test(e)) { return !0 } } } } return !1 }; const V = function () { return v }; return { children: h, elements: g, getValidStyles: E, getValidClasses: N, getBlockElements: D, getInvalidStyles: O, getShortEndedElements: B, getTextBlockElements: A, getTextInlineElements: R, getBoolAttrs: _, getElementRule: T, getSelfClosingElements: M, getNonEmptyElements: P, getMoveCaretBeforeOnEnterElements: z, getWhiteSpaceElements: I, getSpecialElements: L, isValidChild: H, isValid: F, getCustomElements: V, addValidElements: x, setValidElements: C, addCustomElements: S, addValidChildren: k } } let wi; let xi; let Ci; let Si; let ki; let Ti; let Ei; let Oi; let Ni; let _i; let Di; let Ai; let Ri; let Bi; let Mi; let Pi; let zi; let Ii; let Li; const Hi = '\uFEFF'; const Fi = ' '; const Vi = function (e, t, n, r) { const o = function (e) { return e = parseInt(e, 10).toString(16), e.length > 1 ? e : '0' + e }; return '#' + o(t) + o(n) + o(r) }; const Ui = function (e, t) { let n; let r; let o; let i; const u = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi; const a = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi; const c = /\s*([^:]+):\s*([^;]+);?/g; const s = /\s+$/; const l = {}; const f = Hi; for (e = e || {}, t && (o = t.getValidStyles(), i = t.getInvalidStyles()), r = ("\\\" \\' \\; \\: ; : " + f).split(' '), n = 0; n < r.length; n++) { l[r[n]] = f + n, l[f + n] = r[n] } return { toHex (e) { return e.replace(u, Vi) }, parse (t) { let r; let o; let i; let d; const m = {}; const g = e.url_converter; const h = e.url_converter_scope || this; const p = function (e, t, r) { let o, i, u, a; if (o = m[e + '-top' + t], o && (i = m[e + '-right' + t], i && (u = m[e + '-bottom' + t], u && (a = m[e + '-left' + t], a)))) { const c = [o, i, u, a]; n = c.length - 1; while (n--) { if (c[n] !== c[n + 1]) { break } } n > -1 && r || (m[e + t] = n === -1 ? c[0] : c.join(' '), delete m[e + '-top' + t], delete m[e + '-right' + t], delete m[e + '-bottom' + t], delete m[e + '-left' + t]) } }; const v = function (e) { let t; let n = m[e]; if (n) { n = n.split(' '), t = n.length; while (t--) { if (n[t] !== n[0]) { return !1 } } return m[e] = n[0], !0 } }; const b = function (e, t, n, r) { v(t) && v(n) && v(r) && (m[e] = m[t] + ' ' + m[n] + ' ' + m[r], delete m[t], delete m[n], delete m[r]) }; const y = function (e) { return d = !0, l[e] }; const w = function (e, t) { return d && (e = e.replace(/\uFEFF[0-9]/g, function (e) { return l[e] })), t || (e = e.replace(/\\([\'\";:])/g, '$1')), e }; const x = function (e) { return String.fromCharCode(parseInt(e.slice(1), 16)) }; const C = function (e) { return e.replace(/\\[0-9a-f]+/gi, x) }; const S = function (t, n, r, o, i, u) { if (i = i || u, i) { return i = w(i), "'" + i.replace(/\'/g, "\\'") + "'" } if (n = w(n || r || o), !e.allow_script_urls) { const a = n.replace(/[\s\r\n]+/g, ''); if (/(java|vb)script:/i.test(a)) { return '' } if (!e.allow_svg_data_urls && /^data:image\/svg/i.test(a)) { return '' } } return g && (n = g.call(h, n, 'style')), "url('" + n.replace(/\'/g, "\\'") + "')" }; if (t) { t = t.replace(/[\u0000-\u001F]/g, ''), t = t.replace(/\\[\"\';:\uFEFF]/g, y).replace(/\"[^\"]+\"|\'[^\']+\'/g, function (e) { return e.replace(/[;:]/g, y) }); while (r = c.exec(t)) { if (c.lastIndex = r.index + r[0].length, o = r[1].replace(s, '').toLowerCase(), i = r[2].replace(s, ''), o && i) { if (o = C(o), i = C(i), o.includes(f) || o.includes('"')) { continue } if (!e.allow_script_urls && (o === 'behavior' || /expression\s*\(|\/\*|\*\//.test(i))) { continue } o === 'font-weight' && i === '700' ? i = 'bold' : o !== 'color' && o !== 'background-color' || (i = i.toLowerCase()), i = i.replace(u, Vi), i = i.replace(a, S), m[o] = d ? w(i, !0) : i } }p('border', '', !0), p('border', '-width'), p('border', '-color'), p('border', '-style'), p('padding', ''), p('margin', ''), b('border', 'border-width', 'border-style', 'border-color'), m.border === 'medium none' && delete m.border, m['border-image'] === 'none' && delete m['border-image'] } return m }, serialize (e, t) { let n; let r; let u = ''; const a = function (t) { let n, r, i, a; if (n = o[t], n) { for (r = 0, i = n.length; r < i; r++) { t = n[r], a = e[t], a && (u += (u.length > 0 ? ' ' : '') + t + ': ' + a + ';') } } }; const c = function (e, t) { let n; return n = i['*'], (!n || !n[e]) && (n = i[t], !n || !n[e]) }; if (t && o) { a('*'), a(t) } else { for (n in e) { r = e[n], !r || i && !c(n, t) || (u += (u.length > 0 ? ' ' : '') + n + ': ' + r + ';') } } return u } } }; const ji = 'mce-data-'; const Wi = /^(?:mouse|contextmenu)|click/; const qi = { keyLocation: 1, layerX: 1, layerY: 1, returnValue: 1, webkitMovementX: 1, webkitMovementY: 1, keyIdentifier: 1, mozPressure: 1 }; const $i = function (e) { return e.isDefaultPrevented === Xi || e.isDefaultPrevented === Gi }; var Gi = function () { return !1 }; var Xi = function () { return !0 }; const Yi = function (e, t, n, r) { e.addEventListener ? e.addEventListener(t, n, r || !1) : e.attachEvent && e.attachEvent('on' + t, n) }; const Ki = function (e, t, n, r) { e.removeEventListener ? e.removeEventListener(t, n, r || !1) : e.detachEvent && e.detachEvent('on' + t, n) }; const Ji = function (e, t) { if (e.composedPath) { const n = e.composedPath(); if (n && n.length > 0) { return n[0] } } return t }; const Zi = function (e, t) { let r; const o = t || {}; for (r in e) { qi[r] || (o[r] = e[r]) } if (o.target || (o.target = o.srcElement || n.document), $r.experimentalShadowDom && (o.target = Ji(e, o.target)), e && Wi.test(e.type) && void 0 === e.pageX && void 0 !== e.clientX) { const i = o.target.ownerDocument || n.document; const u = i.documentElement; const a = i.body; o.pageX = e.clientX + (u && u.scrollLeft || a && a.scrollLeft || 0) - (u && u.clientLeft || a && a.clientLeft || 0), o.pageY = e.clientY + (u && u.scrollTop || a && a.scrollTop || 0) - (u && u.clientTop || a && a.clientTop || 0) } return o.preventDefault = function () { o.isDefaultPrevented = Xi, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1) }, o.stopPropagation = function () { o.isPropagationStopped = Xi, e && (e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0) }, o.stopImmediatePropagation = function () { o.isImmediatePropagationStopped = Xi, o.stopPropagation() }, !1 === $i(o) && (o.isDefaultPrevented = Gi, o.isPropagationStopped = Gi, o.isImmediatePropagationStopped = Gi), typeof o.metaKey === 'undefined' && (o.metaKey = !1), o }; const Qi = function (e, t, n) { const r = e.document; const o = { type: 'ready' }; if (n.domLoaded) { t(o) } else { const i = function () { return r.readyState === 'complete' || r.readyState === 'interactive' && r.body }; var u = function () { Ki(e, 'DOMContentLoaded', u), Ki(e, 'load', u), n.domLoaded || (n.domLoaded = !0, t(o)) }; i() ? u() : Yi(e, 'DOMContentLoaded', u), Yi(e, 'load', u) } }; const eu = (function () { function e () { this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = ji + (+new Date()).toString(32), this.hasMouseEnterLeave = 'onmouseenter' in n.document.documentElement, this.hasFocusIn = 'onfocusin' in n.document.documentElement, this.count = 1 } return e.prototype.bind = function (e, t, r, o) { let i; let u; let a; let c; let s; let l; let f; const d = this; const m = n.window; const g = function (e) { d.executeHandlers(Zi(e || m.event), i) }; if (e && e.nodeType !== 3 && e.nodeType !== 8) { e[d.expando] ? i = e[d.expando] : (i = d.count++, e[d.expando] = i, d.events[i] = {}), o = o || e; const h = t.split(' '); a = h.length; while (a--) { c = h[a], l = g, s = f = !1, c === 'DOMContentLoaded' && (c = 'ready'), d.domLoaded && c === 'ready' && e.readyState === 'complete' ? r.call(o, Zi({ type: c })) : (d.hasMouseEnterLeave || (s = d.mouseEnterLeave[c], s && (l = function (e) { let t, n; if (t = e.currentTarget, n = e.relatedTarget, n && t.contains) { n = t.contains(n) } else { while (n && n !== t) { n = n.parentNode } }n || (e = Zi(e || m.event), e.type = e.type === 'mouseout' ? 'mouseleave' : 'mouseenter', e.target = t, d.executeHandlers(e, i)) })), d.hasFocusIn || c !== 'focusin' && c !== 'focusout' || (f = !0, s = c === 'focusin' ? 'focus' : 'blur', l = function (e) { e = Zi(e || m.event), e.type = e.type === 'focus' ? 'focusin' : 'focusout', d.executeHandlers(e, i) }), u = d.events[i][c], u ? c === 'ready' && d.domLoaded ? r(Zi({ type: c })) : u.push({ func: r, scope: o }) : (d.events[i][c] = u = [{ func: r, scope: o }], u.fakeName = s, u.capture = f, u.nativeHandler = l, c === 'ready' ? Qi(e, l, d) : Yi(e, s || c, l, f))) } return e = u = 0, r } }, e.prototype.unbind = function (e, t, n) { let r, o, i, u, a, c; if (!e || e.nodeType === 3 || e.nodeType === 8) { return this } if (r = e[this.expando], r) { if (c = this.events[r], t) { const s = t.split(' '); i = s.length; while (i--) { if (a = s[i], o = c[a], o) { if (n) { u = o.length; while (u--) { if (o[u].func === n) { const l = o.nativeHandler; const f = o.fakeName; const d = o.capture; o = o.slice(0, u).concat(o.slice(u + 1)), o.nativeHandler = l, o.fakeName = f, o.capture = d, c[a] = o } } }n && o.length !== 0 || (delete c[a], Ki(e, o.fakeName || a, o.nativeHandler, o.capture)) } } } else { for (a in c) { o = c[a], Ki(e, o.fakeName || a, o.nativeHandler, o.capture) }c = {} } for (a in c) { return this } delete this.events[r]; try { delete e[this.expando] } catch (m) { e[this.expando] = null } } return this }, e.prototype.fire = function (e, t, n) { let r; if (!e || e.nodeType === 3 || e.nodeType === 8) { return this } const o = Zi(null, n); o.type = t, o.target = e; do { r = e[this.expando], r && this.executeHandlers(o, r), e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow } while (e && !o.isPropagationStopped()); return this }, e.prototype.clean = function (e) { let t, n; if (!e || e.nodeType === 3 || e.nodeType === 8) { return this } if (e[this.expando] && this.unbind(e), e.getElementsByTagName || (e = e.document), e && e.getElementsByTagName) { this.unbind(e), n = e.getElementsByTagName('*'), t = n.length; while (t--) { e = n[t], e[this.expando] && this.unbind(e) } } return this }, e.prototype.destroy = function () { this.events = {} }, e.prototype.cancel = function (e) { return e && (e.preventDefault(), e.stopImmediatePropagation()), !1 }, e.prototype.executeHandlers = function (e, t) { let n; let r; let o; let i; const u = this.events[t]; if (n = u && u[e.type], n) { for (r = 0, o = n.length; r < o; r++) { if (i = n[r], i && !1 === i.func.call(i.scope, e) && e.preventDefault(), e.isImmediatePropagationStopped()) { return } } } }, e.Event = new e(), e }()); const tu = 'sizzle' + -new Date(); const nu = n.window.document; let ru = 0; let ou = 0; const iu = Hu(); const uu = Hu(); const au = Hu(); let cu = function (e, t) { return e === t && (Di = !0), 0 }; const su = 'undefined'; const lu = 1 << 31; const fu = {}.hasOwnProperty; let du = []; const mu = du.pop; const gu = du.push; let hu = du.push; const pu = du.slice; const vu = du.indexOf || function (e) { for (let t = 0, n = this.length; t < n; t++) { if (this[t] === e) { return t } } return -1 }; const bu = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped'; const yu = '[\\x20\\t\\r\\n\\f]'; const wu = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+'; const xu = '\\[' + yu + '*(' + wu + ')(?:' + yu + '*([*^$|!~]?=)' + yu + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + wu + '))|)' + yu + '*\\]'; const Cu = ':(' + wu + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + xu + ')*)|.*)\\)|)'; const Su = new RegExp('^' + yu + '+|((?:^|[^\\\\])(?:\\\\.)*)' + yu + '+$', 'g'); const ku = new RegExp('^' + yu + '*,' + yu + '*'); const Tu = new RegExp('^' + yu + '*([>+~]|' + yu + ')' + yu + '*'); const Eu = new RegExp('=' + yu + "*([^\\]'\"]*?)" + yu + '*\\]', 'g'); const Ou = new RegExp(Cu); const Nu = new RegExp('^' + wu + '$'); const _u = { ID: new RegExp('^#(' + wu + ')'), CLASS: new RegExp('^\\.(' + wu + ')'), TAG: new RegExp('^(' + wu + '|[*])'), ATTR: new RegExp('^' + xu), PSEUDO: new RegExp('^' + Cu), CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + yu + '*(even|odd|(([+-]|)(\\d*)n|)' + yu + '*(?:([+-]|)' + yu + '*(\\d+)|))' + yu + '*\\)|)', 'i'), bool: new RegExp('^(?:' + bu + ')$', 'i'), needsContext: new RegExp('^' + yu + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + yu + '*((?:-\\d)?\\d*)' + yu + '*\\)|)(?=[^-]|$)', 'i') }; const Du = /^(?:input|select|textarea|button)$/i; const Au = /^h\d$/i; const Ru = /^[^{]+\{\s*\[native \w/; const Bu = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/; const Mu = /[+~]/; const Pu = /'|\\/g; const zu = new RegExp('\\\\([\\da-f]{1,6}' + yu + '?|(' + yu + ')|.)', 'ig'); const Iu = function (e, t, n) { const r = '0x' + t - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) }; try { hu.apply(du = pu.call(nu.childNodes), nu.childNodes), du[nu.childNodes.length].nodeType } catch (OL) { hu = { apply: du.length ? function (e, t) { gu.apply(e, pu.call(t)) } : function (e, t) { let n = e.length; let r = 0; while (e[n++] = t[r++]) { ; }e.length = n - 1 } } } const Lu = function (e, t, n, r) { let o, i, u, a, c, s, l, f, d, m; if ((t ? t.ownerDocument || t : nu) !== Ri && Ai(t), t = t || Ri, n = n || [], !e || typeof e !== 'string') { return n } if ((a = t.nodeType) !== 1 && a !== 9) { return [] } if (Mi && !r) { if (o = Bu.exec(e)) { if (u = o[1]) { if (a === 9) { if (i = t.getElementById(u), !i || !i.parentNode) { return n } if (i.id === u) { return n.push(i), n } } else if (t.ownerDocument && (i = t.ownerDocument.getElementById(u)) && Li(t, i) && i.id === u) { return n.push(i), n } } else { if (o[2]) { return hu.apply(n, t.getElementsByTagName(e)), n } if ((u = o[3]) && xi.getElementsByClassName) { return hu.apply(n, t.getElementsByClassName(u)), n } } } if (xi.qsa && (!Pi || !Pi.test(e))) { if (f = l = tu, d = t, m = a === 9 && e, a === 1 && t.nodeName.toLowerCase() !== 'object') { s = Ti(e), (l = t.getAttribute('id')) ? f = l.replace(Pu, '\\$&') : t.setAttribute('id', f), f = "[id='" + f + "'] ", c = s.length; while (c--) { s[c] = f + Gu(s[c]) }d = Mu.test(e) && qu(t.parentNode) || t, m = s.join(',') } if (m) { try { return hu.apply(n, d.querySelectorAll(m)), n } catch (g) {} finally { l || t.removeAttribute('id') } } } } return Oi(e.replace(Su, '$1'), t, n, r) }; function Hu () { const e = []; function t (n, r) { return e.push(n + ' ') > Ci.cacheLength && delete t[e.shift()], t[n + ' '] = r } return t } function Fu (e) { return e[tu] = !0, e } function Vu (e, t) { let n = t && e; const r = n && e.nodeType === 1 && t.nodeType === 1 && (~t.sourceIndex || lu) - (~e.sourceIndex || lu); if (r) { return r } if (n) { while (n = n.nextSibling) { if (n === t) { return -1 } } } return e ? 1 : -1 } function Uu (e) { return function (t) { const n = t.nodeName.toLowerCase(); return n === 'input' && t.type === e } } function ju (e) { return function (t) { const n = t.nodeName.toLowerCase(); return (n === 'input' || n === 'button') && t.type === e } } function Wu (e) { return Fu(function (t) { return t = +t, Fu(function (n, r) { let o; const i = e([], n.length, t); let u = i.length; while (u--) { n[o = i[u]] && (n[o] = !(r[o] = n[o])) } }) }) } function qu (e) { return e && typeof e.getElementsByTagName !== su && e } for (wi in xi = Lu.support = {}, ki = Lu.isXML = function (e) { const t = e && (e.ownerDocument || e).documentElement; return !!t && t.nodeName !== 'HTML' }, Ai = Lu.setDocument = function (e) { let t; const n = e ? e.ownerDocument || e : nu; const r = n.defaultView; function o (e) { try { return e.top } catch (t) {} return null } return n !== Ri && n.nodeType === 9 && n.documentElement ? (Ri = n, Bi = n.documentElement, Mi = !ki(n), r && r !== o(r) && (r.addEventListener ? r.addEventListener('unload', function () { Ai() }, !1) : r.attachEvent && r.attachEvent('onunload', function () { Ai() })), xi.attributes = !0, xi.getElementsByTagName = !0, xi.getElementsByClassName = Ru.test(n.getElementsByClassName), xi.getById = !0, Ci.find.ID = function (e, t) { if (typeof t.getElementById !== su && Mi) { const n = t.getElementById(e); return n && n.parentNode ? [n] : [] } }, Ci.filter.ID = function (e) { const t = e.replace(zu, Iu); return function (e) { return e.getAttribute('id') === t } }, Ci.find.TAG = xi.getElementsByTagName ? function (e, t) { if (typeof t.getElementsByTagName !== su) { return t.getElementsByTagName(e) } } : function (e, t) { let n; const r = []; let o = 0; const i = t.getElementsByTagName(e); if (e === '*') { while (n = i[o++]) { n.nodeType === 1 && r.push(n) } return r } return i }, Ci.find.CLASS = xi.getElementsByClassName && function (e, t) { if (Mi) { return t.getElementsByClassName(e) } }, zi = [], Pi = [], xi.disconnectedMatch = !0, Pi = Pi.length && new RegExp(Pi.join('|')), zi = zi.length && new RegExp(zi.join('|')), t = Ru.test(Bi.compareDocumentPosition), Li = t || Ru.test(Bi.contains) ? function (e, t) { const n = e.nodeType === 9 ? e.documentElement : e; const r = t && t.parentNode; return e === r || !(!r || r.nodeType !== 1 || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) { while (t = t.parentNode) { if (t === e) { return !0 } } } return !1 }, cu = t ? function (e, t) { if (e === t) { return Di = !0, 0 } let r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !xi.sortDetached && t.compareDocumentPosition(e) === r ? e === n || e.ownerDocument === nu && Li(nu, e) ? -1 : t === n || t.ownerDocument === nu && Li(nu, t) ? 1 : _i ? vu.call(_i, e) - vu.call(_i, t) : 0 : 4 & r ? -1 : 1) } : function (e, t) { if (e === t) { return Di = !0, 0 } let r; let o = 0; const i = e.parentNode; const u = t.parentNode; const a = [e]; const c = [t]; if (!i || !u) { return e === n ? -1 : t === n ? 1 : i ? -1 : u ? 1 : _i ? vu.call(_i, e) - vu.call(_i, t) : 0 } if (i === u) { return Vu(e, t) } r = e; while (r = r.parentNode) { a.unshift(r) }r = t; while (r = r.parentNode) { c.unshift(r) } while (a[o] === c[o]) { o++ } return o ? Vu(a[o], c[o]) : a[o] === nu ? -1 : c[o] === nu ? 1 : 0 }, n) : Ri }, Lu.matches = function (e, t) { return Lu(e, null, null, t) }, Lu.matchesSelector = function (e, t) { if ((e.ownerDocument || e) !== Ri && Ai(e), t = t.replace(Eu, "='$1']"), xi.matchesSelector && Mi && (!zi || !zi.test(t)) && (!Pi || !Pi.test(t))) { try { const n = Ii.call(e, t); if (n || xi.disconnectedMatch || e.document && e.document.nodeType !== 11) { return n } } catch (OL) {} } return Lu(t, Ri, null, [e]).length > 0 }, Lu.contains = function (e, t) { return (e.ownerDocument || e) !== Ri && Ai(e), Li(e, t) }, Lu.attr = function (e, t) { (e.ownerDocument || e) !== Ri && Ai(e); const n = Ci.attrHandle[t.toLowerCase()]; let r = n && fu.call(Ci.attrHandle, t.toLowerCase()) ? n(e, t, !Mi) : void 0; return void 0 !== r ? r : xi.attributes || !Mi ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }, Lu.error = function (e) { throw new Error('Syntax error, unrecognized expression: ' + e) }, Lu.uniqueSort = function (e) { let t; const n = []; let r = 0; let o = 0; if (Di = !xi.detectDuplicates, _i = !xi.sortStable && e.slice(0), e.sort(cu), Di) { while (t = e[o++]) { t === e[o] && (r = n.push(o)) } while (r--) { e.splice(n[r], 1) } } return _i = null, e }, Si = Lu.getText = function (e) { let t; let n = ''; let r = 0; const o = e.nodeType; if (o) { if (o === 1 || o === 9 || o === 11) { if (typeof e.textContent === 'string') { return e.textContent } for (e = e.firstChild; e; e = e.nextSibling) { n += Si(e) } } else if (o === 3 || o === 4) { return e.nodeValue } } else { while (t = e[r++]) { n += Si(t) } } return n }, Ci = Lu.selectors = { cacheLength: 50, createPseudo: Fu, match: _u, attrHandle: {}, find: {}, relative: { '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' } }, preFilter: { ATTR (e) { return e[1] = e[1].replace(zu, Iu), e[3] = (e[3] || e[4] || e[5] || '').replace(zu, Iu), e[2] === '~=' && (e[3] = ' ' + e[3] + ' '), e.slice(0, 4) }, CHILD (e) { return e[1] = e[1].toLowerCase(), e[1].slice(0, 3) === 'nth' ? (e[3] || Lu.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (e[3] === 'even' || e[3] === 'odd')), e[5] = +(e[7] + e[8] || e[3] === 'odd')) : e[3] && Lu.error(e[0]), e }, PSEUDO (e) { let t; const n = !e[6] && e[2]; return _u.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || '' : n && Ou.test(n) && (t = Ti(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG (e) { const t = e.replace(zu, Iu).toLowerCase(); return e === '*' ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS (e) { let t = iu[e + ' ']; return t || (t = new RegExp('(^|' + yu + ')' + e + '(' + yu + '|$)')) && iu(e, function (e) { return t.test(typeof e.className === 'string' && e.className || typeof e.getAttribute !== su && e.getAttribute('class') || '') }) }, ATTR (e, t, n) { return function (r) { let o = Lu.attr(r, e); return o == null ? t === '!=' : !t || (o += '', t === '=' ? o === n : t === '!=' ? o !== n : t === '^=' ? n && o.indexOf(n) === 0 : t === '*=' ? n && o.includes(n) : t === '$=' ? n && o.slice(-n.length) === n : t === '~=' ? (' ' + o + ' ').includes(n) : t === '|=' && (o === n || o.slice(0, n.length + 1) === n + '-')) } }, CHILD (e, t, n, r, o) { const i = e.slice(0, 3) !== 'nth'; const u = e.slice(-4) !== 'last'; const a = t === 'of-type'; return r === 1 && o === 0 ? function (e) { return !!e.parentNode } : function (t, n, c) { let s; let l; let f; let d; let m; let g; let h = i !== u ? 'nextSibling' : 'previousSibling'; const p = t.parentNode; const v = a && t.nodeName.toLowerCase(); const b = !c && !a; if (p) { if (i) { while (h) { f = t; while (f = f[h]) { if (a ? f.nodeName.toLowerCase() === v : f.nodeType === 1) { return !1 } } g = h = e === 'only' && !g && 'nextSibling' } return !0 } if (g = [u ? p.firstChild : p.lastChild], u && b) { l = p[tu] || (p[tu] = {}), s = l[e] || [], m = s[0] === ru && s[1], d = s[0] === ru && s[2], f = m && p.childNodes[m]; while (f = ++m && f && f[h] || (d = m = 0) || g.pop()) { if (f.nodeType === 1 && ++d && f === t) { l[e] = [ru, m, d]; break } } } else if (b && (s = (t[tu] || (t[tu] = {}))[e]) && s[0] === ru) { d = s[1] } else { while (f = ++m && f && f[h] || (d = m = 0) || g.pop()) { if ((a ? f.nodeName.toLowerCase() === v : f.nodeType === 1) && ++d && (b && ((f[tu] || (f[tu] = {}))[e] = [ru, d]), f === t)) { break } } } return d -= o, d === r || d % r === 0 && d / r >= 0 } } }, PSEUDO (e, t) { let n; const r = Ci.pseudos[e] || Ci.setFilters[e.toLowerCase()] || Lu.error('unsupported pseudo: ' + e); return r[tu] ? r(t) : r.length > 1 ? (n = [e, e, '', t], Ci.setFilters.hasOwnProperty(e.toLowerCase()) ? Fu(function (e, n) { let o; const i = r(e, t); let u = i.length; while (u--) { o = vu.call(e, i[u]), e[o] = !(n[o] = i[u]) } }) : function (e) { return r(e, 0, n) }) : r } }, pseudos: { not: Fu(function (e) { const t = []; const n = []; const r = Ei(e.replace(Su, '$1')); return r[tu] ? Fu(function (e, t, n, o) { let i; const u = r(e, null, o, []); let a = e.length; while (a--) { (i = u[a]) && (e[a] = !(t[a] = i)) } }) : function (e, o, i) { return t[0] = e, r(t, null, i, n), !n.pop() } }), has: Fu(function (e) { return function (t) { return Lu(e, t).length > 0 } }), contains: Fu(function (e) { return e = e.replace(zu, Iu), function (t) { return (t.textContent || t.textContent || Si(t)).includes(e) } }), lang: Fu(function (e) { return Nu.test(e || '') || Lu.error('unsupported lang: ' + e), e = e.replace(zu, Iu).toLowerCase(), function (t) { let n; do { if (n = Mi ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')) { return n = n.toLowerCase(), n === e || n.indexOf(e + '-') === 0 } } while ((t = t.parentNode) && t.nodeType === 1); return !1 } }), target (e) { const t = n.window.location && n.window.location.hash; return t && t.slice(1) === e.id }, root (e) { return e === Bi }, focus (e) { return e === Ri.activeElement && (!Ri.hasFocus || Ri.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled (e) { return !1 === e.disabled }, disabled (e) { return !0 === e.disabled }, checked (e) { const t = e.nodeName.toLowerCase(); return t === 'input' && !!e.checked || t === 'option' && !!e.selected }, selected (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty (e) { for (e = e.firstChild; e; e = e.nextSibling) { if (e.nodeType < 6) { return !1 } } return !0 }, parent (e) { return !Ci.pseudos.empty(e) }, header (e) { return Au.test(e.nodeName) }, input (e) { return Du.test(e.nodeName) }, button (e) { const t = e.nodeName.toLowerCase(); return t === 'input' && e.type === 'button' || t === 'button' }, text (e) { let t; return e.nodeName.toLowerCase() === 'input' && e.type === 'text' && ((t = e.getAttribute('type')) == null || t.toLowerCase() === 'text') }, first: Wu(function () { return [0] }), last: Wu(function (e, t) { return [t - 1] }), eq: Wu(function (e, t, n) { return [n < 0 ? n + t : n] }), even: Wu(function (e, t) { for (let n = 0; n < t; n += 2) { e.push(n) } return e }), odd: Wu(function (e, t) { for (let n = 1; n < t; n += 2) { e.push(n) } return e }), lt: Wu(function (e, t, n) { for (let r = n < 0 ? n + t : n; --r >= 0;) { e.push(r) } return e }), gt: Wu(function (e, t, n) { for (let r = n < 0 ? n + t : n; ++r < t;) { e.push(r) } return e }) } }, Ci.pseudos.nth = Ci.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) { Ci.pseudos[wi] = Uu(wi) } for (wi in { submit: !0, reset: !0 }) { Ci.pseudos[wi] = ju(wi) } function $u () {} function Gu (e) { for (var t = 0, n = e.length, r = ''; t < n; t++) { r += e[t].value } return r } function Xu (e, t, n) { const r = t.dir; const o = n && r === 'parentNode'; const i = ou++; return t.first ? function (t, n, i) { while (t = t[r]) { if (t.nodeType === 1 || o) { return e(t, n, i) } } } : function (t, n, u) { let a; let c; const s = [ru, i]; if (u) { while (t = t[r]) { if ((t.nodeType === 1 || o) && e(t, n, u)) { return !0 } } } else { while (t = t[r]) { if (t.nodeType === 1 || o) { if (c = t[tu] || (t[tu] = {}), (a = c[r]) && a[0] === ru && a[1] === i) { return s[2] = a[2] } if (c[r] = s, s[2] = e(t, n, u)) { return !0 } } } } } } function Yu (e) { return e.length > 1 ? function (t, n, r) { let o = e.length; while (o--) { if (!e[o](t, n, r)) { return !1 } } return !0 } : e[0] } function Ku (e, t, n) { for (let r = 0, o = t.length; r < o; r++) { Lu(e, t[r], n) } return n } function Ju (e, t, n, r, o) { for (var i, u = [], a = 0, c = e.length, s = t != null; a < c; a++) { (i = e[a]) && (n && !n(i, r, o) || (u.push(i), s && t.push(a))) } return u } function Zu (e, t, n, r, o, i) { return r && !r[tu] && (r = Zu(r)), o && !o[tu] && (o = Zu(o, i)), Fu(function (i, u, a, c) { let s; let l; let f; const d = []; const m = []; const g = u.length; const h = i || Ku(t || '*', a.nodeType ? [a] : a, []); const p = !e || !i && t ? h : Ju(h, d, e, a, c); let v = n ? o || (i ? e : g || r) ? [] : u : p; if (n && n(p, v, a, c), r) { s = Ju(v, m), r(s, [], a, c), l = s.length; while (l--) { (f = s[l]) && (v[m[l]] = !(p[m[l]] = f)) } } if (i) { if (o || e) { if (o) { s = [], l = v.length; while (l--) { (f = v[l]) && s.push(p[l] = f) }o(null, v = [], s, c) }l = v.length; while (l--) { (f = v[l]) && (s = o ? vu.call(i, f) : d[l]) > -1 && (i[s] = !(u[s] = f)) } } } else { v = Ju(v === u ? v.splice(g, v.length) : v), o ? o(null, u, v, c) : hu.apply(u, v) } }) } function Qu (e) { for (var t, n, r, o = e.length, i = Ci.relative[e[0].type], u = i || Ci.relative[' '], a = i ? 1 : 0, c = Xu(function (e) { return e === t }, u, !0), s = Xu(function (e) { return vu.call(t, e) > -1 }, u, !0), l = [function (e, n, r) { return !i && (r || n !== Ni) || ((t = n).nodeType ? c(e, n, r) : s(e, n, r)) }]; a < o; a++) { if (n = Ci.relative[e[a].type]) { l = [Xu(Yu(l), n)] } else { if (n = Ci.filter[e[a].type].apply(null, e[a].matches), n[tu]) { for (r = ++a; r < o; r++) { if (Ci.relative[e[r].type]) { break } } return Zu(a > 1 && Yu(l), a > 1 && Gu(e.slice(0, a - 1).concat({ value: e[a - 2].type === ' ' ? '*' : '' })).replace(Su, '$1'), n, a < r && Qu(e.slice(a, r)), r < o && Qu(e = e.slice(r)), r < o && Gu(e)) }l.push(n) } } return Yu(l) } function ea (e, t) { const n = t.length > 0; const r = e.length > 0; const o = function (o, i, u, a, c) { let s; let l; let f; let d = 0; let m = '0'; const g = o && []; let h = []; const p = Ni; const v = o || r && Ci.find.TAG('*', c); const b = ru += p == null ? 1 : Math.random() || 0.1; const y = v.length; for (c && (Ni = i !== Ri && i); m !== y && (s = v[m]) != null; m++) { if (r && s) { l = 0; while (f = e[l++]) { if (f(s, i, u)) { a.push(s); break } }c && (ru = b) }n && ((s = !f && s) && d--, o && g.push(s)) } if (d += m, n && m !== d) { l = 0; while (f = t[l++]) { f(g, h, i, u) } if (o) { if (d > 0) { while (m--) { g[m] || h[m] || (h[m] = mu.call(a)) } }h = Ju(h) }hu.apply(a, h), c && !o && h.length > 0 && d + t.length > 1 && Lu.uniqueSort(a) } return c && (ru = b, Ni = p), g }; return n ? Fu(o) : o }$u.prototype = Ci.filters = Ci.pseudos, Ci.setFilters = new $u(), Ti = Lu.tokenize = function (e, t) { let n; let r; let o; let i; let u; let a; let c; const s = uu[e + ' ']; if (s) { return t ? 0 : s.slice(0) } u = e, a = [], c = Ci.preFilter; while (u) { for (i in n && !(r = ku.exec(u)) || (r && (u = u.slice(r[0].length) || u), a.push(o = [])), n = !1, (r = Tu.exec(u)) && (n = r.shift(), o.push({ value: n, type: r[0].replace(Su, ' ') }), u = u.slice(n.length)), Ci.filter) { Ci.filter.hasOwnProperty(i) && (!(r = _u[i].exec(u)) || c[i] && !(r = c[i](r)) || (n = r.shift(), o.push({ value: n, type: i, matches: r }), u = u.slice(n.length))) } if (!n) { break } } return t ? u.length : u ? Lu.error(e) : uu(e, a).slice(0) }, Ei = Lu.compile = function (e, t) { let n; const r = []; const o = []; let i = au[e + ' ']; if (!i) { t || (t = Ti(e)), n = t.length; while (n--) { i = Qu(t[n]), i[tu] ? r.push(i) : o.push(i) }i = au(e, ea(o, r)), i.selector = e } return i }, Oi = Lu.select = function (e, t, n, r) { let o; let i; let u; let a; let c; const s = typeof e === 'function' && e; const l = !r && Ti(e = s.selector || e); if (n = n || [], l.length === 1) { if (i = l[0] = l[0].slice(0), i.length > 2 && (u = i[0]).type === 'ID' && xi.getById && t.nodeType === 9 && Mi && Ci.relative[i[1].type]) { if (t = (Ci.find.ID(u.matches[0].replace(zu, Iu), t) || [])[0], !t) { return n } s && (t = t.parentNode), e = e.slice(i.shift().value.length) }o = _u.needsContext.test(e) ? 0 : i.length; while (o--) { if (u = i[o], Ci.relative[a = u.type]) { break } if ((c = Ci.find[a]) && (r = c(u.matches[0].replace(zu, Iu), Mu.test(i[0].type) && qu(t.parentNode) || t))) { if (i.splice(o, 1), e = r.length && Gu(i), !e) { return hu.apply(n, r), n } break } } } return (s || Ei(e, l))(r, t, !Mi, n, Mu.test(e) && qu(t.parentNode) || t), n }, xi.sortStable = tu.split('').sort(cu).join('') === tu, xi.detectDuplicates = !!Di, Ai(), xi.sortDetached = !0; const ta = n.document; const na = Array.prototype.push; const ra = Array.prototype.slice; const oa = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/; const ia = eu.Event; const ua = vo.makeMap('children,contents,next,prev'); const aa = function (e) { return typeof e !== 'undefined' }; const ca = function (e) { return typeof e === 'string' }; const sa = function (e) { return e && e === e.window }; const la = function (e, t) { let n, r, o; t = t || ta, o = t.createElement('div'), n = t.createDocumentFragment(), o.innerHTML = e; while (r = o.firstChild) { n.appendChild(r) } return n }; var fa = function (e, t, n, r) { let o; if (ca(t)) { t = la(t, Ea(e[0])) } else if (t.length && !t.nodeType) { if (t = Da.makeArray(t), r) { for (o = t.length - 1; o >= 0; o--) { fa(e, t[o], n, r) } } else { for (o = 0; o < t.length; o++) { fa(e, t[o], n, r) } } return e } if (t.nodeType) { o = e.length; while (o--) { n.call(e[o], t) } } return e }; const da = function (e, t) { return e && t && (' ' + e.className + ' ').includes(' ' + t + ' ') }; const ma = function (e, t, n) { let r, o; return t = Da(t)[0], e.each(function () { const e = this; n && r === e.parentNode ? o.appendChild(e) : (r = e.parentNode, o = t.cloneNode(!1), e.parentNode.insertBefore(o, e), o.appendChild(e)) }), e }; const ga = vo.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' '); const ha = vo.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' '); const pa = { for: 'htmlFor', class: 'className', readonly: 'readOnly' }; const va = { float: 'cssFloat' }; const ba = {}; const ya = {}; const wa = function (e, t) { return new Da.fn.init(e, t) }; const xa = function (e, t) { let n; if (t.indexOf) { return t.indexOf(e) } n = t.length; while (n--) { if (t[n] === e) { return n } } return -1 }; const Ca = /^\s*|\s*$/g; const Sa = function (e) { return e === null || void 0 === e ? '' : ('' + e).replace(Ca, '') }; const ka = function (e, t) { let n, r, o, i; if (e) { if (n = e.length, void 0 === n) { for (r in e) { if (e.hasOwnProperty(r) && (i = e[r], !1 === t.call(i, r, i))) { break } } } else { for (o = 0; o < n; o++) { if (i = e[o], !1 === t.call(i, o, i)) { break } } } } return e }; const Ta = function (e, t) { const n = []; return ka(e, function (e, r) { t(r, e) && n.push(r) }), n }; var Ea = function (e) { return e ? e.nodeType === 9 ? e : e.ownerDocument : ta }; wa.fn = wa.prototype = { constructor: wa, selector: '', context: null, length: 0, init (e, t) { let r; let o; const i = this; if (!e) { return i } if (e.nodeType) { return i.context = i[0] = e, i.length = 1, i } if (t && t.nodeType) { i.context = t } else { if (t) { return Da(e).attr(t) } i.context = t = n.document } if (ca(e)) { if (i.selector = e, r = e.charAt(0) === '<' && e.charAt(e.length - 1) === '>' && e.length >= 3 ? [null, e, null] : oa.exec(e), !r) { return Da(t).find(e) } if (r[1]) { o = la(e, Ea(t)).firstChild; while (o) { na.call(i, o), o = o.nextSibling } } else { if (o = Ea(t).getElementById(r[2]), !o) { return i } if (o.id !== r[2]) { return i.find(e) } i.length = 1, i[0] = o } } else { this.add(e, !1) } return i }, toArray () { return vo.toArray(this) }, add (e, t) { let n; let r; const o = this; if (ca(e)) { return o.add(Da(e)) } if (!1 !== t) { for (n = Da.unique(o.toArray().concat(Da.makeArray(e))), o.length = n.length, r = 0; r < n.length; r++) { o[r] = n[r] } } else { na.apply(o, Da.makeArray(e)) } return o }, attr (e, t) { let n; const r = this; if (typeof e === 'object') { ka(e, function (e, t) { r.attr(e, t) }) } else { if (!aa(t)) { if (r[0] && r[0].nodeType === 1) { if (n = ba[e], n && n.get) { return n.get(r[0], e) } if (ha[e]) { return r.prop(e) ? e : void 0 } t = r[0].getAttribute(e, 2), t === null && (t = void 0) } return t } this.each(function () { let n; if (this.nodeType === 1) { if (n = ba[e], n && n.set) { return void n.set(this, t) } t === null ? this.removeAttribute(e, 2) : this.setAttribute(e, t, 2) } }) } return r }, removeAttr (e) { return this.attr(e, null) }, prop (e, t) { const n = this; if (e = pa[e] || e, typeof e === 'object') { ka(e, function (e, t) { n.prop(e, t) }) } else { if (!aa(t)) { return n[0] && n[0].nodeType && e in n[0] ? n[0][e] : t } this.each(function () { this.nodeType === 1 && (this[e] = t) }) } return n }, css (e, t) { let n; let r; const o = this; const i = function (e) { return e.replace(/-(\D)/g, function (e, t) { return t.toUpperCase() }) }; const u = function (e) { return e.replace(/[A-Z]/g, function (e) { return '-' + e }) }; if (typeof e === 'object') { ka(e, function (e, t) { o.css(e, t) }) } else if (aa(t)) { e = i(e), typeof t !== 'number' || ga[e] || (t = t.toString() + 'px'), o.each(function () { const n = this.style; if (r = ya[e], r && r.set) { r.set(this, t) } else { try { this.style[va[e] || e] = t } catch (o) {}t !== null && t !== '' || (n.removeProperty ? n.removeProperty(u(e)) : n.removeAttribute(e)) } }) } else { if (n = o[0], r = ya[e], r && r.get) { return r.get(n) } if (!n.ownerDocument.defaultView) { return n.currentStyle ? n.currentStyle[i(e)] : '' } try { return n.ownerDocument.defaultView.getComputedStyle(n, null).getPropertyValue(u(e)) } catch (a) { return } } return o }, remove () { let e; const t = this; let n = this.length; while (n--) { e = t[n], ia.clean(e), e.parentNode && e.parentNode.removeChild(e) } return this }, empty () { let e; const t = this; let n = this.length; while (n--) { e = t[n]; while (e.firstChild) { e.removeChild(e.firstChild) } } return this }, html (e) { let t; const n = this; if (aa(e)) { t = n.length; try { while (t--) { n[t].innerHTML = e } } catch (r) { Da(n[t]).empty().append(e) } return n } return n[0] ? n[0].innerHTML : '' }, text (e) { let t; const n = this; if (aa(e)) { t = n.length; while (t--) { 'innerText' in n[t] ? n[t].textContent = e : n[0].textContent = e } return n } return n[0] ? n[0].textContent || n[0].textContent : '' }, append () { return fa(this, arguments, function (e) { (this.nodeType === 1 || this.host && this.host.nodeType === 1) && this.appendChild(e) }) }, prepend () { return fa(this, arguments, function (e) { (this.nodeType === 1 || this.host && this.host.nodeType === 1) && this.insertBefore(e, this.firstChild) }, !0) }, before () { const e = this; return e[0] && e[0].parentNode ? fa(e, arguments, function (e) { this.parentNode.insertBefore(e, this) }) : e }, after () { const e = this; return e[0] && e[0].parentNode ? fa(e, arguments, function (e) { this.parentNode.insertBefore(e, this.nextSibling) }, !0) : e }, appendTo (e) { return Da(e).append(this), this }, prependTo (e) { return Da(e).prepend(this), this }, replaceWith (e) { return this.before(e).remove() }, wrap (e) { return ma(this, e) }, wrapAll (e) { return ma(this, e, !0) }, wrapInner (e) { return this.each(function () { Da(this).contents().wrapAll(e) }), this }, unwrap () { return this.parent().each(function () { Da(this).replaceWith(this.childNodes) }) }, clone () { const e = []; return this.each(function () { e.push(this.cloneNode(!0)) }), Da(e) }, addClass (e) { return this.toggleClass(e, !0) }, removeClass (e) { return this.toggleClass(e, !1) }, toggleClass (e, t) { const n = this; return typeof e !== 'string' ? n : (e.includes(' ') ? ka(e.split(' '), function () { n.toggleClass(this, t) }) : n.each(function (n, r) { let o, i; i = da(r, e), i !== t && (o = r.className, i ? r.className = Sa((' ' + o + ' ').replace(' ' + e + ' ', ' ')) : r.className += o ? ' ' + e : e) }), n) }, hasClass (e) { return da(this[0], e) }, each (e) { return ka(this, e) }, on (e, t) { return this.each(function () { ia.bind(this, e, t) }) }, off (e, t) { return this.each(function () { ia.unbind(this, e, t) }) }, trigger (e) { return this.each(function () { typeof e === 'object' ? ia.fire(this, e.type, e) : ia.fire(this, e) }) }, show () { return this.css('display', '') }, hide () { return this.css('display', 'none') }, slice () { return new Da(ra.apply(this, arguments)) }, eq (e) { return e === -1 ? this.slice(e) : this.slice(e, +e + 1) }, first () { return this.eq(0) }, last () { return this.eq(-1) }, find (e) { let t; let n; const r = []; for (t = 0, n = this.length; t < n; t++) { Da.find(e, this[t], r) } return Da(r) }, filter (e) { return Da(typeof e === 'function' ? Ta(this.toArray(), function (t, n) { return e(n, t) }) : Da.filter(e, this.toArray())) }, closest (e) { const t = []; return e instanceof Da && (e = e[0]), this.each(function (n, r) { while (r) { if (typeof e === 'string' && Da(r).is(e)) { t.push(r); break } if (r === e) { t.push(r); break }r = r.parentNode } }), Da(t) }, offset (e) { let t; let n; let r; let o; let i = 0; let u = 0; return e ? this.css(e) : (t = this[0], t && (n = t.ownerDocument, r = n.documentElement, t.getBoundingClientRect && (o = t.getBoundingClientRect(), i = o.left + (r.scrollLeft || n.body.scrollLeft) - r.clientLeft, u = o.top + (r.scrollTop || n.body.scrollTop) - r.clientTop)), { left: i, top: u }) }, push: na, sort: Array.prototype.sort, splice: Array.prototype.splice }, vo.extend(wa, { extend: vo.extend, makeArray (e) { return sa(e) || e.nodeType ? [e] : vo.toArray(e) }, inArray: xa, isArray: vo.isArray, each: ka, trim: Sa, grep: Ta, find: Lu, expr: Lu.selectors, unique: Lu.uniqueSort, text: Lu.getText, contains: Lu.contains, filter (e, t, n) { let r = t.length; n && (e = ':not(' + e + ')'); while (r--) { t[r].nodeType !== 1 && t.splice(r, 1) } return t = t.length === 1 ? Da.find.matchesSelector(t[0], e) ? [t[0]] : [] : Da.find.matches(e, t), t } }); const Oa = function (e, t, n) { const r = []; let o = e[t]; typeof n !== 'string' && n instanceof Da && (n = n[0]); while (o && o.nodeType !== 9) { if (void 0 !== n) { if (o === n) { break } if (typeof n === 'string' && Da(o).is(n)) { break } }o.nodeType === 1 && r.push(o), o = o[t] } return r }; const Na = function (e, t, n, r) { const o = []; for (r instanceof Da && (r = r[0]); e; e = e[t]) { if (!n || e.nodeType === n) { if (void 0 !== r) { if (e === r) { break } if (typeof r === 'string' && Da(e).is(r)) { break } }o.push(e) } } return o }; const _a = function (e, t, n) { for (e = e[t]; e; e = e[t]) { if (e.nodeType === n) { return e } } return null }; ka({ parent (e) { const t = e.parentNode; return t && t.nodeType !== 11 ? t : null }, parents (e) { return Oa(e, 'parentNode') }, next (e) { return _a(e, 'nextSibling', 1) }, prev (e) { return _a(e, 'previousSibling', 1) }, children (e) { return Na(e.firstChild, 'nextSibling', 1) }, contents (e) { return vo.toArray((e.nodeName === 'iframe' ? e.contentDocument || e.contentWindow.document : e).childNodes) } }, function (e, t) { wa.fn[e] = function (n) { const r = this; let o = []; r.each(function () { const e = t.call(o, this, n, o); e && (Da.isArray(e) ? o.push.apply(o, e) : o.push(e)) }), this.length > 1 && (ua[e] || (o = Da.unique(o)), e.indexOf('parents') === 0 && (o = o.reverse())); const i = Da(o); return n ? i.filter(n) : i } }), ka({ parentsUntil (e, t) { return Oa(e, 'parentNode', t) }, nextUntil (e, t) { return Na(e, 'nextSibling', 1, t).slice(1) }, prevUntil (e, t) { return Na(e, 'previousSibling', 1, t).slice(1) } }, function (e, t) { wa.fn[e] = function (n, r) { const o = this; let i = []; o.each(function () { const e = t.call(i, this, n, i); e && (Da.isArray(e) ? i.push.apply(i, e) : i.push(e)) }), this.length > 1 && (i = Da.unique(i), e.indexOf('parents') !== 0 && e !== 'prevUntil' || (i = i.reverse())); const u = Da(i); return r ? u.filter(r) : u } }), wa.fn.is = function (e) { return !!e && this.filter(e).length > 0 }, wa.fn.init.prototype = wa.fn, wa.overrideDefaults = function (e) { let t; var n = function (r, o) { return t = t || e(), arguments.length === 0 && (r = t.element), o || (o = t.context), new n.fn.init(r, o) }; return Da.extend(n, this), n }, wa.attrHooks = ba, wa.cssHooks = ya; var Da = wa; const Aa = (function () { function e (e, t) { this.node = e, this.rootNode = t, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this) } return e.prototype.current = function () { return this.node }, e.prototype.next = function (e) { return this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', e), this.node }, e.prototype.prev = function (e) { return this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', e), this.node }, e.prototype.prev2 = function (e) { return this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', e), this.node }, e.prototype.findSibling = function (e, t, n, r) { let o, i; if (e) { if (!r && e[t]) { return e[t] } if (e !== this.rootNode) { if (o = e[n], o) { return o } for (i = e.parentNode; i && i !== this.rootNode; i = i.parentNode) { if (o = i[n], o) { return o } } } } }, e.prototype.findPreviousNode = function (e, t, n, r) { let o, i, u; if (e) { if (o = e[n], this.rootNode && o === this.rootNode) { return } if (o) { if (!r) { for (u = o[t]; u; u = u[t]) { if (!u[t]) { return u } } } return o } if (i = e.parentNode, i && i !== this.rootNode) { return i } } }, e }()); const Ra = vo.each; const Ba = vo.grep; const Ma = $r.ie; const Pa = /^([a-z0-9],?)+$/i; const za = /^[ \t\r\n]*$/; const Ia = function (e, t, n) { const r = t.keep_values; const o = { set (e, r, o) { t.url_converter && (r = t.url_converter.call(t.url_converter_scope || n(), r, o, e[0])), e.attr('data-mce-' + o, r).attr(o, r) }, get (e, t) { return e.attr('data-mce-' + t) || e.attr(t) } }; const i = { style: { set (t, n) { n === null || typeof n !== 'object' ? (r && t.attr('data-mce-style', n), n !== null && typeof n === 'string' ? (t.removeAttr('style'), t.css(e.parse(n))) : t.attr('style', n)) : t.css(n) }, get (t) { let n = t.attr('data-mce-style') || t.attr('style'); return n = e.serialize(e.parse(n), t[0].nodeName), n } } }; return r && (i.href = i.src = o), i }; const La = function (e, t) { const n = t.attr('style'); let r = e.serialize(e.parse(n), t[0].nodeName); r || (r = null), t.attr('data-mce-style', r) }; const Ha = function (e, t) { let n; let r; let o = 0; if (e) { for (n = e.nodeType, e = e.previousSibling; e; e = e.previousSibling) { r = e.nodeType, (!t || r !== 3 || r !== n && e.nodeValue.length) && (o++, n = r) } } return o }; function Fa (e, t) { let r; const o = this; void 0 === t && (t = {}); const i = {}; const u = n.window; const a = {}; let c = 0; const s = !0; const l = !0; const f = bo(e, { contentCssCors: t.contentCssCors, referrerPolicy: t.referrerPolicy }); const d = []; const m = t.schema ? t.schema : yi({}); const g = Ui({ url_converter: t.url_converter, url_converter_scope: t.url_converter_scope }, t.schema); const h = t.ownEvents ? new eu() : eu.Event; const p = m.getBlockElements(); const v = Da.overrideDefaults(function () { return { context: e, element: De.getRoot() } }); const b = function (e) { if (typeof e === 'string') { return !!p[e] } if (e) { const t = e.nodeType; if (t) { return !(t !== 1 || !p[e.nodeName]) } } return !1 }; const w = function (t) { if (t && e && typeof t === 'string') { const n = e.getElementById(t); return n && n.id !== t ? e.getElementsByName(t)[1] : n } return t }; const x = function (e) { return typeof e === 'string' && (e = w(e)), v(e) }; const C = function (e, t, n) { let o; let i; const u = x(e); return u.length && (o = r[t], i = o && o.get ? o.get(u, t) : u.attr(t)), typeof i === 'undefined' && (i = n || ''), i }; const S = function (e) { const t = w(e); return t ? t.attributes : [] }; const k = function (e, n, o) { let i, u; o === '' && (o = null); const a = x(e); i = a.attr(n), a.length && (u = r[n], u && u.set ? u.set(a, o, n) : a.attr(n, o), i !== o && t.onSetAttrib && t.onSetAttrib({ attrElm: a, attrName: n, attrValue: o })) }; const T = function (t, n) { if (!Ma || t.nodeType !== 1 || n) { return t.cloneNode(n) } if (!n) { const r = e.createElement(t.nodeName); return Ra(S(t), function (e) { k(r, e.nodeName, C(t, e.nodeName)) }), r } return null }; const E = function () { return t.root_element || e.body }; const O = function (e) { const t = kn(e); return { x: t.x(), y: t.y(), w: t.width(), h: t.height() } }; const N = function (t, n) { return lr.getPos(e.body, w(t), n) }; const _ = function (e, n, r) { const o = y(n) ? x(e).css(n, r) : x(e).css(n); t.update_styles && La(g, o) }; const D = function (e, n) { const r = x(e).css(n); t.update_styles && La(g, r) }; const A = function (e, t, n) { const r = x(e); return n ? r.css(t) : (t = t.replace(/-(\D)/g, function (e, t) { return t.toUpperCase() }), t === 'float' && (t = $r.browser.isIE() ? 'styleFloat' : 'cssFloat'), r[0] && r[0].style ? r[0].style[t] : void 0) }; const R = function (e) { let t, n; return e = w(e), t = A(e, 'width'), n = A(e, 'height'), !t.includes('px') && (t = 0), !n.includes('px') && (n = 0), { w: parseInt(t, 10) || e.offsetWidth || e.clientWidth, h: parseInt(n, 10) || e.offsetHeight || e.clientHeight } }; const B = function (e) { let t, n; return e = w(e), t = N(e), n = R(e), { x: t.x, y: t.y, w: n.w, h: n.h } }; const M = function (e, t) { let n; if (!e) { return !1 } if (!Array.isArray(e)) { if (t === '*') { return e.nodeType === 1 } if (Pa.test(t)) { const r = t.toLowerCase().split(/,/); const o = e.nodeName.toLowerCase(); for (n = r.length - 1; n >= 0; n--) { if (r[n] === o) { return !0 } } return !1 } if (e.nodeType && e.nodeType !== 1) { return !1 } } const i = Array.isArray(e) ? e : [e]; return Lu(t, i[0].ownerDocument || i[0], null, i).length > 0 }; const P = function (e, t, n, r) { let o; const i = []; let u = w(e); r = void 0 === r, n = n || (E().nodeName !== 'BODY' ? E().parentNode : null), vo.is(t, 'string') && (o = t, t = t === '*' ? function (e) { return e.nodeType === 1 } : function (e) { return M(e, o) }); while (u) { if (u === n || !u.nodeType || u.nodeType === 9) { break } if (!t || typeof t === 'function' && t(u)) { if (!r) { return [u] } i.push(u) }u = u.parentNode } return r ? i : null }; const z = function (e, t, n) { const r = P(e, t, n, !1); return r && r.length > 0 ? r[0] : null }; const I = function (e, t, n) { let r = t; if (e) { for (typeof t === 'string' && (r = function (e) { return M(e, t) }), e = e[n]; e; e = e[n]) { if (typeof r === 'function' && r(e)) { return e } } } return null }; const L = function (e, t) { return I(e, t, 'nextSibling') }; const H = function (e, t) { return I(e, t, 'previousSibling') }; const F = function (n, r) { return Lu(n, w(r) || t.root_element || e, []) }; const V = function (e, t, n) { let r; const i = typeof e === 'string' ? w(e) : e; if (!i) { return !1 } if (vo.isArray(i) && (i.length || i.length === 0)) { return r = [], Ra(i, function (e, o) { e && (typeof e === 'string' && (e = w(e)), r.push(t.call(n, e, o))) }), r } const u = n || o; return t.call(u, i) }; const U = function (e, t) { x(e).each(function (e, n) { Ra(t, function (e, t) { k(n, t, e) }) }) }; const j = function (e, t) { const n = x(e); Ma ? n.each(function (e, n) { if (!1 !== n.canHaveHTML) { while (n.firstChild) { n.removeChild(n.firstChild) } try { n.innerHTML = '<br>' + t, n.removeChild(n.firstChild) } catch (r) { Da('<div></div>').html('<br>' + t).contents().slice(1).appendTo(n) } return t } }) : n.html(t) }; const W = function (t, n, r, o, i) { return V(t, function (t) { const u = typeof n === 'string' ? e.createElement(n) : n; return U(u, r), o && (typeof o !== 'string' && o.nodeType ? u.appendChild(o) : typeof o === 'string' && j(u, o)), i ? u : t.appendChild(u) }) }; const q = function (t, n, r) { return W(e.createElement(t), t, n, r, !0) }; const $ = ci.decode; const G = ci.encodeAllRaw; const X = function (e, t, n) { let r; let o = ''; for (r in o += '<' + e, t) { t.hasOwnProperty(r) && t[r] !== null && typeof t[r] !== 'undefined' && (o += ' ' + r + '="' + G(t[r]) + '"') } return typeof n !== 'undefined' ? o + '>' + n + '</' + e + '>' : o + ' />' }; const Y = function (t) { let n; const r = e.createElement('div'); const o = e.createDocumentFragment(); o.appendChild(r), t && (r.innerHTML = t); while (n = r.firstChild) { o.appendChild(n) } return o.removeChild(r), o }; const K = function (e, t) { const n = x(e); return t ? n.each(function () { let e; while (e = this.firstChild) { e.nodeType === 3 && e.data.length === 0 ? this.removeChild(e) : this.parentNode.insertBefore(e, this) } }).remove() : n.remove(), n.length > 1 ? n.toArray() : n[0] }; const J = function (e) { return V(e, function (e) { let t; const n = e.attributes; for (t = n.length - 1; t >= 0; t--) { e.removeAttributeNode(n.item(t)) } }) }; const Z = function (e) { return g.parse(e) }; const Q = function (e, t) { return g.serialize(e, t) }; const ee = function (t) { let r, o; if (De !== Fa.DOM && e === n.document) { if (i[t]) { return } i[t] = !0 }o = e.getElementById('mceDefaultStyles'), o || (o = e.createElement('style'), o.id = 'mceDefaultStyles', o.type = 'text/css', r = e.getElementsByTagName('head')[0], r.firstChild ? r.insertBefore(o, r.firstChild) : r.appendChild(o)), o.styleSheet ? o.styleSheet.cssText += t : o.appendChild(e.createTextNode(t)) }; const te = function (r) { let o; De === Fa.DOM || e !== n.document ? (r || (r = ''), o = e.getElementsByTagName('head')[0], Ra(r.split(','), function (e) { let n; e = vo._addCacheSuffix(e), a[e] || (a[e] = !0, n = q('link', se(se({ rel: 'stylesheet', type: 'text/css', href: e }, t.contentCssCors ? { crossOrigin: 'anonymous' } : {}), t.referrerPolicy ? { referrerPolicy: t.referrerPolicy } : {})), o.appendChild(n)) })) : Fa.DOM.loadCSS(r) }; const ne = function (e, t, n) { x(e).toggleClass(t, n).each(function () { this.className === '' && Da(this).attr('class', null) }) }; const re = function (e, t) { x(e).addClass(t) }; const oe = function (e, t) { ne(e, t, !1) }; const ie = function (e, t) { return x(e).hasClass(t) }; const ue = function (e) { x(e).show() }; const ae = function (e) { x(e).hide() }; const ce = function (e) { return x(e).css('display') === 'none' }; const le = function (e) { return (e || 'mce_') + c++ }; const fe = function (e) { const t = typeof e === 'string' ? w(e) : e; return qn.isElement(t) ? t.outerHTML : Da('<div></div>').append(Da(t).clone()).html() }; const de = function (e, t) { x(e).each(function () { try { if ('outerHTML' in this) { return void (this.outerHTML = t) } } catch (e) {}K(Da(this).html(t), !0) }) }; const me = function (e, t) { const n = w(t); return V(e, function (e) { let t, r; return t = n.parentNode, r = n.nextSibling, r ? t.insertBefore(e, r) : t.appendChild(e), e }) }; const ge = function (e, t, n) { return V(t, function (t) { return vo.is(t, 'array') && (e = e.cloneNode(!0)), n && Ra(Ba(t.childNodes), function (t) { e.appendChild(t) }), t.parentNode.replaceChild(e, t) }) }; const he = function (e, t) { let n; return e.nodeName !== t.toUpperCase() && (n = q(t), Ra(S(e), function (t) { k(n, t.nodeName, C(e, t.nodeName)) }), ge(n, e, !0)), n || e }; const pe = function (e, t) { let n; let r = e; while (r) { n = t; while (n && r !== n) { n = n.parentNode } if (r === n) { break } r = r.parentNode } return !r && e.ownerDocument ? e.ownerDocument.documentElement : r }; const ve = function (e) { return g.toHex(vo.trim(e)) }; const be = function (e) { if (qn.isElement(e)) { const t = e.nodeName.toLowerCase() === 'a' && !C(e, 'href') && C(e, 'id'); if (C(e, 'name') || C(e, 'data-mce-bookmark') || t) { return !0 } } return !1 }; const ye = function (e, t) { let n; let r; let o = 0; if (be(e)) { return !1 } if (e = e.firstChild, e) { const i = new Aa(e, e.parentNode); const u = m ? m.getWhiteSpaceElements() : {}; t = t || (m ? m.getNonEmptyElements() : null); do { if (n = e.nodeType, qn.isElement(e)) { const a = e.getAttribute('data-mce-bogus'); if (a) { e = i.next(a === 'all'); continue } if (r = e.nodeName.toLowerCase(), t && t[r]) { if (r === 'br') { o++, e = i.next(); continue } return !1 } if (be(e)) { return !1 } } if (n === 8) { return !1 } if (n === 3 && !za.test(e.nodeValue)) { return !1 } if (n === 3 && e.parentNode && u[e.parentNode.nodeName] && za.test(e.nodeValue)) { return !1 } e = i.next() } while (e) } return o <= 1 }; const we = function () { return e.createRange() }; const xe = function (e, t, n) { let r; let o; let i; let u = we(); if (e && t) { return u.setStart(e.parentNode, Ha(e)), u.setEnd(t.parentNode, Ha(t)), r = u.extractContents(), u = we(), u.setStart(t.parentNode, Ha(t) + 1), u.setEnd(e.parentNode, Ha(e) + 1), o = u.extractContents(), i = e.parentNode, i.insertBefore(Go.trimNode(De, r), e), n ? i.insertBefore(n, e) : i.insertBefore(t, e), i.insertBefore(Go.trimNode(De, o), e), K(e), n || t } }; var Ce = function (n, r, o, i) { if (vo.isArray(n)) { let a = n.length; const c = []; while (a--) { c[a] = Ce(n[a], r, o, i) } return c } return !t.collect || n !== e && n !== u || d.push([n, r, o, i]), h.bind(n, r, o, i || De) }; var Se = function (t, n, r) { let o; if (vo.isArray(t)) { o = t.length; const i = []; while (o--) { i[o] = Se(t[o], n, r) } return i } if (d && (t === e || t === u)) { o = d.length; while (o--) { const a = d[o]; t !== a[0] || n && n !== a[1] || r && r !== a[2] || h.unbind(a[0], a[1], a[2]) } } return h.unbind(t, n, r) }; const ke = function (e, t, n) { return h.fire(e, t, n) }; const Te = function (e) { if (e && qn.isElement(e)) { const t = e.getAttribute('data-mce-contenteditable'); return t && t !== 'inherit' ? t : e.contentEditable !== 'inherit' ? e.contentEditable : null } return null }; const Ee = function (e) { for (var t = E(), n = null; e && e !== t; e = e.parentNode) { if (n = Te(e), n !== null) { break } } return n }; const Oe = function () { if (d) { let e = d.length; while (e--) { const t = d[e]; h.unbind(t[0], t[1], t[2]) } }Lu.setDocument && Lu.setDocument() }; const Ne = function (e, t) { while (e) { if (t === e) { return !0 } e = e.parentNode } return !1 }; const _e = function (e) { return 'startContainer: ' + e.startContainer.nodeName + ', startOffset: ' + e.startOffset + ', endContainer: ' + e.endContainer.nodeName + ', endOffset: ' + e.endOffset }; var De = { doc: e, settings: t, win: u, files: a, stdMode: s, boxModel: l, styleSheetLoader: f, boundEvents: d, styles: g, schema: m, events: h, isBlock: b, $: v, $$: x, root: null, clone: T, getRoot: E, getViewPort: O, getRect: B, getSize: R, getParent: z, getParents: P, get: w, getNext: L, getPrev: H, select: F, is: M, add: W, create: q, createHTML: X, createFragment: Y, remove: K, setStyle: _, getStyle: A, setStyles: D, removeAllAttribs: J, setAttrib: k, setAttribs: U, getAttrib: C, getPos: N, parseStyle: Z, serializeStyle: Q, addStyle: ee, loadCSS: te, addClass: re, removeClass: oe, hasClass: ie, toggleClass: ne, show: ue, hide: ae, isHidden: ce, uniqueId: le, setHTML: j, getOuterHTML: fe, setOuterHTML: de, decode: $, encode: G, insertAfter: me, replace: ge, rename: he, findCommonAncestor: pe, toHex: ve, run: V, getAttribs: S, isEmpty: ye, createRng: we, nodeIndex: Ha, split: xe, bind: Ce, unbind: Se, fire: ke, getContentEditable: Te, getContentEditableParent: Ee, destroy: Oe, isChildOf: Ne, dumpRng: _e }; return r = Ia(g, t, function () { return De }), De }(function (e) { e.DOM = e(n.document), e.nodeIndex = Ha })(Fa || (Fa = {})); const Va = Fa; const Ua = Va.DOM; const ja = vo.each; const Wa = vo.grep; const qa = 0; const $a = 1; const Ga = 2; const Xa = 3; const Ya = (function () { function e (e) { void 0 === e && (e = {}), this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = 0, this.settings = e } return e.prototype._setReferrerPolicy = function (e) { this.settings.referrerPolicy = e }, e.prototype.loadScript = function (e, t, r) { let o; let i; const u = Ua; const a = function () { u.remove(i), o && (o.onreadystatechange = o.onload = o = null), t() }; const c = function () { k(r) ? r() : typeof n.console !== 'undefined' && n.console.log && n.console.log('Failed to load script: ' + e) }; i = u.uniqueId(), o = n.document.createElement('script'), o.id = i, o.type = 'text/javascript', o.src = vo._addCacheSuffix(e), this.settings.referrerPolicy && u.setAttrib(o, 'referrerpolicy', this.settings.referrerPolicy), o.onload = a, o.onerror = c, (n.document.getElementsByTagName('head')[0] || n.document.body).appendChild(o) }, e.prototype.isDone = function (e) { return this.states[e] === Ga }, e.prototype.markDone = function (e) { this.states[e] = Ga }, e.prototype.add = function (e, t, n, r) { const o = this.states[e]; void 0 === o && (this.queue.push(e), this.states[e] = qa), t && (this.scriptLoadedCallbacks[e] || (this.scriptLoadedCallbacks[e] = []), this.scriptLoadedCallbacks[e].push({ success: t, failure: r, scope: n || this })) }, e.prototype.load = function (e, t, n, r) { return this.add(e, t, n, r) }, e.prototype.remove = function (e) { delete this.states[e], delete this.scriptLoadedCallbacks[e] }, e.prototype.loadQueue = function (e, t, n) { this.loadScripts(this.queue, e, t, n) }, e.prototype.loadScripts = function (e, t, n, r) { let o; const i = this; const u = []; const a = function (e, t) { ja(i.scriptLoadedCallbacks[t], function (t) { k(t[e]) && t[e].call(t.scope) }), i.scriptLoadedCallbacks[t] = void 0 }; i.queueLoadedCallbacks.push({ success: t, failure: r, scope: n || this }), o = function () { const t = Wa(e); if (e.length = 0, ja(t, function (e) { i.states[e] !== Ga ? i.states[e] !== Xa ? i.states[e] !== $a && (i.states[e] = $a, i.loading++, i.loadScript(e, function () { i.states[e] = Ga, i.loading--, a('success', e), o() }, function () { i.states[e] = Xa, i.loading--, u.push(e), a('failure', e), o() })) : a('failure', e) : a('success', e) }), !i.loading) { const n = i.queueLoadedCallbacks.slice(0); i.queueLoadedCallbacks.length = 0, ja(n, function (e) { u.length === 0 ? k(e.success) && e.success.call(e.scope) : k(e.failure) && e.failure.call(e.scope, u) }) } }, o() }, e.ScriptLoader = new e(), e }()); const Ka = function (e) { return w(e) && ce(e, 'raw') }; const Ja = function (e) { return x(e) && e.length > 1 }; const Za = {}; const Qa = be('en'); const ec = function () { return ae(Za, Qa.get()) }; const tc = function () { return te(Za, function (e) { return se({}, e) }) }; const nc = function (e) { e && Qa.set(e) }; const rc = function () { return Qa.get() }; const oc = function (e, t) { let n = Za[e]; n || (Za[e] = n = {}), ee(t, function (e, t) { n[t.toLowerCase()] = e }) }; const ic = function (e) { const t = ec().getOr({}); const n = function (e) { return k(e) ? Object.prototype.toString.call(e) : r(e) ? '' : '' + e }; var r = function (e) { return e === '' || e === null || void 0 === e }; const o = function (e) { const r = n(e); return ae(t, r.toLowerCase()).map(n).getOr(r) }; const i = function (e) { return e.replace(/{context:\w+}$/, '') }; const u = function (e) { return e }; if (r(e)) { return u('') } if (Ka(e)) { return u(n(e.raw)) } if (Ja(e)) { const a = e.slice(1); const c = o(e[0]).replace(/\{([0-9]+)\}/g, function (e, t) { return ce(a, t) ? n(a[t]) : e }); return u(i(c)) } return u(i(o(e))) }; const uc = function () { return ec().bind(function (e) { return ae(e, '_dir') }).exists(function (e) { return e === 'rtl' }) }; const ac = function (e) { return ce(Za, e) }; const cc = { getData: tc, setCode: nc, getCode: rc, add: oc, translate: ic, isRtl: uc, hasCode: ac }; function sc () { const e = this; const t = []; const n = {}; const r = {}; const o = []; const i = function (e, t) { const n = I(o, function (n) { return n.name === e && n.state === t }); M(n, function (e) { return e.callback() }) }; const u = function (e) { if (r[e]) { return r[e].instance } }; const a = function (e) { let t; return r[e] && (t = r[e].dependencies), t || [] }; const c = function (e, t) { !1 !== sc.languageLoad && h(e, function () { const r = cc.getCode(); const o = ',' + (t || '') + ','; !r || t && !o.includes(',' + r + ',') || Ya.ScriptLoader.add(n[e] + '/langs/' + r + '.js') }, 'loaded') }; const s = function (e, n, o) { const u = n; return t.push(u), r[e] = { instance: u, dependencies: o }, i(e, 'added'), u }; const l = function (e) { delete n[e], delete r[e] }; const f = function (e, t) { return typeof t === 'object' ? t : typeof e === 'string' ? { prefix: '', resource: t, suffix: '' } : { prefix: e.prefix, resource: t, suffix: e.suffix } }; const d = function (t, n) { const r = e.urls[t]; M(n, function (e) { Ya.ScriptLoader.add(r + '/' + e) }) }; const m = function (e, t, n, r) { const o = a(e); M(o, function (e) { const n = f(t, e); g(n.resource, n, void 0, void 0) }), n && (r ? n.call(r) : n.call(Ya)) }; var g = function (e, t, o, u, a) { if (!n[e]) { let c = typeof t === 'string' ? t : t.prefix + t.resource + t.suffix; c.indexOf('/') !== 0 && !c.includes('://') && (c = sc.baseURL + '/' + c), n[e] = c.substring(0, c.lastIndexOf('/')); const s = function () { i(e, 'loaded'), m(e, t, o, u) }; r[e] ? s() : Ya.ScriptLoader.add(c, s, u, a) } }; var h = function (e, t, i) { void 0 === i && (i = 'added'), ce(r, e) && i === 'added' ? t() : ce(n, e) && i === 'loaded' ? t() : o.push({ name: e, state: i, callback: t }) }; return { items: t, urls: n, lookup: r, _listeners: o, get: u, dependencies: a, requireLangPack: c, add: s, remove: l, createUrl: f, addComponents: d, load: g, waitFor: h } }(function (e) { e.PluginManager = e(), e.ThemeManager = e() })(sc || (sc = {})); const lc = sc; const fc = function (e, t) { let r = null; const o = function () { r !== null && (n.clearTimeout(r), r = null) }; const i = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r === null && (r = n.setTimeout(function () { e.apply(null, o), r = null }, t)) }; return { cancel: o, throttle: i } }; const dc = function (e, t) { let r = null; const o = function () { r !== null && (n.clearTimeout(r), r = null) }; const i = function () { for (var o = [], i = 0; i < arguments.length; i++) { o[i] = arguments[i] }r !== null && n.clearTimeout(r), r = n.setTimeout(function () { e.apply(null, o), r = null }, t) }; return { cancel: o, throttle: i } }; const mc = function (e, t) { const n = Kn(e, t); return void 0 === n || n === '' ? [] : n.split(' ') }; const gc = function (e, t, n) { const r = mc(e, t); const o = r.concat([n]); return Xn(e, t, o.join(' ')), !0 }; const hc = function (e, t, n) { const r = I(mc(e, t), function (e) { return e !== n }); return r.length > 0 ? Xn(e, t, r.join(' ')) : Qn(e, t), !1 }; const pc = function (e) { return void 0 !== e.dom().classList }; const vc = function (e) { return mc(e, 'class') }; const bc = function (e, t) { return gc(e, 'class', t) }; const yc = function (e, t) { return hc(e, 'class', t) }; const wc = function (e, t) { pc(e) ? e.dom().classList.add(t) : bc(e, t) }; const xc = function (e) { const t = pc(e) ? e.dom().classList : vc(e); t.length === 0 && Qn(e, 'class') }; const Cc = function (e, t) { if (pc(e)) { const n = e.dom().classList; n.remove(t) } else { yc(e, t) }xc(e) }; const Sc = function (e, t) { return pc(e) && e.dom().classList.contains(t) }; var kc = function (e, t) { let n = []; return M(Wt(e), function (e) { t(e) && (n = n.concat([e])), n = n.concat(kc(e, t)) }), n }; const Tc = function (e, t) { return Nt(t, e) }; function Ec (e, t, n, r, o) { return e(n, r) ? p.some(n) : k(o) && o(n) ? p.none() : t(n, r, o) } const Oc = function (e, t, n) { let r = e.dom(); const o = k(n) ? n : i(!1); while (r.parentNode) { r = r.parentNode; const u = ve.fromDom(r); if (t(u)) { return p.some(u) } if (o(u)) { break } } return p.none() }; const Nc = function (e, t, n) { const r = function (e, t) { return t(e) }; return Ec(r, Oc, e, t, n) }; const _c = function (e, t, n) { return Oc(e, function (e) { return Et(e, t) }, n) }; const Dc = function (e, t) { return _t(t, e) }; const Ac = function (e, t, n) { return Ec(Et, _c, e, t, n) }; const Rc = i('mce-annotation'); const Bc = i('data-mce-annotation'); const Mc = i('data-mce-annotation-uid'); const Pc = function (e, t) { const n = e.selection.getRng(); const r = ve.fromDom(n.startContainer); const o = ve.fromDom(e.getBody()); const i = t.fold(function () { return '.' + Rc() }, function (e) { return '[' + Bc() + '="' + e + '"]' }); const u = qt(r, n.startOffset).getOr(r); const a = Ac(u, i, function (e) { return Dt(e, o) }); const c = function (e, t) { return Zn(e, t) ? p.some(Kn(e, t)) : p.none() }; return a.bind(function (t) { return c(t, '' + Mc()).bind(function (n) { return c(t, '' + Bc()).map(function (t) { const r = Ic(e, n); return { uid: n, name: t, elements: r } }) }) }) }; const zc = function (e) { return sn(e) && Sc(e, Rc()) }; var Ic = function (e, t) { const n = ve.fromDom(e.getBody()); return Tc(n, '[' + Mc() + '="' + t + '"]') }; const Lc = function (e, t) { const n = ve.fromDom(e.getBody()); const r = Tc(n, '[' + Bc() + '="' + t + '"]'); const o = {}; return M(r, function (e) { const t = Kn(e, Mc()); const n = o.hasOwnProperty(t) ? o[t] : []; o[t] = n.concat([e]) }), o }; const Hc = function (e, t) { const n = be({}); const r = function () { return { listeners: [], previous: be(p.none()) } }; const o = function (e, t) { i(e, function (e) { return t(e), e }) }; var i = function (e, t) { const o = n.get(); const i = o.hasOwnProperty(e) ? o[e] : r(); const u = t(i); o[e] = u, n.set(o) }; const u = function (e, t, n) { o(e, function (r) { M(r.listeners, function (r) { return r(!0, e, { uid: t, nodes: B(n, function (e) { return e.dom() }) }) }) }) }; const a = function (e) { o(e, function (t) { M(t.listeners, function (t) { return t(!1, e) }) }) }; const c = dc(function () { const t = n.get(); const r = X(Z(t)); M(r, function (t) { i(t, function (n) { const r = n.previous.get(); return Pc(e, p.some(t)).fold(function () { r.isSome() && (a(t), n.previous.set(p.none())) }, function (e) { const t = e.uid; const o = e.name; const i = e.elements; r.is(t) || (u(o, t, i), n.previous.set(p.some(t))) }), { previous: n.previous, listeners: n.listeners } }) }) }, 30); e.on('remove', function () { c.cancel() }), e.on('NodeChange', function () { c.throttle() }); const s = function (e, t) { i(e, function (e) { return { previous: e.previous, listeners: e.listeners.concat([t]) } }) }; return { addListener: s } }; const Fc = function (e, t) { const n = function (e) { return p.from(e.attr(Bc())).bind(t.lookup) }; e.on('init', function () { e.serializer.addNodeFilter('span', function (e) { M(e, function (e) { n(e).each(function (t) { !1 === t.persistent && e.unwrap() }) }) }) }) }; const Vc = function () { const e = {}; const t = function (t, n) { e[t] = { name: t, settings: n } }; const n = function (t) { return e.hasOwnProperty(t) ? p.from(e[t]).map(function (e) { return e.settings }) : p.none() }; return { register: t, lookup: n } }; let Uc = 0; const jc = function (e) { const t = new Date(); const n = t.getTime(); const r = Math.floor(1e9 * Math.random()); return Uc++, e + '_' + r + Uc + String(n) }; const Wc = function (e, t) { M(t, function (t) { wc(e, t) }) }; const qc = function (e, t) { const r = t || n.document; const o = r.createElement('div'); return o.innerHTML = e, Wt(ve.fromDom(o)) }; const $c = function (e) { return e.dom().innerHTML }; const Gc = function (e, t) { const n = Pt(e); const r = n.dom(); const o = ve.fromDom(r.createDocumentFragment()); const i = qc(t, r); tn(o, i), nn(e), Zt(e, o) }; const Xc = function (e, t) { return ve.fromDom(e.dom().cloneNode(t)) }; const Yc = function (e) { return Xc(e, !1) }; const Kc = function (e) { return Xc(e, !0) }; const Jc = Hi; const Zc = function (e) { return e === Jc }; const Qc = function (e) { return e.replace(new RegExp(Jc, 'g'), '') }; const es = { isZwsp: Zc, ZWSP: Jc, trim: Qc }; const ts = qn.isElement; const ns = qn.isText; const rs = function (e) { return ns(e) && (e = e.parentNode), ts(e) && e.hasAttribute('data-mce-caret') }; const os = function (e) { return ns(e) && es.isZwsp(e.data) }; const is = function (e) { return rs(e) || os(e) }; const us = function (e) { return e.firstChild !== e.lastChild || !qn.isBr(e.firstChild) }; const as = function (e, t) { let n, r, o, i; if (n = e.ownerDocument, o = n.createTextNode(es.ZWSP), i = e.parentNode, t) { if (r = e.previousSibling, ns(r)) { if (is(r)) { return r } if (ms(r)) { return r.splitText(r.data.length - 1) } }i.insertBefore(o, e) } else { if (r = e.nextSibling, ns(r)) { if (is(r)) { return r } if (ds(r)) { return r.splitText(1), r } }e.nextSibling ? i.insertBefore(o, e.nextSibling) : i.appendChild(o) } return o }; const cs = function (e) { const t = e.container(); return !(!e || !qn.isText(t)) && (t.data.charAt(e.offset()) === es.ZWSP || e.isAtStart() && os(t.previousSibling)) }; const ss = function (e) { const t = e.container(); return !(!e || !qn.isText(t)) && (t.data.charAt(e.offset() - 1) === es.ZWSP || e.isAtEnd() && os(t.nextSibling)) }; const ls = function () { const e = n.document.createElement('br'); return e.setAttribute('data-mce-bogus', '1'), e }; const fs = function (e, t, n) { let r, o, i; return r = t.ownerDocument, o = r.createElement(e), o.setAttribute('data-mce-caret', n ? 'before' : 'after'), o.setAttribute('data-mce-bogus', 'all'), o.appendChild(ls()), i = t.parentNode, n ? i.insertBefore(o, t) : t.nextSibling ? i.insertBefore(o, t.nextSibling) : i.appendChild(o), o }; var ds = function (e) { return ns(e) && e.data[0] === es.ZWSP }; var ms = function (e) { return ns(e) && e.data[e.data.length - 1] === es.ZWSP }; const gs = function (e) { const t = e.getElementsByTagName('br'); const n = t[t.length - 1]; qn.isBogus(n) && n.parentNode.removeChild(n) }; const hs = function (e) { return e && e.hasAttribute('data-mce-caret') ? (gs(e), e.removeAttribute('data-mce-caret'), e.removeAttribute('data-mce-bogus'), e.removeAttribute('style'), e.removeAttribute('_moz_abspos'), e) : null }; const ps = function (e) { return rs(e.startContainer) }; const vs = qn.isContentEditableTrue; const bs = qn.isContentEditableFalse; const ys = qn.isBr; const ws = qn.isText; const xs = qn.matchNodeNames(['script', 'style', 'textarea']); const Cs = qn.matchNodeNames(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object']); const Ss = qn.matchNodeNames(['table']); const ks = is; const Ts = function (e) { return !ks(e) && (ws(e) ? !xs(e.parentNode) : Cs(e) || ys(e) || Ss(e) || Os(e)) }; const Es = function (e) { return qn.isElement(e) && e.getAttribute('unselectable') === 'true' }; var Os = function (e) { return !1 === Es(e) && bs(e) }; const Ns = function (e, t) { for (e = e.parentNode; e && e !== t; e = e.parentNode) { if (Os(e)) { return !1 } if (vs(e)) { return !0 } } return !0 }; const _s = function (e) { return !!Os(e) && !0 !== H(J(e.getElementsByTagName('*')), function (e, t) { return e || vs(t) }, !1) }; const Ds = function (e) { return Cs(e) || _s(e) }; const As = function (e, t) { return Ts(e) && Ns(e, t) }; const Rs = Math.round; const Bs = function (e) { return e ? { left: Rs(e.left), top: Rs(e.top), bottom: Rs(e.bottom), right: Rs(e.right), width: Rs(e.width), height: Rs(e.height) } : { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 } }; const Ms = function (e, t) { return e = Bs(e), t ? e.right = e.left : (e.left = e.left + e.width, e.right = e.left), e.width = 0, e }; const Ps = function (e, t) { return e.left === t.left && e.top === t.top && e.bottom === t.bottom && e.right === t.right }; const zs = function (e, t, n) { return e >= 0 && e <= Math.min(t.height, n.height) / 2 }; const Is = function (e, t) { return e.bottom - e.height / 2 < t.top || !(e.top > t.bottom) && zs(t.top - e.bottom, e, t) }; const Ls = function (e, t) { return e.top > t.bottom || !(e.bottom < t.top) && zs(t.bottom - e.top, e, t) }; const Hs = function (e, t, n) { return t >= e.left && t <= e.right && n >= e.top && n <= e.bottom }; const Fs = function (e) { const t = e.startContainer; const n = e.startOffset; return t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null }; const Vs = function (e, t) { return e.nodeType === 1 && e.hasChildNodes() && (t >= e.childNodes.length && (t = e.childNodes.length - 1), e = e.childNodes[t]), e }; const Us = new RegExp('[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]'); const js = function (e) { return typeof e === 'string' && e.charCodeAt(0) >= 768 && Us.test(e) }; const Ws = function (e, t, n) { return e.isSome() && t.isSome() ? p.some(n(e.getOrDie(), t.getOrDie())) : p.none() }; const qs = function (e, t, n, r) { return e.isSome() && t.isSome() && n.isSome() ? p.some(r(e.getOrDie(), t.getOrDie(), n.getOrDie())) : p.none() }; const $s = function (e, t) { return e ? p.some(t) : p.none() }; const Gs = [].slice; const Xs = function () { for (let e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } const n = Gs.call(arguments); return function (e) { for (let t = 0; t < n.length; t++) { if (n[t](e)) { return !0 } } return !1 } }; const Ys = function () { for (let e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } const n = Gs.call(arguments); return function (e) { for (let t = 0; t < n.length; t++) { if (!n[t](e)) { return !1 } } return !0 } }; const Ks = { and: Ys, or: Xs }; const Js = qn.isElement; const Zs = Ts; const Qs = qn.matchStyleValues('display', 'block table'); const el = qn.matchStyleValues('float', 'left right'); const tl = Ks.and(Js, Zs, c(el)); const nl = c(qn.matchStyleValues('white-space', 'pre pre-line pre-wrap')); const rl = qn.isText; const ol = qn.isBr; const il = Va.nodeIndex; const ul = Vs; const al = function (e) { return 'createRange' in e ? e.createRange() : Va.DOM.createRng() }; const cl = function (e) { return e && /[\r\n\t ]/.test(e) }; const sl = function (e) { return !!e.setStart && !!e.setEnd }; const ll = function (e) { let t; const n = e.startContainer; const r = e.startOffset; return !!(cl(e.toString()) && nl(n.parentNode) && qn.isText(n) && (t = n.data, cl(t[r - 1]) || cl(t[r + 1]))) }; const fl = function (e) { let t; const n = e.ownerDocument; const r = al(n); const o = n.createTextNode(Fi); const i = e.parentNode; return i.insertBefore(o, e), r.setStart(o, 0), r.setEnd(o, 1), t = Bs(r.getBoundingClientRect()), i.removeChild(o), t }; const dl = function (e) { const t = e.startContainer; const n = e.endContainer; const r = e.startOffset; const o = e.endOffset; if (t === n && qn.isText(n) && r === 0 && o === 1) { const i = e.cloneRange(); return i.setEndAfter(n), gl(i) } return null }; const ml = function (e) { return e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0 }; var gl = function (e) { let t, n; return n = e.getClientRects(), t = n.length > 0 ? Bs(n[0]) : Bs(e.getBoundingClientRect()), !sl(e) && ol(e) && ml(t) ? fl(e) : ml(t) && sl(e) ? dl(e) : t }; const hl = function (e, t) { const n = Ms(e, t); return n.width = 1, n.right = n.left + 1, n }; const pl = function (e) { let t; let n; const r = []; const o = function (e) { e.height !== 0 && (r.length > 0 && Ps(e, r[r.length - 1]) || r.push(e)) }; const i = function (e, t) { const n = al(e.ownerDocument); if (t < e.data.length) { if (js(e.data[t])) { return r } if (js(e.data[t - 1]) && (n.setStart(e, t), n.setEnd(e, t + 1), !ll(n))) { return o(hl(gl(n), !1)), r } }t > 0 && (n.setStart(e, t - 1), n.setEnd(e, t), ll(n) || o(hl(gl(n), !1))), t < e.data.length && (n.setStart(e, t), n.setEnd(e, t + 1), ll(n) || o(hl(gl(n), !0))) }; if (rl(e.container())) { return i(e.container(), e.offset()), r } if (Js(e.container())) { if (e.isAtEnd()) { n = ul(e.container(), e.offset()), rl(n) && i(n, n.data.length), tl(n) && !ol(n) && o(hl(gl(n), !1)) } else { if (n = ul(e.container(), e.offset()), rl(n) && i(n, 0), tl(n) && e.isAtEnd()) { return o(hl(gl(n), !1)), r } t = ul(e.container(), e.offset() - 1), tl(t) && !ol(t) && (Qs(t) || Qs(n) || !tl(n)) && o(hl(gl(t), !1)), tl(n) && o(hl(gl(n), !0)) } } return r }; function vl (e, t, n) { const r = function () { return rl(e), t === 0 }; const o = function () { return rl(e) ? t >= e.data.length : t >= e.childNodes.length }; const u = function () { let n; return n = al(e.ownerDocument), n.setStart(e, t), n.setEnd(e, t), n }; const a = function () { return n || (n = pl(vl(e, t))), n }; const c = function () { return a().length > 0 }; const s = function (n) { return n && e === n.container() && t === n.offset() }; const l = function (n) { return ul(e, n ? t - 1 : t) }; return { container: i(e), offset: i(t), toRange: u, getClientRects: a, isVisible: c, isAtStart: r, isAtEnd: o, isEqual: s, getNode: l } }(function (e) { e.fromRangeStart = function (t) { return e(t.startContainer, t.startOffset) }, e.fromRangeEnd = function (t) { return e(t.endContainer, t.endOffset) }, e.after = function (t) { return e(t.parentNode, il(t) + 1) }, e.before = function (t) { return e(t.parentNode, il(t)) }, e.isAbove = function (e, t) { return Ws(Y(t.getClientRects()), K(e.getClientRects()), Is).getOr(!1) }, e.isBelow = function (e, t) { return Ws(K(t.getClientRects()), Y(e.getClientRects()), Ls).getOr(!1) }, e.isAtStart = function (e) { return !!e && e.isAtStart() }, e.isAtEnd = function (e) { return !!e && e.isAtEnd() }, e.isTextPosition = function (e) { return !!e && qn.isText(e.container()) }, e.isElementPosition = function (t) { return !1 === e.isTextPosition(t) } })(vl || (vl = {})); let bl; const yl = vl; const wl = qn.isText; const xl = qn.isBogus; const Cl = Va.nodeIndex; var Sl = function (e) { const t = e.parentNode; return xl(t) ? Sl(t) : t }; var kl = function (e) { return e ? ro.reduce(e.childNodes, function (e, t) { return xl(t) && t.nodeName !== 'BR' ? e = e.concat(kl(t)) : e.push(t), e }, []) : [] }; const Tl = function (e, t) { while (e = e.previousSibling) { if (!wl(e)) { break } t += e.data.length } return t }; const El = function (e) { return function (t) { return e === t } }; const Ol = function (e) { let t, n, r; return t = kl(Sl(e)), n = ro.findIndex(t, El(e), e), t = t.slice(0, n + 1), r = ro.reduce(t, function (e, n, r) { return wl(n) && wl(t[r - 1]) && e++, e }, 0), t = ro.filter(t, qn.matchNodeNames([e.nodeName])), n = ro.findIndex(t, El(e), e), n - r }; const Nl = function (e) { let t; return t = wl(e) ? 'text()' : e.nodeName.toLowerCase(), t + '[' + Ol(e) + ']' }; const _l = function (e, t, n) { const r = []; for (t = t.parentNode; t !== e; t = t.parentNode) { if (n && n(t)) { break } r.push(t) } return r }; const Dl = function (e, t) { let n; let r; let o; let i; let u; let a = []; return n = t.container(), r = t.offset(), wl(n) ? o = Tl(n, r) : (i = n.childNodes, r >= i.length ? (o = 'after', r = i.length - 1) : o = 'before', n = i[r]), a.push(Nl(n)), u = _l(e, n), u = ro.filter(u, c(qn.isBogus)), a = a.concat(ro.map(u, function (e) { return Nl(e) })), a.reverse().join('/') + ',' + o }; const Al = function (e, t, n) { let r = kl(e); return r = ro.filter(r, function (e, t) { return !wl(e) || !wl(r[t - 1]) }), r = ro.filter(r, qn.matchNodeNames([t])), r[n] }; const Rl = function (e, t) { let n; let r = e; let o = 0; while (wl(r)) { if (n = r.data.length, t >= o && t <= o + n) { e = r, t -= o; break } if (!wl(r.nextSibling)) { e = r, t = n; break }o += n, r = r.nextSibling } return wl(e) && t > e.data.length && (t = e.data.length), yl(e, t) }; const Bl = function (e, t) { let n, r, o; return t ? (n = t.split(','), t = n[0].split('/'), o = n.length > 1 ? n[1] : 'before', r = ro.reduce(t, function (e, t) { return t = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(t), t ? (t[1] === 'text()' && (t[1] = '#text'), Al(e, t[1], parseInt(t[2], 10))) : null }, e), r ? wl(r) ? Rl(r, parseInt(o, 10)) : (o = o === 'after' ? Cl(r) + 1 : Cl(r), yl(r.parentNode, o)) : null) : null }; const Ml = function (e, t) { qn.isText(t) && t.data.length === 0 && e.remove(t) }; const Pl = function (e, t, n) { t.insertNode(n), Ml(e, n.previousSibling), Ml(e, n.nextSibling) }; const zl = function (e, t, n) { const r = p.from(n.firstChild); const o = p.from(n.lastChild); t.insertNode(n), r.each(function (t) { return Ml(e, t.previousSibling) }), o.each(function (t) { return Ml(e, t.nextSibling) }) }; const Il = function (e, t, n) { qn.isDocumentFragment(n) ? zl(e, t, n) : Pl(e, t, n) }; const Ll = qn.isContentEditableFalse; const Hl = function (e, t, n) { let r, o; for (o = e(t.data.slice(0, n)).length, r = t.previousSibling; r && qn.isText(r); r = r.previousSibling) { o += e(r.data).length } return o }; const Fl = function (e, t, n, r, o) { let i; let u = r[o ? 'startContainer' : 'endContainer']; let a = r[o ? 'startOffset' : 'endOffset']; const c = []; let s = 0; const l = e.getRoot(); for (qn.isText(u) ? c.push(n ? Hl(t, u, a) : a) : (i = u.childNodes, a >= i.length && i.length && (s = 1, a = Math.max(0, i.length - 1)), c.push(e.nodeIndex(i[a], n) + s)); u && u !== l; u = u.parentNode) { c.push(e.nodeIndex(u, n)) } return c }; const Vl = function (e, t, n, r) { const o = t.dom; const i = {}; return i.start = Fl(o, e, n, r, !0), t.isCollapsed() || (i.end = Fl(o, e, n, r, !1)), i }; const Ul = function (e, t, n) { let r = 0; return vo.each(e.select(t), function (e) { if (e.getAttribute('data-mce-bogus') !== 'all') { return e !== n && void r++ } }), r }; const jl = function (e, t) { let n; let r; let o; const i = t ? 'start' : 'end'; n = e[i + 'Container'], r = e[i + 'Offset'], qn.isElement(n) && n.nodeName === 'TR' && (o = n.childNodes, n = o[Math.min(t ? r : r - 1, o.length - 1)], n && (r = t ? 0 : n.childNodes.length, e['set' + (t ? 'Start' : 'End')](n, r))) }; const Wl = function (e) { return jl(e, !0), jl(e, !1), e }; const ql = function (e, t) { let n; if (qn.isElement(e) && (e = Vs(e, t), Ll(e))) { return e } if (is(e)) { if (qn.isText(e) && rs(e) && (e = e.parentNode), n = e.previousSibling, Ll(n)) { return n } if (n = e.nextSibling, Ll(n)) { return n } } }; const $l = function (e) { return ql(e.startContainer, e.startOffset) || ql(e.endContainer, e.endOffset) }; const Gl = function (e, t, n) { const r = n.getNode(); let o = r ? r.nodeName : null; const i = n.getRng(); if (Ll(r) || o === 'IMG') { return { name: o, index: Ul(n.dom, o, r) } } const u = $l(i); return u ? (o = u.tagName, { name: o, index: Ul(n.dom, o, u) }) : Vl(e, n, t, i) }; const Xl = function (e) { const t = e.getRng(); return { start: Dl(e.dom.getRoot(), yl.fromRangeStart(t)), end: Dl(e.dom.getRoot(), yl.fromRangeEnd(t)) } }; const Yl = function (e) { return { rng: e.getRng() } }; const Kl = function (e, t, n) { const r = { 'data-mce-type': 'bookmark', id: t, style: 'overflow:hidden;line-height:0px' }; return n ? e.create('span', r, '&#xFEFF;') : e.create('span', r) }; const Jl = function (e, t) { const n = e.dom; let r = e.getRng(); const o = n.uniqueId(); const i = e.isCollapsed(); const u = e.getNode(); const a = u.nodeName; if (a === 'IMG') { return { name: a, index: Ul(n, a, u) } } const c = Wl(r.cloneRange()); if (!i) { c.collapse(!1); const s = Kl(n, o + '_end', t); Il(n, c, s) }r = Wl(r), r.collapse(!0); const l = Kl(n, o + '_start', t); return Il(n, r, l), e.moveToBookmark({ id: o, keep: 1 }), { id: o } }; const Zl = function (e, t, n) { return t === 2 ? Gl(es.trim, n, e) : t === 3 ? Xl(e) : t ? Yl(e) : Jl(e, !1) }; const Ql = { getBookmark: Zl, getUndoBookmark: a(Gl, u, !0), getPersistentBookmark: Jl }; const ef = function (e, t, n) { void 0 === n && (n = l); const r = new Aa(e, t); const o = function (e) { let t; do { t = r[e]() } while (t && !qn.isText(t) && !n(t)); return p.from(t).filter(qn.isText) }; return { current () { return p.from(r.current()).filter(qn.isText) }, next () { return o('next') }, prev () { return o('prev') }, prev2 () { return o('prev2') } } }; const tf = function (e, t) { const n = t || function (t) { return e.isBlock(t) || qn.isBr(t) || qn.isContentEditableFalse(t) }; var r = function (e, t, n, o) { if (qn.isText(e)) { const i = o(e, t, e.data); if (i !== -1) { return p.some({ container: e, offset: i }) } } return n().bind(function (e) { return r(e.container, e.offset, n, o) }) }; const o = function (e, t, o, i) { const u = ef(e, i, n); return r(e, t, function () { return u.prev().map(function (e) { return { container: e, offset: e.length } }) }, o).getOrNull() }; const i = function (e, t, o, i) { const u = ef(e, i, n); return r(e, t, function () { return u.next().map(function (e) { return { container: e, offset: 0 } }) }, o).getOrNull() }; return { backwards: o, forwards: i } }; const nf = '_mce_caret'; const rf = function (e) { return qn.isElement(e) && e.id === nf }; const of = function (e, t) { while (t && t !== e) { if (t.id === nf) { return t } t = t.parentNode } return null }; const uf = qn.isElement; const af = qn.isText; const cf = function (e) { const t = e.parentNode; t && t.removeChild(e) }; const sf = function (e) { try { return e.nodeValue } catch (t) { return '' } }; const lf = function (e, t) { t.length === 0 ? cf(e) : e.nodeValue = t }; const ff = function (e) { const t = es.trim(e); return { count: e.length - t.length, text: t } }; const df = function (e, t) { return bf(e), t }; const mf = function (e, t) { const n = ff(e.data.substr(0, t.offset())); const r = ff(e.data.substr(t.offset())); const o = n.text + r.text; return o.length > 0 ? (lf(e, o), yl(e, t.offset() - n.count)) : t }; const gf = function (e, t) { const n = t.container(); const r = D(J(n.childNodes), e).map(function (e) { return e < t.offset() ? yl(n, t.offset() - 1) : t }).getOr(t); return bf(e), r }; const hf = function (e, t) { return af(e) && t.container() === e ? mf(e, t) : df(e, t) }; const pf = function (e, t) { return t.container() === e.parentNode ? gf(e, t) : df(e, t) }; const vf = function (e, t) { return yl.isTextPosition(t) ? hf(e, t) : pf(e, t) }; var bf = function (e) { if (uf(e) && is(e) && (us(e) ? e.removeAttribute('data-mce-caret') : cf(e)), af(e)) { const t = es.trim(sf(e)); lf(e, t) } }; const yf = { removeAndReposition: vf, remove: bf }; const wf = Va.DOM; const xf = function (e, t, n) { const r = e.getParam(t, n); if (r.includes('=')) { const o = e.getParam(t, '', 'hash'); return o.hasOwnProperty(e.id) ? o[e.id] : n } return r }; const Cf = function (e) { return e.getParam('iframe_attrs', {}) }; const Sf = function (e) { return e.getParam('doctype', '<!DOCTYPE html>') }; const kf = function (e) { return e.getParam('document_base_url', '') }; const Tf = function (e) { return xf(e, 'body_id', 'tinymce') }; const Ef = function (e) { return xf(e, 'body_class', '') }; const Of = function (e) { return e.getParam('content_security_policy', '') }; const Nf = function (e) { return e.getParam('br_in_pre', !0) }; const _f = function (e) { if (e.getParam('force_p_newlines', !1)) { return 'p' } const t = e.getParam('forced_root_block', 'p'); return !1 === t ? '' : !0 === t ? 'p' : t }; const Df = function (e) { return e.getParam('forced_root_block_attrs', {}) }; const Af = function (e) { return e.getParam('br_newline_selector', '.mce-toc h2,figcaption,caption') }; const Rf = function (e) { return e.getParam('no_newline_selector', '') }; const Bf = function (e) { return e.getParam('keep_styles', !0) }; const Mf = function (e) { return e.getParam('end_container_on_empty_block', !1) }; const Pf = function (e) { return vo.explode(e.getParam('font_size_style_values', 'xx-small,x-small,small,medium,large,x-large,xx-large')) }; const zf = function (e) { return vo.explode(e.getParam('font_size_classes', '')) }; const If = function (e) { return e.getParam('images_dataimg_filter', i(!0), 'function') }; const Lf = function (e) { return e.getParam('automatic_uploads', !0, 'boolean') }; const Hf = function (e) { return e.getParam('images_reuse_filename', !1, 'boolean') }; const Ff = function (e) { return e.getParam('images_replace_blob_uris', !0, 'boolean') }; const Vf = function (e) { return e.getParam('icons', '', 'string') }; const Uf = function (e) { return e.getParam('icons_url', '', 'string') }; const jf = function (e) { return e.getParam('images_upload_url', '', 'string') }; const Wf = function (e) { return e.getParam('images_upload_base_path', '', 'string') }; const qf = function (e) { return e.getParam('images_upload_credentials', !1, 'boolean') }; const $f = function (e) { return e.getParam('images_upload_handler', null, 'function') }; const Gf = function (e) { return e.getParam('content_css_cors', !1, 'boolean') }; const Xf = function (e) { return e.getParam('referrer_policy', '', 'string') }; const Yf = function (e) { return e.getParam('language', 'en', 'string') }; const Kf = function (e) { return e.getParam('language_url', '', 'string') }; const Jf = function (e) { return e.getParam('indent_use_margin', !1) }; const Zf = function (e) { return e.getParam('indentation', '40px', 'string') }; const Qf = function (e) { const t = e.settings.content_css; return y(t) ? B(t.split(','), tt) : x(t) ? t : !1 === t || e.inline ? [] : ['default'] }; const ed = function (e) { return e.getParam('directionality', cc.isRtl() ? 'rtl' : void 0) }; const td = function (e) { return e.getParam('inline_boundaries_selector', 'a[href],code,.mce-annotation', 'string') }; const nd = function (e) { return e.getParam('object_resizing') }; const rd = function (e) { return e.getParam('resize_img_proportional', !0, 'boolean') }; const od = function (e) { return e.getParam('placeholder', wf.getAttrib(e.getElement(), 'placeholder'), 'string') }; const id = { getIframeAttrs: Cf, getDocType: Sf, getDocumentBaseUrl: kf, getBodyId: Tf, getBodyClass: Ef, getContentSecurityPolicy: Of, shouldPutBrInPre: Nf, getForcedRootBlock: _f, getForcedRootBlockAttrs: Df, getBrNewLineSelector: Af, getNoNewLineSelector: Rf, shouldKeepStyles: Bf, shouldEndContainerOnEmptyBlock: Mf, getFontStyleValues: Pf, getFontSizeClasses: zf, getIconPackName: Vf, getIconsUrl: Uf, getImagesDataImgFilter: If, isAutomaticUploadsEnabled: Lf, shouldReuseFileName: Hf, shouldReplaceBlobUris: Ff, getImageUploadUrl: jf, getImageUploadBasePath: Wf, getImagesUploadCredentials: qf, getImagesUploadHandler: $f, shouldUseContentCssCors: Gf, getReferrerPolicy: Xf, getLanguageCode: Yf, getLanguageUrl: Kf, shouldIndentUseMargin: Jf, getIndentation: Zf, getContentCss: Qf, getDirectionality: ed, getInlineBoundarySelector: td, getObjectResizing: nd, getResizeImgProportional: rd, getPlaceholder: od }; const ud = mt().browser; const ad = qn.isContentEditableFalse; const cd = function (e) { return qn.isElement(e) && /^(TD|TH)$/i.test(e.tagName) }; const sd = function (e, t, n) { let r; let o; let i; let u; let a; const c = Ms(t.getBoundingClientRect(), n); return e.tagName === 'BODY' ? (r = e.ownerDocument.documentElement, o = e.scrollLeft || r.scrollLeft, i = e.scrollTop || r.scrollTop) : (a = e.getBoundingClientRect(), o = e.scrollLeft - a.left, i = e.scrollTop - a.top), c.left += o, c.right += o, c.top += i, c.bottom += i, c.width = 1, u = t.offsetWidth - t.clientWidth, u > 0 && (n && (u *= -1), c.left += u, c.right += u), c }; const ld = function (e) { let t, n, r, o, i; for (t = Da('*[contentEditable=false]', e), o = 0; o < t.length; o++) { n = t[o], r = n.previousSibling, ms(r) && (i = r.data, i.length === 1 ? r.parentNode.removeChild(r) : r.deleteData(i.length - 1, 1)), r = n.nextSibling, ds(r) && (i = r.data, i.length === 1 ? r.parentNode.removeChild(r) : r.deleteData(0, 1)) } }; const fd = function (e, t, n, r) { let o; let i; const u = be(p.none()); const a = id.getForcedRootBlock(e); const c = a.length > 0 ? a : 'p'; const s = function (e, r) { let o, a; if (l(), cd(r)) { return null } if (!n(r)) { return i = as(r, e), a = r.ownerDocument.createRange(), ad(i.nextSibling) ? (a.setStart(i, 0), a.setEnd(i, 0)) : (a.setStart(i, 1), a.setEnd(i, 1)), a } i = fs(c, r, e), o = sd(t, r, e), Da(i).css('top', o.top); const s = Da('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(o).appendTo(t)[0]; return u.set(p.some({ caret: s, element: r, before: e })), u.get().each(function (t) { e && Da(t.caret).addClass('mce-visual-caret-before') }), f(), a = r.ownerDocument.createRange(), a.setStart(i, 0), a.setEnd(i, 0), a }; var l = function () { ld(t), i && (yf.remove(i), i = null), u.get().each(function (e) { Da(e.caret).remove(), u.set(p.none()) }), Ir.clearInterval(o) }; var f = function () { o = Ir.setInterval(function () { r() ? Da('div.mce-visual-caret', t).toggleClass('mce-visual-caret-hidden') : Da('div.mce-visual-caret', t).addClass('mce-visual-caret-hidden') }, 500) }; const d = function () { u.get().each(function (e) { const n = sd(t, e.element, e.before); Da(e.caret).css(se({}, n)) }) }; const m = function () { return Ir.clearInterval(o) }; const g = function () { return '.mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}' }; return { show: s, hide: l, getCss: g, reposition: d, destroy: m } }; const dd = function () { return ud.isIE() || ud.isEdge() || ud.isFirefox() }; const md = function (e) { return ad(e) || qn.isTable(e) && dd() }; const gd = qn.isContentEditableFalse; const hd = qn.matchStyleValues('display', 'block table table-cell table-caption list-item'); const pd = is; const vd = rs; const bd = qn.isElement; const yd = Ts; const wd = function (e) { return e > 0 }; const xd = function (e) { return e < 0 }; const Cd = function (e, t) { let n; while (n = e(t)) { if (!vd(n)) { return n } } return null }; const Sd = function (e, t, n, r, o) { const i = new Aa(e, r); if (xd(t)) { if ((gd(e) || vd(e)) && (e = Cd(i.prev, !0), n(e))) { return e } while (e = Cd(i.prev, o)) { if (n(e)) { return e } } } if (wd(t)) { if ((gd(e) || vd(e)) && (e = Cd(i.next, !0), n(e))) { return e } while (e = Cd(i.next, o)) { if (n(e)) { return e } } } return null }; const kd = function (e, t) { while (e && e !== t) { if (hd(e)) { return e } e = e.parentNode } return null }; const Td = function (e, t, n) { return kd(e.container(), n) === kd(t.container(), n) }; const Ed = function (e, t) { let n, r; return t ? (n = t.container(), r = t.offset(), bd(n) ? n.childNodes[r + e] : null) : null }; const Od = function (e, t) { const n = t.ownerDocument.createRange(); return e ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), n }; const Nd = function (e, t, n) { return kd(t, e) === kd(n, e) }; const _d = function (e, t, n) { let r, o; o = e ? 'previousSibling' : 'nextSibling'; while (n && n !== t) { if (r = n[o], pd(r) && (r = r[o]), gd(r)) { if (Nd(t, r, n)) { return r } break } if (yd(r)) { break } n = n.parentNode } return null }; const Dd = a(Od, !0); const Ad = a(Od, !1); const Rd = function (e, t, n) { let r; let o; let i; let u; const c = a(_d, !0, t); const s = a(_d, !1, t); if (o = n.startContainer, i = n.startOffset, rs(o)) { if (bd(o) || (o = o.parentNode), u = o.getAttribute('data-mce-caret'), u === 'before' && (r = o.nextSibling, md(r))) { return Dd(r) } if (u === 'after' && (r = o.previousSibling, md(r))) { return Ad(r) } } if (!n.collapsed) { return n } if (qn.isText(o)) { if (pd(o)) { if (e === 1) { if (r = s(o), r) { return Dd(r) } if (r = c(o), r) { return Ad(r) } } if (e === -1) { if (r = c(o), r) { return Ad(r) } if (r = s(o), r) { return Dd(r) } } return n } if (ms(o) && i >= o.data.length - 1) { return e === 1 && (r = s(o), r) ? Dd(r) : n } if (ds(o) && i <= 1) { return e === -1 && (r = c(o), r) ? Ad(r) : n } if (i === o.data.length) { return r = s(o), r ? Dd(r) : n } if (i === 0) { return r = c(o), r ? Ad(r) : n } } return n }; const Bd = function (e, t) { return p.from(Ed(e ? 0 : -1, t)).filter(gd) }; const Md = function (e, t, n) { const r = Rd(e, t, n); return e === -1 ? vl.fromRangeStart(r) : vl.fromRangeEnd(r) }; const Pd = function (e) { return p.from(e.getNode()).map(ve.fromDom) }; const zd = function (e) { return p.from(e.getNode(!0)).map(ve.fromDom) }; const Id = function (e, t) { while (t = e(t)) { if (t.isVisible()) { return t } } return t }; const Ld = function (e, t) { const n = Td(e, t); return !(n || !qn.isBr(e.getNode())) || n }; (function (e) { e[e.Backwards = -1] = 'Backwards', e[e.Forwards = 1] = 'Forwards' })(bl || (bl = {})); const Hd = qn.isContentEditableFalse; const Fd = qn.isText; const Vd = qn.isElement; const Ud = qn.isBr; const jd = Ts; const Wd = Ds; const qd = As; const $d = function (e, t) { const n = []; while (e && e !== t) { n.push(e), e = e.parentNode } return n }; const Gd = function (e, t) { return e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null }; const Xd = function (e, t) { if (wd(e)) { if (jd(t.previousSibling) && !Fd(t.previousSibling)) { return yl.before(t) } if (Fd(t)) { return yl(t, 0) } } if (xd(e)) { if (jd(t.nextSibling) && !Fd(t.nextSibling)) { return yl.after(t) } if (Fd(t)) { return yl(t, t.data.length) } } return xd(e) ? Ud(t) ? yl.before(t) : yl.after(t) : yl.before(t) }; const Yd = function (e, t) { const n = t.nextSibling; return n && jd(n) ? Fd(n) ? yl(n, 0) : yl.before(n) : Kd(bl.Forwards, yl.after(t), e) }; var Kd = function (e, t, n) { let r, o, u, a, c; if (!Vd(n) || !t) { return null } if (t.isEqual(yl.after(n)) && n.lastChild) { if (c = yl.after(n.lastChild), xd(e) && jd(n.lastChild) && Vd(n.lastChild)) { return Ud(n.lastChild) ? yl.before(n.lastChild) : c } } else { c = t } const s = c.container(); let l = c.offset(); if (Fd(s)) { if (xd(e) && l > 0) { return yl(s, --l) } if (wd(e) && l < s.length) { return yl(s, ++l) } r = s } else { if (xd(e) && l > 0 && (o = Gd(s, l - 1), jd(o))) { return !Wd(o) && (u = Sd(o, e, qd, o), u) ? Fd(u) ? yl(u, u.data.length) : yl.after(u) : Fd(o) ? yl(o, o.data.length) : yl.before(o) } if (wd(e) && l < s.childNodes.length && (o = Gd(s, l), jd(o))) { return Ud(o) ? Yd(n, o) : !Wd(o) && (u = Sd(o, e, qd, o), u) ? Fd(u) ? yl(u, 0) : yl.before(u) : Fd(o) ? yl(o, 0) : yl.after(o) } r = o || c.getNode() } return (wd(e) && c.isAtEnd() || xd(e) && c.isAtStart()) && (r = Sd(r, e, i(!0), n, !0), qd(r, n)) ? Xd(e, r) : (o = Sd(r, e, qd, n), a = ro.last(I($d(s, n), Hd)), !a || o && a.contains(o) ? o ? Xd(e, o) : null : (c = wd(e) ? yl.after(a) : yl.before(a), c)) }; const Jd = function (e) { return { next (t) { return Kd(bl.Forwards, t, e) }, prev (t) { return Kd(bl.Backwards, t, e) } } }; const Zd = function (e, t, n) { const r = e ? yl.before(n) : yl.after(n); return im(e, t, r) }; const Qd = function (e) { return qn.isBr(e) ? yl.before(e) : yl.after(e) }; const em = function (e) { return yl.isTextPosition(e) ? e.offset() === 0 : Ts(e.getNode()) }; const tm = function (e) { if (yl.isTextPosition(e)) { const t = e.container(); return e.offset() === t.data.length } return Ts(e.getNode(!0)) }; const nm = function (e, t) { return !yl.isTextPosition(e) && !yl.isTextPosition(t) && e.getNode() === t.getNode(!0) }; const rm = function (e) { return !yl.isTextPosition(e) && qn.isBr(e.getNode()) }; const om = function (e, t, n) { return e ? !nm(t, n) && !rm(t) && tm(t) && em(n) : !nm(n, t) && em(t) && tm(n) }; var im = function (e, t, n) { const r = Jd(t); return p.from(e ? r.next(n) : r.prev(n)) }; const um = function (e, t, n) { return im(e, t, n).bind(function (r) { return Td(n, r, t) && om(e, n, r) ? im(e, t, r) : p.some(r) }) }; var am = function (e, t, n, r) { return um(e, t, n).bind(function (n) { return r(n) ? am(e, t, n, r) : p.some(n) }) }; const cm = function (e, t) { const n = e ? t.firstChild : t.lastChild; return qn.isText(n) ? p.some(yl(n, e ? 0 : n.data.length)) : n ? Ts(n) ? p.some(e ? yl.before(n) : Qd(n)) : Zd(e, t, n) : p.none() }; const sm = a(im, !0); const lm = a(im, !1); const fm = { fromPosition: im, nextPosition: sm, prevPosition: lm, navigate: um, navigateIgnore: am, positionIn: cm, firstPositionIn: a(cm, !0), lastPositionIn: a(cm, !1) }; const dm = function (e) { return typeof e.start === 'string' }; const mm = function (e) { return e.hasOwnProperty('rng') }; const gm = function (e) { return e.hasOwnProperty('id') }; const hm = function (e) { return e.hasOwnProperty('name') }; const pm = function (e) { return vo.isArray(e.start) }; const vm = function (e, t) { return qn.isElement(t) && e.isBlock(t) && !t.innerHTML && !$r.ie && (t.innerHTML = '<br data-mce-bogus="1" />'), t }; const bm = function (e, t) { let n, r; return n = e.createRng(), r = Bl(e.getRoot(), t.start), n.setStart(r.container(), r.offset()), r = Bl(e.getRoot(), t.end), n.setEnd(r.container(), r.offset()), n }; const ym = function (e, t) { const n = e.ownerDocument.createTextNode(es.ZWSP); e.appendChild(n), t.setStart(n, 0), t.setEnd(n, 0) }; const wm = function (e) { return !1 === e.hasChildNodes() }; const xm = function (e, t) { return fm.lastPositionIn(e).fold(function () { return !1 }, function (e) { return t.setStart(e.container(), e.offset()), t.setEnd(e.container(), e.offset()), !0 }) }; const Cm = function (e, t, n) { return !(!wm(t) || !of(e, t)) && (ym(t, n), !0) }; const Sm = function (e, t, n, r) { let o; let i; let u; let a; const c = n[t ? 'start' : 'end']; const s = e.getRoot(); if (c) { for (u = c[0], i = s, o = c.length - 1; o >= 1; o--) { if (a = i.childNodes, Cm(s, i, r)) { return !0 } if (c[o] > a.length - 1) { return !!Cm(s, i, r) || xm(i, r) } i = a[c[o]] }i.nodeType === 3 && (u = Math.min(c[0], i.nodeValue.length)), i.nodeType === 1 && (u = Math.min(c[0], i.childNodes.length)), t ? r.setStart(i, u) : r.setEnd(i, u) } return !0 }; const km = function (e) { return qn.isText(e) && e.data.length > 0 }; const Tm = function (e, t, n) { let r; let o; let i; let u; let a; let c; let s = e.get(n.id + '_' + t); const l = n.keep; if (s) { if (r = s.parentNode, t === 'start' ? (l ? s.hasChildNodes() ? (r = s.firstChild, o = 1) : km(s.nextSibling) ? (r = s.nextSibling, o = 0) : km(s.previousSibling) ? (r = s.previousSibling, o = s.previousSibling.data.length) : (r = s.parentNode, o = e.nodeIndex(s) + 1) : o = e.nodeIndex(s), a = r, c = o) : (l ? s.hasChildNodes() ? (r = s.firstChild, o = 1) : km(s.previousSibling) ? (r = s.previousSibling, o = s.previousSibling.data.length) : (r = s.parentNode, o = e.nodeIndex(s)) : o = e.nodeIndex(s), a = r, c = o), !l) { u = s.previousSibling, i = s.nextSibling, vo.each(vo.grep(s.childNodes), function (e) { qn.isText(e) && (e.nodeValue = e.nodeValue.replace(/\uFEFF/g, '')) }); while (s = e.get(n.id + '_' + t)) { e.remove(s, !0) }u && i && u.nodeType === i.nodeType && qn.isText(u) && !$r.opera && (o = u.nodeValue.length, u.appendData(i.nodeValue), e.remove(i), a = u, c = o) } return p.some(yl(a, c)) } return p.none() }; const Em = function (e, t) { const n = e.createRng(); return Sm(e, !0, t, n) && Sm(e, !1, t, n) ? p.some(n) : p.none() }; const Om = function (e, t) { const n = Tm(e, 'start', t); const r = Tm(e, 'end', t); return Ws(n, r.or(n), function (t, n) { const r = e.createRng(); return r.setStart(vm(e, t.container()), t.offset()), r.setEnd(vm(e, n.container()), n.offset()), r }) }; const Nm = function (e, t) { return p.from(e.select(t.name)[t.index]).map(function (t) { const n = e.createRng(); return n.selectNode(t), n }) }; const _m = function (e, t) { const n = e.dom; if (t) { if (pm(t)) { return Em(n, t) } if (dm(t)) { return p.some(bm(n, t)) } if (gm(t)) { return Om(n, t) } if (hm(t)) { return Nm(n, t) } if (mm(t)) { return p.some(t.rng) } } return p.none() }; const Dm = { resolve: _m }; const Am = function (e, t, n) { return Ql.getBookmark(e, t, n) }; const Rm = function (e, t) { Dm.resolve(e, t).each(function (t) { e.setRng(t) }) }; const Bm = function (e) { return qn.isElement(e) && e.tagName === 'SPAN' && e.getAttribute('data-mce-type') === 'bookmark' }; const Mm = { getBookmark: Am, moveToBookmark: Rm, isBookmarkNode: Bm }; const Pm = function (e) { return function (t) { return e === t } }; const zm = Pm(Fi); const Im = function (e) { return e !== '' && ' \f\n\r\t\v'.includes(e) }; const Lm = function (e) { return !Im(e) && !zm(e) }; const Hm = function (e) { return !!e.nodeType }; const Fm = function (e) { return e && /^(IMG)$/.test(e.nodeName) }; const Vm = function (e, t, n) { let r; let o; let i; const u = n.startOffset; let a = n.startContainer; if ((n.startContainer !== n.endContainer || !Fm(n.startContainer.childNodes[n.startOffset])) && a.nodeType === 1) { for (i = a.childNodes, u < i.length ? (a = i[u], r = new Aa(a, e.getParent(a, e.isBlock))) : (a = i[i.length - 1], r = new Aa(a, e.getParent(a, e.isBlock)), r.next(!0)), o = r.current(); o; o = r.next()) { if (o.nodeType === 3 && !qm(o)) { return n.setStart(o, 0), void t.setRng(n) } } } }; const Um = function (e, t, n) { if (e) { const r = t ? 'nextSibling' : 'previousSibling'; for (e = n ? e : e[r]; e; e = e[r]) { if (e.nodeType === 1 || !qm(e)) { return e } } } }; const jm = function (e, t) { return Hm(t) && (t = t.nodeName), !!e.schema.getTextBlockElements()[t.toLowerCase()] }; const Wm = function (e, t, n) { return e.schema.isValidChild(t, n) }; var qm = function (e) { return e && qn.isText(e) && /^([\t \r\n]+|)$/.test(e.nodeValue) }; const $m = function (e) { return e && qn.isText(e) && e.length === 0 }; const Gm = function (e, t) { return typeof e !== 'string' ? e = e(t) : t && (e = e.replace(/%(\w+)/g, function (e, n) { return t[n] || e })), e }; const Xm = function (e, t) { return e = e || '', t = t || '', e = '' + (e.nodeName || e), t = '' + (t.nodeName || t), e.toLowerCase() === t.toLowerCase() }; const Ym = function (e, t, n) { return n !== 'color' && n !== 'backgroundColor' || (t = e.toHex(t)), n === 'fontWeight' && t === 700 && (t = 'bold'), n === 'fontFamily' && (t = t.replace(/[\'\"]/g, '').replace(/,\s+/g, ',')), '' + t }; const Km = function (e, t, n) { return Ym(e, e.getStyle(t, n), n) }; const Jm = function (e, t) { let n; return e.getParent(t, function (t) { return n = e.getStyle(t, 'text-decoration'), n && n !== 'none' }), n }; const Zm = function (e, t, n) { return e.getParents(t, n, e.getRoot()) }; const Qm = Mm.isBookmarkNode; const eg = Zm; const tg = qm; const ng = jm; const rg = function (e) { return e.nodeName === 'BR' && e.getAttribute('data-mce-bogus') && !e.nextSibling }; const og = function (e, t) { let n = t; while (n) { if (qn.isElement(n) && e.getContentEditable(n)) { return e.getContentEditable(n) === 'false' ? n : t } n = n.parentNode } return t }; const ig = function (e, t, n, r) { for (let o = t.data, i = n; e ? i >= 0 : i < o.length; e ? i-- : i++) { if (r(o.charAt(i))) { return e ? i + 1 : i } } return -1 }; const ug = function (e, t, n) { return ig(e, t, n, function (e) { return zm(e) || Im(e) }) }; const ag = function (e, t, n) { return ig(e, t, n, Lm) }; const cg = function (e, t, n, r, o, i) { let u; const a = e.getParent(n, e.isBlock) || t; const c = function (t, n, r) { const i = tf(e); const c = o ? i.backwards : i.forwards; return p.from(c(t, n, function (e, t) { return Qm(e.parentNode) ? -1 : (u = e, r(o, e, t)) }, a)) }; const s = c(n, r, ug); return s.bind(function (e) { return i ? c(e.container, e.offset + (o ? -1 : 0), ag) : p.some(e) }).orThunk(function () { return u ? p.some({ container: u, offset: o ? 0 : u.length }) : p.none() }) }; const sg = function (e, t, n, r, o) { qn.isText(r) && r.nodeValue.length === 0 && r[o] && (r = r[o]); for (let i = eg(e, r), u = 0; u < i.length; u++) { for (let a = 0; a < t.length; a++) { const c = t[a]; if (!('collapsed' in c && c.collapsed !== n.collapsed) && e.is(i[u], c.selector)) { return i[u] } } } return r }; const lg = function (e, t, n, r) { let o; const i = e.dom; const u = i.getRoot(); if (t[0].wrapper || (o = i.getParent(n, t[0].block, u)), !o) { const a = i.getParent(n, 'LI,TD,TH'); o = i.getParent(qn.isText(n) ? n.parentNode : n, function (t) { return t !== u && ng(e, t) }, a) } if (o && t[0].wrapper && (o = eg(i, o, 'ul,ol').reverse()[0] || o), !o) { o = n; while (o[r] && !i.isBlock(o[r])) { if (o = o[r], Xm(o, 'br')) { break } } } return o || n }; const fg = function (e, t, n, r, o, i, u) { let a, c, s, l, f; if (a = c = u ? n : o, l = u ? 'previousSibling' : 'nextSibling', f = e.getRoot(), qn.isText(a) && !tg(a) && (u ? r > 0 : i < a.nodeValue.length)) { return a } while (1) { if (!t[0].block_expand && e.isBlock(c)) { return c } for (s = c[l]; s; s = s[l]) { if (!Qm(s) && !tg(s) && !rg(s)) { return c } } if (c === f || c.parentNode === f) { a = c; break }c = c.parentNode } return a }; const dg = function (e, t, n, r) { void 0 === r && (r = !1); let o = t.startContainer; let i = t.startOffset; let u = t.endContainer; let a = t.endOffset; const c = e.dom; if (qn.isElement(o) && o.hasChildNodes() && (o = Vs(o, i), qn.isText(o) && (i = 0)), qn.isElement(u) && u.hasChildNodes() && (u = Vs(u, t.collapsed ? a : a - 1), qn.isText(u) && (a = u.nodeValue.length)), o = og(c, o), u = og(c, u), (Qm(o.parentNode) || Qm(o)) && (o = Qm(o) ? o : o.parentNode, o = t.collapsed ? o.previousSibling || o : o.nextSibling || o, qn.isText(o) && (i = t.collapsed ? o.length : 0)), (Qm(u.parentNode) || Qm(u)) && (u = Qm(u) ? u : u.parentNode, u = t.collapsed ? u.nextSibling || u : u.previousSibling || u, qn.isText(u) && (a = t.collapsed ? 0 : u.length)), t.collapsed) { const s = cg(c, e.getBody(), o, i, !0, r); s.each(function (e) { const t = e.container; const n = e.offset; o = t, i = n }); const l = cg(c, e.getBody(), u, a, !1, r); l.each(function (e) { const t = e.container; const n = e.offset; u = t, a = n }) } return (n[0].inline || n[0].block_expand) && (n[0].inline && qn.isText(o) && i !== 0 || (o = fg(c, n, o, i, u, a, !0)), n[0].inline && qn.isText(u) && a !== u.nodeValue.length || (u = fg(c, n, o, i, u, a, !1))), n[0].selector && !1 !== n[0].expand && !n[0].inline && (o = sg(c, n, t, o, 'previousSibling'), u = sg(c, n, t, u, 'nextSibling')), (n[0].block || n[0].selector) && (o = lg(e, n, o, 'previousSibling'), u = lg(e, n, u, 'nextSibling'), n[0].block && (c.isBlock(o) || (o = fg(c, n, o, i, u, a, !0)), c.isBlock(u) || (u = fg(c, n, o, i, u, a, !1)))), qn.isElement(o) && (i = c.nodeIndex(o), o = o.parentNode), qn.isElement(u) && (a = c.nodeIndex(u) + 1, u = u.parentNode), { startContainer: o, startOffset: i, endContainer: u, endOffset: a } }; const mg = vo.each; const gg = function (e, t) { const n = e.childNodes; return t >= n.length ? t = n.length - 1 : t < 0 && (t = 0), n[t] || e }; const hg = function (e, t) { return gg(e, t - 1) }; const pg = function (e, t, n) { let r = t.startContainer; const o = t.startOffset; let i = t.endContainer; const u = t.endOffset; const a = e.select('td[data-mce-selected],th[data-mce-selected]'); if (a.length > 0) { mg(a, function (e) { n([e]) }) } else { const c = function (e) { let t; return t = e[0], t.nodeType === 3 && t === r && o >= t.nodeValue.length && e.splice(0, 1), t = e[e.length - 1], u === 0 && e.length > 0 && t === i && t.nodeType === 3 && e.splice(e.length - 1, 1), e }; const s = function (e, t, n) { for (var r = []; e && e !== n; e = e[t]) { r.push(e) } return r }; const l = function (e, t) { do { if (e.parentNode === t) { return e } e = e.parentNode } while (e) }; const f = function (e, t, r) { for (let o = r ? 'nextSibling' : 'previousSibling', i = e, u = i.parentNode; i && i !== t; i = u) { u = i.parentNode; const a = s(i === e ? i : i[o], o); a.length && (r || a.reverse(), n(c(a))) } }; if (r.nodeType === 1 && r.hasChildNodes() && (r = gg(r, o)), i.nodeType === 1 && i.hasChildNodes() && (i = hg(i, u)), r === i) { return n(c([r])) } for (var d = e.findCommonAncestor(r, i), m = r; m; m = m.parentNode) { if (m === i) { return f(r, d, !0) } if (m === d) { break } } for (m = i; m; m = m.parentNode) { if (m === r) { return f(i, d) } if (m === d) { break } } const g = l(r, d) || r; const h = l(i, d) || i; f(r, g, !0); const p = s(g === r ? g : g.nextSibling, 'nextSibling', h === i ? h.nextSibling : h); p.length && n(c(p)), f(i, h) } }; const vg = { walk: pg }; function bg (e, t) { const n = function (n) { if (!e(n)) { throw new Error('Can only get ' + t + ' value of a ' + t + ' node') } return r(n).getOr('') }; var r = function (t) { return e(t) ? p.from(t.dom().nodeValue) : p.none() }; const o = function (n, r) { if (!e(n)) { throw new Error('Can only set raw ' + t + ' value of a ' + t + ' node') } n.dom().nodeValue = r }; return { get: n, getOption: r, set: o } } const yg = bg(ln, 'text'); const wg = function (e) { return yg.get(e) }; const xg = function (e) { return ln(e) && wg(e) === Hi }; const Cg = function (e, t, n, r) { return Lt(t).fold(function () { return 'skipping' }, function (o) { return r === 'br' || xg(t) ? 'valid' : zc(t) ? 'existing' : rf(t) ? 'caret' : Wm(e, n, r) && Wm(e, un(o), n) ? 'valid' : 'invalid-child' }) }; const Sg = function (e, t) { const n = dg(e, t, [{ inline: !0 }]); t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t) }; const kg = function (e, t, n, r) { const o = t.uid; const i = void 0 === o ? jc('mce-annotation') : o; const u = le(t, ['uid']); const a = ve.fromTag('span', e); wc(a, Rc()), Xn(a, '' + Mc(), i), Xn(a, '' + Bc(), n); const c = r(i, u); const s = c.attributes; const l = void 0 === s ? {} : s; const f = c.classes; const d = void 0 === f ? [] : f; return Yn(a, l), Wc(a, d), a }; const Tg = function (e, t, n, r, o) { const i = []; const u = kg(e.getDoc(), o, n, r); const a = be(p.none()); const c = function () { a.set(p.none()) }; const s = function () { return a.get().getOrThunk(function () { const e = Yc(u); return i.push(e), a.set(p.some(e)), e }) }; const l = function (e) { M(e, f) }; var f = function (t) { const n = Cg(e, t, 'span', un(t)); switch (n) { case 'invalid-child':c(); var r = Wt(t); l(r), c(); break; case 'valid':var o = s(); Qt(t, o); break } }; const d = function (e) { const t = B(e, ve.fromDom); l(t) }; return vg.walk(e.dom, t, function (e) { c(), d(e) }), i }; const Eg = function (e, t, n, r) { e.undoManager.transact(function () { const o = e.selection.getRng(); if (o.collapsed && Sg(e, o), e.selection.getRng().collapsed) { const i = kg(e.getDoc(), r, t, n.decorate); Gc(i, Fi), e.selection.getRng().insertNode(i.dom()), e.selection.select(i.dom()) } else { const u = Ql.getPersistentBookmark(e.selection, !1); const a = e.selection.getRng(); Tg(e, a, t, n.decorate, r), e.selection.moveToBookmark(u) } }) }; const Og = function (e) { const t = Vc(); Fc(e, t); const n = Hc(e); return { register (e, n) { t.register(e, n) }, annotate (n, r) { t.lookup(n).each(function (t) { Eg(e, n, t, r) }) }, annotationChanged (e, t) { n.addListener(e, t) }, remove (t) { Pc(e, p.some(t)).each(function (e) { const t = e.elements; M(t, on) }) }, getAll (t) { const n = Lc(e, t); return te(n, function (e) { return B(e, function (e) { return e.dom() }) }) } } }; const Ng = /^[ \t\r\n]*$/; const _g = { '#text': 3, '#comment': 8, '#cdata': 4, '#pi': 7, '#doctype': 10, '#document-fragment': 11 }; const Dg = function (e, t, n) { const r = n ? 'lastChild' : 'firstChild'; const o = n ? 'prev' : 'next'; if (e[r]) { return e[r] } if (e !== t) { let i = e[o]; if (i) { return i } for (let u = e.parent; u && u !== t; u = u.parent) { if (i = u[o], i) { return i } } } }; const Ag = function (e) { if (!Ng.test(e.value)) { return !1 } const t = e.parent; return !t || t.name === 'span' && !t.attr('style') || !/^[ ]+$/.test(e.value) }; const Rg = function (e) { const t = e.name === 'a' && !e.attr('href') && e.attr('id'); return e.attr('name') || e.attr('id') && !e.firstChild || e.attr('data-mce-bookmark') || t }; const Bg = (function () { function e (e, t) { this.name = e, this.type = t, t === 1 && (this.attributes = [], this.attributes.map = {}) } return e.create = function (t, n) { const r = new e(t, _g[t] || 1); if (n) { for (const o in n) { r.attr(o, n[o]) } } return r }, e.prototype.replace = function (e) { const t = this; return e.parent && e.remove(), t.insert(e, t), t.remove(), t }, e.prototype.attr = function (e, t) { let n; const r = this; if (typeof e !== 'string') { for (const o in e) { r.attr(o, e[o]) } return r } if (n = r.attributes) { if (void 0 !== t) { if (t === null) { if (e in n.map) { delete n.map[e]; var i = n.length; while (i--) { if (n[i].name === e) { return n.splice(i, 1), r } } } return r } if (e in n.map) { i = n.length; while (i--) { if (n[i].name === e) { n[i].value = t; break } } } else { n.push({ name: e, value: t }) } return n.map[e] = t, r } return n.map[e] } }, e.prototype.clone = function () { let t; const n = this; const r = new e(n.name, n.type); if (t = n.attributes) { const o = []; o.map = {}; for (let i = 0, u = t.length; i < u; i++) { const a = t[i]; a.name !== 'id' && (o[o.length] = { name: a.name, value: a.value }, o.map[a.name] = a.value) }r.attributes = o } return r.value = n.value, r.shortEnded = n.shortEnded, r }, e.prototype.wrap = function (e) { const t = this; return t.parent.insert(e, t), e.append(t), t }, e.prototype.unwrap = function () { for (var e = this, t = e.firstChild; t;) { const n = t.next; e.insert(t, e, !0), t = n }e.remove() }, e.prototype.remove = function () { const e = this; const t = e.parent; const n = e.next; const r = e.prev; return t && (t.firstChild === e ? (t.firstChild = n, n && (n.prev = null)) : r.next = n, t.lastChild === e ? (t.lastChild = r, r && (r.next = null)) : n.prev = r, e.parent = e.next = e.prev = null), e }, e.prototype.append = function (e) { const t = this; e.parent && e.remove(); const n = t.lastChild; return n ? (n.next = e, e.prev = n, t.lastChild = e) : t.lastChild = t.firstChild = e, e.parent = t, e }, e.prototype.insert = function (e, t, n) { e.parent && e.remove(); const r = t.parent || this; return n ? (t === r.firstChild ? r.firstChild = e : t.prev.next = e, e.prev = t.prev, e.next = t, t.prev = e) : (t === r.lastChild ? r.lastChild = e : t.next.prev = e, e.next = t.next, e.prev = t, t.next = e), e.parent = r, e }, e.prototype.getAll = function (e) { for (var t = this, n = [], r = t.firstChild; r; r = Dg(r, t)) { r.name === e && n.push(r) } return n }, e.prototype.empty = function () { const e = this; if (e.firstChild) { for (var t = [], n = e.firstChild; n; n = Dg(n, e)) { t.push(n) } let r = t.length; while (r--) { n = t[r]; n.parent = n.firstChild = n.lastChild = n.next = n.prev = null } } return e.firstChild = e.lastChild = null, e }, e.prototype.isEmpty = function (e, t, n) { void 0 === t && (t = {}); const r = this; let o = r.firstChild; if (Rg(r)) { return !1 } if (o) { do { if (o.type === 1) { if (o.attr('data-mce-bogus')) { continue } if (e[o.name]) { return !1 } if (Rg(o)) { return !1 } } if (o.type === 8) { return !1 } if (o.type === 3 && !Ag(o)) { return !1 } if (o.type === 3 && o.parent && t[o.parent.name] && Ng.test(o.value)) { return !1 } if (n && n(o)) { return !1 } } while (o = Dg(o, r)) } return !0 }, e.prototype.walk = function (e) { return Dg(this, null, e) }, e }()); const Mg = function (e) { return e.indexOf('data-') === 0 || e.indexOf('aria-') === 0 }; const Pg = function (e, t) { return !e.allow_html_data_urls && (/^data:image\//i.test(t) ? !1 === e.allow_svg_data_urls && /^data:image\/svg\+xml/i.test(t) : /^data:/i.test(t)) }; const zg = function (e, t, n) { let r; let o; let i; let u; let a = 1; u = e.getShortEndedElements(), i = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g, i.lastIndex = r = n; while (o = i.exec(t)) { if (r = i.lastIndex, o[1] === '/') { a-- } else if (!o[1]) { if (o[2] in u) { continue } a++ } if (a === 0) { break } } return r }; const Ig = function (e, t) { return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(e.substr(t)) }; const Lg = function (e, t, n) { void 0 === n && (n = 0); const r = e.toLowerCase(); if (r.includes('[if ', n) && Ig(r, n)) { const o = r.indexOf('[endif]', n); return r.indexOf('>', o) } if (t) { const i = r.indexOf('>', n); return i !== -1 ? i : r.length } const u = /--!?>/; u.lastIndex = n; const a = u.exec(e); return a ? a.index + a[0].length : r.length }; const Hg = function (e, t) { const n = e.exec(t); if (n) { const r = n[1]; const o = n[2]; return typeof r === 'string' && r.toLowerCase() === 'data-mce-bogus' ? o : null } return null }; function Fg (e, t) { void 0 === t && (t = yi()); const n = function () {}; e = e || {}, !1 !== e.fix_self_closing && (e.fix_self_closing = !0); const r = e.comment ? e.comment : n; const o = e.cdata ? e.cdata : n; const i = e.text ? e.text : n; const u = e.start ? e.start : n; const a = e.end ? e.end : n; const c = e.pi ? e.pi : n; const s = e.doctype ? e.doctype : n; const l = function (n, l) { void 0 === l && (l = 'html'); let f; let d; let m; let g; let h; let p; let v; let b; let y; let w; let x; let C; let S; let k; let T; let E; let O; let N; let _; let D; let A; let R; let B; let M; let P; let z; let I; let L; let H; let F; let V = 0; const U = []; let j = 0; const W = ci.decode; const q = vo.makeMap('src,href,data,background,formaction,poster,xlink:href'); const $ = /((java|vb)script|mhtml):/i; const G = l === 'html' ? 0 : 1; const X = function (e) { let t, n; t = U.length; while (t--) { if (U[t].name === e) { break } } if (t >= 0) { for (n = U.length - 1; n >= t; n--) { e = U[n], e.valid && a(e.name) }U.length = t } }; const Y = function (t) { t !== '' && (t.charAt(0) === '>' && (t = ' ' + t), e.allow_conditional_comments || t.substr(0, 3).toLowerCase() !== '[if' || (t = ' ' + t), r(t)) }; const K = function (e, t) { const r = e || ''; const o = !et(r, '--'); const i = Lg(n, o, t); return e = n.substr(t, i - t), Y(o ? r + e : e), i + 1 }; const J = function (t, n, r, o, i) { let u; let a; const c = /[\s\u0000-\u001F]+/g; if (n = n.toLowerCase(), r = n in x ? n : W(r || o || i || ''), S && !b && !1 === Mg(n)) { if (u = N[n], !u && _) { a = _.length; while (a--) { if (u = _[a], u.pattern.test(n)) { break } } a === -1 && (u = null) } if (!u) { return } if (u.validValues && !(r in u.validValues)) { return } } if (q[n] && !e.allow_script_urls) { let s = r.replace(c, ''); try { s = decodeURIComponent(s) } catch (l) { s = unescape(s) } if ($.test(s)) { return } if (Pg(e, s)) { return } }b && (n in q || n.indexOf('on') === 0) || (g.map[n] = r, g.push({ name: n, value: r })) }; z = new RegExp("<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|(?:!(--)?)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^\"'>]+(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>]*))*|\\/|\\s+)>))", 'g'), I = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g, w = t.getShortEndedElements(), P = e.self_closing_elements || t.getSelfClosingElements(), x = t.getBoolAttrs(), S = e.validate, y = e.remove_internals, F = e.fix_self_closing, L = t.getSpecialElements(), B = n + '>'; while (f = z.exec(B)) { const Z = f[0]; if (V < f.index && i(W(n.substr(V, f.index - V))), d = f[7]) { d = d.toLowerCase(), d.charAt(0) === ':' && (d = d.substr(1)), X(d) } else if (d = f[8]) { if (f.index + Z.length > n.length) { i(W(n.substr(f.index))), V = f.index + Z.length; continue }d = d.toLowerCase(), d.charAt(0) === ':' && (d = d.substr(1)), C = d in w, F && P[d] && U.length > 0 && U[U.length - 1].name === d && X(d); const Q = Hg(I, f[9]); if (Q !== null) { if (Q === 'all') { V = zg(t, n, z.lastIndex), z.lastIndex = V; continue }T = !1 } if (!S || (k = t.getElementRule(d))) { if (T = !0, S && (N = k.attributes, _ = k.attributePatterns), (O = f[9]) ? (b = O.includes('data-mce-type'), b && y && (T = !1), g = [], g.map = {}, O.replace(I, J)) : (g = [], g.map = {}), S && !b) { if (D = k.attributesRequired, A = k.attributesDefault, R = k.attributesForced, M = k.removeEmptyAttrs, M && !g.length && (T = !1), R) { h = R.length; while (h--) { E = R[h], v = E.name, H = E.value, H === '{$uid}' && (H = 'mce_' + j++), g.map[v] = H, g.push({ name: v, value: H }) } } if (A) { h = A.length; while (h--) { E = A[h], v = E.name, v in g.map || (H = E.value, H === '{$uid}' && (H = 'mce_' + j++), g.map[v] = H, g.push({ name: v, value: H })) } } if (D) { h = D.length; while (h--) { if (D[h] in g.map) { break } } h === -1 && (T = !1) } if (E = g.map['data-mce-bogus']) { if (E === 'all') { V = zg(t, n, z.lastIndex), z.lastIndex = V; continue }T = !1 } }T && u(d, g, C) } else { T = !1 } if (m = L[d]) { m.lastIndex = V = f.index + Z.length, (f = m.exec(n)) ? (T && (p = n.substr(V, f.index - V)), V = f.index + f[0].length) : (p = n.substr(V), V = n.length), T && (p.length > 0 && i(p, !0), a(d)), z.lastIndex = V; continue }C || (O && O.indexOf('/') === O.length - 1 ? T && a(d) : U.push({ name: d, valid: T })) } else if (d = f[1]) { Y(d) } else if (d = f[2]) { const ee = G === 1 || e.preserve_cdata || U.length > 0 && t.isValidChild(U[U.length - 1].name, '#cdata'); if (!ee) { V = K('', f.index + 2), z.lastIndex = V; continue }o(d) } else if (d = f[3]) { s(d) } else { if ((d = f[4]) || Z === '<!') { V = K(d, f.index + Z.length), z.lastIndex = V; continue } if (d = f[5]) { if (G !== 1) { V = K('?', f.index + 2), z.lastIndex = V; continue }c(d, f[6]) } }V = f.index + Z.length } for (V < n.length && i(W(n.substr(V))), h = U.length - 1; h >= 0; h--) { d = U[h], d.valid && a(d.name) } }; return { parse: l } }(function (e) { e.findEndTag = zg })(Fg || (Fg = {})); let Vg; const Ug = Fg; const jg = function (e, t) { const n = new RegExp(['\\s?(' + e.join('|') + ')="[^"]+"'].join('|'), 'gi'); return t.replace(n, '') }; const Wg = function (e, t) { let n; let r; let o; let i; let u; let a = t; const c = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g; const s = e.schema; a = jg(e.getTempAttrs(), a), u = s.getShortEndedElements(); while (i = c.exec(a)) { r = c.lastIndex, o = i[0].length, n = u[i[1]] ? r : Ug.findEndTag(s, a, r), a = a.substring(0, r - o) + a.substring(n), c.lastIndex = r - o } return es.trim(a) }; const qg = Wg; const $g = { trimExternal: qg, trimInternal: Wg }; const Gg = 'html'; const Xg = function (e, t) { const n = id.getForcedRootBlock(e); const r = new RegExp('^(<' + n + '[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/' + n + '>[\r\n]*|<br \\/>[\r\n]*)$'); return t.replace(r, '') }; const Yg = function (e, t, n) { let r; if (t.format = t.format ? t.format : Gg, t.get = !0, t.getInner = !0, t.no_events || e.fire('BeforeGetContent', t), t.format === 'raw') { r = vo.trim($g.trimExternal(e.serializer, n.innerHTML)) } else if (t.format === 'text') { r = es.trim(n.textContent || n.textContent) } else { if (t.format === 'tree') { return e.serializer.serialize(n, t) } r = Xg(e, e.serializer.serialize(n, t)) } return t.format === 'text' || jo(ve.fromDom(n)) ? t.content = r : t.content = vo.trim(r), t.no_events || e.fire('GetContent', t), t.content }; const Kg = function (e, t) { return void 0 === t && (t = {}), p.from(e.getBody()).fold(i(t.format === 'tree' ? new Bg('body', 11) : ''), function (n) { return Yg(e, t, n) }) }; const Jg = vo.makeMap; const Zg = function (e) { let t; let n; let r; let o; let i; const u = []; return e = e || {}, t = e.indent, n = Jg(e.indent_before || ''), r = Jg(e.indent_after || ''), o = ci.getEncodeFunc(e.entity_encoding || 'raw', e.entities), i = e.element_format === 'html', { start (e, a, c) { let s, l, f, d; if (t && n[e] && u.length > 0 && (d = u[u.length - 1], d.length > 0 && d !== '\n' && u.push('\n')), u.push('<', e), a) { for (s = 0, l = a.length; s < l; s++) { f = a[s], u.push(' ', f.name, '="', o(f.value, !0), '"') } }u[u.length] = !c || i ? '>' : ' />', c && t && r[e] && u.length > 0 && (d = u[u.length - 1], d.length > 0 && d !== '\n' && u.push('\n')) }, end (e) { let n; u.push('</', e, '>'), t && r[e] && u.length > 0 && (n = u[u.length - 1], n.length > 0 && n !== '\n' && u.push('\n')) }, text (e, t) { e.length > 0 && (u[u.length] = t ? e : o(e)) }, cdata (e) { u.push('<![CDATA[', e, ']]>') }, comment (e) { u.push('\x3C!--', e, '--\x3E') }, pi (e, n) { n ? u.push('<?', e, ' ', o(n), '?>') : u.push('<?', e, '?>'), t && u.push('\n') }, doctype (e) { u.push('<!DOCTYPE', e, '>', t ? '\n' : '') }, reset () { u.length = 0 }, getContent () { return u.join('').replace(/\n$/, '') } } }; const Qg = function (e, t) { void 0 === t && (t = yi()); const n = Zg(e); e = e || {}, e.validate = !('validate' in e) || e.validate; const r = function (r) { let o, i; i = e.validate, o = { 3 (e) { n.text(e.value, e.raw) }, 8 (e) { n.comment(e.value) }, 7 (e) { n.pi(e.name, e.value) }, 10 (e) { n.doctype(e.value) }, 4 (e) { n.cdata(e.value) }, 11 (e) { if (e = e.firstChild) { do { u(e) } while (e = e.next) } } }, n.reset(); var u = function (e) { let r; let a; let c; let s; let l; let f; let d; let m; let g; const h = o[e.type]; if (h) { h(e) } else { if (r = e.name, a = e.shortEnded, c = e.attributes, i && c && c.length > 1 && (f = [], f.map = {}, g = t.getElementRule(e.name), g)) { for (d = 0, m = g.attributesOrder.length; d < m; d++) { s = g.attributesOrder[d], s in c.map && (l = c.map[s], f.map[s] = l, f.push({ name: s, value: l })) } for (d = 0, m = c.length; d < m; d++) { s = c[d].name, s in f.map || (l = c.map[s], f.map[s] = l, f.push({ name: s, value: l })) }c = f } if (n.start(e.name, c, a), !a) { if (e = e.firstChild) { do { u(e) } while (e = e.next) } n.end(r) } } }; return r.type !== 1 || e.inner ? o[11](r) : u(r), n.getContent() }; return { serialize: r } }; var eh = function (e, t) { t(e), e.firstChild && eh(e.firstChild, t), e.next && eh(e.next, t) }; const th = function (e, t, n) { const r = {}; const o = {}; const i = []; for (const u in n.firstChild && eh(n.firstChild, function (n) { M(e, function (e) { e.name === n.name && (r[e.name] ? r[e.name].nodes.push(n) : r[e.name] = { filter: e, nodes: [n] }) }), M(t, function (e) { typeof n.attr(e.name) === 'string' && (o[e.name] ? o[e.name].nodes.push(n) : o[e.name] = { filter: e, nodes: [n] }) }) }), r) { r.hasOwnProperty(u) && i.push(r[u]) } for (const a in o) { o.hasOwnProperty(a) && i.push(o[a]) } return i }; const nh = function (e, t, n) { const r = th(e, t, n); M(r, function (e) { M(e.filter.callbacks, function (t) { t(e.nodes, e.filter.name, {}) }) }) }; const rh = function (e) { const t = Pt(e).dom(); return e.dom() === t.activeElement }; const oh = function (e) { const t = void 0 !== e ? e.dom() : n.document; return p.from(t.activeElement).map(ve.fromDom) }; const ih = function (e) { return oh(Pt(e)).filter(function (t) { return e.dom().contains(t.dom()) }) }; const uh = function (e) { if (!x(e)) { throw new Error('cases must be an array') } if (e.length === 0) { throw new Error('there must be at least one case') } const t = []; const r = {}; return M(e, function (o, i) { const u = Z(o); if (u.length !== 1) { throw new Error('one and only one name per case') } const a = u[0]; const c = o[a]; if (void 0 !== r[a]) { throw new Error('duplicate key detected:' + a) } if (a === 'cata') { throw new Error('cannot have a case named cata (sorry)') } if (!x(c)) { throw new Error('case arguments must be an array') } t.push(a), r[a] = function () { const r = arguments.length; if (r !== c.length) { throw new Error('Wrong number of arguments to case ' + a + '. Expected ' + c.length + ' (' + c + '), got ' + r) } for (var o = new Array(r), u = 0; u < o.length; u++) { o[u] = arguments[u] } const s = function (e) { const n = Z(e); if (t.length !== n.length) { throw new Error('Wrong number of arguments to match. Expected: ' + t.join(',') + '\nActual: ' + n.join(',')) } const r = W(t, function (e) { return A(n, e) }); if (!r) { throw new Error('Not all branches were specified when using match. Specified: ' + n.join(', ') + '\nRequired: ' + t.join(', ')) } return e[a].apply(null, o) }; return { fold () { if (arguments.length !== e.length) { throw new Error('Wrong number of arguments to fold. Expected ' + e.length + ', got ' + arguments.length) } const t = arguments[i]; return t.apply(null, o) }, match: s, log (e) { n.console.log(e, { constructors: t, constructor: a, params: o }) } } } }), r }; const ah = { generate: uh }; const ch = gt('start', 'soffset', 'finish', 'foffset'); const sh = { create: ch }; const lh = ah.generate([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]); const fh = function (e, t, n, r) { return e.fold(t, n, r) }; const dh = function (e) { return e.fold(u, u, u) }; const mh = lh.before; const gh = lh.on; const hh = lh.after; const ph = { before: mh, on: gh, after: hh, cata: fh, getStart: dh }; const vh = ah.generate([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }]); const bh = function (e) { return vh.exact(e.start(), e.soffset(), e.finish(), e.foffset()) }; const yh = function (e) { return e.match({ domRange (e) { return ve.fromDom(e.startContainer) }, relative (e, t) { return ph.getStart(e) }, exact (e, t, n, r) { return e } }) }; const wh = vh.domRange; const xh = vh.relative; const Ch = vh.exact; const Sh = function (e) { const t = yh(e); return It(t) }; const kh = sh.create; const Th = { domRange: wh, relative: xh, exact: Ch, exactFromRange: bh, getWin: Sh, range: kh }; const Eh = mt().browser; const Oh = function (e, t) { const n = ln(t) ? wg(t).length : Wt(t).length + 1; return e > n ? n : e < 0 ? 0 : e }; const Nh = function (e) { return Th.range(e.start(), Oh(e.soffset(), e.start()), e.finish(), Oh(e.foffset(), e.finish())) }; const _h = function (e, t) { return !qn.isRestrictedNode(t.dom()) && (Mt(e, t) || Dt(e, t)) }; const Dh = function (e) { return function (t) { return _h(e, t.start()) && _h(e, t.finish()) } }; const Ah = function (e) { return !0 === e.inline || Eh.isIE() }; const Rh = function (e) { return Th.range(ve.fromDom(e.startContainer), e.startOffset, ve.fromDom(e.endContainer), e.endOffset) }; const Bh = function (e) { const t = e.getSelection(); const n = t && t.rangeCount !== 0 ? p.from(t.getRangeAt(0)) : p.none(); return n.map(Rh) }; const Mh = function (e) { const t = It(e); return Bh(t.dom()).filter(Dh(e)) }; const Ph = function (e, t) { return p.from(t).filter(Dh(e)).map(Nh) }; const zh = function (e) { const t = n.document.createRange(); try { return t.setStart(e.start().dom(), e.soffset()), t.setEnd(e.finish().dom(), e.foffset()), p.some(t) } catch (r) { return p.none() } }; const Ih = function (e) { const t = Ah(e) ? Mh(ve.fromDom(e.getBody())) : p.none(); e.bookmark = t.isSome() ? t : e.bookmark }; const Lh = function (e, t) { const n = ve.fromDom(e.getBody()); const r = Ah(e) ? p.from(t) : p.none(); const o = r.map(Rh).filter(Dh(n)); e.bookmark = o.isSome() ? o : e.bookmark }; const Hh = function (e) { const t = e.bookmark ? e.bookmark : p.none(); return t.bind(function (t) { return Ph(ve.fromDom(e.getBody()), t) }).bind(zh) }; const Fh = function (e) { Hh(e).each(function (t) { e.selection.setRng(t) }) }; const Vh = { store: Ih, storeNative: Lh, readRange: Bh, restore: Fh, getRng: Hh, getBookmark: Mh, validate: Ph }; const Uh = function (e) { const t = e.className.toString(); return t.includes('tox-') || t.includes('mce-') }; const jh = { isEditorUIElement: Uh }; const Wh = function (e) { return e.type === 'nodechange' && e.selectionChange }; const qh = function (e, t) { const r = function () { t.throttle() }; Va.DOM.bind(n.document, 'mouseup', r), e.on('remove', function () { Va.DOM.unbind(n.document, 'mouseup', r) }) }; const $h = function (e) { e.on('focusout', function () { Vh.store(e) }) }; const Gh = function (e, t) { e.on('mouseup touchend', function (e) { t.throttle() }) }; const Xh = function (e, t) { const n = mt().browser; n.isIE() ? $h(e) : Gh(e, t), e.on('keyup NodeChange', function (t) { Wh(t) || Vh.store(e) }) }; const Yh = function (e) { const t = fc(function () { Vh.store(e) }, 0); e.on('init', function () { e.inline && qh(e, t), Xh(e, t) }), e.on('remove', function () { t.cancel() }) }; const Kh = { register: Yh }; const Jh = Va.DOM; const Zh = function (e) { return jh.isEditorUIElement(e) }; const Qh = function (e) { const t = e.classList; return void 0 !== t && (t.contains('tox-edit-area') || t.contains('tox-edit-area__iframe') || t.contains('mce-content-body')) }; const ep = function (e, t) { const n = e ? e.settings.custom_ui_selector : ''; const r = Jh.getParent(t, function (t) { return Zh(t) || !!n && e.dom.is(t, n) }); return r !== null }; const tp = function () { try { return n.document.activeElement } catch (e) { return n.document.body } }; const np = function (e, t) { const r = t.editor; Kh.register(r), r.on('focusin', function () { const t = this; const n = e.focusedEditor; n !== t && (n && n.fire('blur', { focusedEditor: t }), e.setActive(t), e.focusedEditor = t, t.fire('focus', { blurredEditor: n }), t.focus(!0)) }), r.on('focusout', function () { const t = this; Ir.setEditorTimeout(t, function () { const n = e.focusedEditor; ep(t, tp()) || n !== t || (t.fire('blur', { focusedEditor: null }), e.focusedEditor = null) }) }), Vg || (Vg = function (t) { let r; const o = e.activeEditor; r = t.target, o && r.ownerDocument === n.document && (r === n.document.body || ep(o, r) || e.focusedEditor !== o || (o.fire('blur', { focusedEditor: null }), e.focusedEditor = null)) }, Jh.bind(n.document, 'focusin', Vg)) }; const rp = function (e, t) { e.focusedEditor === t.editor && (e.focusedEditor = null), e.activeEditor || (Jh.unbind(n.document, 'focusin', Vg), Vg = null) }; const op = function (e) { e.on('AddEditor', a(np, e)), e.on('RemoveEditor', a(rp, e)) }; const ip = { setup: op, isEditorUIElement: Zh, isEditorContentAreaElement: Qh, isUIElement: ep }; const up = function (e, t) { return e.dom.getParent(t, function (t) { return e.dom.getContentEditable(t) === 'true' }) }; const ap = function (e) { return e.collapsed ? p.from(Vs(e.startContainer, e.startOffset)).map(ve.fromDom) : p.none() }; const cp = function (e, t) { return ap(t).bind(function (t) { return Vo(t) ? p.some(t) : !1 === Mt(e, t) ? p.some(e) : p.none() }) }; const sp = function (e, t) { cp(ve.fromDom(e.getBody()), t).bind(function (e) { return fm.firstPositionIn(e.dom()) }).fold(function () { e.selection.normalize() }, function (t) { return e.selection.setRng(t.toRange()) }) }; const lp = function (e) { if (e.setActive) { try { e.setActive() } catch (t) { e.focus() } } else { e.focus() } }; const fp = function (e) { return rh(e) || ih(e).isSome() }; const dp = function (e) { return e.iframeElement && rh(ve.fromDom(e.iframeElement)) }; const mp = function (e) { const t = e.getBody(); return t && fp(ve.fromDom(t)) }; const gp = function (e) { return oh().filter(function (t) { return !ip.isEditorContentAreaElement(t.dom()) && ip.isUIElement(e, t.dom()) }).isSome() }; const hp = function (e) { return e.inline ? mp(e) : dp(e) }; const pp = function (e) { return hp(e) || gp(e) }; const vp = function (e) { const t = e.selection; const n = e.getBody(); let r = t.getRng(); e.quirks.refreshContentEditable(), void 0 !== e.bookmark && !1 === hp(e) && Vh.getRng(e).each(function (t) { e.selection.setRng(t), r = t }); const o = up(e, t.getNode()); if (e.$.contains(n, o)) { return lp(o), sp(e, r), void bp(e) } e.inline || ($r.opera || lp(n), e.getWin().focus()), ($r.gecko || e.inline) && (lp(n), sp(e, r)), bp(e) }; var bp = function (e) { return e.editorManager.setActive(e) }; const yp = function (e, t) { e.removed || (t ? bp(e) : vp(e)) }; const wp = { focus: yp, hasFocus: hp, hasEditorOrUiFocus: pp }; const xp = 'html'; const Cp = function (e) { return e instanceof Bg }; const Sp = function (e) { wp.hasFocus(e) && fm.firstPositionIn(e.getBody()).each(function (t) { const n = t.getNode(); const r = qn.isTable(n) ? fm.firstPositionIn(n).getOr(t) : t; e.selection.setRng(r.toRange()) }) }; const kp = function (e, t) { e.dom.setHTML(e.getBody(), t), Sp(e) }; const Tp = function (e, t, n, r) { let o, i; return n.length === 0 || /^\s+$/.test(n) ? (i = '<br data-mce-bogus="1">', t.nodeName === 'TABLE' ? n = '<tr><td>' + i + '</td></tr>' : /^(UL|OL)$/.test(t.nodeName) && (n = '<li>' + i + '</li>'), o = id.getForcedRootBlock(e), o && e.schema.isValidChild(t.nodeName.toLowerCase(), o.toLowerCase()) ? (n = i, n = e.dom.createHTML(o, e.settings.forced_root_block_attrs, n)) : n || (n = '<br data-mce-bogus="1">'), kp(e, n), e.fire('SetContent', r)) : (r.format !== 'raw' && (n = Qg({ validate: e.validate }, e.schema).serialize(e.parser.parse(n, { isRootContent: !0, insert: !0 }))), r.content = jo(ve.fromDom(t)) ? n : vo.trim(n), kp(e, r.content), r.no_events || e.fire('SetContent', r)), r.content }; const Ep = function (e, t, n, r) { nh(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), n); const o = Qg({ validate: e.validate }, e.schema).serialize(n); return r.content = jo(ve.fromDom(t)) ? o : vo.trim(o), kp(e, r.content), r.no_events || e.fire('SetContent', r), n }; const Op = function (e, t, n) { return void 0 === n && (n = {}), n.format = n.format ? n.format : xp, n.set = !0, n.content = Cp(t) ? '' : t, Cp(t) || n.no_events || (e.fire('BeforeSetContent', n), t = n.content), p.from(e.getBody()).fold(i(t), function (r) { return Cp(t) ? Ep(e, r, t, n) : Tp(e, r, t, n) }) }; const Np = function (e, t) { return e.fire('PreProcess', t) }; const _p = function (e, t) { return e.fire('PostProcess', t) }; const Dp = function (e) { return e.fire('remove') }; const Ap = function (e) { return e.fire('detach') }; const Rp = function (e, t) { return e.fire('SwitchMode', { mode: t }) }; const Bp = function (e, t, n, r) { e.fire('ObjectResizeStart', { target: t, width: n, height: r }) }; const Mp = function (e, t, n, r) { e.fire('ObjectResized', { target: t, width: n, height: r }) }; const Pp = function (e) { return e.fire('PreInit') }; const zp = function (e) { return e.fire('PostRender') }; const Ip = function (e) { return e.fire('Init') }; const Lp = function (e, t) { return e.fire('PlaceholderToggle', { state: t }) }; const Hp = function (e, t, n) { return e.fire(t, n) }; const Fp = Va.DOM; const Vp = function (e) { Fp.setStyle(e.id, 'display', e.orgDisplay) }; const Up = function (e) { return p.from(e).each(function (e) { return e.destroy() }) }; const jp = function (e) { e.contentAreaContainer = e.formElement = e.container = e.editorContainer = null, e.bodyElement = e.contentDocument = e.contentWindow = null, e.iframeElement = e.targetElm = null, e.selection && (e.selection = e.selection.win = e.selection.dom = e.selection.dom.doc = null) }; const Wp = function (e) { const t = e.formElement; t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, t._mceOldSubmit = null), Fp.unbind(t, 'submit reset', e.formEventDelegate)) }; const qp = function (e) { if (!e.removed) { const t = e._selectionOverrides; const n = e.editorUpload; const r = e.getBody(); const o = e.getElement(); r && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && o && Fp.remove(o.nextSibling), Dp(e), e.editorManager.remove(e), !e.inline && r && Vp(e), Ap(e), Fp.remove(e.getContainer()), Up(t), Up(n), e.destroy() } }; const $p = function (e, t) { const n = e.selection; const r = e.dom; e.destroyed || (t || e.removed ? (t || (e.editorManager.off('beforeunload', e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), Up(n), Up(r)), Wp(e), jp(e), e.destroyed = !0) : e.remove()) }; const Gp = Object.prototype.hasOwnProperty; const Xp = function (e, t) { const n = w(e) && w(t); return n ? Kp(e, t) : t }; const Yp = function (e) { return function () { for (var t = new Array(arguments.length), n = 0; n < t.length; n++) { t[n] = arguments[n] } if (t.length === 0) { throw new Error("Can't merge zero objects") } for (var r = {}, o = 0; o < t.length; o++) { const i = t[o]; for (const u in i) { Gp.call(i, u) && (r[u] = e(r[u], i[u])) } } return r } }; var Kp = Yp(Xp); const Jp = gt('sections', 'settings'); const Zp = mt().deviceType; const Qp = Zp.isTouch(); const ev = Zp.isPhone(); const tv = Zp.isTablet(); const nv = ['lists', 'autolink', 'autosave']; const rv = { table_grid: !1, object_resizing: !1, resize: !1 }; const ov = function (e) { const t = x(e) ? e.join(' ') : e; const n = B(y(t) ? t.split(' ') : [], tt); return I(n, function (e) { return e.length > 0 }) }; const iv = function (e) { return I(e, a(A, nv)) }; const uv = function (e, t) { const n = ie(t, function (t, n) { return A(e, n) }); return Jp(n.t, n.f) }; const av = function (e, t, n) { void 0 === n && (n = {}); const r = e.sections(); const o = r.hasOwnProperty(t) ? r[t] : {}; return vo.extend({}, n, o) }; const cv = function (e, t) { return e.sections().hasOwnProperty(t) }; const sv = function (e, t, n) { const r = e.sections(); return cv(e, t) && r[t].theme === n }; const lv = function (e, t) { return cv(e, t) ? e.sections()[t] : {} }; const fv = function (e, t) { return ae(e, 'toolbar_mode').orThunk(function () { return ae(e, 'toolbar_drawer').map(function (e) { return !1 === e ? 'wrap' : e }) }).getOr(t) }; const dv = function (e, t, n, r, o) { const i = { id: t, theme: 'silver', toolbar_mode: fv(e, 'floating'), plugins: '', document_base_url: n, add_form_submit_trigger: !0, submit_patch: !0, add_unload_trigger: !0, convert_urls: !0, relative_urls: !0, remove_script_host: !0, object_resizing: !0, doctype: '<!DOCTYPE html>', visual: !0, font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%', forced_root_block: 'p', hidden_input: !0, inline_styles: !0, convert_fonts_to_spans: !0, indent: !0, indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist', indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist', entity_encoding: 'named', url_converter: o.convertURL, url_converter_scope: o }; return se(se({}, i), r ? rv : {}) }; const mv = function (e, t) { const n = { resize: !1, toolbar_mode: fv(e, 'scrolling'), toolbar_sticky: !1 }; const r = { menubar: !1 }; return se(se(se({}, rv), n), t ? r : {}) }; const gv = function (e, t) { const n = t.external_plugins ? t.external_plugins : {}; return e && e.external_plugins ? vo.extend({}, e.external_plugins, n) : n }; const hv = function (e, t) { return [].concat(ov(e)).concat(ov(t)) }; const pv = function (e, t, n, r) { const o = ov(n.forced_plugins); const i = ov(r.plugins); const u = lv(t, 'mobile'); const a = u.plugins ? ov(u.plugins) : i; const c = e && sv(t, 'mobile', 'mobile') ? iv(a) : e && cv(t, 'mobile') ? a : i; const s = hv(o, c); return vo.extend(r, { plugins: s.join(' ') }) }; const vv = function (e, t) { return e && cv(t, 'mobile') }; const bv = function (e, t, n, r, o) { const i = e ? { mobile: mv(o, t) } : {}; const u = uv(['mobile'], Kp(i, o)); const a = vo.extend(n, r, u.settings(), vv(e, u) ? av(u, 'mobile') : {}, { validate: !0, external_plugins: gv(r, u.settings()) }); return pv(e, u, r, a) }; const yv = function (e, t, n, r, o) { const i = dv(o, t, n, Qp, e); return bv(ev || tv, ev, i, r, o) }; const wv = function (e, t, n) { return p.from(t.settings[n]).filter(e) }; const xv = function (e) { let t = {}; return typeof e === 'string' ? M(e.indexOf('=') > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(','), function (e) { const n = e.split('='); n.length > 1 ? t[vo.trim(n[0])] = vo.trim(n[1]) : t[vo.trim(n[0])] = vo.trim(n[0]) }) : t = e, t }; const Cv = function (e) { return function (t) { return x(t) && W(t, e) } }; const Sv = function (e, t, n, r) { const o = t in e.settings ? e.settings[t] : n; return r === 'hash' ? xv(o) : r === 'string' ? wv(y, e, t).getOr(n) : r === 'number' ? wv(T, e, t).getOr(n) : r === 'boolean' ? wv(S, e, t).getOr(n) : r === 'object' ? wv(w, e, t).getOr(n) : r === 'array' ? wv(x, e, t).getOr(n) : r === 'string[]' ? wv(Cv(y), e, t).getOr(n) : r === 'function' ? wv(k, e, t).getOr(n) : o }; const kv = function () { const e = {}; const t = function (t, n) { e[t] = n }; const n = function (t) { return e[t] ? e[t] : { icons: {} } }; const r = function (t) { return ce(e, t) }; return { add: t, get: n, has: r } }; const Tv = kv(); const Ev = function (e, t) { const n = t.dom(); return n[e] }; const Ov = function (e, t) { return parseInt(er(t, e), 10) }; const Nv = a(Ev, 'clientWidth'); const _v = a(Ev, 'clientHeight'); const Dv = a(Ov, 'margin-top'); const Av = a(Ov, 'margin-left'); const Rv = function (e) { return e.dom().getBoundingClientRect() }; const Bv = function (e, t, n) { const r = Nv(e); const o = _v(e); return t >= 0 && n >= 0 && t <= r && n <= o }; const Mv = function (e, t, n, r) { const o = Rv(t); const i = e ? o.left + t.dom().clientLeft + Av(t) : 0; const u = e ? o.top + t.dom().clientTop + Dv(t) : 0; const a = n - i; const c = r - u; return { x: a, y: c } }; const Pv = function (e, t, n) { const r = ve.fromDom(e.getBody()); const o = e.inline ? r : zt(r); const i = Mv(e.inline, o, t, n); return Bv(o, i.x, i.y) }; const zv = function (e) { return p.from(e).map(ve.fromDom) }; const Iv = function (e) { const t = e.inline ? e.getBody() : e.getContentAreaContainer(); return zv(t).map(function (e) { return Mt(Pt(e), e) }).getOr(!1) }; const Lv = { isXYInContentArea: Pv, isEditorAttachedToDom: Iv }; function Hv () { const e = function () { throw new Error('Theme did not provide a NotificationManager implementation.') }; return { open: e, close: e, reposition: e, getArgs: e } } function Fv (e) { const t = []; const n = function () { const t = e.theme; return t && t.getNotificationManagerImpl ? t.getNotificationManagerImpl() : Hv() }; const r = function () { return p.from(t[0]) }; const o = function (e, t) { return e.type === t.type && e.text === t.text && !e.progressBar && !e.timeout && !t.progressBar && !t.timeout }; const i = function () { t.length > 0 && n().reposition(t) }; const u = function (e) { t.push(e) }; const a = function (e) { V(t, function (t) { return t === e }).each(function (e) { t.splice(e, 1) }) }; const c = function (r) { if (!e.removed && Lv.isEditorAttachedToDom(e)) { return F(t, function (e) { return o(n().getArgs(e), r) }).getOrThunk(function () { e.editorManager.setActive(e); var t = n().open(r, function () { a(t), i() }); return u(t), i(), t }) } }; const s = function () { r().each(function (e) { n().close(e), a(e), i() }) }; const l = function () { return t }; const f = function (e) { e.on('SkinLoaded', function () { const t = e.settings.service_message; t && c({ text: t, type: 'warning', timeout: 0 }) }), e.on('ResizeEditor ResizeWindow NodeChange', function () { Ir.requestAnimationFrame(i) }), e.on('remove', function () { M(t.slice(), function (e) { n().close(e) }) }) }; return f(e), { open: c, close: s, getNotifications: l } } const Vv = lc.PluginManager; const Uv = lc.ThemeManager; function jv () { const e = function () { throw new Error('Theme did not provide a WindowManager implementation.') }; return { open: e, openUrl: e, alert: e, confirm: e, close: e, getParams: e, setParams: e } } const Wv = function (e) { let t = []; const n = function () { const t = e.theme; return t && t.getWindowManagerImpl ? t.getWindowManagerImpl() : jv() }; const r = function (e, t) { return function () { return t ? t.apply(e, arguments) : void 0 } }; const o = function (t) { e.fire('OpenWindow', { dialog: t }) }; const i = function (t) { e.fire('CloseWindow', { dialog: t }) }; const u = function (e) { t.push(e), o(e) }; const a = function (n) { i(n), t = I(t, function (e) { return e !== n }), t.length === 0 && e.focus() }; const c = function () { return p.from(t[t.length - 1]) }; const s = function (t) { e.editorManager.setActive(e), Vh.store(e); const n = t(); return u(n), n }; const l = function (e, t) { return s(function () { return n().open(e, t, a) }) }; const f = function (e) { return s(function () { return n().openUrl(e, a) }) }; const d = function (e, t, o) { n().alert(e, r(o || this, t)) }; const m = function (e, t, o) { n().confirm(e, r(o || this, t)) }; const g = function () { c().each(function (e) { n().close(e), a(e) }) }; return e.on('remove', function () { M(t, function (e) { n().close(e) }) }), { open: l, openUrl: f, alert: d, confirm: m, close: g } }; const qv = function (e, t) { e.notificationManager.open({ type: 'error', text: t }) }; const $v = function (e, t) { e._skinLoaded ? qv(e, t) : e.on('SkinLoaded', function () { qv(e, t) }) }; const Gv = function (e, t) { $v(e, cc.translate(['Failed to upload image: {0}', t])) }; const Xv = function (e, t, r) { Hp(e, t, { message: r }), n.console.error(r) }; const Yv = function (e, t, n) { return n ? 'Failed to load ' + e + ': ' + n + ' from url ' + t : 'Failed to load ' + e + ' url: ' + t }; const Kv = function (e, t, n) { Xv(e, 'PluginLoadError', Yv('plugin', t, n)) }; const Jv = function (e, t, n) { Xv(e, 'IconsLoadError', Yv('icons', t, n)) }; const Zv = function (e, t, n) { Xv(e, 'LanguageLoadError', Yv('language', t, n)) }; const Qv = function (e, t, n) { const r = cc.translate(['Failed to initialize plugin: {0}', t]); eb(r, n), $v(e, r) }; var eb = function (e) { for (let t = [], r = 1; r < arguments.length; r++) { t[r - 1] = arguments[r] } const o = n.window.console; o && (o.error ? o.error.apply(o, arguments) : o.log.apply(o, arguments)) }; const tb = { pluginLoadError: Kv, iconsLoadError: Jv, languageLoadError: Zv, pluginInitError: Qv, uploadError: Gv, displayError: $v, initError: eb }; const nb = function () { return { 'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>', 'action-next': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3z"/></svg>', 'action-prev': '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3z"/></svg>', 'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-none': '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 1 1 0-2h9.2zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h6.8zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h4.4zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 0 1 0-2h2zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>', 'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'arrow-left': '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8z" fill-rule="evenodd"/></svg>', 'arrow-right': '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8z" fill-rule="evenodd"/></svg>', bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>', bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1z" fill-rule="nonzero"/></svg>', 'border-width': '<svg width="24" height="24"><path d="M5 14.8h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm-.5 3.7h15c.3 0 .5.2.5.5s-.2.5-.5.5h-15a.5.5 0 1 1 0-1zm.5-8.3h14c.6 0 1 .4 1 1v1c0 .5-.4 1-1 1H5a1 1 0 0 1-1-1v-1c0-.6.4-1 1-1zm0-5.7h14c.6 0 1 .4 1 1v2c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-2c0-.6.4-1 1-1z" fill-rule="evenodd"/></svg>', brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0zm-10-7l-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>', browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6z" fill-rule="nonzero"/></svg>', cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8zM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>', 'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 1 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>', 'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>', 'checklist-rtl': '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>', checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>', checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>', 'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>', 'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>', 'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>', 'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>', close: '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5z" fill-rule="evenodd"/></svg>', 'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>', 'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5z" fill-rule="evenodd"/></svg>', 'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z" fill-rule="nonzero"/></svg>', 'color-swatch-remove-color': '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>', 'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>', 'comment-add': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2z"/></g></svg>', comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23z"/></svg>', contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6z" fill-rule="evenodd"/></svg>', copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>', crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>', cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>', 'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>', drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>', duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1z"/></g></svg>', 'edit-block': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z"/></svg>', 'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9zM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>', 'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2z" fill-rule="nonzero"/></svg>', embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4z" fill-rule="nonzero"/></svg>', emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13z" fill-rule="nonzero"/></svg>', fill: '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>', 'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2zm14-2v2h2a2 2 0 0 0-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 0 0 2-2h-2v2z" fill-rule="nonzero"/></svg>', 'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2zm2 14h-2v2a2 2 0 0 0 2-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>', 'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>', format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10z"/></svg>', fullscreen: '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>', gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4zM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1z"/></svg>', gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0z" fill-rule="nonzero"/></svg>', help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1zM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>', 'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>', home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>', 'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>', 'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" fill-rule="nonzero"/></svg>', image: '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" fill-rule="nonzero"/></svg>', indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>', info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>', 'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5z" fill-rule="evenodd"/></svg>', 'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z"/></g></svg>', invert: '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>', italic: '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>', line: '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>', link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2.1 2a2 2 0 1 0 2.7 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2z" fill-rule="nonzero"/></svg>', 'list-bull-circle': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-bull-default': '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-bull-square': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-num-default-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>', 'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>', 'list-num-lower-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-greek-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>', 'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>', 'list-num-upper-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-upper-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>', 'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>', lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7z" fill-rule="evenodd"/></svg>', ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>', 'more-drawer': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" fill-rule="nonzero"/></svg>', 'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>', 'new-tab': '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>', 'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>', notice: '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>', 'ordered-list-rtl': '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19zm-1 8.8l.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>', 'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>', orientation: '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1z" fill-rule="nonzero"/></svg>', outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>', 'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>', paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5z"/></svg>', 'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>', paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>', 'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>', plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1z"/></svg>', preferences: '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" fill-rule="evenodd"/></svg>', preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6z" fill-rule="nonzero"/></svg>', print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>', quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3z" fill-rule="nonzero"/></svg>', redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>', reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1z"/></g></svg>', 'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8zM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1z" fill-rule="evenodd"/></svg>', remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4z" fill-rule="nonzero"/></svg>', 'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7zM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3z"/></g></svg>', resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5z" fill-rule="evenodd"/></svg>', 'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></g></svg>', 'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></svg>', 'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>', rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>', save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6z" fill-rule="nonzero"/></svg>', search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12z" fill-rule="nonzero"/></svg>', 'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 0 0-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 0 0 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>', selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3z"/></svg>', settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>', sharpen: '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>', 'sort-asc': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M4 8h5a1 1 0 1 1 0 2H4a1 1 0 1 1 0-2zm0 8h8a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0-4h7a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"/><path fill-rule="nonzero" d="M16 8.4l-2.3 2.3a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L18 8.4V18a1 1 0 0 1-2 0V8.4z"/></g></svg>', 'sort-dsc': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M4 16h5a1 1 0 0 0 0-2H4a1 1 0 0 0 0 2zm0-8h8a1 1 0 0 0 0-2H4a1 1 0 1 0 0 2zm0 4h7a1 1 0 0 0 0-2H4a1 1 0 0 0 0 2z"/><path fill-rule="nonzero" d="M16 15.6l-2.3-2.3a1 1 0 0 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 0 0-1.4-1.4L18 15.6V6a1 1 0 0 0-2 0v9.6z"/></g></svg>', sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>', 'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>', 'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2z" fill-rule="nonzero"/></g></svg>', subscript: '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>', superscript: '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>', 'table-cell-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z"/></svg>', 'table-cell-select-all': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z" opacity=".2"/></g></svg>', 'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z"/></g></svg>', 'table-delete-column': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z"/></svg>', 'table-delete-row': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z"/></svg>', 'table-delete-table': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z"/><path d="M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>', 'table-insert-column-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z"/></svg>', 'table-insert-column-before': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z"/></svg>', 'table-insert-row-above': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1z"/></svg>', 'table-insert-row-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z"/></svg>', 'table-left-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z"/></svg>', 'table-merge-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z"/></svg>', 'table-row-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z"/></svg>', 'table-split-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z"/></svg>', 'table-top-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></svg>', table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z"/></svg>', template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>', 'temporary-placeholder': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>', 'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>', toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', translate: '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 1 1 2 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>', underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>', unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2zM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1zM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19z" fill-rule="nonzero"/></svg>', unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>', 'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>', unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z"/></svg>', upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12zM11 6.4L8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4z" fill-rule="nonzero"/></svg>', user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>', visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2zm-4 0v2a2 2 0 0 1-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 0 1-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 0 1 2 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z" fill-rule="evenodd"/></svg>', visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5z" fill-rule="evenodd"/></svg>', warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>', 'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>', 'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>' } }; const rb = function (e) { return /^[a-z0-9\-]+$/i.test(e) }; const ob = function (e) { const t = id.getContentCss(e); const n = e.editorManager.baseURL + '/skins/content'; const r = e.editorManager.suffix; const o = 'content' + r + '.css'; const i = !0 === e.inline; return B(t, function (t) { return rb(t) && !i ? n + '/' + t + '/' + o : e.documentBaseURI.toAbsolute(t) }) }; const ib = function (e) { e.contentCSS = e.contentCSS.concat(ob(e)) }; function ub (e) { return { getBookmark: a(Mm.getBookmark, e), moveToBookmark: a(Mm.moveToBookmark, e) } }(function (e) { e.isBookmarkNode = Mm.isBookmarkNode })(ub || (ub = {})); const ab = ub; const cb = function (e, t, n) { if (n.collapsed) { return !1 } if ($r.browser.isIE() && n.startOffset === n.endOffset - 1 && n.startContainer === n.endContainer) { const r = n.startContainer.childNodes[n.startOffset]; if (qn.isElement(r)) { return R(r.getClientRects(), function (n) { return Hs(n, e, t) }) } } return R(n.getClientRects(), function (n) { return Hs(n, e, t) }) }; const sb = { isXYWithinRange: cb }; const lb = { BACKSPACE: 8, DELETE: 46, DOWN: 40, ENTER: 13, LEFT: 37, RIGHT: 39, SPACEBAR: 32, TAB: 9, UP: 38, END: 35, HOME: 36, modifierPressed (e) { return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e) }, metaKeyPressed (e) { return $r.mac ? e.metaKey : e.ctrlKey && !e.altKey } }; const fb = qn.isContentEditableFalse; const db = qn.isContentEditableTrue; const mb = function (e, t) { while (t && t !== e) { if (db(t) || fb(t)) { return t } t = t.parentNode } return null }; const gb = function (e, t) { let r; let o; let i; let u; let a; let c; let s; let l; let f; let d; let m; let g; let h; let p; let v; let b; let y; const w = t.dom; const x = vo.each; const C = t.getDoc(); const S = n.document; const k = Math.abs; const T = Math.round; const E = t.getBody(); u = { nw: [0, 0, -1, -1], ne: [1, 0, 1, -1], se: [1, 1, 1, 1], sw: [0, 1, -1, 1] }; const O = function (e) { return e && (e.nodeName === 'IMG' || t.dom.is(e, 'figure.image')) }; const N = function (e, t) { if (e.type === 'longpress' || e.type.indexOf('touch') === 0) { const n = e.touches[0]; return O(e.target) && !sb.isXYWithinRange(n.clientX, n.clientY, t) } return O(e.target) && !sb.isXYWithinRange(e.clientX, e.clientY, t) }; const _ = function (e) { const n = e.target; N(e, t.selection.getRng()) && !e.isDefaultPrevented() && t.selection.select(n) }; const D = function (e) { return t.dom.is(e, 'figure.image') ? e.querySelector('img') : e }; const A = function (e) { let n = id.getObjectResizing(t); return !1 !== n && !$r.iOS && (typeof n !== 'string' && (n = 'table,img,figure.image,div'), e.getAttribute('data-mce-resize') !== 'false' && (e !== t.getBody() && Et(ve.fromDom(e), n))) }; const R = function (e) { let n, u, x, C, S; n = e.screenX - c, u = e.screenY - s, p = n * a[2] + d, v = u * a[3] + m, p = p < 5 ? 5 : p, v = v < 5 ? 5 : v, x = O(r) && !1 !== id.getResizeImgProportional(t) ? !lb.modifierPressed(e) : lb.modifierPressed(e), x && (k(n) > k(u) ? (v = T(p * g), p = T(v / g)) : (p = T(v / g), v = T(p * g))), w.setStyles(D(o), { width: p, height: v }), C = a.startPos.x + n, S = a.startPos.y + u, C = C > 0 ? C : 0, S = S > 0 ? S : 0, w.setStyles(i, { left: C, top: S, display: 'block' }), i.innerHTML = p + ' &times; ' + v, a[2] < 0 && o.clientWidth <= p && w.setStyle(o, 'left', l + (d - p)), a[3] < 0 && o.clientHeight <= v && w.setStyle(o, 'top', f + (m - v)), n = E.scrollWidth - b, u = E.scrollHeight - y, n + u !== 0 && w.setStyles(i, { left: C - n, top: S - u }), h || (Bp(t, r, d, m), h = !0) }; var B = function () { h = !1; const e = function (e, n) { n && (r.style[e] || !t.schema.isValid(r.nodeName.toLowerCase(), e) ? w.setStyle(D(r), e, n) : w.setAttrib(D(r), e, n)) }; e('width', p), e('height', v), w.unbind(C, 'mousemove', R), w.unbind(C, 'mouseup', B), S !== C && (w.unbind(S, 'mousemove', R), w.unbind(S, 'mouseup', B)), w.remove(o), w.remove(i), M(r), Mp(t, r, p, v), w.setAttrib(r, 'style', w.getAttrib(r, 'style')), t.nodeChanged() }; var M = function (e) { let n, h, k, T, O; P(), L(), n = w.getPos(e, E), l = n.x, f = n.y, O = e.getBoundingClientRect(), h = O.width || O.right - O.left, k = O.height || O.bottom - O.top, r !== e && (r = e, p = v = 0), T = t.fire('ObjectSelected', { target: e }), A(e) && !T.isDefaultPrevented() ? x(u, function (e, t) { let n; const u = function (t) { c = t.screenX, s = t.screenY, d = D(r).clientWidth, m = D(r).clientHeight, g = m / d, a = e, e.startPos = { x: h * e[0] + l, y: k * e[1] + f }, b = E.scrollWidth, y = E.scrollHeight, o = r.cloneNode(!0), w.addClass(o, 'mce-clonedresizable'), w.setAttrib(o, 'data-mce-bogus', 'all'), o.contentEditable = !1, o.unSelectabe = !0, w.setStyles(o, { left: l, top: f, margin: 0 }), o.removeAttribute('data-mce-selected'), E.appendChild(o), w.bind(C, 'mousemove', R), w.bind(C, 'mouseup', B), S !== C && (w.bind(S, 'mousemove', R), w.bind(S, 'mouseup', B)), i = w.add(E, 'div', { class: 'mce-resize-helper', 'data-mce-bogus': 'all' }, d + ' &times; ' + m) }; n = w.get('mceResizeHandle' + t), n && w.remove(n), n = w.add(E, 'div', { id: 'mceResizeHandle' + t, 'data-mce-bogus': 'all', class: 'mce-resizehandle', unselectable: !0, style: 'cursor:' + t + '-resize; margin:0; padding:0' }), $r.ie === 11 && (n.contentEditable = !1), w.bind(n, 'mousedown', function (e) { e.stopImmediatePropagation(), e.preventDefault(), u(e) }), e.elm = n, w.setStyles(n, { left: h * e[0] + l - n.offsetWidth / 2, top: k * e[1] + f - n.offsetHeight / 2 }) }) : P(), r.setAttribute('data-mce-selected', '1') }; var P = function () { let e, t; for (e in L(), r && r.removeAttribute('data-mce-selected'), u) { t = w.get('mceResizeHandle' + e), t && (w.unbind(t), w.remove(t)) } }; const z = function (n) { let r; let o; const i = function (e, t) { if (e) { do { if (e === t) { return !0 } } while (e = e.parentNode) } }; h || t.removed || (x(w.select('img[data-mce-selected],hr[data-mce-selected]'), function (e) { e.removeAttribute('data-mce-selected') }), o = n.type === 'mousedown' ? n.target : e.getNode(), o = w.$(o).closest('table,img,figure.image,hr')[0], i(o, E) && (H(), r = e.getStart(!0), i(r, o) && i(e.getEnd(!0), o)) ? M(o) : P()) }; const I = function (e) { return fb(mb(t.getBody(), e)) }; var L = function () { for (const e in u) { const t = u[e]; t.elm && (w.unbind(t.elm), delete t.elm) } }; var H = function () { try { t.getDoc().execCommand('enableObjectResizing', !1, !1) } catch (e) {} }; t.on('init', function () { if (H(), $r.browser.isIE() || $r.browser.isEdge()) { t.on('mousedown click', function (e) { const n = e.target; const r = n.nodeName; h || !/^(TABLE|IMG|HR)$/.test(r) || I(n) || (e.button !== 2 && t.selection.select(n, r === 'TABLE'), e.type === 'mousedown' && t.nodeChanged()) }); const e = function (e) { const n = function (e) { Ir.setEditorTimeout(t, function () { return t.selection.select(e) }) }; if (I(e.target)) { return e.preventDefault(), void n(e.target) } /^(TABLE|IMG|HR)$/.test(e.target.nodeName) && (e.preventDefault(), e.target.tagName === 'IMG' && n(e.target)) }; w.bind(E, 'mscontrolselect', e), t.on('remove', function () { return w.unbind(E, 'mscontrolselect', e) }) } const n = Ir.throttle(function (e) { t.composing || z(e) }); t.on('nodechange ResizeEditor ResizeWindow drop FullscreenStateChanged', n), t.on('keyup compositionend', function (e) { r && r.nodeName === 'TABLE' && n(e) }), t.on('hide blur', P), t.on('contextmenu longpress', _, !0) }), t.on('remove', L); const F = function () { r = o = null }; return { isResizable: A, showResizeRect: M, hideResizeRect: P, updateResizeRect: z, destroy: F } }; function hb (e, t) { const n = function (t, n) { if (!T(n) && !n.match(/^[0-9]+$/)) { throw new Error(e + '.set accepts only positive integer values. Value was ' + n) } const r = t.dom(); $n(r) && (r.style[e] = n + 'px') }; const r = function (n) { const r = t(n); if (r <= 0 || r === null) { const o = er(n, e); return parseFloat(o) || 0 } return r }; const o = r; const i = function (e, t) { return H(t, function (t, n) { const r = er(e, n); const o = void 0 === r ? 0 : parseInt(r, 10); return isNaN(o) ? t : t + o }, 0) }; const u = function (e, t, n) { const r = i(e, n); const o = t > r ? t - r : 0; return o }; return { set: n, get: r, getOuter: o, aggregate: i, max: u } } const pb = hb('height', function (e) { const t = e.dom(); return fn(e) ? t.getBoundingClientRect().height : t.offsetHeight }); const vb = function (e) { return pb.get(e) }; var bb = function (e, t) { const n = e.view(t); return n.fold(i([]), function (t) { const n = e.owner(t); const r = bb(e, n); return [t].concat(r) }) }; const yb = function (e, t) { const n = t.owner(e); return bb(t, n) }; const wb = function (e) { const t = e.dom() === n.document ? p.none() : p.from(e.dom().defaultView.frameElement); return t.map(ve.fromDom) }; const xb = function (e) { return Pt(e) }; const Cb = Object.freeze({ __proto__: null, view: wb, owner: xb }); const Sb = function (e) { const t = ve.fromDom(n.document); const r = yn(t); const o = yb(e, Cb); const i = vn(e); const u = L(o, function (e, t) { const n = vn(t); return { left: e.left + n.left(), top: e.top + n.top() } }, { left: 0, top: 0 }); return mn(u.left + i.left() + r.left(), u.top + i.top() + r.top()) }; const kb = function (e) { return un(e) === 'textarea' }; const Tb = function (e, t) { const n = e.fire('ScrollIntoView', t); return n.isDefaultPrevented() }; const Eb = function (e, t) { e.fire('AfterScrollIntoView', t) }; const Ob = function (e, t) { const n = Wt(e); if (n.length === 0 || kb(e)) { return { element: e, offset: t } } if (t < n.length && !kb(n[t])) { return { element: n[t], offset: 0 } } const r = n[n.length - 1]; return kb(r) ? { element: e, offset: t } : un(r) === 'img' ? { element: r, offset: 1 } : ln(r) ? { element: r, offset: wg(r).length } : { element: r, offset: Wt(r).length } }; const Nb = function (e, t) { const n = pn(e); const r = vb(e); return { element: e, bottom: n.top() + r, height: r, pos: n, cleanup: t } }; const _b = function (e, t) { const n = Ob(e, t); const r = ve.fromHtml('<span data-mce-bogus="all">' + es.ZWSP + '</span>'); return Yt(n.element, r), Nb(r, function () { return rn(r) }) }; const Db = function (e) { return Nb(ve.fromDom(e), r) }; const Ab = function (e, t, n, r) { Pb(e, function (o, i) { return Bb(e, t, n, r) }, n) }; const Rb = function (e, t, n, r, o) { const i = { elm: r.element.dom(), alignToTop: o }; if (!Tb(e, i)) { const u = yn(t).top(); n(t, u, r, o), Eb(e, i) } }; var Bb = function (e, t, n, r) { const o = ve.fromDom(e.getBody()); const i = ve.fromDom(e.getDoc()); or(o); const u = _b(ve.fromDom(n.startContainer), n.startOffset); Rb(e, i, t, u, r), u.cleanup() }; const Mb = function (e, t, n, r) { const o = ve.fromDom(e.getDoc()); Rb(e, o, n, Db(t), r) }; var Pb = function (e, t, n) { const r = n.startContainer; const o = n.startOffset; const i = n.endContainer; const u = n.endOffset; t(ve.fromDom(r), ve.fromDom(i)); const a = e.dom.createRng(); a.setStart(r, o), a.setEnd(i, u), e.selection.setRng(n) }; const zb = function (e, t, n, r) { const o = e.pos; if (n) { wn(o.left(), o.top(), r) } else { const i = o.top() - t + e.height; wn(o.left(), i, r) } }; const Ib = function (e, t, n, r, o) { const i = n + t; const u = r.pos.top(); const a = r.bottom; const c = a - u >= n; if (u < t) { zb(r, n, !1 !== o, e) } else if (u > i) { const s = c ? !1 !== o : !0 === o; zb(r, n, s, e) } else { a > i && !c && zb(r, n, !0 === o, e) } }; const Lb = function (e, t, n, r) { const o = e.dom().defaultView.innerHeight; Ib(e, t, o, n, r) }; const Hb = function (e, t, r, o) { const i = e.dom().defaultView.innerHeight; Ib(e, t, i, r, o); const u = Sb(r.element); const a = kn(n.window); u.top() < a.y() ? xn(r.element, !1 !== o) : u.top() > a.bottom() && xn(r.element, !0 === o) }; const Fb = function (e, t, n) { return Ab(e, Lb, t, n) }; const Vb = function (e, t, n) { return Mb(e, t, Lb, n) }; const Ub = function (e, t, n) { return Ab(e, Hb, t, n) }; const jb = function (e, t, n) { return Mb(e, t, Hb, n) }; const Wb = function (e, t, n) { const r = e.inline ? Vb : jb; r(e, t, n) }; const qb = function (e, t, n) { const r = e.inline ? Fb : Ub; r(e, t, n) }; const $b = { scrollElementIntoView: Wb, scrollRangeIntoView: qb }; const Gb = function (e) { return qn.isContentEditableTrue(e) || qn.isContentEditableFalse(e) }; const Xb = function (e, t, n) { while (e && e !== t) { if (n(e)) { return e } e = e.parentNode } return null }; const Yb = function (e, t, n) { let r, o, i; if (r = n.elementFromPoint(e, t), o = n.body.createTextRange(), r && r.tagName !== 'HTML' || (r = n.body), o.moveToElementText(r), i = vo.toArray(o.getClientRects()), i = i.sort(function (e, n) { return e = Math.abs(Math.max(e.top - t, e.bottom - t)), n = Math.abs(Math.max(n.top - t, n.bottom - t)), e - n }), i.length > 0) { t = (i[0].bottom + i[0].top) / 2; try { return o.moveToPoint(e, t), o.collapse(!0), o } catch (u) {} } return null }; const Kb = function (e, t) { const n = e && e.parentElement ? e.parentElement() : null; return qn.isContentEditableFalse(Xb(n, t, Gb)) ? null : e }; const Jb = function (e, t, n) { let r; let o; const i = n; if (i.caretPositionFromPoint) { o = i.caretPositionFromPoint(e, t), o && (r = n.createRange(), r.setStart(o.offsetNode, o.offset), r.collapse(!0)) } else if (n.caretRangeFromPoint) { r = n.caretRangeFromPoint(e, t) } else if (i.body.createTextRange) { r = i.body.createTextRange(); try { r.moveToPoint(e, t), r.collapse(!0) } catch (u) { r = Yb(e, t, n) } return Kb(r, n.body) } return r }; const Zb = { fromPoint: Jb }; const Qb = function (e, t) { return B(t, function (t) { const n = e.fire('GetSelectionRange', { range: t }); return n.range !== t ? n.range : t }) }; const ey = { processRanges: Qb }; const ty = function (e, t) { const r = t || n.document; const o = r.createDocumentFragment(); return M(e, function (e) { o.appendChild(e.dom()) }), ve.fromDom(o) }; const ny = function (e) { return e.slice(0, -1) }; const ry = function (e, t, n) { return Mt(t, e) ? ny(Ht(e, function (e) { return n(e) || Dt(e, t) })) : [] }; const oy = function (e, t) { return ry(e, t, i(!1)) }; const iy = function (e, t) { return [e].concat(oy(e, t)) }; const uy = { parentsUntil: ry, parents: oy, parentsAndSelf: iy }; const ay = function (e) { const t = e.startContainer; const n = e.startOffset; return qn.isText(t) ? n === 0 ? p.some(ve.fromDom(t)) : p.none() : p.from(t.childNodes[n]).map(ve.fromDom) }; const cy = function (e) { const t = e.endContainer; const n = e.endOffset; return qn.isText(t) ? n === t.data.length ? p.some(ve.fromDom(t)) : p.none() : p.from(t.childNodes[n - 1]).map(ve.fromDom) }; var sy = function (e) { return $t(e).fold(i([e]), function (t) { return [e].concat(sy(t)) }) }; var ly = function (e) { return Gt(e).fold(i([e]), function (t) { return un(t) === 'br' ? Ft(t).map(function (t) { return [e].concat(ly(t)) }).getOr([]) : [e].concat(ly(t)) }) }; const fy = function (e, t) { return Ws(ay(t), cy(t), function (t, n) { const r = F(sy(e), a(Dt, t)); const o = F(ly(e), a(Dt, n)); return r.isSome() && o.isSome() }).getOr(!1) }; const dy = function (e, t, n, r) { const o = n; const i = new Aa(n, o); const u = e.schema.getNonEmptyElements(); do { if (n.nodeType === 3 && vo.trim(n.nodeValue).length !== 0) { return void (r ? t.setStart(n, 0) : t.setEnd(n, n.nodeValue.length)) } if (u[n.nodeName] && !/^(TD|TH)$/.test(n.nodeName)) { return void (r ? t.setStartBefore(n) : n.nodeName === 'BR' ? t.setEndBefore(n) : t.setEndAfter(n)) } } while (n = r ? i.next() : i.prev()); o.nodeName === 'BODY' && (r ? t.setStart(o, 0) : t.setEnd(o, o.childNodes.length)) }; const my = function (e) { const t = e.selection.getSel(); return t && t.rangeCount > 0 }; const gy = gt('element', 'width', 'rows'); const hy = gt('element', 'cells'); const py = gt('x', 'y'); const vy = function (e, t) { const n = parseInt(Kn(e, t), 10); return isNaN(n) ? 1 : n }; const by = function (e, t, n, r, o) { for (let i = vy(o, 'rowspan'), u = vy(o, 'colspan'), a = e.rows(), c = n; c < n + i; c++) { a[c] || (a[c] = hy(Kc(r), [])); for (let s = t; s < t + u; s++) { const l = a[c].cells(); l[s] = c === n && s === t ? o : Yc(o) } } }; const yy = function (e, t, n) { const r = e.rows(); const o = r[n] ? r[n].cells() : []; return !!o[t] }; const wy = function (e, t, n) { while (yy(e, t, n)) { t++ } return t }; const xy = function (e) { return H(e, function (e, t) { return t.cells().length > e ? t.cells().length : e }, 0) }; const Cy = function (e, t) { for (let n = e.rows(), r = 0; r < n.length; r++) { for (let o = n[r].cells(), i = 0; i < o.length; i++) { if (Dt(o[i], t)) { return p.some(py(i, r)) } } } return p.none() }; const Sy = function (e, t, n, r, o) { for (var i = [], u = e.rows(), a = n; a <= o; a++) { const c = u[a].cells(); const s = t < r ? c.slice(t, r + 1) : c.slice(r, t + 1); i.push(hy(u[a].element(), s)) } return i }; const ky = function (e, t, n) { const r = t.x(); const o = t.y(); const i = n.x(); const u = n.y(); const a = o < u ? Sy(e, r, o, i, u) : Sy(e, r, u, i, o); return gy(e.element(), xy(a), a) }; const Ty = function (e, t) { const n = Yc(e.element()); const r = ve.fromTag('tbody'); return tn(r, t), Zt(n, r), n }; const Ey = function (e) { return B(e.rows(), function (e) { const t = B(e.cells(), function (e) { const t = Kc(e); return Qn(t, 'colspan'), Qn(t, 'rowspan'), t }); const n = Yc(e.element()); return tn(n, t), n }) }; const Oy = function (e) { const t = gy(Yc(e), 0, []); return M(Tc(e, 'tr'), function (e, n) { M(Tc(e, 'td,th'), function (r, o) { by(t, wy(t, o, n), n, e, r) }) }), gy(t.element(), xy(t.rows()), t.rows()) }; const Ny = function (e) { return Ty(e, Ey(e)) }; const _y = function (e, t, n) { return Cy(e, t).bind(function (t) { return Cy(e, n).map(function (n) { return ky(e, t, n) }) }) }; const Dy = { fromDom: Oy, toDom: Ny, subsection: _y }; const Ay = function (e) { const t = []; if (e) { for (let n = 0; n < e.rangeCount; n++) { t.push(e.getRangeAt(n)) } } return t }; const Ry = function (e) { return j(e, function (e) { const t = Fs(e); return t ? [ve.fromDom(t)] : [] }) }; const By = function (e) { return Ay(e).length > 1 }; const My = { getRanges: Ay, getSelectedNodes: Ry, hasMultipleRanges: By }; const Py = function (e) { return I(My.getSelectedNodes(e), Uo) }; const zy = function (e) { return Tc(e, 'td[data-mce-selected],th[data-mce-selected]') }; const Iy = function (e, t) { const n = zy(t); const r = Py(e); return n.length > 0 ? n : r }; const Ly = function (e) { return Iy(My.getRanges(e.selection.getSel()), ve.fromDom(e.getBody())) }; const Hy = { getCellsFromRanges: Py, getCellsFromElement: zy, getCellsFromElementOrRanges: Iy, getCellsFromEditor: Ly }; const Fy = function (e) { return F(e, function (e) { return un(e) === 'ul' || un(e) === 'ol' }) }; const Vy = function (e, t) { return F(e, function (e) { return un(e) === 'li' && fy(e, t) }).fold(i([]), function (t) { return Fy(e).map(function (e) { return [ve.fromTag('li'), ve.fromTag(un(e))] }).getOr([]) }) }; const Uy = function (e, t) { const n = H(t, function (e, t) { return Zt(t, e), t }, e); return t.length > 0 ? ty([n]) : n }; const jy = function (e) { return Ho(e) ? Lt(e).filter(Lo).fold(i([]), function (t) { return [e, t] }) : Lo(e) ? [e] : [] }; const Wy = function (e, t) { const n = ve.fromDom(t.commonAncestorContainer); const r = uy.parentsAndSelf(n, e); const o = I(r, function (e) { return Po(e) || Ro(e) }); const i = Vy(r, t); const u = o.concat(i.length ? i : jy(n)); return B(u, Yc) }; const qy = function () { return ty([]) }; const $y = function (e, t) { return Uy(ve.fromDom(t.cloneContents()), Wy(e, t)) }; const Gy = function (e, t) { return _c(t, 'table', a(Dt, e)) }; const Xy = function (e, t) { return Gy(e, t[0]).bind(function (e) { const n = t[0]; const r = t[t.length - 1]; const o = Dy.fromDom(e); return Dy.subsection(o, n, r).map(function (e) { return ty([Dy.toDom(e)]) }) }).getOrThunk(qy) }; const Yy = function (e, t) { return t.length > 0 && t[0].collapsed ? qy() : $y(e, t[0]) }; const Ky = function (e, t) { const n = Hy.getCellsFromElementOrRanges(t, e); return n.length > 0 ? Xy(e, n) : Yy(e, t) }; const Jy = { read: Ky }; const Zy = function (e) { return p.from(e.selection.getRng()).map(function (t) { const n = e.dom.add(e.getBody(), 'div', { 'data-mce-bogus': 'all', style: 'overflow: hidden; opacity: 0;' }, t.cloneContents()); const r = es.trim(n.textContent); return e.dom.remove(n), r }).getOr('') }; const Qy = function (e, t) { let n; const r = e.selection.getRng(); const o = e.dom.create('body'); const i = e.selection.getSel(); const u = ey.processRanges(e, My.getRanges(i)); return n = t.contextual ? Jy.read(ve.fromDom(e.getBody()), u).dom() : r.cloneContents(), n && o.appendChild(n), e.selection.serializer.serialize(o, t) }; const ew = function (e, t) { if (void 0 === t && (t = {}), t.get = !0, t.format = t.format || 'html', t.selection = !0, t = e.fire('BeforeGetContent', t), t.isDefaultPrevented()) { return e.fire('GetContent', t), t.content } if (t.format === 'text') { return Zy(e) } t.getInner = !0; const n = Qy(e, t); return t.format === 'tree' ? n : (t.content = e.selection.isCollapsed() ? '' : n, e.fire('GetContent', t), t.content) }; const tw = { getContent: ew }; const nw = function (e, t) { return e && t && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset }; const rw = { isEq: nw }; const ow = function (e, t, n) { while (e && e !== t) { if (n(e)) { return e } e = e.parentNode } return null }; const iw = function (e, t, n) { return ow(e, t, n) !== null }; const uw = function (e, t, n) { return iw(e, t, function (e) { return e.nodeName === n }) }; const aw = function (e) { return e && e.nodeName === 'TABLE' }; const cw = function (e) { return e && /^(TD|TH|CAPTION)$/.test(e.nodeName) }; const sw = function (e, t) { return is(e) && !1 === iw(e, t, rf) }; const lw = function (e, t, n) { const r = new Aa(t, e.getParent(t.parentNode, e.isBlock) || e.getRoot()); while (t = r[n ? 'prev' : 'next']()) { if (qn.isBr(t)) { return !0 } } }; const fw = function (e, t) { return e.previousSibling && e.previousSibling.nodeName === t }; const dw = function (e, t) { while (t && t !== e) { if (qn.isContentEditableFalse(t)) { return !0 } t = t.parentNode } return !1 }; const mw = function (e, t, n, r, o) { let i; let u; const a = e.getRoot(); const c = e.schema.getNonEmptyElements(); const s = e.getParent(o.parentNode, e.isBlock) || a; if (r && qn.isBr(o) && t && e.isEmpty(s)) { return p.some(vl(o.parentNode, e.nodeIndex(o))) } const l = new Aa(o, s); while (u = l[r ? 'prev' : 'next']()) { if (e.getContentEditableParent(u) === 'false' || sw(u, a)) { return p.none() } if (qn.isText(u) && u.nodeValue.length > 0) { return !1 === uw(u, a, 'A') ? p.some(vl(u, r ? u.nodeValue.length : 0)) : p.none() } if (e.isBlock(u) || c[u.nodeName.toLowerCase()]) { return p.none() } i = u } return n && i ? p.some(vl(i, 0)) : p.none() }; const gw = function (e, t, n, r) { let o; let i; let u; let a; let c; let s; const l = e.getRoot(); let f = !1; if (o = r[(n ? 'start' : 'end') + 'Container'], i = r[(n ? 'start' : 'end') + 'Offset'], s = qn.isElement(o) && i === o.childNodes.length, a = e.schema.getNonEmptyElements(), c = n, is(o)) { return p.none() } if (qn.isElement(o) && i > o.childNodes.length - 1 && (c = !1), qn.isDocument(o) && (o = l, i = 0), o === l) { if (c && (u = o.childNodes[i > 0 ? i - 1 : 0], u)) { if (is(u)) { return p.none() } if (a[u.nodeName] || aw(u)) { return p.none() } } if (o.hasChildNodes()) { if (i = Math.min(!c && i > 0 ? i - 1 : i, o.childNodes.length - 1), o = o.childNodes[i], i = qn.isText(o) && s ? o.data.length : 0, !t && o === l.lastChild && aw(o)) { return p.none() } if (dw(l, o) || is(o)) { return p.none() } if (o.hasChildNodes() && !1 === aw(o)) { u = o; const d = new Aa(o, l); do { if (qn.isContentEditableFalse(u) || is(u)) { f = !1; break } if (qn.isText(u) && u.nodeValue.length > 0) { i = c ? 0 : u.nodeValue.length, o = u, f = !0; break } if (a[u.nodeName.toLowerCase()] && !cw(u)) { i = e.nodeIndex(u), o = u.parentNode, c || i++, f = !0; break } } while (u = c ? d.next() : d.prev()) } } } return t && (qn.isText(o) && i === 0 && mw(e, s, t, !0, o).each(function (e) { o = e.container(), i = e.offset(), f = !0 }), qn.isElement(o) && (u = o.childNodes[i], u || (u = o.childNodes[i - 1]), !u || !qn.isBr(u) || fw(u, 'A') || lw(e, u, !1) || lw(e, u, !0) || mw(e, s, t, !0, u).each(function (e) { o = e.container(), i = e.offset(), f = !0 }))), c && !t && qn.isText(o) && i === o.nodeValue.length && mw(e, s, t, !1, o).each(function (e) { o = e.container(), i = e.offset(), f = !0 }), f ? p.some(vl(o, i)) : p.none() }; const hw = function (e, t) { const n = t.collapsed; const r = t.cloneRange(); const o = vl.fromRangeStart(t); return gw(e, n, !0, r).each(function (e) { n && vl.isAbove(o, e) || r.setStart(e.container(), e.offset()) }), n || gw(e, n, !1, r).each(function (e) { r.setEnd(e.container(), e.offset()) }), n && r.collapse(!0), rw.isEq(t, r) ? p.none() : p.some(r) }; const pw = { normalize: hw }; const vw = function (e, t) { e.insertData(0, t) }; const bw = function (e) { return e.dom().length === 0 ? (rn(e), p.none()) : p.some(e) }; const yw = function (e, t) { const n = p.from(t.firstChild).map(ve.fromDom); const r = p.from(t.lastChild).map(ve.fromDom); e.deleteContents(), e.insertNode(t); const o = n.bind(Ft).filter(ln).bind(bw); const i = r.bind(Vt).filter(ln).bind(bw); Ws(o, n.filter(ln), function (e, t) { vw(t.dom(), e.dom().data), rn(e) }), Ws(i, r.filter(ln), function (t, n) { const r = n.dom().length; n.dom().appendData(t.dom().data), e.setEnd(n.dom(), r), rn(t) }), e.collapse(!1) }; const ww = function (e, t) { return e = e || { format: 'html' }, e.set = !0, e.selection = !0, e.content = t, e }; const xw = function (e, t, n) { if (n = ww(n, t), n.no_events || (n = e.fire('BeforeSetContent', n), !n.isDefaultPrevented())) { const r = e.selection.getRng(); yw(r, r.createContextualFragment(n.content)), e.selection.setRng(r), $b.scrollRangeIntoView(e, r), n.no_events || e.fire('SetContent', n) } else { e.fire('SetContent', n) } }; const Cw = { setContent: xw }; const Sw = function (e, t, n, r, o) { const i = n ? t.startContainer : t.endContainer; const u = n ? t.startOffset : t.endOffset; return p.from(i).map(ve.fromDom).map(function (e) { return r && t.collapsed ? e : qt(e, o(e, u)).getOr(e) }).bind(function (e) { return sn(e) ? p.some(e) : Lt(e) }).map(function (e) { return e.dom() }).getOr(e) }; const kw = function (e, t, n) { return Sw(e, t, !0, n, function (e, t) { return Math.min(Xt(e), t) }) }; const Tw = function (e, t, n) { return Sw(e, t, !1, n, function (e, t) { return t > 0 ? t - 1 : t }) }; const Ew = function (e, t) { const n = e; while (e && qn.isText(e) && e.length === 0) { e = t ? e.nextSibling : e.previousSibling } return e || n }; const Ow = function (e, t) { let n, r, o, i, u; return t ? (r = t.startContainer, o = t.endContainer, i = t.startOffset, u = t.endOffset, n = t.commonAncestorContainer, !t.collapsed && (r === o && u - i < 2 && r.hasChildNodes() && (n = r.childNodes[i]), r.nodeType === 3 && o.nodeType === 3 && (r = r.length === i ? Ew(r.nextSibling, !0) : r.parentNode, o = u === 0 ? Ew(o.previousSibling, !1) : o.parentNode, r && r === o)) ? r : n && n.nodeType === 3 ? n.parentNode : n) : e }; const Nw = function (e, t, n, r) { let o; let i; const u = []; if (i = e.getRoot(), n = e.getParent(n || kw(i, t, t.collapsed), e.isBlock), r = e.getParent(r || Tw(i, t, t.collapsed), e.isBlock), n && n !== i && u.push(n), n && r && n !== r) { o = n; const a = new Aa(n, i); while ((o = a.next()) && o !== r) { e.isBlock(o) && u.push(o) } } return r && n !== r && r !== i && u.push(r), u }; const _w = function (e, t, n) { return p.from(t).map(function (t) { const r = e.nodeIndex(t); const o = e.createRng(); return o.setStart(t.parentNode, r), o.setEnd(t.parentNode, r + 1), n && (dy(e, o, t, !0), dy(e, o, t, !1)), o }) }; const Dw = function (e, t, n) { if (e && e.hasOwnProperty(t)) { const r = I(e[t], function (e) { return e !== n }); r.length === 0 ? delete e[t] : e[t] = r } }; function Aw (e, t) { let n, r; return { selectorChangedWithUnbind (o, i) { return n || (n = {}, r = {}, t.on('NodeChange', function (t) { const o = t.element; const i = e.getParents(o, null, e.getRoot()); const u = {}; vo.each(n, function (t, n) { vo.each(i, function (o) { if (e.is(o, n)) { return r[n] || (vo.each(t, function (e) { e(!0, { node: o, selector: n, parents: i }) }), r[n] = t), u[n] = t, !1 } }) }), vo.each(r, function (e, t) { u[t] || (delete r[t], vo.each(e, function (e) { e(!1, { node: o, selector: t, parents: i }) })) }) })), n[o] || (n[o] = []), n[o].push(i), { unbind () { Dw(n, o, i), Dw(r, o, i) } } } } } const Rw = function (e) { return !!e.select }; const Bw = function (e) { return !(!e || !e.ownerDocument) && Mt(ve.fromDom(e.ownerDocument), ve.fromDom(e)) }; const Mw = function (e) { return !!e && (!!Rw(e) || Bw(e.startContainer) && Bw(e.endContainer)) }; const Pw = function (e, t, n, r) { let o; let i; let u; let a; const c = Aw(e, r).selectorChangedWithUnbind; const s = function (t, n) { const o = e.createRng(); t ? (o.setStart(t, n), o.setEnd(t, n), x(o), b(!1)) : (dy(e, o, r.getBody(), !0), x(o)) }; const l = function (e) { return tw.getContent(r, e) }; const f = function (e, t) { return Cw.setContent(r, e, t) }; const d = function (e) { return kw(r.getBody(), w(), e) }; const m = function (e) { return Tw(r.getBody(), w(), e) }; const g = function (e, t) { return o.getBookmark(e, t) }; const h = function (e) { return o.moveToBookmark(e) }; const p = function (t, n) { return _w(e, t, n).each(x), t }; const v = function () { const e = w(); const t = y(); return !(!e || e.item) && (e.compareEndPoints ? e.compareEndPoints('StartToEnd', e) === 0 : !t || e.collapsed) }; var b = function (e) { const t = w(); t.collapse(!!e), x(t) }; var y = function () { return t.getSelection ? t.getSelection() : t.document.selection }; var w = function () { let n; let o; let i; let c; const s = function (e, t, n) { try { return t.compareBoundaryPoints(e, n) } catch (r) { return -1 } }; if (!t) { return null } if (c = t.document, typeof c === 'undefined' || c === null) { return null } if (void 0 !== r.bookmark && !1 === wp.hasFocus(r)) { const l = Vh.getRng(r); if (l.isSome()) { return l.map(function (e) { return ey.processRanges(r, [e])[0] }).getOr(c.createRange()) } } try { (n = y()) && !qn.isRestrictedNode(n.anchorNode) && (o = n.rangeCount > 0 ? n.getRangeAt(0) : n.createRange ? n.createRange() : c.createRange()) } catch (f) {} return o = ey.processRanges(r, [o])[0], o || (o = c.createRange ? c.createRange() : c.body.createTextRange()), o.setStart && o.startContainer.nodeType === 9 && o.collapsed && (i = e.getRoot(), o.setStart(i, 0), o.setEnd(i, 0)), u && a && (s(o.START_TO_START, o, u) === 0 && s(o.END_TO_END, o, u) === 0 ? o = a : (u = null, a = null)), o }; var x = function (e, t) { let n, o, i; if (Mw(e)) { const c = Rw(e) ? e : null; if (c) { a = null; try { c.select() } catch (s) {} } else { if (n = y(), i = r.fire('SetSelectionRange', { range: e, forward: t }), e = i.range, n) { a = e; try { n.removeAllRanges(), n.addRange(e) } catch (s) {}!1 === t && n.extend && (n.collapse(e.endContainer, e.endOffset), n.extend(e.startContainer, e.startOffset)), u = n.rangeCount > 0 ? n.getRangeAt(0) : null }e.collapsed || e.startContainer !== e.endContainer || !n.setBaseAndExtent || $r.ie || e.endOffset - e.startOffset < 2 && e.startContainer.hasChildNodes() && (o = e.startContainer.childNodes[e.startOffset], o && o.tagName === 'IMG' && (n.setBaseAndExtent(e.startContainer, e.startOffset, e.endContainer, e.endOffset), n.anchorNode === e.startContainer && n.focusNode === e.endContainer || n.setBaseAndExtent(o, 0, o, 1))), r.fire('AfterSetSelectionRange', { range: e, forward: t }) } } }; const C = function (t) { return f(e.getOuterHTML(t)), t }; const S = function () { return Ow(r.getBody(), w()) }; const k = function (t, n) { return Nw(e, w(), t, n) }; const T = function () { let t; let n; const r = y(); return !(r && r.anchorNode && r.focusNode) || (t = e.createRng(), t.setStart(r.anchorNode, r.anchorOffset), t.collapse(!0), n = e.createRng(), n.setStart(r.focusNode, r.focusOffset), n.collapse(!0), t.compareBoundaryPoints(t.START_TO_START, n) <= 0) }; const E = function () { const t = w(); const n = y(); if (!My.hasMultipleRanges(n) && my(r)) { const o = pw.normalize(e, t); return o.each(function (e) { x(e, T()) }), o.getOr(t) } return t }; const O = function (e, t) { return c(e, t), B }; const N = function () { let t; let n = e.getRoot(); while (n && n.nodeName !== 'BODY') { if (n.scrollHeight > n.clientHeight) { t = n; break }n = n.parentNode } return t }; const _ = function (e, t) { return $b.scrollElementIntoView(r, e, t) }; const D = function (e, t) { return x(Zb.fromPoint(e, t, r.getDoc())) }; const A = function () { const e = w(); return e.collapsed ? yl.fromRangeStart(e).getClientRects()[0] : e.getBoundingClientRect() }; const R = function () { t = u = a = null, i.destroy() }; var B = { bookmarkManager: null, controlSelection: null, dom: e, win: t, serializer: n, editor: r, collapse: b, setCursorLocation: s, getContent: l, setContent: f, getBookmark: g, moveToBookmark: h, select: p, isCollapsed: v, isForward: T, setNode: C, getNode: S, getSel: y, setRng: x, getRng: w, getStart: d, getEnd: m, getSelectedBlocks: k, normalize: E, selectorChanged: O, selectorChangedWithUnbind: c, getScrollContainer: N, scrollIntoView: _, placeCaretAt: D, getBoundingClientRect: A, destroy: R }; return o = ab(B), i = gb(B, r), B.bookmarkManager = o, B.controlSelection = i, B }; const zw = function (e, t) { M(t, function (t) { e.attr(t, null) }) }; const Iw = function (e, t, n) { e.addNodeFilter('font', function (e) { M(e, function (e) { const r = t.parse(e.attr('style')); const o = e.attr('color'); const i = e.attr('face'); const u = e.attr('size'); o && (r.color = o), i && (r['font-family'] = i), u && (r['font-size'] = n[parseInt(e.attr('size'), 10) - 1]), e.name = 'span', e.attr('style', t.serialize(r)), zw(e, ['color', 'face', 'size']) }) }) }; const Lw = function (e, t) { e.addNodeFilter('strike', function (e) { M(e, function (e) { const n = t.parse(e.attr('style')); n['text-decoration'] = 'line-through', e.name = 'span', e.attr('style', t.serialize(n)) }) }) }; const Hw = function (e, t) { const n = Ui(); t.convert_fonts_to_spans && Iw(e, n, vo.explode(t.font_size_legacy_values)), Lw(e, n) }; const Fw = function (e, t) { t.inline_styles && Hw(e, t) }; const Vw = { register: Fw }; const Uw = function (e, t, n, r) { const o = e.padd_empty_with_br || t.insert; o && n[r.name] ? r.empty().append(new Bg('br', 1)).shortEnded = !0 : r.empty().append(new Bg('#text', 3)).value = Fi }; const jw = function (e) { return Ww(e, '#text') && e.firstChild.value === Fi }; var Ww = function (e, t) { return e && e.firstChild && e.firstChild === e.lastChild && e.firstChild.name === t }; const qw = function (e, t) { const n = e.getElementRule(t.name); return n && n.paddEmpty }; const $w = function (e, t, n, r) { return r.isEmpty(t, n, function (t) { return qw(e, t) }) }; const Gw = function (e, t) { return e && (t[e.name] || e.name === 'br') }; const Xw = function (e, t) { const n = e.schema; t.remove_trailing_brs && e.addNodeFilter('br', function (e, r, o) { let i; let u; let a; let c; let s; let l; let f; let d; const m = e.length; const g = vo.extend({}, n.getBlockElements()); const h = n.getNonEmptyElements(); const p = n.getNonEmptyElements(); for (g.body = 1, i = 0; i < m; i++) { if (u = e[i], a = u.parent, g[u.parent.name] && u === a.lastChild) { s = u.prev; while (s) { if (l = s.name, l !== 'span' || s.attr('data-mce-type') !== 'bookmark') { if (l !== 'br') { break } if (l === 'br') { u = null; break } }s = s.prev }u && (u.remove(), $w(n, h, p, a) && (f = n.getElementRule(a.name), f && (f.removeEmpty ? a.remove() : f.paddEmpty && Uw(t, o, g, a)))) } else { c = u; while (a && a.firstChild === c && a.lastChild === c) { if (c = a, g[a.name]) { break } a = a.parent }c === a && !0 !== t.padd_empty_with_br && (d = new Bg('#text', 3), d.value = Fi, u.replace(d)) } } }), e.addAttributeFilter('href', function (e) { let n; let r = e.length; const o = function (e) { const t = e.split(' ').filter(function (e) { return e.length > 0 }); return t.concat(['noopener']).sort().join(' ') }; const i = function (e) { const t = e ? vo.trim(e) : ''; return /\b(noopener)\b/g.test(t) ? t : o(t) }; if (!t.allow_unsafe_link_target) { while (r--) { n = e[r], n.name === 'a' && n.attr('target') === '_blank' && n.attr('rel', i(n.attr('rel'))) } } }), t.allow_html_in_named_anchor || e.addAttributeFilter('id,name', function (e) { let t; let n; let r; let o; let i = e.length; while (i--) { if (o = e[i], o.name === 'a' && o.firstChild && !o.attr('href')) { r = o.parent, t = o.lastChild; do { n = t.prev, r.insert(t, o), t = n } while (t) } } }), t.fix_list_elements && e.addNodeFilter('ul,ol', function (e) { let t; let n; let r = e.length; while (r--) { if (t = e[r], n = t.parent, n.name === 'ul' || n.name === 'ol') { if (t.prev && t.prev.name === 'li') { t.prev.append(t) } else { const o = new Bg('li', 1); o.attr('style', 'list-style-type: none'), t.wrap(o) } } } }), t.validate && n.getValidClasses() && e.addAttributeFilter('class', function (e) { let t; let r; let o; let i; let u; let a; let c; let s = e.length; const l = n.getValidClasses(); while (s--) { for (t = e[s], r = t.attr('class').split(' '), u = '', o = 0; o < r.length; o++) { i = r[o], c = !1, a = l['*'], a && a[i] && (c = !0), a = l[t.name], !c && a && a[i] && (c = !0), c && (u && (u += ' '), u += i) }u.length || (u = null), t.attr('class', u) } }) }; const Yw = vo.makeMap; const Kw = vo.each; const Jw = vo.explode; const Zw = vo.extend; const Qw = function (e, t) { void 0 === t && (t = yi()); const n = {}; const r = []; let o = {}; let i = {}; e = e || {}, e.validate = !('validate' in e) || e.validate, e.root_name = e.root_name || 'body'; const u = function (e) { let n, r, o, i, u, c, s, l, f, d, m, g, h, p, v, b; for (g = Yw('tr,td,th,tbody,thead,tfoot,table'), d = t.getNonEmptyElements(), m = t.getWhiteSpaceElements(), h = t.getTextBlockElements(), p = t.getSpecialElements(), n = 0; n < e.length; n++) { if (r = e[n], r.parent && !r.fixed) { if (h[r.name] && r.parent.name === 'li') { v = r.next; while (v) { if (!h[v.name]) { break } v.name = 'li', v.fixed = !0, r.parent.insert(v, r.parent), v = v.next }r.unwrap(r) } else { for (i = [r], o = r.parent; o && !t.isValidChild(o.name, r.name) && !g[o.name]; o = o.parent) { i.push(o) } if (o && i.length > 1) { for (i.reverse(), u = c = a(i[0].clone()), f = 0; f < i.length - 1; f++) { for (t.isValidChild(c.name, i[f].name) ? (s = a(i[f].clone()), c.append(s)) : s = c, l = i[f].firstChild; l && l !== i[f + 1];) { b = l.next, s.append(l), l = b }c = s }$w(t, d, m, u) ? o.insert(r, i[0], !0) : (o.insert(u, i[0], !0), o.insert(r, u)), o = i[0], ($w(t, d, m, o) || Ww(o, 'br')) && o.empty().remove() } else if (r.parent) { if (r.name === 'li') { if (v = r.prev, v && (v.name === 'ul' || v.name === 'ul')) { v.append(r); continue } if (v = r.next, v && (v.name === 'ul' || v.name === 'ul')) { v.insert(r, v.firstChild, !0); continue }r.wrap(a(new Bg('ul', 1))); continue }t.isValidChild(r.parent.name, 'div') && t.isValidChild('div', r.name) ? r.wrap(a(new Bg('div', 1))) : p[r.name] ? r.empty().remove() : r.unwrap() } } } } }; var a = function (e) { let t, u, a; u = e.name, u in n && (a = o[u], a ? a.push(e) : o[u] = [e]), t = r.length; while (t--) { u = r[t].name, u in e.attributes.map && (a = i[u], a ? a.push(e) : i[u] = [e]) } return e }; const c = function (e, t) { Kw(Jw(e), function (e) { let r = n[e]; r || (n[e] = r = []), r.push(t) }) }; const s = function () { const e = []; for (const t in n) { n.hasOwnProperty(t) && e.push({ name: t, callbacks: n[t] }) } return e }; const l = function (e, t) { Kw(Jw(e), function (e) { let n; for (n = 0; n < r.length; n++) { if (r[n].name === e) { return void r[n].callbacks.push(t) } } r.push({ name: e, callbacks: [t] }) }) }; const f = function () { return [].concat(r) }; const d = function (a, c) { let s; let l; let f; let d; let m; let g; let h; let p; let v; let b; let y; const w = []; const x = function (e) { return !1 === e ? '' : !0 === e ? 'p' : e }; c = c || {}, o = {}, i = {}, v = Zw(Yw('script,style,head,html,body,title,meta,param'), t.getBlockElements()); const C = t.getNonEmptyElements(); const S = t.children; const k = e.validate; const T = 'forced_root_block' in c ? c.forced_root_block : e.forced_root_block; const E = x(T); const O = t.getWhiteSpaceElements(); const N = /^[ \t\r\n]+/; const _ = /[ \t\r\n]+$/; const D = /[ \t\r\n]+/g; const A = /^[ \t\r\n]+$/; b = O.hasOwnProperty(c.context) || O.hasOwnProperty(e.root_name); const R = function () { let n; let r; let o = z.firstChild; const i = function (e) { e && (o = e.firstChild, o && o.type === 3 && (o.value = o.value.replace(N, '')), o = e.lastChild, o && o.type === 3 && (o.value = o.value.replace(_, ''))) }; if (t.isValidChild(z.name, E.toLowerCase())) { while (o) { n = o.next, o.type === 3 || o.type === 1 && o.name !== 'p' && !v[o.name] && !o.attr('data-mce-type') ? r ? r.append(o) : (r = B(E, 1), r.attr(e.forced_root_block_attrs), z.insert(r, o), r.append(o)) : (i(r), r = null), o = n }i(r) } }; var B = function (e, t) { let r; const i = new Bg(e, t); return e in n && (r = o[e], r ? r.push(i) : o[e] = [i]), i }; const M = function (e) { let n; let r; let o; let i; const u = t.getBlockElements(); for (n = e.prev; n && n.type === 3;) { if (o = n.value.replace(_, ''), o.length > 0) { return void (n.value = o) } if (r = n.next, r) { if (r.type === 3 && r.value.length) { n = n.prev; continue } if (!u[r.name] && r.name !== 'script' && r.name !== 'style') { n = n.prev; continue } }i = n.prev, n.remove(), n = i } }; const P = function (e) { let t; const n = {}; for (t in e) { t !== 'li' && t !== 'p' && (n[t] = e[t]) } return n }; s = Ug({ validate: k, allow_script_urls: e.allow_script_urls, allow_conditional_comments: e.allow_conditional_comments, preserve_cdata: e.preserve_cdata, self_closing_elements: P(t.getSelfClosingElements()), cdata (e) { y.append(B('#cdata', 4)).value = e }, text (e, t) { let n; b || (e = e.replace(D, ' '), Gw(y.lastChild, v) && (e = e.replace(N, ''))), e.length !== 0 && (n = B('#text', 3), n.raw = !!t, y.append(n).value = e) }, comment (e) { y.append(B('#comment', 8)).value = e }, pi (e, t) { y.append(B(e, 7)).value = t, M(y) }, doctype (e) { let t; t = y.append(B('#doctype', 10)), t.value = e, M(y) }, start (e, n, o) { let u, a, c, s, l; if (c = k ? t.getElementRule(e) : {}, c) { u = B(c.outputName || e, 1), u.attributes = n, u.shortEnded = o, y.append(u), l = S[y.name], l && S[u.name] && !l[u.name] && w.push(u), a = r.length; while (a--) { s = r[a].name, s in n.map && (h = i[s], h ? h.push(u) : i[s] = [u]) }v[e] && M(u), o || (y = u), !b && O[e] && (b = !0) } }, end (n) { let r, o, i, u, a; if (o = k ? t.getElementRule(n) : {}, o) { if (v[n] && !b) { if (r = y.firstChild, r && r.type === 3) { if (i = r.value.replace(N, ''), i.length > 0) { r.value = i, r = r.next } else { u = r.next, r.remove(), r = u; while (r && r.type === 3) { i = r.value, u = r.next, (i.length === 0 || A.test(i)) && (r.remove(), r = u), r = u } } } if (r = y.lastChild, r && r.type === 3) { if (i = r.value.replace(_, ''), i.length > 0) { r.value = i, r = r.prev } else { u = r.prev, r.remove(), r = u; while (r && r.type === 3) { i = r.value, u = r.prev, (i.length === 0 || A.test(i)) && (r.remove(), r = u), r = u } } } } if (b && O[n] && (b = !1), o.removeEmpty && $w(t, C, O, y)) { return a = y.parent, v[y.name] ? y.empty().remove() : y.unwrap(), void (y = a) } o.paddEmpty && (jw(y) || $w(t, C, O, y)) && Uw(e, c, v, y), y = y.parent } } }, t); var z = y = new Bg(c.context || e.root_name, 11); if (s.parse(a, c.format), k && w.length && (c.context ? c.invalid = !0 : u(w)), E && (z.name === 'body' || c.isRootContent) && R(), !c.invalid) { for (p in o) { if (o.hasOwnProperty(p)) { h = n[p], l = o[p], m = l.length; while (m--) { l[m].parent || l.splice(m, 1) } for (f = 0, d = h.length; f < d; f++) { h[f](l, p, c) } } } for (f = 0, d = r.length; f < d; f++) { if (h = r[f], h.name in i) { l = i[h.name], m = l.length; while (m--) { l[m].parent || l.splice(m, 1) } for (m = 0, g = h.callbacks.length; m < g; m++) { h.callbacks[m](l, h.name, c) } } } } return z }; const m = { schema: t, addAttributeFilter: l, getAttributeFilters: f, addNodeFilter: c, getNodeFilters: s, filterNode: a, parse: d }; return Xw(m, e), Vw.register(m, e), m }; const ex = function (e, t, n) { e.addAttributeFilter('data-mce-tabindex', function (e, t) { let n; let r = e.length; while (r--) { n = e[r], n.attr('tabindex', n.attr('data-mce-tabindex')), n.attr(t, null) } }), e.addAttributeFilter('src,href,style', function (e, r) { let o; let i; let u = e.length; const a = 'data-mce-' + r; const c = t.url_converter; const s = t.url_converter_scope; while (u--) { o = e[u], i = o.attr(a), void 0 !== i ? (o.attr(r, i.length > 0 ? i : null), o.attr(a, null)) : (i = o.attr(r), r === 'style' ? i = n.serializeStyle(n.parseStyle(i), o.name) : c && (i = c.call(s, i, r, o.name)), o.attr(r, i.length > 0 ? i : null)) } }), e.addAttributeFilter('class', function (e) { let t; let n; let r = e.length; while (r--) { t = e[r], n = t.attr('class'), n && (n = t.attr('class').replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ''), t.attr('class', n.length > 0 ? n : null)) } }), e.addAttributeFilter('data-mce-type', function (e, t, n) { let r; let o = e.length; while (o--) { if (r = e[o], r.attr('data-mce-type') === 'bookmark' && !n.cleanup) { const i = p.from(r.firstChild).exists(function (e) { return !es.isZwsp(e.value) }); i ? r.unwrap() : r.remove() } } }), e.addNodeFilter('noscript', function (e) { let t; let n = e.length; while (n--) { t = e[n].firstChild, t && (t.value = ci.decode(t.value)) } }), e.addNodeFilter('script,style', function (e, n) { let r; let o; let i; let u = e.length; const a = function (e) { return e.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n').replace(/^[\r\n]*|[\r\n]*$/g, '').replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '').replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '') }; while (u--) { r = e[u], o = r.firstChild ? r.firstChild.value : '', n === 'script' ? (i = r.attr('type'), i && r.attr('type', i === 'mce-no/type' ? null : i.replace(/^mce\-/, '')), t.element_format === 'xhtml' && o.length > 0 && (r.firstChild.value = '// <![CDATA[\n' + a(o) + '\n// ]]>')) : t.element_format === 'xhtml' && o.length > 0 && (r.firstChild.value = '\x3C!--\n' + a(o) + '\n--\x3E') } }), e.addNodeFilter('#comment', function (e) { let r; let o = e.length; while (o--) { r = e[o], t.preserve_cdata && r.value.indexOf('[CDATA[') === 0 ? (r.name = '#cdata', r.type = 4, r.value = n.decode(r.value.replace(/^\[CDATA\[|\]\]$/g, ''))) : r.value.indexOf('mce:protected ') === 0 && (r.name = '#text', r.type = 3, r.raw = !0, r.value = unescape(r.value).substr(14)) } }), e.addNodeFilter('xml:namespace,input', function (e, t) { let n; let r = e.length; while (r--) { n = e[r], n.type === 7 ? n.remove() : n.type === 1 && (t !== 'input' || n.attr('type') || n.attr('type', 'text')) } }), e.addAttributeFilter('data-mce-type', function (t) { M(t, function (t) { t.attr('data-mce-type') === 'format-caret' && (t.isEmpty(e.schema.getNonEmptyElements()) ? t.remove() : t.unwrap()) }) }), e.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder', function (e, t) { let n = e.length; while (n--) { e[n].attr(t, null) } }) }; const tx = function (e) { let t; let n; const r = function (e) { return e && e.name === 'br' }; t = e.lastChild, r(t) && (n = t.prev, r(n) && (t.remove(), n.remove())) }; const nx = { register: ex, trimTrailingBr: tx }; const rx = function (e, t, r) { let o; let i; let u; const a = e.dom; return t = t.cloneNode(!0), o = n.document.implementation, o.createHTMLDocument && (i = o.createHTMLDocument(''), vo.each(t.nodeName === 'BODY' ? t.childNodes : [t], function (e) { i.body.appendChild(i.importNode(e, !0)) }), t = t.nodeName !== 'BODY' ? i.body.firstChild : i.body, u = a.doc, a.doc = i), Np(e, se(se({}, r), { node: t })), u && (a.doc = u), t }; const ox = function (e, t) { return e && e.hasEventListeners('PreProcess') && !t.no_events }; const ix = function (e, t, n) { return ox(e, n) ? rx(e, t, n) : t }; const ux = { process: ix }; const ax = function (e, t, n) { vo.inArray(t, n) === -1 && (e.addAttributeFilter(n, function (e, t) { let n = e.length; while (n--) { e[n].attr(t, null) } }), t.push(n)) }; const cx = function (e, t, n) { if (!t.no_events && e) { const r = _p(e, se(se({}, t), { content: n })); return r.content } return n }; const sx = function (e, t, n) { const r = es.trim(n.getInner ? t.innerHTML : e.getOuterHTML(t)); return n.selection || jo(ve.fromDom(t)) ? r : vo.trim(r) }; const lx = function (e, t, n) { const r = n.selection ? se({ forced_root_block: !1 }, n) : n; const o = e.parse(t, r); return nx.trimTrailingBr(o), o }; const fx = function (e, t, n) { const r = Qg(e, t); return r.serialize(n) }; const dx = function (e, t, n, r, o) { const i = fx(t, n, r); return cx(e, o, i) }; const mx = function (e, t) { const n = ['data-mce-selected']; const r = t && t.dom ? t.dom : Va.DOM; const o = t && t.schema ? t.schema : yi(e); e.entity_encoding = e.entity_encoding || 'named', e.remove_trailing_brs = !('remove_trailing_brs' in e) || e.remove_trailing_brs; const i = Qw(e, o); nx.register(i, e, r); const u = function (n, u) { void 0 === u && (u = {}); const a = se({ format: 'html' }, u); const c = ux.process(t, n, a); const s = sx(r, c, a); const l = lx(i, s, a); return a.format === 'tree' ? l : dx(t, e, o, l, a) }; return { schema: o, addNodeFilter: i.addNodeFilter, addAttributeFilter: i.addAttributeFilter, serialize: u, addRules (e) { o.addValidElements(e) }, setRules (e) { o.setValidElements(e) }, addTempAttr: a(ax, i, n), getTempAttrs () { return n }, getNodeFilters: i.getNodeFilters, getAttributeFilters: i.getAttributeFilters } }; const gx = function (e, t) { const n = mx(e, t); return { schema: n.schema, addNodeFilter: n.addNodeFilter, addAttributeFilter: n.addAttributeFilter, serialize: n.serialize, addRules: n.addRules, setRules: n.setRules, addTempAttr: n.addTempAttr, getTempAttrs: n.getTempAttrs, getNodeFilters: n.getNodeFilters, getAttributeFilters: n.getAttributeFilters } }; const hx = function (e) { return new Dr(function (t, r) { const o = function () { r('Cannot convert ' + e + ' to Blob. Resource might not exist or is inaccessible.') }; try { const i = new n.XMLHttpRequest(); i.open('GET', e, !0), i.responseType = 'blob', i.onload = function () { this.status === 200 ? t(this.response) : o() }, i.onerror = o, i.send() } catch (u) { o() } }) }; const px = function (e) { let t; let n; const r = decodeURIComponent(e).split(','); return n = /data:([^;]+)/.exec(r[0]), n && (t = n[1]), { type: t, data: r[1] } }; const vx = function (e) { return new Dr(function (t) { let r; let o; let i; const u = px(e); try { r = n.atob(u.data) } catch (OL) { return void t(new n.Blob([])) } for (o = new Uint8Array(r.length), i = 0; i < o.length; i++) { o[i] = r.charCodeAt(i) }t(new n.Blob([o], { type: u.type })) }) }; const bx = function (e) { return e.indexOf('blob:') === 0 ? hx(e) : e.indexOf('data:') === 0 ? vx(e) : null }; const yx = function (e) { return new Dr(function (t) { const r = new n.FileReader(); r.onloadend = function () { t(r.result) }, r.readAsDataURL(e) }) }; const wx = { uriToBlob: bx, blobToDataUri: yx, parseDataUri: px }; let xx = 0; const Cx = function (e) { return (e || 'blobid') + xx++ }; const Sx = function (e, t, n, r) { let o, i; if (t.src.indexOf('blob:') === 0) { return i = e.getByUri(t.src), void (i ? n({ image: t, blobInfo: i }) : wx.uriToBlob(t.src).then(function (r) { wx.blobToDataUri(r).then(function (u) { o = wx.parseDataUri(u).data, i = e.create(Cx(), r, o), e.add(i), n({ image: t, blobInfo: i }) }) }, function (e) { r(e) })) } o = wx.parseDataUri(t.src).data, i = e.findFirst(function (e) { return e.base64() === o }), i ? n({ image: t, blobInfo: i }) : wx.uriToBlob(t.src).then(function (r) { i = e.create(Cx(), r, o), e.add(i), n({ image: t, blobInfo: i }) }, function (e) { r(e) }) }; const kx = function (e) { return e ? J(e.getElementsByTagName('img')) : [] }; function Tx (e, t) { const n = {}; const r = function (r, o) { let u; o || (o = i(!0)), u = I(kx(r), function (t) { const n = t.src; return !!$r.fileApi && (!t.hasAttribute('data-mce-bogus') && (!t.hasAttribute('data-mce-placeholder') && (!(!n || n === $r.transparentSrc) && (n.indexOf('blob:') === 0 ? !e.isUploaded(n) && o(t) : n.indexOf('data:') === 0 && o(t))))) }); const a = B(u, function (e) { if (n[e.src]) { return new Dr(function (t) { n[e.src].then(function (n) { if (typeof n === 'string') { return n } t({ image: e, blobInfo: n.blobInfo }) }) }) } const r = new Dr(function (n, r) { Sx(t, e, n, r) }).then(function (e) { return delete n[e.image.src], e }).catch(function (t) { return delete n[e.src], t }); return n[e.src] = r, r }); return Dr.all(a) }; return { findAll: r } } function Ex (e, t) { const r = {}; const o = function (e, t) { return e ? e.replace(/\/$/, '') + '/' + t.replace(/^\//, '') : t }; const i = function (e, r, i, u) { let a, c; a = new n.XMLHttpRequest(), a.open('POST', t.url), a.withCredentials = t.credentials, a.upload.onprogress = function (e) { u(e.loaded / e.total * 100) }, a.onerror = function () { i('Image upload failed due to a XHR Transport error. Code: ' + a.status) }, a.onload = function () { let e; a.status < 200 || a.status >= 300 ? i('HTTP Error: ' + a.status) : (e = JSON.parse(a.responseText), e && typeof e.location === 'string' ? r(o(t.basePath, e.location)) : i('Invalid JSON: ' + a.responseText)) }, c = new n.FormData(), c.append('file', e.blob(), e.filename()), a.send(c) }; const u = function () { return new Dr(function (e) { e([]) }) }; const a = function (e, t) { return { url: t, blobInfo: e, status: !0 } }; const c = function (e, t) { return { url: '', blobInfo: e, status: !1, error: t } }; const s = function (e, t) { vo.each(r[e], function (e) { e(t) }), delete r[e] }; const l = function (t, n, r) { return e.markPending(t.blobUri()), new Dr(function (o) { let i; let u; const l = function () {}; try { const f = function () { i && (i.close(), u = l) }; const d = function (n) { f(), e.markUploaded(t.blobUri(), n), s(t.blobUri(), a(t, n)), o(a(t, n)) }; const m = function (n) { f(), e.removeFailed(t.blobUri()), s(t.blobUri(), c(t, n)), o(c(t, n)) }; u = function (e) { e < 0 || e > 100 || (i || (i = r()), i.progressBar.value(e)) }, n(t, d, m, u) } catch (g) { o(c(t, g.message)) } }) }; const f = function (e) { return e === i }; const d = function (e) { const t = e.blobUri(); return new Dr(function (e) { r[t] = r[t] || [], r[t].push(e) }) }; const m = function (n, r) { return n = vo.grep(n, function (t) { return !e.isUploaded(t.blobUri()) }), Dr.all(vo.map(n, function (n) { return e.isPending(n.blobUri()) ? d(n) : l(n, t.handler, r) })) }; const g = function (e, n) { return !t.url && f(t.handler) ? u() : m(e, n) }; return !1 === k(t.handler) && (t.handler = i), { upload: g } } function Ox () { const e = 1; const t = 2; let n = {}; const r = function (e, t) { return { status: e, resultUri: t } }; const o = function (e) { return e in n }; const i = function (e) { const t = n[e]; return t ? t.resultUri : null }; const u = function (t) { return !!o(t) && n[t].status === e }; const a = function (e) { return !!o(e) && n[e].status === t }; const c = function (t) { n[t] = r(e, null) }; const s = function (e, o) { n[e] = r(t, o) }; const l = function (e) { delete n[e] }; const f = function () { n = {} }; return { hasBlobUri: o, getResultUri: i, isPending: u, isUploaded: a, markPending: c, markUploaded: s, removeFailed: l, destroy: f } } let Nx = 0; const _x = function () { const e = function () { return Math.round(4294967295 * Math.random()).toString(36) }; const t = (new Date()).getTime(); return 's' + t.toString(36) + e() + e() + e() }; const Dx = function (e) { return e + Nx++ + _x() }; const Ax = { uuid: Dx }; const Rx = function () { let e = []; const t = function (e) { const t = { 'image/jpeg': 'jpg', 'image/jpg': 'jpg', 'image/gif': 'gif', 'image/png': 'png' }; return t[e.toLowerCase()] || 'dat' }; const r = function (e, t, n, r) { if (y(e)) { const i = e; return o({ id: i, name: r, blob: t, base64: n }) } if (w(e)) { return o(e) } throw new Error('Unknown input type') }; var o = function (e) { let r, o; if (!e.blob || !e.base64) { throw new Error('blob and base64 representations of the image are required for BlobInfo to be created') } return r = e.id || Ax.uuid('blobid'), o = e.name || r, { id: i(r), name: i(o), filename: i(o + '.' + t(e.blob.type)), blob: i(e.blob), base64: i(e.base64), blobUri: i(e.blobUri || n.URL.createObjectURL(e.blob)), uri: i(e.uri) } }; const u = function (t) { a(t.id()) || e.push(t) }; var a = function (e) { return c(function (t) { return t.id() === e }) }; var c = function (t) { return I(e, t)[0] }; const s = function (e) { return c(function (t) { return t.blobUri() === e }) }; const l = function (t) { e = I(e, function (e) { return e.blobUri() !== t || (n.URL.revokeObjectURL(e.blobUri()), !1) }) }; const f = function () { M(e, function (e) { n.URL.revokeObjectURL(e.blobUri()) }), e = [] }; return { create: r, add: u, get: a, getByUri: s, findFirst: c, removeByUri: l, destroy: f } }; const Bx = function (e) { let t; let n; const r = Rx(); const o = Ox(); const i = []; const u = function (t) { return function (n) { return e.selection ? t(n) : [] } }; const a = function (e) { return e + (!e.includes('?') ? '?' : '&') + (new Date()).getTime() }; const c = function (e, t, n) { let r = 0; do { r = e.indexOf(t, r), r !== -1 && (e = e.substring(0, r) + n + e.substr(r + t.length), r += n.length - t.length + 1) } while (r !== -1); return e }; const s = function (e, t, n) { return e = c(e, 'src="' + t + '"', 'src="' + n + '"'), e = c(e, 'data-mce-src="' + t + '"', 'data-mce-src="' + n + '"'), e }; const l = function (t, n) { M(e.undoManager.data, function (e) { e.type === 'fragmented' ? e.fragments = B(e.fragments, function (e) { return s(e, t, n) }) : e.content = s(e.content, t, n) }) }; const f = function () { return e.notificationManager.open({ text: e.translate('Image uploading...'), type: 'info', timeout: -1, progressBar: !0 }) }; const d = function (t, n) { r.removeByUri(t.src), l(t.src, n), e.$(t).attr({ src: id.shouldReuseFileName(e) ? a(n) : n, 'data-mce-src': e.convertURL(n, 'src') }) }; const m = function (n) { return t || (t = Ex(o, { url: id.getImageUploadUrl(e), basePath: id.getImageUploadBasePath(e), credentials: id.getImagesUploadCredentials(e), handler: id.getImagesUploadHandler(e) })), v().then(u(function (r) { const o = B(r, function (e) { return e.blobInfo }); return t.upload(o, f).then(u(function (t) { const o = B(t, function (t, n) { const o = r[n].image; return t.status && id.shouldReplaceBlobUris(e) ? d(o, t.url) : t.error && tb.uploadError(e, t.error), { element: o, status: t.status } }); return n && n(o), o })) })) }; const g = function (t) { if (id.isAutomaticUploadsEnabled(e)) { return m(t) } }; const h = function (t) { if (!1 === W(i, function (e) { return e(t) })) { return !1 } if (t.getAttribute('src').indexOf('data:') === 0) { const n = id.getImagesDataImgFilter(e); return n(t) } return !0 }; const p = function (e) { i.push(e) }; var v = function () { return n || (n = Tx(o, r)), n.findAll(e.getBody(), h).then(u(function (t) { return t = I(t, function (t) { return typeof t !== 'string' || (tb.displayError(e, t), !1) }), M(t, function (e) { l(e.image.src, e.blobInfo.blobUri()), e.image.src = e.blobInfo.blobUri(), e.image.removeAttribute('data-mce-src') }), t })) }; const b = function () { r.destroy(), o.destroy(), n = t = null }; const y = function (t) { return t.replace(/src="(blob:[^"]+)"/g, function (t, n) { const i = o.getResultUri(n); if (i) { return 'src="' + i + '"' } let u = r.getByUri(n); if (u || (u = H(e.editorManager.get(), function (e, t) { return e || t.editorUpload && t.editorUpload.blobCache.getByUri(n) }, null)), u) { const a = u.blob(); return 'src="data:' + a.type + ';base64,' + u.base64() + '"' } return t }) }; return e.on('SetContent', function () { id.isAutomaticUploadsEnabled(e) ? g() : v() }), e.on('RawSaveContent', function (e) { e.content = y(e.content) }), e.on('GetContent', function (e) { e.source_view || e.format === 'raw' || (e.content = y(e.content)) }), e.on('PostRender', function () { e.parser.addNodeFilter('img', function (e) { M(e, function (e) { const t = e.attr('src'); if (!r.getByUri(t)) { const n = o.getResultUri(t); n && e.attr('src', n) } }) }) }), { blobCache: r, addFilter: p, uploadImages: m, uploadImagesAuto: g, scanForImages: v, destroy: b } }; const Mx = function (e) { const t = []; let n = e.dom(); while (n) { t.push(ve.fromDom(n)), n = n.lastChild } return t }; const Px = function (e) { const t = Tc(e, 'br'); const n = I(Mx(e).slice(-1), zo); t.length === n.length && M(n, rn) }; const zx = function (e) { nn(e), Zt(e, ve.fromHtml('<br data-mce-bogus="1">')) }; const Ix = function (e) { return ln(e) ? wg(e) === Fi : zo(e) }; const Lx = function (e) { return I(Wt(e), Ix).length === 1 }; const Hx = function (e) { Gt(e).each(function (t) { Ft(t).each(function (n) { Bo(e) && zo(t) && Bo(n) && rn(t) }) }) }; const Fx = { removeTrailingBr: Px, fillWithPaddingBr: zx, isPaddedElement: Lx, trimBlockTrailingBr: Hx }; const Vx = Xm; const Ux = function (e, t, n) { const r = e.formatter.get(n); if (r) { for (let o = 0; o < r.length; o++) { if (!1 === r[o].inherit && e.dom.is(t, r[o].selector)) { return !0 } } } return !1 }; const jx = function (e, t, n, r) { const o = e.dom.getRoot(); return t !== o && (t = e.dom.getParent(t, function (t) { return !!Ux(e, t, n) || (t.parentNode === o || !!$x(e, t, n, r, !0)) }), $x(e, t, n, r)) }; const Wx = function (e, t, n) { return !!Vx(t, n.inline) || (!!Vx(t, n.block) || (n.selector ? t.nodeType === 1 && e.is(t, n.selector) : void 0)) }; const qx = function (e, t, n, r, o, i) { let u; let a; let c; const s = n[r]; if (n.onmatch) { return n.onmatch(t, n, r) } if (s) { if (typeof s.length === 'undefined') { for (u in s) { if (s.hasOwnProperty(u)) { if (a = r === 'attributes' ? e.getAttrib(t, u) : Km(e, t, u), o && !a && !n.exact) { return } if ((!o || n.exact) && !Vx(a, Ym(e, Gm(s[u], i), u))) { return } } } } else { for (c = 0; c < s.length; c++) { if (r === 'attributes' ? e.getAttrib(t, s[c]) : Km(e, t, s[c])) { return n } } } } return n }; var $x = function (e, t, n, r, o) { let i; let u; let a; let c; const s = e.formatter.get(n); const l = e.dom; if (s && t) { for (u = 0; u < s.length; u++) { if (i = s[u], Wx(e.dom, t, i) && qx(l, t, i, 'attributes', o, r) && qx(l, t, i, 'styles', o, r)) { if (c = i.classes) { for (a = 0; a < c.length; a++) { if (!e.dom.hasClass(t, c[a])) { return } } } return i } } } }; const Gx = function (e, t, n, r) { let o; return r ? jx(e, r, t, n) : (r = e.selection.getNode(), !!jx(e, r, t, n) || (o = e.selection.getStart(), !(o === r || !jx(e, o, t, n)))) }; const Xx = function (e, t, n) { let r; const o = []; const i = {}; return r = e.selection.getStart(), e.dom.getParent(r, function (r) { let u, a; for (u = 0; u < t.length; u++) { a = t[u], !i[a] && $x(e, r, a, n) && (i[a] = !0, o.push(a)) } }, e.dom.getRoot()), o }; const Yx = function (e, t) { let n; let r; let o; let i; let u; const a = e.formatter.get(t); const c = e.dom; if (a) { for (n = e.selection.getStart(), r = Zm(c, n), i = a.length - 1; i >= 0; i--) { if (u = a[i].selector, !u || a[i].defaultBlock) { return !0 } for (o = r.length - 1; o >= 0; o--) { if (c.is(r[o], u)) { return !0 } } } } return !1 }; const Kx = function (e, t) { return e.splitText(t) }; const Jx = function (e) { let t = e.startContainer; let n = e.startOffset; let r = e.endContainer; let o = e.endOffset; return t === r && qn.isText(t) ? n > 0 && n < t.nodeValue.length && (r = Kx(t, n), t = r.previousSibling, o > n ? (o -= n, t = r = Kx(r, o).previousSibling, o = r.nodeValue.length, n = 0) : o = 0) : (qn.isText(t) && n > 0 && n < t.nodeValue.length && (t = Kx(t, n), n = 0), qn.isText(r) && o > 0 && o < r.nodeValue.length && (r = Kx(r, o).previousSibling, o = r.nodeValue.length)), { startContainer: t, startOffset: n, endContainer: r, endOffset: o } }; const Zx = function (e, t, n) { const r = H(e, function (r, o) { return Im(o) || zm(o) ? r.previousCharIsSpace || r.str === '' && t || r.str.length === e.length - 1 && n ? { previousCharIsSpace: !1, str: r.str + Fi } : { previousCharIsSpace: !0, str: r.str + ' ' } : { previousCharIsSpace: !1, str: r.str + o } }, { previousCharIsSpace: !1, str: '' }); return r.str }; const Qx = function (e, t, n) { if (n !== 0) { const r = e.data.slice(t, t + n); const o = t + n >= e.data.length; const i = t === 0; e.replaceData(t, n, Zx(r, i, o)) } }; const eC = function (e, t) { const n = e.data.slice(t); const r = n.length - nt(n).length; return Qx(e, t, r) }; const tC = function (e, t) { const n = e.data.slice(0, t); const r = n.length - rt(n).length; return Qx(e, t - r, r) }; const nC = function (e, t, n) { const r = rt(e.data).length; return e.appendData(t.data), rn(ve.fromDom(t)), n && eC(e, r), e }; const rC = function (e, t, n) { return _c(e, t, n).isSome() }; const oC = function (e, t) { const n = ve.fromDom(e); const r = ve.fromDom(t); return rC(r, 'pre,code', a(Dt, n)) }; const iC = function (e, t) { return qn.isText(t) && /^[ \t\r\n]*$/.test(t.data) && !1 === oC(e, t) }; const uC = function (e) { return qn.isElement(e) && e.nodeName === 'A' && e.hasAttribute('name') }; const aC = function (e, t) { return Ts(t) && !1 === iC(e, t) || uC(t) || cC(t) }; var cC = qn.hasAttribute('data-mce-bookmark'); const sC = qn.hasAttribute('data-mce-bogus'); const lC = qn.hasAttributeValue('data-mce-bogus', 'all'); const fC = function (e, t) { let n; let r = 0; if (aC(e, e)) { return !1 } if (n = e.firstChild, !n) { return !0 } const o = new Aa(n, e); do { if (t) { if (lC(n)) { n = o.next(!0); continue } if (sC(n)) { n = o.next(); continue } } if (qn.isBr(n)) { r++, n = o.next() } else { if (aC(e, n)) { return !1 } n = o.next() } } while (n); return r <= 1 }; const dC = function (e, t) { return void 0 === t && (t = !0), fC(e.dom(), t) }; const mC = { isEmpty: dC }; const gC = function (e, t) { const n = e.container(); const r = e.offset(); return !1 === yl.isTextPosition(e) && n === t.parentNode && r > yl.before(t).offset() }; const hC = function (e, t) { return gC(t, e) ? yl(t.container(), t.offset() - 1) : t }; const pC = function (e) { return qn.isText(e) ? yl(e, 0) : yl.before(e) }; const vC = function (e) { return qn.isText(e) ? yl(e, e.data.length) : yl.after(e) }; const bC = function (e) { return Ts(e.previousSibling) ? p.some(vC(e.previousSibling)) : e.previousSibling ? fm.lastPositionIn(e.previousSibling) : p.none() }; const yC = function (e) { return Ts(e.nextSibling) ? p.some(pC(e.nextSibling)) : e.nextSibling ? fm.firstPositionIn(e.nextSibling) : p.none() }; const wC = function (e, t) { const n = yl.before(t.previousSibling ? t.previousSibling : t.parentNode); return fm.prevPosition(e, n).fold(function () { return fm.nextPosition(e, yl.after(t)) }, p.some) }; const xC = function (e, t) { return fm.nextPosition(e, yl.after(t)).fold(function () { return fm.prevPosition(e, yl.before(t)) }, p.some) }; const CC = function (e, t) { return bC(t).orThunk(function () { return yC(t) }).orThunk(function () { return wC(e, t) }) }; const SC = function (e, t) { return yC(t).orThunk(function () { return bC(t) }).orThunk(function () { return xC(e, t) }) }; const kC = function (e, t, n) { return e ? SC(t, n) : CC(t, n) }; const TC = function (e, t, n) { return kC(e, t, n).map(a(hC, n)) }; const EC = function (e, t, n) { n.fold(function () { e.focus() }, function (n) { e.selection.setRng(n.toRange(), t) }) }; const OC = function (e) { return function (t) { return t.dom() === e } }; const NC = function (e, t) { return t && e.schema.getBlockElements().hasOwnProperty(un(t)) }; const _C = function (e) { if (mC.isEmpty(e)) { const t = ve.fromHtml('<br data-mce-bogus="1">'); return nn(e), Zt(e, t), p.some(yl.before(t.dom())) } return p.none() }; const DC = function (e, t, n) { const r = Ft(e).filter(ln); const o = Vt(e).filter(ln); return rn(e), qs(r, o, t, function (e, t, r) { const o = e.dom(); const i = t.dom(); const u = o.data.length; return nC(o, i, n), r.container() === i ? yl(o, u) : r }).orThunk(function () { return n && (r.each(function (e) { return tC(e.dom(), e.dom().length) }), o.each(function (e) { return eC(e.dom(), 0) })), t }) }; const AC = function (e, t) { return ce(e.schema.getTextInlineElements(), un(t)) }; const RC = function (e, t, n, r) { void 0 === r && (r = !0); const o = TC(t, e.getBody(), n.dom()); const i = Oc(n, a(NC, e), OC(e.getBody())); const u = DC(n, o, AC(e, n)); e.dom.isEmpty(e.getBody()) ? (e.setContent(''), e.selection.setCursorLocation()) : i.bind(_C).fold(function () { r && EC(e, t, u) }, function (n) { r && EC(e, t, p.some(n)) }) }; const BC = { deleteElement: RC }; const MC = es.ZWSP; const PC = '_mce_caret'; const zC = function (e, t) { return e.importNode(t, !0) }; const IC = function (e) { const t = []; while (e) { if (e.nodeType === 3 && e.nodeValue !== MC || e.childNodes.length > 1) { return [] } e.nodeType === 1 && t.push(e), e = e.firstChild } return t }; const LC = function (e) { return IC(e).length > 0 }; const HC = function (e) { if (e) { const t = new Aa(e, e); for (e = t.current(); e; e = t.next()) { if (qn.isText(e)) { return e } } } return null }; const FC = function (e) { const t = ve.fromTag('span'); return Yn(t, { id: PC, 'data-mce-bogus': '1', 'data-mce-type': 'format-caret' }), e && Zt(t, ve.fromText(MC)), t }; const VC = function (e) { const t = HC(e); return t && t.nodeValue.charAt(0) === MC && t.deleteData(0, 1), t }; const UC = function (e, t, n) { void 0 === n && (n = !0); const r = e.dom; const o = e.selection; if (LC(t)) { BC.deleteElement(e, !1, ve.fromDom(t), n) } else { const i = o.getRng(); const u = r.getParent(t, r.isBlock); const a = VC(t); i.startContainer === a && i.startOffset > 0 && i.setStart(a, i.startOffset - 1), i.endContainer === a && i.endOffset > 0 && i.setEnd(a, i.endOffset - 1), r.remove(t, !0), u && r.isEmpty(u) && Fx.fillWithPaddingBr(ve.fromDom(u)), o.setRng(i) } }; const jC = function (e, t, n) { void 0 === n && (n = !0); const r = e.dom; const o = e.selection; if (t) { UC(e, t, n) } else if (t = of(e.getBody(), o.getStart()), !t) { while (t = r.get(PC)) { UC(e, t, !1) } } }; const WC = function (e, t, n) { const r = e.dom; const o = r.getParent(n, a(jm, e)); o && r.isEmpty(o) ? n.parentNode.replaceChild(t, n) : (Fx.removeTrailingBr(ve.fromDom(n)), r.isEmpty(n) ? n.parentNode.replaceChild(t, n) : r.insertAfter(t, n)) }; const qC = function (e, t) { return e.appendChild(t), t }; const $C = function (e, t) { const n = L(e, function (e, t) { return qC(e, t.cloneNode(!1)) }, t); return qC(n, n.ownerDocument.createTextNode(MC)) }; const GC = function (e, t, n) { let r; let o; let i; let u; let a; let c; let s; const l = e.selection; r = l.getRng(), u = r.startOffset, c = r.startContainer, s = c.nodeValue, o = of(e.getBody(), l.getStart()), o && (i = HC(o)); const f = /[^\s\u00A0\u00AD\u200B\uFEFF]/; s && u > 0 && u < s.length && f.test(s.charAt(u)) && f.test(s.charAt(u - 1)) ? (a = l.getBookmark(), r.collapse(!0), r = dg(e, r, e.formatter.get(t)), r = Jx(r), e.formatter.apply(t, n, r), l.moveToBookmark(a)) : (o && i.nodeValue === MC ? e.formatter.apply(t, n, o) : (o = zC(e.getDoc(), FC(!0).dom()), i = o.firstChild, r.insertNode(o), u = 1, e.formatter.apply(t, n, o)), l.setCursorLocation(i, u)) }; const XC = function (e, t, n, r) { let o; let i; let u; let a; let c; let s; let l; const f = e.dom; const d = e.selection; const m = []; const g = d.getRng(); o = g.startContainer, i = g.startOffset, c = o, o.nodeType === 3 && (i !== o.nodeValue.length && (a = !0), c = c.parentNode); while (c) { if ($x(e, c, t, n, r)) { s = c; break }c.nextSibling && (a = !0), m.push(c), c = c.parentNode } if (s) { if (a) { u = d.getBookmark(), g.collapse(!0); let h = dg(e, g, e.formatter.get(t), !0); h = Jx(h), e.formatter.remove(t, n, h), d.moveToBookmark(u) } else { l = of(e.getBody(), s); const p = FC(!1).dom(); const v = $C(m, p); WC(e, p, l || s), UC(e, l, !1), d.setCursorLocation(v, 1), f.isEmpty(s) && f.remove(s) } } }; const YC = function (e, t) { const n = e.selection; const r = e.getBody(); jC(e, null, !1), t !== 8 && t !== 46 || !n.isCollapsed() || n.getStart().innerHTML !== MC || jC(e, of(r, n.getStart())), t !== 37 && t !== 39 || jC(e, of(r, n.getStart())) }; const KC = function (e) { e.on('mouseup keydown', function (t) { YC(e, t.keyCode) }) }; const JC = function (e, t) { const n = FC(!1); const r = $C(t, n.dom()); return Yt(ve.fromDom(e), n), rn(ve.fromDom(e)), yl(r, 0) }; const ZC = function (e, t) { const n = e.schema.getTextInlineElements(); return n.hasOwnProperty(un(t)) && !rf(t.dom()) && !qn.isBogus(t.dom()) }; const QC = function (e) { return rf(e.dom()) && LC(e.dom()) }; const eS = {}; const tS = ro.filter; const nS = ro.each; const rS = function (e, t) { let n = eS[e]; n || (eS[e] = n = []), eS[e].push(t) }; const oS = function (e, t) { nS(eS[e], function (e) { e(t) }) }; rS('pre', function (e) { let t; let n; const r = e.selection.getRng(); const o = function (e) { return t(e.previousSibling) && ro.includes(n, e.previousSibling) }; const i = function (e, t) { Da(t).remove(), Da(e).append('<br><br>').append(t.childNodes) }; t = qn.matchNodeNames(['pre']), r.collapsed || (n = e.selection.getSelectedBlocks(), nS(tS(tS(n, t), o), function (e) { i(e.previousSibling, e) })) }); const iS = vo.each; const uS = function (e) { this.compare = function (t, n) { if (t.nodeName !== n.nodeName) { return !1 } const r = function (t) { const n = {}; return iS(e.getAttribs(t), function (r) { const o = r.nodeName.toLowerCase(); o.indexOf('_') !== 0 && o !== 'style' && o.indexOf('data-') !== 0 && (n[o] = e.getAttrib(t, o)) }), n }; const o = function (e, t) { let n, r; for (r in e) { if (e.hasOwnProperty(r)) { if (n = t[r], typeof n === 'undefined') { return !1 } if (e[r] !== n) { return !1 } delete t[r] } } for (r in t) { if (t.hasOwnProperty(r)) { return !1 } } return !0 }; return !!o(r(t), r(n)) && (!!o(e.parseStyle(e.getAttrib(t, 'style')), e.parseStyle(e.getAttrib(n, 'style'))) && (!Mm.isBookmarkNode(t) && !Mm.isBookmarkNode(n))) } }; const aS = /^(src|href|style)$/; const cS = vo.each; const sS = Xm; const lS = function (e) { return /^(TH|TD)$/.test(e.nodeName) }; const fS = function (e, t, n) { return e.isChildOf(t, n) && t !== n && !e.isBlock(n) }; const dS = function (e, t, n) { let r, o; if (r = t[n ? 'startContainer' : 'endContainer'], o = t[n ? 'startOffset' : 'endOffset'], qn.isElement(r)) { const i = r.childNodes.length - 1; !n && o && o--, r = r.childNodes[o > i ? i : o] } return qn.isText(r) && n && o >= r.nodeValue.length && (r = new Aa(r, e.getBody()).next() || r), qn.isText(r) && !n && o === 0 && (r = new Aa(r, e.getBody()).prev() || r), r }; const mS = function (e, t, n, r) { const o = e.create(n, r); return t.parentNode.insertBefore(o, t), o.appendChild(t), o }; const gS = function (e, t, n, r, o) { const i = ve.fromDom(t); const u = ve.fromDom(e.create(r, o)); const a = n ? jt(i) : Ut(i); return tn(u, a), n ? (Yt(i, u), Jt(u, i)) : (Kt(i, u), Zt(u, i)), u.dom() }; const hS = function (e, t, n) { return !!sS(t, n.inline) || (!!sS(t, n.block) || (n.selector ? qn.isElement(t) && e.is(t, n.selector) : void 0)) }; const pS = function (e, t) { return t.links && e.nodeName === 'A' }; const vS = function (e, t, n, r) { return t = Um(t, n, r), !t || t.nodeName === 'BR' || e.isBlock(t) }; const bS = function (e, t, n) { let r; const o = t.parentNode; const i = e.dom; const u = id.getForcedRootBlock(e); n.block && (u ? o === i.getRoot() && (n.list_block && sS(t, n.list_block) || cS(vo.grep(t.childNodes), function (t) { Wm(e, u, t.nodeName.toLowerCase()) ? r ? r.appendChild(t) : (r = mS(i, t, u), i.setAttribs(r, e.settings.forced_root_block_attrs)) : r = 0 })) : i.isBlock(t) && !i.isBlock(o) && (vS(i, t, !1) || vS(i, t.firstChild, !0, !0) || t.insertBefore(i.create('br'), t.firstChild), vS(i, t, !0) || vS(i, t.lastChild, !1, !0) || t.appendChild(i.create('br')))), n.selector && n.inline && !sS(n.inline, t) || i.remove(t, !0) }; const yS = function (e, t, n, r, o) { let i; const u = e.dom; if (!hS(u, r, t) && !pS(r, t)) { return !1 } const a = r; if (t.remove !== 'all') { cS(t.styles, function (e, r) { e = Ym(u, Gm(e, n), r), typeof r === 'number' && (r = e, o = null), (t.remove_similar || !o || sS(Km(u, o, r), e)) && u.setStyle(a, r, ''), i = !0 }), i && u.getAttrib(a, 'style') === '' && (a.removeAttribute('style'), a.removeAttribute('data-mce-style')), cS(t.attributes, function (e, r) { let i; if (e = Gm(e, n), typeof r === 'number' && (r = e, o = null), t.remove_similar || !o || sS(u.getAttrib(o, r), e)) { if (r === 'class' && (e = u.getAttrib(a, r), e && (i = '', cS(e.split(/\s+/), function (e) { /mce\-\w+/.test(e) && (i += (i ? ' ' : '') + e) }), i))) { return void u.setAttrib(a, r, i) } r === 'class' && a.removeAttribute('className'), aS.test(r) && a.removeAttribute('data-mce-' + r), a.removeAttribute(r) } }), cS(t.classes, function (e) { e = Gm(e, n), o && !u.hasClass(o, e) || u.removeClass(a, e) }); for (let c = u.getAttribs(a), s = 0; s < c.length; s++) { const l = c[s].nodeName; if (l.indexOf('_') !== 0 && l.indexOf('data-') !== 0) { return !1 } } } return t.remove !== 'none' ? (bS(e, a, t), !0) : void 0 }; const wS = function (e, t, n, r, o) { let i; return cS(Zm(e.dom, t.parentNode).reverse(), function (t) { let u; i || t.id === '_start' || t.id === '_end' || (u = $x(e, t, n, r, o), u && !1 !== u.split && (i = t)) }), i }; const xS = function (e, t, n, r, o, i, u, a) { let c; let s; let l; let f; let d; let m; const g = e.dom; if (n) { for (m = n.parentNode, c = r.parentNode; c && c !== m; c = c.parentNode) { for (s = g.clone(c, !1), d = 0; d < t.length; d++) { if (yS(e, t[d], a, s, s)) { s = 0; break } }s && (l && s.appendChild(l), f || (f = s), l = s) }!i || u.mixed && g.isBlock(n) || (r = g.split(n, r)), l && (o.parentNode.insertBefore(l, o), f.appendChild(o)) } return r }; const CS = function (e, t, n, r, o) { let i; let u; const a = e.formatter.get(t); const c = a[0]; let s = !0; const l = e.dom; const f = e.selection; const d = function (r) { const i = wS(e, r, t, n, o); return xS(e, a, i, r, r, !0, c, n) }; const m = function (e) { return Mm.isBookmarkNode(e) && qn.isElement(e) && (e.id === '_start' || e.id === '_end') }; var g = function (t) { let r, o, i, u, f; if (qn.isElement(t) && l.getContentEditable(t) && (u = s, s = l.getContentEditable(t) === 'true', f = !0), r = vo.grep(t.childNodes), s && !f) { for (o = 0, i = a.length; o < i; o++) { if (yS(e, a[o], n, t, t)) { break } } } if (c.deep && r.length) { for (o = 0, i = r.length; o < i; o++) { g(r[o]) }f && (s = u) } }; const h = function (e) { const t = l.get(e ? '_start' : '_end'); let n = t[e ? 'firstChild' : 'lastChild']; return m(n) && (n = n[e ? 'firstChild' : 'lastChild']), qn.isText(n) && n.data.length === 0 && (n = e ? t.previousSibling || t.nextSibling : t.nextSibling || t.previousSibling), l.remove(t, !0), n }; const v = function (t) { let n; let r; const o = t.commonAncestorContainer; let i = dg(e, t, a, !0); if (c.split) { if (i = Jx(i), n = dS(e, i, !0), r = dS(e, i), n !== r) { if (/^(TR|TH|TD)$/.test(n.nodeName) && n.firstChild && (n = n.nodeName === 'TR' ? n.firstChild.firstChild || n : n.firstChild || n), o && /^T(HEAD|BODY|FOOT|R)$/.test(o.nodeName) && lS(r) && r.firstChild && (r = r.firstChild || r), fS(l, n, r)) { var u = p.from(n.firstChild).getOr(n); return d(gS(l, u, !0, 'span', { id: '_start', 'data-mce-type': 'bookmark' })), void h(!0) } if (fS(l, r, n)) { u = p.from(r.lastChild).getOr(r); return d(gS(l, u, !1, 'span', { id: '_end', 'data-mce-type': 'bookmark' })), void h(!1) }n = mS(l, n, 'span', { id: '_start', 'data-mce-type': 'bookmark' }), r = mS(l, r, 'span', { id: '_end', 'data-mce-type': 'bookmark' }); const s = l.createRng(); s.setStartAfter(n), s.setEndBefore(r), vg.walk(l, s, function (e) { M(e, function (e) { Mm.isBookmarkNode(e) || Mm.isBookmarkNode(e.parentNode) || d(e) }) }), d(n), d(r), n = h(!0), r = h() } else { n = r = d(n) }i.startContainer = n.parentNode ? n.parentNode : n, i.startOffset = l.nodeIndex(n), i.endContainer = r.parentNode ? r.parentNode : r, i.endOffset = l.nodeIndex(r) + 1 }vg.walk(l, i, function (t) { cS(t, function (t) { g(t), qn.isElement(t) && e.dom.getStyle(t, 'text-decoration') === 'underline' && t.parentNode && Jm(l, t.parentNode) === 'underline' && yS(e, { deep: !1, exact: !0, inline: 'span', styles: { textDecoration: 'underline' } }, null, t) }) }) }; if (r) { Hm(r) ? (u = l.createRng(), u.setStartBefore(r), u.setEndAfter(r), v(u)) : v(r) } else if (l.getContentEditable(f.getNode()) !== 'false') { f.isCollapsed() && c.inline && !l.select('td[data-mce-selected],th[data-mce-selected]').length ? XC(e, t, n, o) : (i = Ql.getPersistentBookmark(e.selection, !0), v(f.getRng()), f.moveToBookmark(i), c.inline && Gx(e, t, n, f.getStart()) && Vm(l, f, f.getRng()), e.nodeChanged()) } else { r = f.getNode(); for (let b = 0, y = a.length; b < y; b++) { if (a[b].ceFalseOverride && yS(e, a[b], n, r, r)) { break } } } }; const SS = vo.each; const kS = function (e) { return qn.isElement(e) && !Mm.isBookmarkNode(e) && !rf(e) && !qn.isBogus(e) }; const TS = function (e, t) { let n; for (n = e; n; n = n[t]) { if (qn.isText(n) && n.nodeValue.length !== 0) { return e } if (qn.isElement(n) && !Mm.isBookmarkNode(n)) { return n } } return e }; const ES = function (e, t, n) { let r; let o; const i = new uS(e); if (t && n && (t = TS(t, 'previousSibling'), n = TS(n, 'nextSibling'), i.compare(t, n))) { for (r = t.nextSibling; r && r !== n;) { o = r, r = r.nextSibling, t.appendChild(o) } return e.remove(n), vo.each(vo.grep(n.childNodes), function (e) { t.appendChild(e) }), t } return n }; var OS = function (e, t, n) { SS(e.childNodes, function (e) { kS(e) && (t(e) && n(e), e.hasChildNodes() && OS(e, t, n)) }) }; const NS = function (e, t) { return a(function (t, n) { return !(!n || !Km(e, n, t)) }, t) }; const _S = function (e, t, n) { return a(function (t, n, r) { e.setStyle(r, t, n), r.getAttribute('style') === '' && r.removeAttribute('style'), DS(e, r) }, t, n) }; var DS = function (e, t) { t.nodeName === 'SPAN' && e.getAttribs(t).length === 0 && e.remove(t, !0) }; const AS = function (e, t) { if (t.nodeType === 1 && t.parentNode && t.parentNode.nodeType === 1) { const n = Jm(e, t.parentNode); e.getStyle(t, 'color') && n ? e.setStyle(t, 'text-decoration', n) : e.getStyle(t, 'text-decoration') === n && e.setStyle(t, 'text-decoration', null) } }; const RS = function (e, t, n, r) { t.styles && (t.styles.color || t.styles.textDecoration) && (vo.walk(r, a(AS, e), 'childNodes'), AS(e, r)) }; const BS = function (e, t, n, r) { t.styles && t.styles.backgroundColor && OS(r, NS(e, 'fontSize'), _S(e, 'backgroundColor', Gm(t.styles.backgroundColor, n))) }; const MS = function (e, t, n, r) { t.inline !== 'sub' && t.inline !== 'sup' || (OS(r, NS(e, 'fontSize'), _S(e, 'fontSize', '')), e.remove(e.select(t.inline === 'sup' ? 'sub' : 'sup', r), !0)) }; const PS = function (e, t, n, r) { r && !1 !== t.merge_siblings && (r = ES(e, Um(r), r), r = ES(e, r, Um(r, !0))) }; const zS = function (e, t, n) { if (t.clear_child_styles) { const r = t.links ? '*:not(a)' : '*'; SS(e.select(r, n), function (n) { kS(n) && SS(t.styles, function (t, r) { e.setStyle(n, r, '') }) }) } }; const IS = function (e, t, n, r) { SS(t, function (t) { SS(e.dom.select(t.inline, r), function (r) { kS(r) && yS(e, t, n, r, t.exact ? r : null) }), zS(e.dom, t, r) }) }; const LS = function (e, t, n, r, o) { $x(e, o.parentNode, n, r) && yS(e, t, r, o) || t.merge_with_parents && e.dom.getParent(o.parentNode, function (i) { if ($x(e, i, n, r)) { return yS(e, t, r, o), !0 } }) }; const HS = function (e, t, r, o) { const i = n.document.createRange(); return i.setStart(e, t), i.setEnd(r, o), i }; const FS = function (e) { const t = yl.fromRangeStart(e); const n = yl.fromRangeEnd(e); const r = e.commonAncestorContainer; return fm.fromPosition(!1, r, n).map(function (o) { return !Td(t, n, r) && Td(t, o, r) ? HS(t.container(), t.offset(), o.container(), o.offset()) : e }).getOr(e) }; const VS = function (e) { return e.collapsed ? e : FS(e) }; const US = { normalize: VS }; const jS = vo.each; const WS = function (e) { return e && e.nodeType === 1 && !Mm.isBookmarkNode(e) && !rf(e) && !qn.isBogus(e) }; var qS = function (e, t, n, r) { let o; let i; const u = e.formatter.get(t); const a = u[0]; const c = !r && e.selection.isCollapsed(); const s = e.dom; const l = e.selection; const f = function (e, t) { if (t = t || a, e) { if (t.onformat && t.onformat(e, t, n, r), jS(t.styles, function (t, r) { s.setStyle(e, r, Gm(t, n)) }), t.styles) { const o = s.getAttrib(e, 'style'); o && s.setAttrib(e, 'data-mce-style', o) }jS(t.attributes, function (t, r) { s.setAttrib(e, r, Gm(t, n)) }), jS(t.classes, function (t) { t = Gm(t, n), s.hasClass(e, t) || s.addClass(e, t) }) } }; const d = function (e, t) { let n = !1; return !!a.selector && (jS(e, function (e) { if (!('collapsed' in e && e.collapsed !== c)) { return s.is(t, e.selector) && !rf(t) ? (f(t, e), n = !0, !1) : void 0 } }), n) }; const m = function (r, o, i, c) { let s; let l; const m = []; let g = !0; s = a.inline || a.block, l = r.create(s), f(l), vg.walk(r, o, function (o) { let i; var h = function (o) { let p = !1; let v = g; const b = o.nodeName.toLowerCase(); const y = o.parentNode.nodeName.toLowerCase(); if (qn.isElement(o) && r.getContentEditable(o) && (v = g, g = r.getContentEditable(o) === 'true', p = !0), Xm(b, 'br')) { return i = 0, void (a.block && r.remove(o)) } if (a.wrapper && $x(e, o, t, n)) { i = 0 } else { if (g && !p && a.block && !a.wrapper && jm(e, b) && Wm(e, y, s)) { return o = r.rename(o, s), f(o), m.push(o), void (i = 0) } if (a.selector) { const w = d(u, o); if (!a.inline || w) { return void (i = 0) } }!g || p || !Wm(e, s, b) || !Wm(e, y, s) || !c && o.nodeType === 3 && o.nodeValue.length === 1 && o.nodeValue.charCodeAt(0) === 65279 || rf(o) || a.inline && r.isBlock(o) ? (i = 0, jS(vo.grep(o.childNodes), h), p && (g = v), i = 0) : (i || (i = r.clone(l, !1), o.parentNode.insertBefore(i, o), m.push(i)), i.appendChild(o)) } }; jS(o, h) }), !0 === a.links && jS(m, function (e) { var t = function (e) { e.nodeName === 'A' && f(e, a), jS(vo.grep(e.childNodes), t) }; t(e) }), jS(m, function (o) { let i; const c = function (e) { let t = 0; return jS(e.childNodes, function (e) { $m(e) || Mm.isBookmarkNode(e) || t++ }), t }; const s = function (e) { let t = !1; return jS(e.childNodes, function (e) { if (WS(e)) { return t = e, !1 } }), t }; const l = function (e) { let t, n; return t = s(e), t && !Mm.isBookmarkNode(t) && Wx(r, t, a) && (n = r.clone(t, !1), f(n), r.replace(n, e, !0), r.remove(t, !0)), n || e }; i = c(o), !(m.length > 1) && r.isBlock(o) || i !== 0 ? (a.inline || a.wrapper) && (a.exact || i !== 1 || (o = l(o)), IS(e, u, n, o), LS(e, a, t, n, o), BS(r, a, n, o), RS(r, a, n, o), MS(r, a, n, o), PS(r, a, n, o)) : r.remove(o, !0) }) }; if (s.getContentEditable(l.getNode()) !== 'false') { if (a) { if (r) { Hm(r) ? d(u, r) || (i = s.createRng(), i.setStartBefore(r), i.setEndAfter(r), m(s, dg(e, i, u), null, !0)) : m(s, r, null, !0) } else if (c && a.inline && !s.select('td[data-mce-selected],th[data-mce-selected]').length) { GC(e, t, n) } else { const g = e.selection.getNode(); e.settings.forced_root_block || !u[0].defaultBlock || s.getParent(g, s.isBlock) || qS(e, u[0].defaultBlock), e.selection.setRng(US.normalize(e.selection.getRng())), o = Ql.getPersistentBookmark(e.selection, !0), m(s, dg(e, l.getRng(), u)), l.moveToBookmark(o), Vm(s, l, l.getRng()), e.nodeChanged() }oS(t, e) } } else { r = l.getNode(); for (let h = 0, p = u.length; h < p; h++) { if (u[h].ceFalseOverride && s.is(r, u[h].selector)) { return void f(r, u[h]) } } } }; const $S = function (e, t) { const n = be({}); e.set({}), t.on('NodeChange', function (r) { GS(t, r.element, n, e.get()) }) }; var GS = function (e, t, n, r) { const o = Z(n.get()); const i = {}; const u = {}; const a = I(Zm(e.dom, t), function (e) { return e.nodeType === 1 && !e.getAttribute('data-mce-bogus') }); ee(r, function (t, n) { vo.each(a, function (r) { return e.formatter.matchNode(r, n, {}, t.similar) ? (!o.includes(n) && (M(t.callbacks, function (e) { e(!0, { node: r, format: n, parents: a }) }), i[n] = t.callbacks), u[n] = t.callbacks, !1) : !Ux(e, r, n) && void 0 }) }); const c = XS(n.get(), u, t, a); n.set(se(se({}, i), c)) }; var XS = function (e, t, n, r) { return ie(e, function (e, o) { return !!ce(t, o) || (M(e, function (e) { e(!1, { node: n, format: o, parents: r }) }), !1) }).t }; const YS = function (e, t, n, r) { const o = e.get(); M(t.split(','), function (e) { o[e] || (o[e] = { similar: r, callbacks: [] }), o[e].callbacks.push(n) }), e.set(o) }; const KS = function (e, t, n) { const r = e.get(); M(t.split(','), function (e) { r[e].callbacks = I(r[e].callbacks, function (e) { return e !== n }), r[e].callbacks.length === 0 && delete r[e] }), e.set(r) }; const JS = function (e, t, n, r, o) { return t.get() === null && $S(t, e), YS(t, n, r, o), { unbind () { return KS(t, n, r) } } }; const ZS = function (e) { const t = { valigntop: [{ selector: 'td,th', styles: { verticalAlign: 'top' } }], valignmiddle: [{ selector: 'td,th', styles: { verticalAlign: 'middle' } }], valignbottom: [{ selector: 'td,th', styles: { verticalAlign: 'bottom' } }], alignleft: [{ selector: 'figure.image', collapsed: !1, classes: 'align-left', ceFalseOverride: !0, preview: 'font-family font-size' }, { selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li', styles: { textAlign: 'left' }, inherit: !1, preview: !1, defaultBlock: 'div' }, { selector: 'img,table', collapsed: !1, styles: { float: 'left' }, preview: 'font-family font-size' }], aligncenter: [{ selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li', styles: { textAlign: 'center' }, inherit: !1, preview: 'font-family font-size', defaultBlock: 'div' }, { selector: 'figure.image', collapsed: !1, classes: 'align-center', ceFalseOverride: !0, preview: 'font-family font-size' }, { selector: 'img', collapsed: !1, styles: { display: 'block', marginLeft: 'auto', marginRight: 'auto' }, preview: !1 }, { selector: 'table', collapsed: !1, styles: { marginLeft: 'auto', marginRight: 'auto' }, preview: 'font-family font-size' }], alignright: [{ selector: 'figure.image', collapsed: !1, classes: 'align-right', ceFalseOverride: !0, preview: 'font-family font-size' }, { selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li', styles: { textAlign: 'right' }, inherit: !1, preview: 'font-family font-size', defaultBlock: 'div' }, { selector: 'img,table', collapsed: !1, styles: { float: 'right' }, preview: 'font-family font-size' }], alignjustify: [{ selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li', styles: { textAlign: 'justify' }, inherit: !1, defaultBlock: 'div', preview: 'font-family font-size' }], bold: [{ inline: 'strong', remove: 'all' }, { inline: 'span', styles: { fontWeight: 'bold' } }, { inline: 'b', remove: 'all' }], italic: [{ inline: 'em', remove: 'all' }, { inline: 'span', styles: { fontStyle: 'italic' } }, { inline: 'i', remove: 'all' }], underline: [{ inline: 'span', styles: { textDecoration: 'underline' }, exact: !0 }, { inline: 'u', remove: 'all' }], strikethrough: [{ inline: 'span', styles: { textDecoration: 'line-through' }, exact: !0 }, { inline: 'strike', remove: 'all' }], forecolor: { inline: 'span', styles: { color: '%value' }, links: !0, remove_similar: !0, clear_child_styles: !0 }, hilitecolor: { inline: 'span', styles: { backgroundColor: '%value' }, links: !0, remove_similar: !0, clear_child_styles: !0 }, fontname: { inline: 'span', toggle: !1, styles: { fontFamily: '%value' }, clear_child_styles: !0 }, fontsize: { inline: 'span', toggle: !1, styles: { fontSize: '%value' }, clear_child_styles: !0 }, fontsize_class: { inline: 'span', attributes: { class: '%value' } }, blockquote: { block: 'blockquote', wrapper: !0, remove: 'all' }, subscript: { inline: 'sub' }, superscript: { inline: 'sup' }, code: { inline: 'code' }, link: { inline: 'a', selector: 'a', remove: 'all', split: !0, deep: !0, onmatch () { return !0 }, onformat (t, n, r) { vo.each(r, function (n, r) { e.setAttrib(t, r, n) }) } }, removeformat: [{ selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins', remove: 'all', split: !0, expand: !1, block_expand: !0, deep: !0 }, { selector: 'span', attributes: ['style', 'class'], remove: 'empty', split: !0, expand: !1, deep: !0 }, { selector: '*', attributes: ['style', 'class'], split: !1, expand: !1, deep: !0 }] }; return vo.each('p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp'.split(/\s/), function (e) { t[e] = { block: e, remove: 'all' } }), t }; const QS = { get: ZS }; function ek (e) { const t = {}; const n = function (e) { return e ? t[e] : t }; const r = function (e) { return ce(t, e) }; var o = function (e, n) { e && (typeof e !== 'string' ? vo.each(e, function (e, t) { o(t, e) }) : (x(n) || (n = [n]), vo.each(n, function (e) { typeof e.deep === 'undefined' && (e.deep = !e.selector), typeof e.split === 'undefined' && (e.split = !e.selector || e.inline), typeof e.remove === 'undefined' && e.selector && !e.inline && (e.remove = 'none'), e.selector && e.inline && (e.mixed = !0, e.block_expand = !0), typeof e.classes === 'string' && (e.classes = e.classes.split(/\s+/)) }), t[e] = n)) }; const i = function (e) { return e && t[e] && delete t[e], t }; return o(QS.get(e.dom)), o(e.settings.formats), { get: n, has: r, register: o, unregister: i } } let tk; const nk = vo.each; const rk = Va.DOM; const ok = function (e, t) { let n; let r; let o; const i = t && t.schema || yi({}); const u = function (e, t) { t.classes.length && rk.addClass(e, t.classes.join(' ')), rk.setAttribs(e, t.attrs) }; const a = function (e) { let t; return r = typeof e === 'string' ? { name: e, classes: [], attrs: {} } : e, t = rk.create(r.name), u(t, r), t }; const c = function (e, t) { const n = typeof e !== 'string' ? e.nodeName.toLowerCase() : e; const r = i.getElementRule(n); const o = r && r.parentsRequired; return !(!o || !o.length) && (t && vo.inArray(o, t) !== -1 ? t : o[0]) }; var s = function (e, t, n) { let r; let o; let i; const u = t.length > 0 && t[0]; const l = u && u.name; if (i = c(e, l), i) { l === i ? (o = t[0], t = t.slice(1)) : o = i } else if (u) { o = t[0], t = t.slice(1) } else if (!n) { return e } return o && (r = a(o), r.appendChild(e)), n && (r || (r = rk.create('div'), r.appendChild(e)), vo.each(n, function (t) { const n = a(t); r.insertBefore(n, e) })), s(r, t, o && o.siblings) }; return e && e.length ? (r = e[0], n = a(r), o = rk.create('div'), o.appendChild(s(n, e.slice(1), r.siblings)), o) : '' }; const ik = function (e) { let t; const n = { classes: [], attrs: {} }; return e = n.selector = vo.trim(e), e !== '*' && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function (e, t, r, o, i) { switch (t) { case '#':n.attrs.id = r; break; case '.':n.classes.push(r); break; case ':':vo.inArray('checked disabled enabled read-only required'.split(' '), r) !== -1 && (n.attrs[r] = r); break } if (o === '[') { const u = i.match(/([\w\-]+)(?:\=\"([^\"]+))?/); u && (n.attrs[u[1]] = u[2]) } return '' })), n.name = t || 'div', n }; const uk = function (e) { return e && typeof e === 'string' ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, '$1'), vo.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), function (e) { const t = vo.map(e.split(/(?:~\+|~|\+)/), ik); const n = t.pop(); return t.length && (n.siblings = t), n }).reverse()) : [] }; const ak = function (e, t) { let n; let r; let o; let i; let u; let a; let c = ''; if (a = e.settings.preview_styles, !1 === a) { return '' } typeof a !== 'string' && (a = 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'); const s = function (e) { return e.replace(/%(\w+)/g, '') }; if (typeof t === 'string') { if (t = e.formatter.get(t), !t) { return } t = t[0] } return 'preview' in t && (a = t.preview, !1 === a) ? '' : (n = t.block || t.inline || 'span', i = uk(t.selector), i.length ? (i[0].name || (i[0].name = n), n = t.selector, r = ok(i, e)) : r = ok([n], e), o = rk.select(n, r)[0] || r.firstChild, nk(t.styles, function (e, t) { e = s(e), e && rk.setStyle(o, t, e) }), nk(t.attributes, function (e, t) { e = s(e), e && rk.setAttrib(o, t, e) }), nk(t.classes, function (e) { e = s(e), rk.hasClass(o, e) || rk.addClass(o, e) }), e.fire('PreviewFormats'), rk.setStyles(r, { position: 'absolute', left: -65535 }), e.getBody().appendChild(r), u = rk.getStyle(e.getBody(), 'fontSize', !0), u = u.endsWith('px') ? parseInt(u, 10) : 0, nk(a.split(' '), function (t) { let n = rk.getStyle(o, t, !0); if ((t !== 'background-color' || !/transparent|rgba\s*\([^)]+,\s*0\)/.test(n) || (n = rk.getStyle(e.getBody(), t, !0), rk.toHex(n).toLowerCase() !== '#ffffff')) && (t !== 'color' || rk.toHex(n).toLowerCase() !== '#000000')) { if (t === 'font-size' && /em|%$/.test(n)) { if (u === 0) { return } const r = parseFloat(n) / (n.endsWith('%') ? 100 : 1); n = r * u + 'px' }t === 'border' && n && (c += 'padding:0 2px;'), c += t + ':' + n + ';' } }), e.fire('AfterPreviewFormats'), rk.remove(r), c) }; const ck = function (e, t, n, r, o) { const i = t.get(n); !Gx(e, n, r, o) || 'toggle' in i[0] && !i[0].toggle ? qS(e, n, r, o) : CS(e, n, r, o) }; const sk = function (e) { e.addShortcut('meta+b', '', 'Bold'), e.addShortcut('meta+i', '', 'Italic'), e.addShortcut('meta+u', '', 'Underline'); for (let t = 1; t <= 6; t++) { e.addShortcut('access+' + t, '', ['FormatBlock', !1, 'h' + t]) }e.addShortcut('access+7', '', ['FormatBlock', !1, 'p']), e.addShortcut('access+8', '', ['FormatBlock', !1, 'div']), e.addShortcut('access+9', '', ['FormatBlock', !1, 'address']) }; const lk = { setup: sk }; const fk = function (e) { const t = ek(e); const n = be(null); return lk.setup(e), KC(e), { get: t.get, has: t.has, register: t.register, unregister: t.unregister, apply: a(qS, e), remove: a(CS, e), toggle: a(ck, e, t), match: a(Gx, e), matchAll: a(Xx, e), matchNode: a($x, e), canApply: a(Yx, e), formatChanged: a(JS, e, n), getCssText: a(ak, e) } }; const dk = 0; const mk = 1; const gk = 2; const hk = function (e, t) { const n = e.length + t.length + 2; const r = new Array(n); const o = new Array(n); const i = function (e, t, n) { return { start: e, end: t, diag: n } }; var u = function (n, r, o, i, a) { const s = c(n, r, o, i); if (s === null || s.start === r && s.diag === r - i || s.end === n && s.diag === n - o) { let l = n; let f = o; while (l < r || f < i) { l < r && f < i && e[l] === t[f] ? (a.push([dk, e[l]]), ++l, ++f) : r - n > i - o ? (a.push([gk, e[l]]), ++l) : (a.push([mk, t[f]]), ++f) } } else { u(n, s.start, o, s.start - s.diag, a); for (let d = s.start; d < s.end; ++d) { a.push([dk, e[d]]) }u(s.end, r, s.end - s.diag, i, a) } }; const a = function (n, r, o, u) { let a = n; while (a - r < u && a < o && e[a] === t[a - r]) { ++a } return i(n, a, r) }; var c = function (n, i, u, c) { const s = i - n; const l = c - u; if (s === 0 || l === 0) { return null } let f; let d; let m; let g; let h; const p = s - l; const v = l + s; const b = (v % 2 === 0 ? v : v + 1) / 2; for (r[1 + b] = n, o[1 + b] = i + 1, f = 0; f <= b; ++f) { for (d = -f; d <= f; d += 2) { m = d + b, d === -f || d !== f && r[m - 1] < r[m + 1] ? r[m] = r[m + 1] : r[m] = r[m - 1] + 1, g = r[m], h = g - n + u - d; while (g < i && h < c && e[g] === t[h]) { r[m] = ++g, ++h } if (p % 2 !== 0 && p - f <= d && d <= p + f && o[m - p] <= r[m]) { return a(o[m - p], d + n - u, i, c) } } for (d = p - f; d <= p + f; d += 2) { m = d + b - p, d === p - f || d !== p + f && o[m + 1] <= o[m - 1] ? o[m] = o[m + 1] - 1 : o[m] = o[m - 1], g = o[m] - 1, h = g - n + u - d; while (g >= n && h >= u && e[g] === t[h]) { o[m] = g--, h-- } if (p % 2 === 0 && -f <= d && d <= f && o[m] <= r[m + p]) { return a(o[m], d + n - u, i, c) } } } }; const s = []; return u(0, e.length, 0, t.length, s), s }; const pk = { KEEP: dk, DELETE: gk, INSERT: mk, diff: hk }; const vk = function (e) { return qn.isElement(e) ? e.outerHTML : qn.isText(e) ? ci.encodeRaw(e.data, !1) : qn.isComment(e) ? '\x3C!--' + e.data + '--\x3E' : '' }; const bk = function (e) { let t, r, o; o = n.document.createElement('div'), t = n.document.createDocumentFragment(), e && (o.innerHTML = e); while (r = o.firstChild) { t.appendChild(r) } return t }; const yk = function (e, t, n) { const r = bk(t); if (e.hasChildNodes() && n < e.childNodes.length) { const o = e.childNodes[n]; o.parentNode.insertBefore(r, o) } else { e.appendChild(r) } }; const wk = function (e, t) { if (e.hasChildNodes() && t < e.childNodes.length) { const n = e.childNodes[t]; n.parentNode.removeChild(n) } }; const xk = function (e, t) { let n = 0; M(e, function (e) { e[0] === pk.KEEP ? n++ : e[0] === pk.INSERT ? (yk(t, e[1], n), n++) : e[0] === pk.DELETE && wk(t, n) }) }; const Ck = function (e) { return I(B(J(e.childNodes), vk), function (e) { return e.length > 0 }) }; const Sk = function (e, t) { const n = B(J(t.childNodes), vk); return xk(pk.diff(n, e), t), t }; const kk = { read: Ck, write: Sk }; const Tk = be(p.none()); const Ek = function () { return Tk.get().getOrThunk(function () { const e = n.document.implementation.createHTMLDocument('undo'); return Tk.set(p.some(e)), e }) }; const Ok = function (e) { return e.includes('</iframe>') }; const Nk = function (e) { return { type: 'fragmented', fragments: e, content: '', bookmark: null, beforeBookmark: null } }; const _k = function (e) { return { type: 'complete', fragments: null, content: e, bookmark: null, beforeBookmark: null } }; const Dk = function (e) { let t, n, r; return t = kk.read(e.getBody()), r = j(t, function (t) { const n = $g.trimInternal(e.serializer, t); return n.length > 0 ? [n] : [] }), n = r.join(''), Ok(n) ? Nk(r) : _k(n) }; const Ak = function (e, t, n) { t.type === 'fragmented' ? kk.write(t.fragments, e.getBody()) : e.setContent(t.content, { format: 'raw' }), e.selection.moveToBookmark(n ? t.beforeBookmark : t.bookmark) }; const Rk = function (e) { return e.type === 'fragmented' ? e.fragments.join('') : e.content }; const Bk = function (e) { const t = ve.fromTag('body', Ek()); return Gc(t, Rk(e)), M(Tc(t, '*[data-mce-bogus]'), on), $c(t) }; const Mk = function (e, t) { return Rk(e) === Rk(t) }; const Pk = function (e, t) { return Bk(e) === Bk(t) }; const zk = function (e, t) { return !(!e || !t) && (!!Mk(e, t) || Pk(e, t)) }; const Ik = { createFragmentedLevel: Nk, createCompleteLevel: _k, createFromEditor: Dk, applyToEditor: Ak, isEq: zk }; const Lk = function (e) { return e.get() === 0 }; const Hk = function (e, t, n) { Lk(n) && (e.typing = t) }; const Fk = function (e, t) { e.typing && (Hk(e, !1, t), e.add()) }; const Vk = function (e) { e.typing && (e.typing = !1, e.add()) }; const Uk = function (e, t, n) { Lk(t) && n.set(p.some(Ql.getUndoBookmark(e.selection))) }; const jk = function (e, t, n, r, o, i, u) { const a = e.settings; const c = Ik.createFromEditor(e); if (i = i || {}, i = vo.extend(i, c), !1 === Lk(r) || e.removed) { return null } const s = t.data[n.get()]; if (e.fire('BeforeAddUndo', { level: i, lastLevel: s, originalEvent: u }).isDefaultPrevented()) { return null } if (s && Ik.isEq(s, i)) { return null } if (t.data[n.get()] && o.get().each(function (e) { t.data[n.get()].beforeBookmark = e }), a.custom_undo_redo_levels && t.data.length > a.custom_undo_redo_levels) { for (let l = 0; l < t.data.length - 1; l++) { t.data[l] = t.data[l + 1] }t.data.length--, n.set(t.data.length) }i.bookmark = Ql.getUndoBookmark(e.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(i), n.set(t.data.length - 1); const f = { level: i, lastLevel: s, originalEvent: u }; return e.fire('AddUndo', f), n.get() > 0 && (e.setDirty(!0), e.fire('change', f)), i }; const Wk = function (e, t, n) { t.data = [], n.set(0), t.typing = !1, e.fire('ClearUndos') }; const qk = function (e, t, n, r, o) { if (t.transact(r)) { const i = t.data[n.get()].bookmark; const u = t.data[n.get() - 1]; Ik.applyToEditor(e, u, !0), t.transact(o) && (t.data[n.get() - 1].beforeBookmark = i) } }; const $k = function (e, t, n) { let r; return t.get() < n.length - 1 && (t.set(t.get() + 1), r = n[t.get()], Ik.applyToEditor(e, r, !1), e.setDirty(!0), e.fire('Redo', { level: r })), r }; const Gk = function (e, t, n, r) { let o; return t.typing && (t.add(), t.typing = !1, Hk(t, !1, n)), r.get() > 0 && (r.set(r.get() - 1), o = t.data[r.get()], Ik.applyToEditor(e, o, !0), e.setDirty(!0), e.fire('Undo', { level: o })), o }; const Xk = function (e) { e.clear(), e.add() }; const Yk = function (e, t, n) { return n.get() > 0 || t.typing && t.data[0] && !Ik.isEq(Ik.createFromEditor(e), t.data[0]) }; const Kk = function (e, t) { return t.get() < e.data.length - 1 && !e.typing }; const Jk = function (e, t, n) { return Fk(e, t), e.beforeChange(), e.ignore(n), e.add() }; const Zk = function (e, t) { try { e.set(e.get() + 1), t() } finally { e.set(e.get() - 1) } }; const Qk = function (e, t, n) { const r = be(!1); const o = function (e) { Hk(t, !1, n), t.add({}, e) }; e.on('init', function () { t.add() }), e.on('BeforeExecCommand', function (e) { const r = e.command; r !== 'Undo' && r !== 'Redo' && r !== 'mceRepaint' && (Fk(t, n), t.beforeChange()) }), e.on('ExecCommand', function (e) { const t = e.command; t !== 'Undo' && t !== 'Redo' && t !== 'mceRepaint' && o(e) }), e.on('ObjectResizeStart cut', function () { t.beforeChange() }), e.on('SaveContent ObjectResized blur', o), e.on('dragend', o), e.on('keyup', function (n) { const i = n.keyCode; n.isDefaultPrevented() || ((i >= 33 && i <= 36 || i >= 37 && i <= 40 || i === 45 || n.ctrlKey) && (o(), e.nodeChanged()), i !== 46 && i !== 8 || e.nodeChanged(), r.get() && t.typing && !1 === Ik.isEq(Ik.createFromEditor(e), t.data[0]) && (!1 === e.isDirty() && (e.setDirty(!0), e.fire('change', { level: t.data[0], lastLevel: null })), e.fire('TypingUndo'), r.set(!1), e.nodeChanged())) }), e.on('keydown', function (e) { const i = e.keyCode; if (!e.isDefaultPrevented()) { if (i >= 33 && i <= 36 || i >= 37 && i <= 40 || i === 45) { t.typing && o(e) } else { const u = e.ctrlKey && !e.altKey || e.metaKey; !(i < 16 || i > 20) || i === 224 || i === 91 || t.typing || u || (t.beforeChange(), Hk(t, !0, n), t.add({}, e), r.set(!0)) } } }), e.on('mousedown', function (e) { t.typing && o(e) }); const i = function (e) { return e.inputType === 'insertReplacementText' }; const u = function (e) { return e.inputType === 'insertText' && e.data === null }; e.on('input', function (e) { e.inputType && (i(e) || u(e)) && o(e) }), e.on('AddUndo Undo Redo ClearUndos', function (t) { t.isDefaultPrevented() || e.nodeChanged() }) }; const eT = function (e) { e.addShortcut('meta+z', '', 'Undo'), e.addShortcut('meta+y,meta+shift+z', '', 'Redo') }; const tT = function (e) { const t = be(p.none()); const n = be(0); const r = be(0); var o = { data: [], typing: !1, beforeChange () { Uk(e, n, t) }, add (i, u) { return jk(e, o, r, n, t, i, u) }, undo () { return Gk(e, o, n, r) }, redo () { return $k(e, r, o.data) }, clear () { Wk(e, o, r) }, reset () { Xk(o) }, hasUndo () { return Yk(e, o, r) }, hasRedo () { return Kk(o, r) }, transact (e) { return Jk(o, n, e) }, ignore (e) { Zk(n, e) }, extra (t, n) { qk(e, o, r, t, n) } }; return Qk(e, o, n), eT(e), o }; const nT = [9, 27, lb.HOME, lb.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, lb.DOWN, lb.UP, lb.LEFT, lb.RIGHT].concat($r.browser.isFirefox() ? [224] : []); const rT = 'data-mce-placeholder'; const oT = function (e) { return e.type === 'keydown' || e.type === 'keyup' }; const iT = function (e) { const t = e.keyCode; return t === lb.BACKSPACE || t === lb.DELETE }; const uT = function (e) { if (oT(e)) { const t = e.keyCode; return !iT(e) && (lb.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || A(nT, t)) } return !1 }; const aT = function (e) { return oT(e) && !(iT(e) || e.type === 'keyup' && e.keyCode === 229) }; const cT = function (e, t, n) { if (mC.isEmpty(ve.fromDom(t), !1)) { const r = n === ''; const o = t.firstElementChild; return !o || !e.getStyle(t.firstElementChild, 'padding-left') && !e.getStyle(t.firstElementChild, 'padding-right') && (r ? !e.isBlock(o) : n === o.nodeName.toLowerCase()) } return !1 }; const sT = function (e) { const t = e.dom; const n = id.getForcedRootBlock(e); const r = id.getPlaceholder(e); var o = function (i, u) { if (!uT(i)) { const a = e.getBody(); const c = !aT(i) && cT(t, a, n); const s = t.getAttrib(a, rT) !== ''; (s !== c || u) && (t.setAttrib(a, rT, c ? r : null), t.setAttrib(a, 'aria-placeholder', c ? r : null), Lp(e, c), e.on(c ? 'keydown' : 'keyup', o), e.off(c ? 'keyup' : 'keydown', o)) } }; r && e.on('init', function (n) { o(n, !0), e.on('change SetContent ExecCommand', o), e.on('remove', function () { const n = e.getBody(); t.setAttrib(n, rT, null), t.setAttrib(n, 'aria-placeholder', null) }) }) }; const lT = 5; const fT = 400; const dT = function (e) { return void 0 === e.touches || e.touches.length !== 1 ? p.none() : p.some(e.touches[0]) }; const mT = function (e, t) { const n = Math.abs(e.clientX - t.x()); const r = Math.abs(e.clientY - t.y()); return n > lT || r > lT }; const gT = function (e) { const t = be(p.none()); const n = be(!1); const r = dc(function (t) { e.fire('longpress', se(se({}, t), { type: 'longpress' })), n.set(!0) }, fT); e.on('touchstart', function (e) { dT(e).each(function (o) { r.cancel(); const u = { x: i(o.clientX), y: i(o.clientY), target: i(e.target) }; r.throttle(e), n.set(!1), t.set(p.some(u)) }) }, !0), e.on('touchmove', function (o) { r.cancel(), dT(o).each(function (r) { t.get().each(function (o) { mT(r, o) && (t.set(p.none()), n.set(!1), e.fire('longpresscancel')) }) }) }, !0), e.on('touchend touchcancel', function (o) { r.cancel(), o.type !== 'touchcancel' && t.get().filter(function (e) { return e.target().isEqualNode(o.target) }).each(function () { n.get() ? o.preventDefault() : e.fire('tap', se(se({}, o), { type: 'tap' })) }) }, !0) }; const hT = { setup: gT }; const pT = function (e, t) { return e.hasOwnProperty(t.nodeName) }; const vT = function (e, t) { return !!qn.isText(t) || !!qn.isElement(t) && (!pT(e, t) && !Mm.isBookmarkNode(t)) }; const bT = function (e, t, n) { return R(uy.parents(ve.fromDom(n), ve.fromDom(t)), function (t) { return pT(e, t.dom()) }) }; const yT = function (e, t) { if (qn.isText(t)) { if (t.nodeValue.length === 0) { return !0 } if (/^\s+$/.test(t.nodeValue) && (!t.nextSibling || pT(e, t.nextSibling))) { return !0 } } return !1 }; const wT = function (e) { let t; let n; let r; let o; let i; let u; let a; let c; let s; let l; const f = e.dom; const d = e.selection; const m = e.schema; const g = m.getBlockElements(); let h = d.getStart(); const p = e.getBody(); const v = id.getForcedRootBlock(e); if (h && qn.isElement(h) && v && (l = p.nodeName.toLowerCase(), m.isValidChild(l, v.toLowerCase()) && !bT(g, p, h))) { t = d.getRng(), n = t.startContainer, r = t.startOffset, o = t.endContainer, i = t.endOffset, s = wp.hasFocus(e), h = p.firstChild; while (h) { if (vT(g, h)) { if (yT(g, h)) { a = h, h = h.nextSibling, f.remove(a); continue }u || (u = f.create(v, id.getForcedRootBlockAttrs(e)), h.parentNode.insertBefore(u, h), c = !0), a = h, h = h.nextSibling, u.appendChild(a) } else { u = null, h = h.nextSibling } }c && s && (t.setStart(n, r), t.setEnd(o, i), d.setRng(t), e.nodeChanged()) } }; const xT = function (e) { id.getForcedRootBlock(e) && e.on('NodeChange', a(wT, e)) }; const CT = { setup: xT }; const ST = qn.isText; const kT = function (e) { return ST(e) && e.data[0] === es.ZWSP }; const TT = function (e) { return ST(e) && e.data[e.data.length - 1] === es.ZWSP }; const ET = function (e) { return e.ownerDocument.createTextNode(es.ZWSP) }; const OT = function (e) { if (ST(e.previousSibling)) { return TT(e.previousSibling) ? e.previousSibling : (e.previousSibling.appendData(es.ZWSP), e.previousSibling) } if (ST(e)) { return kT(e) ? e : (e.insertData(0, es.ZWSP), e) } const t = ET(e); return e.parentNode.insertBefore(t, e), t }; const NT = function (e) { if (ST(e.nextSibling)) { return kT(e.nextSibling) ? e.nextSibling : (e.nextSibling.insertData(0, es.ZWSP), e.nextSibling) } if (ST(e)) { return TT(e) ? e : (e.appendData(es.ZWSP), e) } const t = ET(e); return e.nextSibling ? e.parentNode.insertBefore(t, e.nextSibling) : e.parentNode.appendChild(t), t }; const _T = function (e, t) { return e ? OT(t) : NT(t) }; const DT = a(_T, !0); const AT = a(_T, !1); const RT = function (e, t) { return qn.isText(e.container()) ? _T(t, e.container()) : _T(t, e.getNode()) }; const BT = function (e, t) { const n = t.get(); return n && e.container() === n && os(n) }; const MT = function (e, t) { return t.fold(function (t) { yf.remove(e.get()); const n = DT(t); return e.set(n), p.some(yl(n, n.length - 1)) }, function (t) { return fm.firstPositionIn(t).map(function (t) { if (BT(t, e)) { return yl(e.get(), 1) } yf.remove(e.get()); const n = RT(t, !0); return e.set(n), yl(n, 1) }) }, function (t) { return fm.lastPositionIn(t).map(function (t) { if (BT(t, e)) { return yl(e.get(), e.get().length - 1) } yf.remove(e.get()); const n = RT(t, !1); return e.set(n), yl(n, n.length - 1) }) }, function (t) { yf.remove(e.get()); const n = AT(t); return e.set(n), p.some(yl(n, 1)) }) }; const PT = { renderCaret: MT }; const zT = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/; const IT = function (e) { return zT.test(e) }; const LT = function (e, t) { return Et(ve.fromDom(t), id.getInlineBoundarySelector(e)) }; const HT = function (e) { return Va.DOM.getStyle(e, 'direction', !0) === 'rtl' || IT(e.textContent) }; const FT = function (e, t, n) { return I(Va.DOM.getParents(n.container(), '*', t), e) }; const VT = function (e, t, n) { const r = FT(e, t, n); return p.from(r[r.length - 1]) }; const UT = function (e, t, n) { const r = kd(t, e); const o = kd(n, e); return r && r === o }; const jT = function (e) { return cs(e) || ss(e) }; const WT = function (e, t) { if (!t) { return t } const n = t.container(); const r = t.offset(); return e ? os(n) ? qn.isText(n.nextSibling) ? yl(n.nextSibling, 0) : yl.after(n) : cs(t) ? yl(n, r + 1) : t : os(n) ? qn.isText(n.previousSibling) ? yl(n.previousSibling, n.previousSibling.data.length) : yl.before(n) : ss(t) ? yl(n, r - 1) : t }; const qT = a(WT, !0); const $T = a(WT, !1); const GT = { isInlineTarget: LT, findRootInline: VT, isRtl: HT, isAtZwsp: jT, normalizePosition: WT, normalizeForwards: qT, normalizeBackwards: $T, hasSameParentBlock: UT }; const XT = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n].apply(null, t); if (r.isSome()) { return r } } return p.none() }; const YT = { evaluateUntil: XT }; const KT = ah.generate([{ before: ['element'] }, { start: ['element'] }, { end: ['element'] }, { after: ['element'] }]); const JT = function (e, t) { const n = kd(t, e); return n || e }; const ZT = function (e, t, n) { const r = GT.normalizeForwards(n); const o = JT(t, r.container()); return GT.findRootInline(e, o, r).fold(function () { return fm.nextPosition(o, r).bind(a(GT.findRootInline, e, o)).map(function (e) { return KT.before(e) }) }, p.none) }; const QT = function (e, t) { return of(e, t) === null }; const eE = function (e, t, n) { return GT.findRootInline(e, t, n).filter(a(QT, t)) }; const tE = function (e, t, n) { const r = GT.normalizeBackwards(n); return eE(e, t, r).bind(function (e) { const t = fm.prevPosition(e, r); return t.isNone() ? p.some(KT.start(e)) : p.none() }) }; const nE = function (e, t, n) { const r = GT.normalizeForwards(n); return eE(e, t, r).bind(function (e) { const t = fm.nextPosition(e, r); return t.isNone() ? p.some(KT.end(e)) : p.none() }) }; const rE = function (e, t, n) { const r = GT.normalizeBackwards(n); const o = JT(t, r.container()); return GT.findRootInline(e, o, r).fold(function () { return fm.prevPosition(o, r).bind(a(GT.findRootInline, e, o)).map(function (e) { return KT.after(e) }) }, p.none) }; const oE = function (e) { return !1 === GT.isRtl(uE(e)) }; const iE = function (e, t, n) { const r = YT.evaluateUntil([ZT, tE, nE, rE], [e, t, n]); return r.filter(oE) }; var uE = function (e) { return e.fold(u, u, u, u) }; const aE = function (e) { return e.fold(i('before'), i('start'), i('end'), i('after')) }; const cE = function (e) { return e.fold(KT.before, KT.before, KT.after, KT.after) }; const sE = function (e) { return e.fold(KT.start, KT.start, KT.end, KT.end) }; const lE = function (e, t) { return aE(e) === aE(t) && uE(e) === uE(t) }; const fE = function (e, t, n, r, o, i) { return Ws(GT.findRootInline(t, n, r), GT.findRootInline(t, n, o), function (t, r) { return t !== r && GT.hasSameParentBlock(n, t, r) ? KT.after(e ? t : r) : i }).getOr(i) }; const dE = function (e, t) { return e.fold(i(!0), function (e) { return !lE(e, t) }) }; const mE = function (e, t, n, r, o) { const i = GT.normalizePosition(e, o); const u = fm.fromPosition(e, n, i).map(a(GT.normalizePosition, e)); const c = u.fold(function () { return r.map(cE) }, function (o) { return iE(t, n, o).map(a(fE, e, t, n, i, o)).filter(a(dE, r)) }); return c.filter(oE) }; const gE = function (e, t) { return e ? t.fold(o(p.some, KT.start), p.none, o(p.some, KT.after), p.none) : t.fold(p.none, o(p.some, KT.before), p.none, o(p.some, KT.end)) }; const hE = function (e, t, n, r) { const o = GT.normalizePosition(e, r); const i = iE(t, n, o); return iE(t, n, o).bind(a(gE, e)).orThunk(function () { return mE(e, t, n, i, r) }) }; const pE = { readLocation: iE, findLocation: hE, prevLocation: a(hE, !1), nextLocation: a(hE, !0), getElement: uE, outside: cE, inside: sE }; const vE = function (e) { return k(e.selection.getSel().modify) }; const bE = function (e, t, n) { const r = e ? 1 : -1; return t.setRng(yl(n.container(), n.offset() + r).toRange()), t.getSel().modify('move', e ? 'forward' : 'backward', 'word'), !0 }; const yE = function (e, t) { const n = t.selection.getRng(); const r = e ? yl.fromRangeEnd(n) : yl.fromRangeStart(n); return !!vE(t) && (e && cs(r) ? bE(!0, t.selection, r) : !(e || !ss(r)) && bE(!1, t.selection, r)) }; const wE = { hasSelectionModifyApi: vE, moveByWord: yE }; const xE = function (e, t) { const n = e.dom.createRng(); n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n) }; const CE = function (e) { return !1 !== e.settings.inline_boundaries }; const SE = function (e, t) { e ? t.setAttribute('data-mce-selected', 'inline-boundary') : t.removeAttribute('data-mce-selected') }; const kE = function (e, t, n) { return PT.renderCaret(t, n).map(function (t) { return xE(e, t), n }) }; const TE = function (e, t, n) { const r = e.getBody(); const o = yl.fromRangeStart(e.selection.getRng()); const i = a(GT.isInlineTarget, e); const u = pE.findLocation(n, i, r, o); return u.bind(function (n) { return kE(e, t, n) }) }; const EE = function (e, t, n) { const r = I(t.select('*[data-mce-selected="inline-boundary"]'), e); const o = I(n, e); M($(r, o), a(SE, !1)), M($(o, r), a(SE, !0)) }; const OE = function (e, t) { if (e.selection.isCollapsed() && !0 !== e.composing && t.get()) { const n = yl.fromRangeStart(e.selection.getRng()); yl.isTextPosition(n) && !1 === GT.isAtZwsp(n) && (xE(e, yf.removeAndReposition(t.get(), n)), t.set(null)) } }; const NE = function (e, t, n, r) { if (t.selection.isCollapsed()) { const o = I(r, e); M(o, function (r) { const o = yl.fromRangeStart(t.selection.getRng()); pE.readLocation(e, t.getBody(), o).bind(function (e) { return kE(t, n, e) }) }) } }; const _E = function (e, t, n) { return function () { return !!CE(e) && TE(e, t, n).isSome() } }; const DE = function (e, t, n) { return function () { return !!CE(t) && wE.moveByWord(e, t) } }; const AE = function (e) { const t = be(null); const n = a(GT.isInlineTarget, e); return e.on('NodeChange', function (r) { !CE(e) || $r.browser.isIE() && r.initial || (EE(n, e.dom, r.parents), OE(e, t), NE(n, e, t, r.parents)) }), t }; const RE = a(DE, !0); const BE = a(DE, !1); const ME = { move: _E, moveNextWord: RE, movePrevWord: BE, setupSelectedState: AE, setCaretPosition: xE }; const PE = function (e) { const t = function (t) { return B(t, function (t) { return t = Bs(t), t.node = e, t }) }; if (qn.isElement(e)) { return t(e.getClientRects()) } if (qn.isText(e)) { const n = e.ownerDocument.createRange(); return n.setStart(e, 0), n.setEnd(e, e.data.length), t(n.getClientRects()) } }; const zE = function (e) { return H(e, function (e, t) { return e.concat(PE(t)) }, []) }; (function (e) { e[e.Up = -1] = 'Up', e[e.Down = 1] = 'Down' })(tk || (tk = {})); let IE; const LE = function (e, t, n, r) { while (r = Sd(r, e, As, t)) { if (n(r)) { return } } }; const HE = function (e, t, n, r, o, i) { let u; let a; let c = 0; const s = []; const l = function (r) { let i, u, l; for (l = zE([r]), e === -1 && (l = l.reverse()), i = 0; i < l.length; i++) { if (u = l[i], !n(u, a)) { if (s.length > 0 && t(u, ro.last(s)) && c++, u.line = c, o(u)) { return !0 } s.push(u) } } }; return a = ro.last(i.getClientRects()), a ? (u = i.getNode(), l(u), LE(e, r, l, u), s) : s }; const FE = function (e, t) { return t.line > e }; const VE = function (e, t) { return t.line === e }; const UE = a(HE, tk.Up, Is, Ls); const jE = a(HE, tk.Down, Ls, Is); const WE = function (e, t, n, r) { let o; let i; let u; let a; let c; let s; const l = Jd(t); const f = []; let d = 0; const m = function (e) { return ro.last(e.getClientRects()) }; e === 1 ? (o = l.next, i = Ls, u = Is, a = yl.after(r)) : (o = l.prev, i = Is, u = Ls, a = yl.before(r)), s = m(a); do { if (a.isVisible() && (c = m(a), !u(c, s))) { if (f.length > 0 && i(c, ro.last(f)) && d++, c = Bs(c), c.position = a, c.line = d, n(c)) { return f } f.push(c) } } while (a = o(a)); return f }; const qE = function (e) { return function (t) { return FE(e, t) } }; const $E = function (e) { return function (t) { return VE(e, t) } }; const GE = qn.isContentEditableFalse; const XE = Sd; const YE = function (e, t) { return Math.abs(e.left - t) }; const KE = function (e, t) { return Math.abs(e.right - t) }; const JE = function (e, t) { return e >= t.left && e <= t.right }; const ZE = function (e, t) { return ro.reduce(e, function (e, n) { let r, o; return r = Math.min(YE(e, t), KE(e, t)), o = Math.min(YE(n, t), KE(n, t)), JE(t, n) ? n : JE(t, e) ? e : o === r && GE(n.node) ? n : o < r ? n : e }) }; const QE = function (e, t, n, r) { while (r = XE(r, e, As, t)) { if (n(r)) { return } } }; const eO = function (e, t) { let n = []; const r = function (e, r) { let o; return o = I(zE([r]), function (n) { return !e(n, t) }), n = n.concat(o), o.length === 0 }; return n.push(t), QE(tk.Up, e, a(r, Is), t.node), QE(tk.Down, e, a(r, Ls), t.node), n }; const tO = function (e) { return I(J(e.getElementsByTagName('*')), md) }; const nO = function (e, t) { return { node: e.node, before: YE(e, t) < KE(e, t) } }; const rO = function (e, t, n) { let r; const o = zE(tO(e)); const i = I(o, function (e) { return n >= e.top && n <= e.bottom }); return r = ZE(i, t), r && (r = ZE(eO(e, r), t), r && md(r.node)) ? nO(r, t) : null }; const oO = qn.isContentEditableTrue; const iO = qn.isContentEditableFalse; const uO = function (e, t, n, r, o) { return t._selectionOverrides.showCaret(e, n, r, o) }; const aO = function (e) { const t = e.ownerDocument.createRange(); return t.selectNode(e), t }; const cO = function (e, t) { const n = e.fire('BeforeObjectSelected', { target: t }); return n.isDefaultPrevented() ? null : aO(t) }; const sO = function (e, t, n) { const r = Rd(1, e.getBody(), t); const o = yl.fromRangeStart(r); const i = o.getNode(); if (iO(i)) { return uO(1, e, i, !o.isAtEnd(), !1) } const u = o.getNode(!0); if (iO(u)) { return uO(1, e, u, !1, !1) } const a = e.dom.getParent(o.getNode(), function (e) { return iO(e) || oO(e) }); return iO(a) ? uO(1, e, a, !1, n) : null }; const lO = function (e, t, n) { if (!t || !t.collapsed) { return t } const r = sO(e, t, n); return r || t }; const fO = function (e, t, n) { return p.from(n.container()).filter(qn.isText).exists(function (r) { const o = e ? 0 : -1; return t(r.data.charAt(n.offset() + o)) }) }; const dO = a(fO, !0, Im); const mO = a(fO, !1, Im); const gO = function (e) { const t = e.container(); return qn.isText(t) && t.data.length === 0 }; const hO = function (e, t) { return function (n) { return p.from(Ed(e ? 0 : -1, n)).filter(t).isSome() } }; const pO = function (e) { return e.nodeName === 'IMG' && er(ve.fromDom(e), 'display') === 'block' }; const vO = function (e) { return qn.isContentEditableFalse(e) && !qn.isBogusAll(e) }; const bO = hO(!0, pO); const yO = hO(!1, pO); const wO = hO(!0, qn.isTable); const xO = hO(!1, qn.isTable); const CO = hO(!0, vO); const SO = hO(!1, vO); (function (e) { e[e.Br = 0] = 'Br', e[e.Block = 1] = 'Block', e[e.Wrap = 2] = 'Wrap', e[e.Eol = 3] = 'Eol' })(IE || (IE = {})); let kO; let TO; const EO = function (e, t) { return e === bl.Backwards ? q(t) : t }; const OO = function (e, t, n) { return e === bl.Forwards ? t.next(n) : t.prev(n) }; const NO = function (e, t, n, r) { return qn.isBr(r.getNode(t === bl.Forwards)) ? IE.Br : !1 === Td(n, r) ? IE.Block : IE.Wrap }; const _O = function (e, t, n, r) { let o; const i = Jd(n); let u = r; const a = []; while (u) { if (o = OO(t, i, u), !o) { break } if (qn.isBr(o.getNode(!1))) { return t === bl.Forwards ? { positions: EO(t, a).concat([o]), breakType: IE.Br, breakAt: p.some(o) } : { positions: EO(t, a), breakType: IE.Br, breakAt: p.some(o) } } if (o.isVisible()) { if (e(u, o)) { const c = NO(n, t, u, o); return { positions: EO(t, a), breakType: c, breakAt: p.some(o) } }a.push(o), u = o } else { u = o } } return { positions: EO(t, a), breakType: IE.Eol, breakAt: p.none() } }; const DO = function (e, t, n, r) { return t(n, r).breakAt.map(function (r) { const o = t(n, r).positions; return e === bl.Backwards ? o.concat(r) : [r].concat(o) }).getOr([]) }; const AO = function (e, t) { return H(e, function (e, n) { return e.fold(function () { return p.some(n) }, function (r) { return Ws(Y(r.getClientRects()), Y(n.getClientRects()), function (e, o) { const i = Math.abs(t - e.left); const u = Math.abs(t - o.left); return u <= i ? n : r }).or(e) }) }, p.none()) }; const RO = function (e, t) { return Y(t.getClientRects()).bind(function (t) { return AO(e, t.left) }) }; const BO = a(_O, vl.isAbove, -1); const MO = a(_O, vl.isBelow, 1); const PO = function (e, t) { return BO(e, t).breakAt.isNone() }; const zO = function (e, t) { return MO(e, t).breakAt.isNone() }; const IO = a(DO, -1, BO); const LO = a(DO, 1, MO); const HO = function (e) { return fm.firstPositionIn(e).map(function (t) { return [t].concat(MO(e, t).positions) }).getOr([]) }; const FO = function (e) { return fm.lastPositionIn(e).map(function (t) { return BO(e, t).positions.concat(t) }).getOr([]) }; const VO = qn.isContentEditableFalse; const UO = Fs; const jO = function (e, t, n, r) { const o = e === bl.Forwards; const i = o ? CO : SO; if (!r.collapsed) { const u = UO(r); if (VO(u)) { return uO(e, t, u, e === bl.Backwards, !0) } } const a = ps(r); const c = Md(e, t.getBody(), r); if (i(c)) { return cO(t, c.getNode(!o)) } const s = GT.normalizePosition(o, n(c)); if (!s) { return a ? r : null } if (i(s)) { return uO(e, t, s.getNode(!o), o, !0) } const l = n(s); return l && i(l) && Ld(s, l) ? uO(e, t, l.getNode(!o), o, !0) : a ? lO(t, s.toRange(), !0) : null }; const WO = function (e, t, n, r) { let o, i, u, a, c, s, l, f, d; if (d = UO(r), o = Md(e, t.getBody(), r), i = n(t.getBody(), qE(1), o), u = I(i, $E(1)), c = ro.last(o.getClientRects()), (CO(o) || wO(o)) && (d = o.getNode()), (SO(o) || xO(o)) && (d = o.getNode(!0)), !c) { return null } if (s = c.left, a = ZE(u, s), a && VO(a.node)) { return l = Math.abs(s - a.left), f = Math.abs(s - a.right), uO(e, t, a.node, l < f, !0) } if (d) { const m = WE(e, t.getBody(), qE(1), d); if (a = ZE(I(m, $E(1)), s), a) { return lO(t, a.position.toRange(), !0) } if (a = ro.last(I(m, $E(0))), a) { return lO(t, a.position.toRange(), !0) } } }; const qO = function (e) { const t = e.dom.create(id.getForcedRootBlock(e)); return (!$r.ie || $r.ie >= 11) && (t.innerHTML = '<br data-mce-bogus="1">'), t }; const $O = function (e, t, n) { let r; let o; let i; const u = Jd(e.getBody()); const c = a(Id, u.next); const s = a(Id, u.prev); if (n.collapsed && e.settings.forced_root_block) { if (r = e.dom.getParent(n.startContainer, 'PRE'), !r) { return } o = t === 1 ? c(yl.fromRangeStart(n)) : s(yl.fromRangeStart(n)), o || (i = qO(e), t === 1 ? e.$(r).after(i) : e.$(r).before(i), e.selection.select(i, !0), e.selection.collapse()) } }; const GO = function (e, t) { let n; const r = Jd(e.getBody()); const o = a(Id, r.next); const i = a(Id, r.prev); const u = t ? bl.Forwards : bl.Backwards; const c = t ? o : i; const s = e.selection.getRng(); return n = jO(u, e, c, s), n || (n = $O(e, u, s), n || null) }; const XO = function (e, t) { let n; const r = t ? 1 : -1; const o = t ? jE : UE; const i = e.selection.getRng(); return n = WO(r, e, o, i), n || (n = $O(e, r, i), n || null) }; const YO = function (e, t) { return function () { const n = GO(e, t); return !!n && (e.selection.setRng(n), !0) } }; const KO = function (e, t) { return function () { const n = XO(e, t); return !!n && (e.selection.setRng(n), !0) } }; const JO = function (e) { return function (t) { return e ? SO(t) : CO(t) } }; const ZO = function (e, t) { return function () { const n = t ? yl.fromRangeEnd(e.selection.getRng()) : yl.fromRangeStart(e.selection.getRng()); const r = t ? MO(e.getBody(), n) : BO(e.getBody(), n); const o = t ? K(r.positions) : Y(r.positions); return o.filter(JO(t)).fold(i(!1), function (t) { return e.selection.setRng(t.toRange()), !0 }) } }; const QO = function (e, t) { return { left: e.left - t, top: e.top - t, right: e.right + 2 * t, bottom: e.bottom + 2 * t, width: e.width + t, height: e.height + t } }; const eN = function (e, t) { return j(t, function (t) { const n = QO(Bs(t.getBoundingClientRect()), -1); return [{ x: n.left, y: e(n), cell: t }, { x: n.right, y: e(n), cell: t }] }) }; const tN = function (e, t, n) { return H(e, function (e, r) { return e.fold(function () { return p.some(r) }, function (e) { const o = Math.sqrt(Math.abs(e.x - t) + Math.abs(e.y - n)); const i = Math.sqrt(Math.abs(r.x - t) + Math.abs(r.y - n)); return p.some(i < o ? r : e) }) }, p.none()) }; const nN = function (e, t, n, r, o) { const i = Tc(ve.fromDom(n), 'td,th,caption').map(function (e) { return e.dom() }); const u = I(eN(e, i), function (e) { return t(e, o) }); return tN(u, r, o).map(function (e) { return e.cell }) }; const rN = function (e) { return e.bottom }; const oN = function (e) { return e.top }; const iN = function (e, t) { return e.y < t }; const uN = function (e, t) { return e.y > t }; const aN = a(nN, rN, iN); const cN = a(nN, oN, uN); const sN = function (e, t) { return Y(t.getClientRects()).bind(function (t) { return aN(e, t.left, t.top) }).bind(function (e) { return RO(FO(e), t) }) }; const lN = function (e, t) { return K(t.getClientRects()).bind(function (t) { return cN(e, t.left, t.top) }).bind(function (e) { return RO(HO(e), t) }) }; const fN = function (e, t) { e.selection.setRng(t), $b.scrollRangeIntoView(e, t) }; const dN = function (e, t, n) { return n.breakAt.map(function (n) { return e(t, n).breakAt.isSome() }).getOr(!1) }; const mN = function (e) { return e.breakType === IE.Wrap && e.positions.length === 0 }; const gN = function (e) { return e.breakType === IE.Br && e.positions.length === 1 }; const hN = function (e, t, n) { const r = e(t, n); return mN(r) || !qn.isBr(n.getNode()) && gN(r) ? !dN(e, t, r) : r.breakAt.isNone() }; const pN = a(hN, BO); const vN = a(hN, MO); const bN = function (e, t, n) { const r = yl.fromRangeStart(t); return fm.positionIn(!e, n).map(function (e) { return e.isEqual(r) }).getOr(!1) }; const yN = function (e, t, n, r) { const o = e.selection.getRng(); const i = t ? 1 : -1; if (dd() && bN(t, o, n)) { const u = uO(i, e, n, !t, !0); return fN(e, u), !0 } return !1 }; const wN = function (e, t, n) { return sN(t, n).orThunk(function () { return Y(n.getClientRects()).bind(function (n) { return AO(IO(e, yl.before(t)), n.left) }) }).getOr(yl.before(t)) }; const xN = function (e, t, n) { return lN(t, n).orThunk(function () { return Y(n.getClientRects()).bind(function (n) { return AO(LO(e, yl.after(t)), n.left) }) }).getOr(yl.after(t)) }; const CN = function (e, t) { const n = t.getNode(e); return qn.isElement(n) && n.nodeName === 'TABLE' ? p.some(n) : p.none() }; const SN = function (e, t, n, r) { const o = id.getForcedRootBlock(t); o ? t.undoManager.transact(function () { const r = ve.fromTag(o); Yn(r, id.getForcedRootBlockAttrs(t)), Zt(r, ve.fromTag('br')), e ? Kt(ve.fromDom(n), r) : Yt(ve.fromDom(n), r); const i = t.dom.createRng(); i.setStart(r.dom(), 0), i.setEnd(r.dom(), 0), fN(t, i) }) : fN(t, r.toRange()) }; const kN = function (e, t, n) { const r = CN(!!t, n); const o = !1 === t; r.fold(function () { return fN(e, n.toRange()) }, function (r) { return fm.positionIn(o, e.getBody()).filter(function (e) { return e.isEqual(n) }).fold(function () { return fN(e, n.toRange()) }, function (o) { return SN(t, e, r, n) }) }) }; const TN = function (e, t, n, r) { const o = e.selection.getRng(); const i = yl.fromRangeStart(o); const u = e.getBody(); if (!t && pN(r, i)) { var a = wN(u, n, i); return kN(e, t, a), !0 } if (t && vN(r, i)) { a = xN(u, n, i); return kN(e, t, a), !0 } return !1 }; const EN = function (e, t) { return function () { return p.from(e.dom.getParent(e.selection.getNode(), 'td,th')).bind(function (n) { return p.from(e.dom.getParent(n, 'table')).map(function (n) { return yN(e, t, n) }) }).getOr(!1) } }; const ON = function (e, t) { return function () { return p.from(e.dom.getParent(e.selection.getNode(), 'td,th')).bind(function (n) { return p.from(e.dom.getParent(n, 'table')).map(function (r) { return TN(e, t, r, n) }) }).getOr(!1) } }; const NN = function (e) { return A(['figcaption'], un(e)) }; const _N = function (e) { const t = n.document.createRange(); return t.setStartBefore(e.dom()), t.setEndBefore(e.dom()), t }; const DN = function (e, t, n) { n ? Zt(e, t) : Jt(e, t) }; const AN = function (e, t) { const n = ve.fromTag('br'); return DN(e, n, t), _N(n) }; const RN = function (e, t, n, r) { const o = ve.fromTag(n); const i = ve.fromTag('br'); return Yn(o, r), Zt(o, i), DN(e, o, t), _N(i) }; const BN = function (e, t, n, r) { return t === '' ? AN(e, r) : RN(e, r, t, n) }; const MN = function (e, t) { const n = a(Dt, t); return Nc(ve.fromDom(e.container()), Bo, n).filter(NN) }; const PN = function (e, t, n) { return t ? zO(e.dom(), n) : PO(e.dom(), n) }; const zN = function (e, t) { const n = ve.fromDom(e.getBody()); const r = yl.fromRangeStart(e.selection.getRng()); const o = id.getForcedRootBlock(e); const i = id.getForcedRootBlockAttrs(e); return MN(r, n).exists(function () { if (PN(n, t, r)) { const u = BN(n, o, i, t); return e.selection.setRng(u), !0 } return !1 }) }; const IN = function (e, t) { return function () { return !!e.selection.isCollapsed() && zN(e, t) } }; const LN = function (e) { return B(e, function (e) { return se({ shiftKey: !1, altKey: !1, ctrlKey: !1, metaKey: !1, keyCode: 0, action: r }, e) }) }; const HN = function (e, t) { return t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey }; const FN = function (e, t) { return j(LN(e), function (e) { return HN(e, t) ? [e] : [] }) }; const VN = function (e) { for (let t = [], n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } const r = Array.prototype.slice.call(arguments, 1); return function () { return e.apply(null, r) } }; const UN = function (e, t) { return F(FN(e, t), function (e) { return e.action() }) }; const jN = { match: FN, action: VN, execute: UN }; const WN = function (e, t, n) { const r = mt().os; jN.execute([{ keyCode: lb.RIGHT, action: YO(e, !0) }, { keyCode: lb.LEFT, action: YO(e, !1) }, { keyCode: lb.UP, action: KO(e, !1) }, { keyCode: lb.DOWN, action: KO(e, !0) }, { keyCode: lb.RIGHT, action: EN(e, !0) }, { keyCode: lb.LEFT, action: EN(e, !1) }, { keyCode: lb.UP, action: ON(e, !1) }, { keyCode: lb.DOWN, action: ON(e, !0) }, { keyCode: lb.RIGHT, action: ME.move(e, t, !0) }, { keyCode: lb.LEFT, action: ME.move(e, t, !1) }, { keyCode: lb.RIGHT, ctrlKey: !r.isOSX(), altKey: r.isOSX(), action: ME.moveNextWord(e, t) }, { keyCode: lb.LEFT, ctrlKey: !r.isOSX(), altKey: r.isOSX(), action: ME.movePrevWord(e, t) }, { keyCode: lb.UP, action: IN(e, !1) }, { keyCode: lb.DOWN, action: IN(e, !0) }], n).each(function (e) { n.preventDefault() }) }; const qN = function (e, t) { e.on('keydown', function (n) { !1 === n.isDefaultPrevented() && WN(e, t, n) }) }; const $N = { setup: qN }; const GN = function (e) { return function (t) { return Dt(e, ve.fromDom(t.dom().parentNode)) } }; const XN = function (e, t) { return Mt(e, t) ? Nc(t, function (e) { return Io(e) || Ho(e) }, GN(e)) : p.none() }; const YN = function (e) { const t = e.getBody(); const n = t.firstChild && e.dom.isBlock(t.firstChild) ? t.firstChild : t; e.selection.setCursorLocation(n, 0) }; const KN = function (e) { e.dom.isEmpty(e.getBody()) && (e.setContent(''), YN(e)) }; const JN = function (e, t, n) { return Ws(fm.firstPositionIn(n), fm.lastPositionIn(n), function (r, o) { const i = GT.normalizePosition(!0, r); const u = GT.normalizePosition(!1, o); const a = GT.normalizePosition(!1, t); return e ? fm.nextPosition(n, a).map(function (e) { return e.isEqual(u) && t.isEqual(i) }).getOr(!1) : fm.prevPosition(n, a).map(function (e) { return e.isEqual(i) && t.isEqual(u) }).getOr(!1) }).getOr(!0) }; const ZN = { getParentBlock: XN, paddEmptyBody: KN, willDeleteLastPositionInElement: JN }; const QN = function (e, t) { return { block: i(e), position: i(t) } }; const e_ = function (e, t) { return { from: i(e), to: i(t) } }; const t_ = function (e, t) { const n = ve.fromDom(e); const r = ve.fromDom(t.container()); return ZN.getParentBlock(n, r).map(function (e) { return QN(e, t) }) }; const n_ = function (e) { return !1 === Dt(e.from().block(), e.to().block()) }; const r_ = function (e) { return Lt(e.from().block()).bind(function (t) { return Lt(e.to().block()).filter(function (e) { return Dt(t, e) }) }).isSome() }; const o_ = function (e) { return !1 === qn.isContentEditableFalse(e.from().block().dom()) && !1 === qn.isContentEditableFalse(e.to().block().dom()) }; const i_ = function (e, t, n) { return qn.isBr(n.position().getNode()) && !1 === mC.isEmpty(n.block()) ? fm.positionIn(!1, n.block().dom()).bind(function (r) { return r.isEqual(n.position()) ? fm.fromPosition(t, e, r).bind(function (t) { return t_(e, t) }) : p.some(n) }).getOr(n) : n }; const u_ = function (e, t, n) { const r = t_(e, yl.fromRangeStart(n)); const o = r.bind(function (n) { return fm.fromPosition(t, e, n.position()).bind(function (n) { return t_(e, n).map(function (n) { return i_(e, t, n) }) }) }); return Ws(r, o, e_).filter(function (e) { return n_(e) && r_(e) && o_(e) }) }; const a_ = function (e, t, n) { return n.collapsed ? u_(e, t, n) : p.none() }; const c_ = { read: a_ }; const s_ = function (e) { const t = Wt(e); return V(t, Bo).fold(function () { return t }, function (e) { return t.slice(0, e) }) }; const l_ = function (e) { const t = s_(e); return M(t, rn), t }; const f_ = function (e, t) { const n = uy.parentsAndSelf(t, e); return F(n.reverse(), function (e) { return mC.isEmpty(e) }).each(rn) }; const d_ = function (e) { return I(Ut(e), function (e) { return !mC.isEmpty(e) }).length === 0 }; const m_ = function (e, t, n, r) { if (mC.isEmpty(n)) { return Fx.fillWithPaddingBr(n), fm.firstPositionIn(n.dom()) } d_(r) && mC.isEmpty(t) && Yt(r, ve.fromTag('br')); const o = fm.prevPosition(n.dom(), yl.before(r.dom())); return M(l_(t), function (e) { Yt(r, e) }), f_(e, t), o }; const g_ = function (e, t, n) { if (mC.isEmpty(n)) { return rn(n), mC.isEmpty(t) && Fx.fillWithPaddingBr(t), fm.firstPositionIn(t.dom()) } const r = fm.lastPositionIn(n.dom()); return M(l_(t), function (e) { Zt(n, e) }), f_(e, t), r }; const h_ = function (e, t) { const n = uy.parentsAndSelf(t, e); return p.from(n[n.length - 1]) }; const p_ = function (e, t) { return Mt(t, e) ? h_(t, e) : p.none() }; const v_ = function (e, t) { fm.positionIn(e, t.dom()).map(function (e) { return e.getNode() }).map(ve.fromDom).filter(zo).each(rn) }; const b_ = function (e, t, n) { return v_(!0, t), v_(!1, n), p_(t, n).fold(a(g_, e, t, n), a(m_, e, t, n)) }; const y_ = function (e, t, n, r) { return t ? b_(e, r, n) : b_(e, n, r) }; const w_ = { mergeBlocks: y_ }; const x_ = function (e, t) { const n = ve.fromDom(e.getBody()); const r = c_.read(n.dom(), t, e.selection.getRng()).bind(function (e) { return w_.mergeBlocks(n, t, e.from().block(), e.to().block()) }); return r.each(function (t) { e.selection.setRng(t.toRange()) }), r.isSome() }; const C_ = { backspaceDelete: x_ }; const S_ = function (e, t) { const n = t.getRng(); return Ws(ZN.getParentBlock(e, ve.fromDom(n.startContainer)), ZN.getParentBlock(e, ve.fromDom(n.endContainer)), function (r, o) { return !1 === Dt(r, o) && (n.deleteContents(), w_.mergeBlocks(e, !0, r, o).each(function (e) { t.setRng(e.toRange()) }), !0) }).getOr(!1) }; const k_ = function (e, t) { const n = ve.fromDom(t); const r = a(Dt, e); return Oc(n, Uo, r).isSome() }; const T_ = function (e, t) { return k_(e, t.startContainer) || k_(e, t.endContainer) }; const E_ = function (e, t) { const n = fm.prevPosition(e.dom(), yl.fromRangeStart(t)).isNone(); const r = fm.nextPosition(e.dom(), yl.fromRangeEnd(t)).isNone(); return !T_(e, t) && n && r }; const O_ = function (e) { return e.setContent(''), e.selection.setCursorLocation(), !0 }; const N_ = function (e) { const t = ve.fromDom(e.getBody()); const n = e.selection.getRng(); return E_(t, n) ? O_(e) : S_(t, e.selection) }; const __ = function (e, t) { return !e.selection.isCollapsed() && N_(e) }; const D_ = { backspaceDelete: __ }; const A_ = function (e) { return Pd(e).exists(zo) }; const R_ = function (e, t, n) { const r = I(uy.parentsAndSelf(ve.fromDom(n.container()), t), Bo); const o = Y(r).getOr(t); return fm.fromPosition(e, o.dom(), n).filter(A_) }; const B_ = function (e, t) { return Pd(t).exists(zo) || R_(!0, e, t).isSome() }; const M_ = function (e, t) { return zd(t).exists(zo) || R_(!1, e, t).isSome() }; const P_ = a(R_, !1); const z_ = a(R_, !0); const I_ = function (e) { return Uo(ve.fromDom(e)) || Ho(ve.fromDom(e)) }; const L_ = ah.generate([{ remove: ['element'] }, { moveToElement: ['element'] }, { moveToPosition: ['position'] }]); const H_ = function (e, t) { const n = t.getNode(!1 === e); const r = e ? 'after' : 'before'; return qn.isElement(n) && n.getAttribute('data-mce-caret') === r }; const F_ = function (e, t, n, r) { const o = function (t) { return Po(ve.fromDom(t)) && !Td(n, r, e) }; return Bd(!t, n).fold(function () { return Bd(t, r).fold(i(!1), o) }, o) }; const V_ = function (e, t, n, r) { const o = r.getNode(!1 === t); return ZN.getParentBlock(ve.fromDom(e), ve.fromDom(n.getNode())).map(function (e) { return mC.isEmpty(e) ? L_.remove(e.dom()) : L_.moveToElement(o) }).orThunk(function () { return p.some(L_.moveToElement(o)) }) }; const U_ = function (e, t, n) { return fm.fromPosition(t, e, n).bind(function (r) { return I_(r.getNode()) ? p.none() : F_(e, t, n, r) ? p.none() : t && qn.isContentEditableFalse(r.getNode()) ? V_(e, t, n, r) : !1 === t && qn.isContentEditableFalse(r.getNode(!0)) ? V_(e, t, n, r) : t && SO(n) ? p.some(L_.moveToPosition(r)) : !1 === t && CO(n) ? p.some(L_.moveToPosition(r)) : p.none() }) }; const j_ = function (e, t) { return e && qn.isContentEditableFalse(t.nextSibling) ? p.some(L_.moveToElement(t.nextSibling)) : !1 === e && qn.isContentEditableFalse(t.previousSibling) ? p.some(L_.moveToElement(t.previousSibling)) : p.none() }; const W_ = function (e, t, n) { return n.fold(function (e) { return p.some(L_.remove(e)) }, function (e) { return p.some(L_.moveToElement(e)) }, function (n) { return Td(t, n, e) ? p.none() : p.some(L_.moveToPosition(n)) }) }; const q_ = function (e, t, n) { return H_(t, n) ? j_(t, n.getNode(!1 === t)).fold(function () { return U_(e, t, n) }, p.some) : U_(e, t, n).bind(function (t) { return W_(e, n, t) }) }; const $_ = function (e, t, n) { const r = Rd(t ? 1 : -1, e, n); const o = yl.fromRangeStart(r); const i = ve.fromDom(e); return !1 === t && SO(o) ? p.some(L_.remove(o.getNode(!0))) : t && CO(o) ? p.some(L_.remove(o.getNode())) : !1 === t && CO(o) && M_(i, o) ? P_(i, o).map(function (e) { return L_.remove(e.getNode()) }) : t && SO(o) && B_(i, o) ? z_(i, o).map(function (e) { return L_.remove(e.getNode()) }) : q_(e, t, o) }; const G_ = function (e, t) { return function (n) { return e._selectionOverrides.hideFakeCaret(), BC.deleteElement(e, t, ve.fromDom(n)), !0 } }; const X_ = function (e, t) { return function (n) { const r = t ? yl.before(n) : yl.after(n); return e.selection.setRng(r.toRange()), !0 } }; const Y_ = function (e) { return function (t) { return e.selection.setRng(t.toRange()), !0 } }; const K_ = function (e, t) { return p.from(eD(e.getBody(), t)) }; const J_ = function (e, t) { const n = e.selection.getNode(); return K_(e, n).filter(qn.isContentEditableFalse).fold(function () { const n = $_(e.getBody(), t, e.selection.getRng()).map(function (n) { return n.fold(G_(e, t), X_(e, t), Y_(e)) }); return n.getOr(!1) }, function () { return !0 }) }; const Z_ = function (e) { M(Tc(e, '.mce-offscreen-selection'), rn) }; const Q_ = function (e, t) { const n = e.selection.getNode(); if (qn.isContentEditableFalse(n)) { const r = K_(e, n.parentNode).filter(qn.isContentEditableFalse); return r.fold(function () { return Z_(ve.fromDom(e.getBody())), BC.deleteElement(e, t, ve.fromDom(e.selection.getNode())), ZN.paddEmptyBody(e), !0 }, function () { return !0 }) } return !1 }; var eD = function (e, t) { while (t && t !== e) { if (qn.isContentEditableTrue(t) || qn.isContentEditableFalse(t)) { return t } t = t.parentNode } return null }; const tD = function (e) { let t; const n = eD(e.getBody(), e.selection.getNode()); return qn.isContentEditableTrue(n) && e.dom.isBlock(n) && e.dom.isEmpty(n) && (t = e.dom.create('br', { 'data-mce-bogus': '1' }), e.dom.setHTML(n, ''), n.appendChild(t), e.selection.setRng(yl.before(t).toRange())), !0 }; const nD = function (e, t) { return e.selection.isCollapsed() ? J_(e, t) : Q_(e, t) }; const rD = { backspaceDelete: nD, paddEmptyElement: tD }; const oD = function (e, t) { qn.isText(t) && t.data.length === 0 && e.remove(t) }; const iD = function (e, t, n, r, o, i) { const u = uO(r, e, i.getNode(!o), o, !0); if (t.collapsed) { const a = t.cloneRange(); o ? a.setEnd(u.startContainer, u.startOffset) : a.setStart(u.endContainer, u.endOffset), a.deleteContents() } else { t.deleteContents() } return e.selection.setRng(u), oD(e.dom, n), !0 }; const uD = function (e, t) { const n = e.selection.getRng(); if (!qn.isText(n.commonAncestorContainer)) { return !1 } const r = t ? bl.Forwards : bl.Backwards; const o = Jd(e.getBody()); const i = a(Id, o.next); const u = a(Id, o.prev); const c = t ? i : u; const s = t ? CO : SO; const l = Md(r, e.getBody(), n); const f = GT.normalizePosition(t, c(l)); if (!f || !Ld(l, f)) { return !1 } if (s(f)) { return iD(e, n, l.getNode(), r, t, f) } const d = c(f); return !!(d && s(d) && Ld(f, d)) && iD(e, n, l.getNode(), r, t, d) }; const aD = function (e, t) { return uD(e, t) }; const cD = { backspaceDelete: aD }; const sD = function (e) { return !1 !== e.settings.inline_boundaries }; const lD = function (e, t) { const r = n.document.createRange(); return r.setStart(e.container(), e.offset()), r.setEnd(t.container(), t.offset()), r }; const fD = function (e) { return Ws(fm.firstPositionIn(e), fm.lastPositionIn(e), function (t, n) { const r = GT.normalizePosition(!0, t); const o = GT.normalizePosition(!1, n); return fm.nextPosition(e, r).map(function (e) { return e.isEqual(o) }).getOr(!0) }).getOr(!0) }; const dD = function (e, t) { return function (n) { return PT.renderCaret(t, n).map(function (t) { return ME.setCaretPosition(e, t), !0 }).getOr(!1) } }; const mD = function (e, t, n, r) { const o = e.getBody(); const i = a(GT.isInlineTarget, e); e.undoManager.ignore(function () { e.selection.setRng(lD(n, r)), e.execCommand('Delete'), pE.readLocation(i, o, yl.fromRangeStart(e.selection.getRng())).map(pE.inside).map(dD(e, t)) }), e.nodeChanged() }; const gD = function (e, t) { const n = kd(t, e); return n || e }; const hD = function (e, t, n, r) { const o = gD(e.getBody(), r.container()); const u = a(GT.isInlineTarget, e); const c = pE.readLocation(u, o, r); return c.bind(function (e) { return n ? e.fold(i(p.some(pE.inside(e))), p.none, i(p.some(pE.outside(e))), p.none) : e.fold(p.none, i(p.some(pE.outside(e))), p.none, i(p.some(pE.inside(e)))) }).map(dD(e, t)).getOrThunk(function () { const i = fm.navigate(n, o, r); const a = i.bind(function (e) { return pE.readLocation(u, o, e) }); return c.isSome() && a.isSome() ? GT.findRootInline(u, o, r).map(function (t) { return !!fD(t) && (BC.deleteElement(e, n, ve.fromDom(t)), !0) }).getOr(!1) : a.bind(function (o) { return i.map(function (o) { return n ? mD(e, t, r, o) : mD(e, t, o, r), !0 }) }).getOr(!1) }) }; const pD = function (e, t, n) { if (e.selection.isCollapsed() && sD(e)) { const r = yl.fromRangeStart(e.selection.getRng()); return hD(e, t, n, r) } return !1 }; const vD = { backspaceDelete: pD }; const bD = function (e, t) { const n = uy.parentsAndSelf(t, e); return V(n, Bo).fold(i(n), function (e) { return n.slice(0, e) }) }; const yD = function (e) { return Wt(e).length === 1 }; const wD = function (e, t, n, r) { const o = a(ZC, t); const i = B(I(r, o), function (e) { return e.dom() }); if (i.length === 0) { BC.deleteElement(t, e, n) } else { const u = JC(n.dom(), i); t.selection.setRng(u.toRange()) } }; const xD = function (e, t) { const n = ve.fromDom(e.getBody()); const r = ve.fromDom(e.selection.getStart()); const o = I(bD(n, r), yD); return K(o).map(function (n) { const r = yl.fromRangeStart(e.selection.getRng()); return !(!ZN.willDeleteLastPositionInElement(t, r, n.dom()) || QC(n)) && (wD(t, e, n, o), !0) }).getOr(!1) }; const CD = function (e, t) { return !!e.selection.isCollapsed() && xD(e, t) }; const SD = { backspaceDelete: CD }; const kD = function (e, t) { return { start: i(e), end: i(t) } }; const TD = function (e, t, n) { return { rng: i(e), table: i(t), cells: i(n) } }; const ED = ah.generate([{ removeTable: ['element'] }, { emptyCells: ['cells'] }]); const OD = function (e) { return function (t) { return Dt(e, t) } }; const ND = function (e, t) { return Ac(ve.fromDom(e), 'td,th', t) }; const _D = function (e, t) { return _c(e, 'table', t) }; const DD = function (e) { return !1 === Dt(e.start(), e.end()) }; const AD = function (e, t) { return _D(e.start(), t).bind(function (n) { return _D(e.end(), t).bind(function (e) { return $s(Dt(n, e), n) }) }) }; const RD = function (e) { return Tc(e, 'td,th') }; const BD = function (e, t) { return _D(e.start(), t).bind(function (t) { return K(RD(t)).map(function (t) { return kD(e.start(), t) }) }) }; const MD = function (e, t) { const n = ND(t.startContainer, e); const r = ND(t.endContainer, e); return t.collapsed ? p.none() : Ws(n, r, kD).fold(function () { return n.fold(function () { return r.bind(function (t) { return _D(t, e).bind(function (e) { return Y(RD(e)).map(function (e) { return kD(e, t) }) }) }) }, function (t) { return _D(t, e).bind(function (e) { return K(RD(e)).map(function (e) { return kD(t, e) }) }) }) }, function (t) { return PD(e, t) ? p.none() : BD(t, e) }) }; var PD = function (e, t) { return AD(t, e).isSome() }; const zD = function (e, t) { const n = ND(e.startContainer, t); const r = ND(e.endContainer, t); return Ws(n, r, kD).filter(DD).filter(function (e) { return PD(t, e) }).orThunk(function () { return MD(t, e) }) }; const ID = function (e, t) { return AD(e, t).map(function (t) { return TD(e, t, RD(t)) }) }; const LD = function (e, t) { const n = OD(e); return zD(t, n).bind(function (e) { return ID(e, n) }) }; const HD = function (e, t) { return V(e, function (e) { return Dt(e, t) }) }; const FD = function (e) { return Ws(HD(e.cells(), e.rng().start()), HD(e.cells(), e.rng().end()), function (t, n) { return e.cells().slice(t, n + 1) }) }; const VD = function (e) { return FD(e).map(function (t) { const n = e.cells(); return t.length === n.length ? ED.removeTable(e.table()) : ED.emptyCells(t) }) }; const UD = function (e, t) { return LD(e, t).bind(VD) }; const jD = function (e, t) { return M(t, Fx.fillWithPaddingBr), e.selection.setCursorLocation(t[0].dom(), 0), !0 }; const WD = function (e, t) { return BC.deleteElement(e, !1, t), !0 }; const qD = function (e, t, n) { return UD(t, n).map(function (t) { return t.fold(a(WD, e), a(jD, e)) }) }; const $D = function (e, t) { return ZD(e, t) }; const GD = function (e, t, n, r) { return KD(t, r).fold(function () { return qD(e, t, n) }, function (t) { return $D(e, t) }).getOr(!1) }; const XD = function (e, t) { const n = ve.fromDom(e.getBody()); const r = e.selection.getRng(); const o = Hy.getCellsFromEditor(e); return o.length !== 0 ? jD(e, o) : GD(e, n, r, t) }; const YD = function (e, t) { return F(uy.parentsAndSelf(t, e), Uo) }; var KD = function (e, t) { return F(uy.parentsAndSelf(t, e), function (e) { return un(e) === 'caption' }) }; const JD = function (e, t, n, r, o) { return fm.navigate(n, e.getBody(), o).bind(function (e) { return YD(t, ve.fromDom(e.getNode())).map(function (e) { return !1 === Dt(e, r) }) }) }; var ZD = function (e, t) { return Fx.fillWithPaddingBr(t), e.selection.setCursorLocation(t.dom(), 0), p.some(!0) }; const QD = function (e, t, n, r) { return fm.firstPositionIn(e.dom()).bind(function (o) { return fm.lastPositionIn(e.dom()).map(function (e) { return t ? n.isEqual(o) && r.isEqual(e) : n.isEqual(e) && r.isEqual(o) }) }).getOr(!0) }; const eA = function (e, t) { return ZD(e, t) }; const tA = function (e, t, n) { return KD(e, ve.fromDom(n.getNode())).map(function (e) { return !1 === Dt(e, t) }) }; const nA = function (e, t, n, r, o) { return fm.navigate(n, e.getBody(), o).bind(function (i) { return QD(r, n, o, i) ? eA(e, r) : tA(t, r, i) }).or(p.some(!0)) }; const rA = function (e, t, n, r) { const o = yl.fromRangeStart(e.selection.getRng()); return YD(n, r).bind(function (r) { return mC.isEmpty(r) ? ZD(e, r) : JD(e, n, t, r, o) }).getOr(!1) }; const oA = function (e, t, n, r) { const o = yl.fromRangeStart(e.selection.getRng()); return mC.isEmpty(r) ? ZD(e, r) : nA(e, n, t, r, o) }; const iA = function (e, t) { return e ? wO(t) : xO(t) }; const uA = function (e, t) { const n = yl.fromRangeStart(e.selection.getRng()); return iA(t, n) || fm.fromPosition(t, e.getBody(), n).map(function (e) { return iA(t, e) }).getOr(!1) }; const aA = function (e, t, n) { const r = ve.fromDom(e.getBody()); return KD(r, n).fold(function () { return rA(e, t, r, n) || uA(e, t) }, function (n) { return oA(e, t, r, n).getOr(!1) }) }; const cA = function (e, t) { const n = ve.fromDom(e.selection.getStart(!0)); const r = Hy.getCellsFromEditor(e); return e.selection.isCollapsed() && r.length === 0 ? aA(e, t, n) : XD(e, n) }; const sA = { backspaceDelete: cA }; const lA = function (e, t) { const n = yl.fromRangeStart(e.selection.getRng()); return fm.fromPosition(t, e.getBody(), n).filter(function (e) { return t ? bO(e) : yO(e) }).bind(function (e) { return p.from(Ed(t ? 0 : -1, e)) }).map(function (t) { return e.selection.select(t), !0 }).getOr(!1) }; const fA = function (e, t) { return !!e.selection.isCollapsed() && lA(e, t) }; const dA = { backspaceDelete: fA }; const mA = function (e) { return Nc(e, function (e) { return qn.isContentEditableTrue(e.dom()) || qn.isContentEditableFalse(e.dom()) }).exists(function (e) { return qn.isContentEditableTrue(e.dom()) }) }; const gA = function (e) { const t = parseInt(e, 10); return isNaN(t) ? 0 : t }; const hA = function (e, t) { const n = e || Mo(t) ? 'margin' : 'padding'; const r = er(t, 'direction') === 'rtl' ? '-right' : '-left'; return n + r }; const pA = function (e, t, n, r, o, i) { const u = hA(n, ve.fromDom(i)); if (t === 'outdent') { var a = Math.max(0, gA(i.style[u]) - r); e.setStyle(i, u, a ? a + o : '') } else { a = gA(i.style[u]) + r + o; e.setStyle(i, u, a) } }; const vA = function (e, t) { return W(t, function (t) { const n = hA(id.shouldIndentUseMargin(e), t); const r = nr(t, n).map(gA).getOr(0); const o = e.dom.getContentEditable(t.dom()); return o !== 'false' && r > 0 }) }; const bA = function (e) { const t = xA(e); return !e.mode.isReadOnly() && (t.length > 1 || vA(e, t)) }; const yA = function (e) { return Lo(e) || Ho(e) }; const wA = function (e) { return Lt(e).map(yA).getOr(!1) }; var xA = function (e) { return I(B(e.selection.getSelectedBlocks(), ve.fromDom), function (e) { return !yA(e) && !wA(e) && mA(e) }) }; const CA = function (e, t) { const n = e.dom; const r = e.selection; const o = e.formatter; const i = id.getIndentation(e); const u = /[a-z%]+$/i.exec(i)[0]; const a = parseInt(i, 10); const c = id.shouldIndentUseMargin(e); const s = id.getForcedRootBlock(e); e.queryCommandState('InsertUnorderedList') || e.queryCommandState('InsertOrderedList') || s !== '' || n.getParent(r.getNode(), n.isBlock) || o.apply('div'), M(xA(e), function (e) { pA(n, t, c, a, u, e.dom()) }) }; const SA = function (e, t, n) { return fm.navigateIgnore(e, t, n, gO) }; const kA = function (e, t) { return F(uy.parentsAndSelf(ve.fromDom(t.container()), e), Bo) }; const TA = function (e, t, n) { return SA(e, t.dom(), n).forall(function (e) { return kA(t, n).fold(function () { return !1 === Td(e, n, t.dom()) }, function (r) { return !1 === Td(e, n, t.dom()) && Mt(r, ve.fromDom(e.container())) }) }) }; const EA = function (e, t, n) { return kA(t, n).fold(function () { return SA(e, t.dom(), n).forall(function (e) { return !1 === Td(e, n, t.dom()) }) }, function (t) { return SA(e, t.dom(), n).isNone() }) }; const OA = a(EA, !1); const NA = a(EA, !0); const _A = a(TA, !1); const DA = a(TA, !0); const AA = function (e, t, n) { if (e.selection.isCollapsed() && bA(e)) { const r = e.dom; const o = e.selection.getRng(); const i = yl.fromRangeStart(o); const u = r.getParent(o.startContainer, r.isBlock); if (u !== null && OA(ve.fromDom(u), i)) { return CA(e, 'outdent'), !0 } } return !1 }; const RA = { backspaceDelete: AA }; const BA = function (e, t, n) { jN.execute([{ keyCode: lb.BACKSPACE, action: jN.action(RA.backspaceDelete, e, !1) }, { keyCode: lb.BACKSPACE, action: jN.action(rD.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(rD.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(cD.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(cD.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(vD.backspaceDelete, e, t, !1) }, { keyCode: lb.DELETE, action: jN.action(vD.backspaceDelete, e, t, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(sA.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(sA.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(dA.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(dA.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(D_.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(D_.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(C_.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(C_.backspaceDelete, e, !0) }, { keyCode: lb.BACKSPACE, action: jN.action(SD.backspaceDelete, e, !1) }, { keyCode: lb.DELETE, action: jN.action(SD.backspaceDelete, e, !0) }], n).each(function (e) { n.preventDefault() }) }; const MA = function (e, t) { jN.execute([{ keyCode: lb.BACKSPACE, action: jN.action(rD.paddEmptyElement, e) }, { keyCode: lb.DELETE, action: jN.action(rD.paddEmptyElement, e) }], t) }; const PA = function (e, t) { e.on('keydown', function (n) { !1 === n.isDefaultPrevented() && BA(e, t, n) }), e.on('keyup', function (t) { !1 === t.isDefaultPrevented() && MA(e, t) }) }; const zA = { setup: PA }; const IA = function (e) { while (e) { if (e.nodeType === 1 || e.nodeType === 3 && e.data && /[\r\n\s]/.test(e.data)) { return e } e = e.nextSibling } }; const LA = function (e, t) { let n; let r; let o = t; const i = e.dom; const u = e.schema.getMoveCaretBeforeOnEnterElements(); if (t) { if (/^(LI|DT|DD)$/.test(t.nodeName)) { const a = IA(t.firstChild); a && /^(UL|OL|DL)$/.test(a.nodeName) && t.insertBefore(i.doc.createTextNode(Fi), t.firstChild) } if (r = i.createRng(), t.normalize(), t.hasChildNodes()) { const c = new Aa(t, t); while (n = c.current()) { if (qn.isText(n)) { r.setStart(n, 0), r.setEnd(n, 0); break } if (u[n.nodeName.toLowerCase()]) { r.setStartBefore(n), r.setEndBefore(n); break }o = n, n = c.next() }n || (r.setStart(o, 0), r.setEnd(o, 0)) } else { qn.isBr(t) ? t.nextSibling && i.isBlock(t.nextSibling) ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)) : (r.setStart(t, 0), r.setEnd(t, 0)) }e.selection.setRng(r), $b.scrollRangeIntoView(e, r) } }; const HA = function (e, t) { let n; let r; const o = e.getRoot(); n = t; while (n !== o && e.getContentEditable(n) !== 'false') { e.getContentEditable(n) === 'true' && (r = n), n = n.parentNode } return n !== o ? r : o }; const FA = function (e) { return p.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)) }; const VA = function (e) { return FA(e).fold(i(''), function (e) { return e.nodeName.toUpperCase() }) }; const UA = function (e) { return FA(e).filter(function (e) { return Ho(ve.fromDom(e)) }).isSome() }; const jA = { moveToCaretPosition: LA, getEditableRoot: HA, getParentBlock: FA, getParentBlockName: VA, isListItemParentBlock: UA }; const WA = function (e, t) { return e.firstChild && e.firstChild.nodeName === t }; const qA = function (e, t) { return e && e.parentNode && e.parentNode.nodeName === t }; const $A = function (e) { return e && /^(OL|UL|LI)$/.test(e.nodeName) }; const GA = function (e) { return $A(e) && $A(e.parentNode) }; const XA = function (e) { const t = e.parentNode; return /^(LI|DT|DD)$/.test(t.nodeName) ? t : e }; const YA = function (e, t, n) { let r = e[n ? 'firstChild' : 'lastChild']; while (r) { if (qn.isElement(r)) { break } r = r[n ? 'nextSibling' : 'previousSibling'] } return r === t }; const KA = function (e, t, n, r, o) { const i = e.dom; const u = e.selection.getRng(); if (n !== e.getBody()) { GA(n) && (o = 'LI'); let a = o ? t(o) : i.create('BR'); if (YA(n, r, !0) && YA(n, r, !1)) { qA(n, 'LI') ? i.insertAfter(a, XA(n)) : i.replace(a, n) } else if (YA(n, r, !0)) { qA(n, 'LI') ? (i.insertAfter(a, XA(n)), a.appendChild(i.doc.createTextNode(' ')), a.appendChild(n)) : n.parentNode.insertBefore(a, n) } else if (YA(n, r, !1)) { i.insertAfter(a, XA(n)) } else { n = XA(n); const c = u.cloneRange(); c.setStartAfter(r), c.setEndAfter(n); const s = c.extractContents(); o === 'LI' && WA(s, 'LI') ? (a = s.firstChild, i.insertAfter(s, n)) : (i.insertAfter(s, n), i.insertAfter(a, n)) }i.remove(r), jA.moveToCaretPosition(e, a) } }; const JA = { insert: KA }; const ZA = function (e) { M(kc(ve.fromDom(e), ln), function (e) { const t = e.dom(); t.nodeValue = es.trim(t.nodeValue) }) }; const QA = function (e, t) { return t && t.nodeName === 'A' && e.isEmpty(t) }; const eR = function (e) { return e && /^(TD|TH|CAPTION)$/.test(e.nodeName) }; const tR = function (e) { e.innerHTML = '<br data-mce-bogus="1">' }; const nR = function (e, t) { return e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t }; const rR = function (e, t) { return t && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && e.getContentEditable(t) !== 'true' }; const oR = function (e, t, n) { let r; let o = n; const i = []; if (o) { while (o = o.firstChild) { if (e.isBlock(o)) { return } qn.isElement(o) && !t[o.nodeName.toLowerCase()] && i.push(o) }r = i.length; while (r--) { o = i[r], !o.hasChildNodes() || o.firstChild === o.lastChild && o.firstChild.nodeValue === '' ? e.remove(o) : QA(e, o) && e.remove(o) } } }; const iR = function (e, t, n) { return !1 === qn.isText(t) ? n : e ? n === 1 && t.data.charAt(n - 1) === es.ZWSP ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === es.ZWSP ? t.data.length : n }; const uR = function (e) { const t = e.cloneRange(); return t.setStart(e.startContainer, iR(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, iR(!1, e.endContainer, e.endOffset)), t }; const aR = function (e) { do { qn.isText(e) && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, '')), e = e.firstChild } while (e) }; const cR = function (e, t) { let n; let r; const o = e.getRoot(); n = t; while (n !== o && e.getContentEditable(n) !== 'false') { e.getContentEditable(n) === 'true' && (r = n), n = n.parentNode } return n !== o ? r : o }; const sR = function (e, t, n) { p.from(n.style).map(e.dom.parseStyle).each(function (n) { const r = rr(ve.fromDom(t)); const o = se(se({}, r), n); e.dom.setStyles(t, o) }); const r = p.from(n.class).map(function (e) { return e.split(/\s+/) }); const o = p.from(t.className).map(function (e) { return I(e.split(/\s+/), function (e) { return e !== '' }) }); Ws(r, o, function (n, r) { const o = I(r, function (e) { return !A(n, e) }); const i = fe(n, o); e.dom.setAttrib(t, 'class', i.join(' ')) }); const i = ['style', 'class']; const u = ue(n, function (e, t) { return !A(i, t) }); e.dom.setAttribs(t, u) }; const lR = function (e, t) { const n = id.getForcedRootBlock(e); if (n && n.toLowerCase() === t.tagName.toLowerCase()) { const r = id.getForcedRootBlockAttrs(e); sR(e, t, r) } }; const fR = function (e, t, n, r, o) { let i; let u; let a; let c; let s; let l; const f = t || 'P'; const d = e.dom; const m = cR(d, r); if (u = d.getParent(r, d.isBlock), !u || !rR(d, u)) { if (u = u || m, l = u === e.getBody() || eR(u) ? u.nodeName.toLowerCase() : u.parentNode.nodeName.toLowerCase(), !u.hasChildNodes()) { return i = d.create(f), lR(e, i), u.appendChild(i), n.setStart(i, 0), n.setEnd(i, 0), i } c = r; while (c.parentNode !== u) { c = c.parentNode } while (c && !d.isBlock(c)) { a = c, c = c.previousSibling } if (a && e.schema.isValidChild(l, f.toLowerCase())) { i = d.create(f), lR(e, i), a.parentNode.insertBefore(i, a), c = a; while (c && !d.isBlock(c)) { s = c.nextSibling, i.appendChild(c), c = s }n.setStart(r, o), n.setEnd(r, o) } } return r }; const dR = function (e, t) { let n; t.normalize(), n = t.lastChild, n && !/^(left|right)$/gi.test(e.getStyle(n, 'float', !0)) || e.add(t, 'br') }; const mR = function (e, t) { let n; let r; let o; let i; let u; let a; let c; let s; let l; let f; let d; let m; let g; const h = e.dom; const p = e.schema; const v = p.getNonEmptyElements(); const b = e.selection.getRng(); const y = function (t) { let n; let i; let a; let c = o; const s = p.getTextInlineElements(); if (n = t || f === 'TABLE' || f === 'HR' ? h.create(t || m) : u.cloneNode(!1), a = n, !1 === id.shouldKeepStyles(e)) { h.setAttrib(n, 'style', null), h.setAttrib(n, 'class', null) } else { do { if (s[c.nodeName]) { if (rf(c) || Mm.isBookmarkNode(c)) { continue } i = c.cloneNode(!1), h.setAttrib(i, 'id', ''), n.hasChildNodes() ? (i.appendChild(n.firstChild), n.appendChild(i)) : (a = i, n.appendChild(i)) } } while ((c = c.parentNode) && c !== r) } return lR(e, n), tR(a), n }; const w = function (e) { let t; let n; const r = iR(e, o, i); if (qn.isText(o) && (e ? r > 0 : r < o.nodeValue.length)) { return !1 } if (o.parentNode === u && g && !e) { return !0 } if (e && qn.isElement(o) && o === u.firstChild) { return !0 } if (nR(o, 'TABLE') || nR(o, 'HR')) { return g && !e || !g && e } const a = new Aa(o, u); qn.isText(o) && (e && r === 0 ? a.prev() : e || r !== o.nodeValue.length || a.next()); while (t = a.current()) { if (qn.isElement(t)) { if (!t.getAttribute('data-mce-bogus') && (n = t.nodeName.toLowerCase(), v[n] && n !== 'br')) { return !1 } } else if (qn.isText(t) && !/^[ \t\r\n]*$/.test(t.nodeValue)) { return !1 } e ? a.prev() : a.next() } return !0 }; const x = function () { c = /^(H[1-6]|PRE|FIGURE)$/.test(f) && d !== 'HGROUP' ? y(m) : y(), id.shouldEndContainerOnEmptyBlock(e) && rR(h, l) && h.isEmpty(u) ? c = h.split(l, u) : h.insertAfter(c, u), jA.moveToCaretPosition(e, c) }; pw.normalize(h, b).each(function (e) { b.setStart(e.startContainer, e.startOffset), b.setEnd(e.endContainer, e.endOffset) }), o = b.startContainer, i = b.startOffset, m = id.getForcedRootBlock(e), a = !(!t || !t.shiftKey); const C = !(!t || !t.ctrlKey); qn.isElement(o) && o.hasChildNodes() && (g = i > o.childNodes.length - 1, o = o.childNodes[Math.min(i, o.childNodes.length - 1)] || o, i = g && qn.isText(o) ? o.nodeValue.length : 0), r = cR(h, o), r && ((m && !a || !m && a) && (o = fR(e, m, b, o, i)), u = h.getParent(o, h.isBlock), l = u ? h.getParent(u.parentNode, h.isBlock) : null, f = u ? u.nodeName.toUpperCase() : '', d = l ? l.nodeName.toUpperCase() : '', d !== 'LI' || C || (u = l, l = l.parentNode, f = d), /^(LI|DT|DD)$/.test(f) && h.isEmpty(u) ? JA.insert(e, y, l, u, m) : m && u === e.getBody() || (m = m || 'P', rs(u) ? (c = hs(u), h.isEmpty(u) && tR(u), lR(e, c), jA.moveToCaretPosition(e, c)) : w() ? x() : w(!0) ? (c = u.parentNode.insertBefore(y(), u), jA.moveToCaretPosition(e, nR(u, 'HR') ? c : u)) : (n = uR(b).cloneRange(), n.setEndAfter(u), s = n.extractContents(), ZA(s), aR(s), c = s.firstChild, h.insertAfter(s, u), oR(h, v, c), dR(h, u), h.isEmpty(u) && tR(u), c.normalize(), h.isEmpty(c) ? (h.remove(c), x()) : (lR(e, c), jA.moveToCaretPosition(e, c))), h.setAttrib(c, 'id', ''), e.fire('NewBlock', { newBlock: c }))) }; const gR = { insert: mR }; const hR = function (e, t, n) { let r; const o = new Aa(t, n); const i = e.getNonEmptyElements(); while (r = o.next()) { if (i[r.nodeName.toLowerCase()] || r.length > 0) { return !0 } } }; const pR = function (e, t, n) { const r = e.create('span', {}, '&nbsp;'); n.parentNode.insertBefore(r, n), t.scrollIntoView(r), e.remove(r) }; const vR = function (e, t, n, r) { const o = e.createRng(); r ? (o.setStartBefore(n), o.setEndBefore(n)) : (o.setStartAfter(n), o.setEndAfter(n)), t.setRng(o) }; const bR = function (e, t) { let n; let r; const o = e.selection; const i = e.dom; const u = o.getRng(); pw.normalize(i, u).each(function (e) { u.setStart(e.startContainer, e.startOffset), u.setEnd(e.endContainer, e.endOffset) }); let a = u.startOffset; let c = u.startContainer; if (c.nodeType === 1 && c.hasChildNodes()) { const s = a > c.childNodes.length - 1; c = c.childNodes[Math.min(a, c.childNodes.length - 1)] || c, a = s && c.nodeType === 3 ? c.nodeValue.length : 0 } let l = i.getParent(c, i.isBlock); const f = l ? i.getParent(l.parentNode, i.isBlock) : null; const d = f ? f.nodeName.toUpperCase() : ''; const m = !(!t || !t.ctrlKey); d !== 'LI' || m || (l = f), c && c.nodeType === 3 && a >= c.nodeValue.length && (hR(e.schema, c, l) || (n = i.create('br'), u.insertNode(n), u.setStartAfter(n), u.setEndAfter(n), r = !0)), n = i.create('br'), Il(i, u, n), pR(i, o, n), vR(i, o, n, r), e.undoManager.add() }; const yR = function (e, t) { const n = ve.fromTag('br'); Yt(ve.fromDom(t), n), e.undoManager.add() }; const wR = function (e, t) { CR(e.getBody(), t) || Kt(ve.fromDom(t), ve.fromTag('br')); const n = ve.fromTag('br'); Kt(ve.fromDom(t), n), pR(e.dom, e.selection, n.dom()), vR(e.dom, e.selection, n.dom(), !1), e.undoManager.add() }; const xR = function (e) { return qn.isBr(e.getNode()) }; var CR = function (e, t) { return !!xR(yl.after(t)) || fm.nextPosition(e, yl.after(t)).map(function (e) { return qn.isBr(e.getNode()) }).getOr(!1) }; const SR = function (e) { return e && e.nodeName === 'A' && 'href' in e }; const kR = function (e) { return e.fold(i(!1), SR, SR, i(!1)) }; const TR = function (e) { const t = a(GT.isInlineTarget, e); const n = yl.fromRangeStart(e.selection.getRng()); return pE.readLocation(t, e.getBody(), n).filter(kR) }; const ER = function (e, t) { t.fold(r, a(yR, e), a(wR, e), r) }; const OR = function (e, t) { const n = TR(e); n.isSome() ? n.each(a(ER, e)) : bR(e, t) }; const NR = { insert: OR }; const _R = function (e, t) { return jA.getParentBlock(e).filter(function (e) { return t.length > 0 && Et(ve.fromDom(e), t) }).isSome() }; const DR = function (e) { return _R(e, id.getBrNewLineSelector(e)) }; const AR = function (e) { return _R(e, id.getNoNewLineSelector(e)) }; const RR = { shouldInsertBr: DR, shouldBlockNewLine: AR }; const BR = ah.generate([{ br: [] }, { block: [] }, { none: [] }]); const MR = function (e, t) { return RR.shouldBlockNewLine(e) }; const PR = function (e) { return function (t, n) { const r = id.getForcedRootBlock(t) === ''; return r === e } }; const zR = function (e) { return function (t, n) { return jA.isListItemParentBlock(t) === e } }; const IR = function (e, t) { return function (n, r) { const o = jA.getParentBlockName(n) === e.toUpperCase(); return o === t } }; const LR = function (e) { return IR('pre', e) }; const HR = function () { return IR('summary', !0) }; const FR = function (e) { return function (t, n) { return id.shouldPutBrInPre(t) === e } }; const VR = function (e, t) { return RR.shouldInsertBr(e) }; const UR = function (e, t) { return t }; const jR = function (e) { const t = id.getForcedRootBlock(e); const n = jA.getEditableRoot(e.dom, e.selection.getStart()); return n && e.schema.isValidChild(n.nodeName, t || 'P') }; const WR = function (e, t) { return function (n, r) { const o = H(e, function (e, t) { return e && t(n, r) }, !0); return o ? p.some(t) : p.none() } }; const qR = function (e, t) { return YT.evaluateUntil([WR([MR], BR.none()), WR([HR()], BR.br()), WR([LR(!0), FR(!1), UR], BR.br()), WR([LR(!0), FR(!1)], BR.block()), WR([LR(!0), FR(!0), UR], BR.block()), WR([LR(!0), FR(!0)], BR.br()), WR([zR(!0), UR], BR.br()), WR([zR(!0)], BR.block()), WR([PR(!0), UR, jR], BR.block()), WR([PR(!0)], BR.br()), WR([VR], BR.br()), WR([PR(!1), UR], BR.br()), WR([jR], BR.block())], [e, !(!t || !t.shiftKey)]).getOr(BR.none()) }; const $R = { getAction: qR }; const GR = function (e, t) { $R.getAction(e, t).fold(function () { NR.insert(e, t) }, function () { gR.insert(e, t) }, r) }; const XR = { insert: GR }; const YR = function (e, t) { t.isDefaultPrevented() || (t.preventDefault(), Vk(e.undoManager), e.undoManager.transact(function () { !1 === e.selection.isCollapsed() && e.execCommand('Delete'), XR.insert(e, t) })) }; const KR = function (e) { e.on('keydown', function (t) { t.keyCode === lb.ENTER && YR(e, t) }) }; const JR = { setup: KR }; const ZR = function (e, t) { const n = t.container(); const r = t.offset(); return qn.isText(n) ? (n.insertData(r, e), p.some(vl(n, r + e.length))) : Pd(t).map(function (n) { const r = ve.fromText(e); return t.isAtEnd() ? Kt(n, r) : Yt(n, r), vl(r.dom(), e.length) }) }; const QR = a(ZR, Fi); const eB = a(ZR, ' '); const tB = function (e) { return vl.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd() }; const nB = function (e, t) { const n = I(uy.parentsAndSelf(ve.fromDom(t.container()), e), Bo); return Y(n).getOr(e) }; const rB = function (e, t) { return tB(t) ? mO(t) : mO(t) || fm.prevPosition(nB(e, t).dom(), t).exists(mO) }; const oB = function (e, t) { return tB(t) ? dO(t) : dO(t) || fm.nextPosition(nB(e, t).dom(), t).exists(dO) }; const iB = function (e) { return A(['pre', 'pre-wrap'], e) }; const uB = function (e) { return Pd(e).bind(function (e) { return Nc(e, sn) }).exists(function (e) { return iB(er(e, 'white-space')) }) }; const aB = function (e, t) { return fm.prevPosition(e.dom(), t).isNone() }; const cB = function (e, t) { return fm.nextPosition(e.dom(), t).isNone() }; const sB = function (e, t) { return aB(e, t) || cB(e, t) || OA(e, t) || NA(e, t) || M_(e, t) || B_(e, t) }; const lB = function (e, t) { return !uB(t) && (sB(e, t) || rB(e, t) || oB(e, t)) }; const fB = function (e, t) { return !uB(t) && (OA(e, t) || _A(e, t) || M_(e, t) || rB(e, t)) }; const dB = function (e) { const t = e.container(); const n = e.offset(); return qn.isText(t) && n < t.data.length ? vl(t, n + 1) : e }; const mB = function (e, t) { const n = dB(t); return !uB(n) && (NA(e, n) || DA(e, n) || B_(e, n) || oB(e, n)) }; const gB = function (e, t) { return fB(e, t) || mB(e, t) }; const hB = function (e, t) { return zm(e.charAt(t)) }; const pB = function (e) { const t = e.container(); return qn.isText(t) && Qe(t.data, Fi) }; const vB = function (e) { const t = e.split(''); return B(t, function (e, n) { return zm(e) && n > 0 && n < t.length - 1 && Lm(t[n - 1]) && Lm(t[n + 1]) ? ' ' : e }).join('') }; const bB = function (e, t) { const n = t.data; const r = vl(t, 0); return !(!hB(n, 0) || gB(e, r)) && (t.data = ' ' + n.slice(1), !0) }; const yB = function (e) { const t = e.data; const n = vB(t); return n !== t && (e.data = n, !0) }; const wB = function (e, t) { const n = t.data; const r = vl(t, n.length - 1); return !(!hB(n, n.length - 1) || gB(e, r)) && (t.data = n.slice(0, -1) + ' ', !0) }; const xB = function (e, t) { return p.some(t).filter(pB).bind(function (t) { const n = t.container(); const r = bB(e, n) || yB(n) || wB(e, n); return r ? p.some(t) : p.none() }) }; const CB = function (e) { const t = ve.fromDom(e.getBody()); e.selection.isCollapsed() && xB(t, vl.fromRangeStart(e.selection.getRng())).each(function (t) { e.selection.setRng(t.toRange()) }) }; const SB = function (e) { return function (t) { return t.fold(function (t) { return fm.prevPosition(e.dom(), yl.before(t)) }, function (e) { return fm.firstPositionIn(e) }, function (e) { return fm.lastPositionIn(e) }, function (t) { return fm.nextPosition(e.dom(), yl.after(t)) }) } }; const kB = function (e, t) { return function (n) { return lB(e, n) ? QR(t) : eB(t) } }; const TB = function (e) { return function (t) { return e.selection.setRng(t.toRange()), e.nodeChanged(), !0 } }; const EB = function (e) { const t = yl.fromRangeStart(e.selection.getRng()); const n = ve.fromDom(e.getBody()); if (e.selection.isCollapsed()) { const r = a(GT.isInlineTarget, e); const o = yl.fromRangeStart(e.selection.getRng()); return pE.readLocation(r, e.getBody(), o).bind(SB(n)).bind(kB(n, t)).exists(TB(e)) } return !1 }; const OB = function (e, t) { jN.execute([{ keyCode: lb.SPACEBAR, action: jN.action(EB, e) }], t).each(function (e) { t.preventDefault() }) }; const NB = function (e) { e.on('keydown', function (t) { !1 === t.isDefaultPrevented() && OB(e, t) }) }; const _B = { setup: NB }; const DB = function (e) { return Dc(ve.fromDom(e.getBody()), '*[data-mce-caret]').fold(i(null), function (e) { return e.dom() }) }; const AB = function (e) { e.selection.setRng(e.selection.getRng()) }; const RB = function (e, t) { t.hasAttribute('data-mce-caret') && (hs(t), AB(e), e.selection.scrollIntoView(t)) }; const BB = function (e, t) { const n = DB(e); if (n) { return t.type === 'compositionstart' ? (t.preventDefault(), t.stopPropagation(), void RB(e, n)) : void (us(n) && (RB(e, n), e.undoManager.add())) } }; const MB = function (e) { e.on('keyup compositionstart', a(BB, e)) }; const PB = { setup: MB }; const zB = mt().browser; const IB = function (e) { const t = fc(function () { e.composing || CB(e) }, 0); zB.isIE() && (e.on('keypress', function (e) { t.throttle() }), e.on('remove', function (e) { t.cancel() })) }; const LB = function (e) { IB(e), e.on('input', function (t) { !1 === t.isComposing && CB(e) }) }; const HB = function (e, t) { jN.execute([{ keyCode: lb.END, action: ZO(e, !0) }, { keyCode: lb.HOME, action: ZO(e, !1) }], t).each(function (e) { t.preventDefault() }) }; const FB = function (e) { e.on('keydown', function (t) { !1 === t.isDefaultPrevented() && HB(e, t) }) }; const VB = { setup: FB }; const UB = function (e) { const t = ME.setupSelectedState(e); PB.setup(e), $N.setup(e, t), zA.setup(e, t), JR.setup(e), _B.setup(e), LB(e), VB.setup(e) }; const jB = { setup: UB }; const WB = (function () { function e (e) { let t; this.lastPath = [], this.editor = e; const n = this; 'onselectionchange' in e.getDoc() || e.on('NodeChange click mouseup keyup focus', function (n) { let r, o; r = e.selection.getRng(), o = { startContainer: r.startContainer, startOffset: r.startOffset, endContainer: r.endContainer, endOffset: r.endOffset }, n.type !== 'nodechange' && rw.isEq(o, t) || e.fire('SelectionChange'), t = o }), e.on('contextmenu', function () { e.fire('SelectionChange') }), e.on('SelectionChange', function () { const t = e.selection.getStart(!0); !t || !$r.range && e.selection.isCollapsed() || my(e) && !n.isSameElementPath(t) && e.dom.isChildOf(t, e.getBody()) && e.nodeChanged({ selectionChange: !0 }) }), e.on('mouseup', function (t) { !t.isDefaultPrevented() && my(e) && (e.selection.getNode().nodeName === 'IMG' ? Ir.setEditorTimeout(e, function () { e.nodeChanged() }) : e.nodeChanged()) }) } return e.prototype.nodeChanged = function (e) { let t; let n; let r; const o = this.editor.selection; this.editor.initialized && o && !this.editor.settings.disable_nodechange && !this.editor.mode.isReadOnly() && (r = this.editor.getBody(), t = o.getStart(!0) || r, t.ownerDocument === this.editor.getDoc() && this.editor.dom.isChildOf(t, r) || (t = r), n = [], this.editor.dom.getParent(t, function (e) { if (e === r) { return !0 } n.push(e) }), e = e || {}, e.element = t, e.parents = n, this.editor.fire('NodeChange', e)) }, e.prototype.isSameElementPath = function (e) { let t, n; if (n = this.editor.$(e).parentsUntil(this.editor.getBody()).add(e), n.length === this.lastPath.length) { for (t = n.length; t >= 0; t--) { if (n[t] !== this.lastPath[t]) { break } } if (t === -1) { return this.lastPath = n, !0 } } return this.lastPath = n, !1 }, e }()); const qB = function (e) { e.on('click', function (t) { e.dom.getParent(t.target, 'details') && t.preventDefault() }) }; const $B = function (e) { e.parser.addNodeFilter('details', function (e) { M(e, function (e) { e.attr('data-mce-open', e.attr('open')), e.attr('open', 'open') }) }), e.serializer.addNodeFilter('details', function (e) { M(e, function (e) { const t = e.attr('data-mce-open'); e.attr('open', y(t) ? t : null), e.attr('data-mce-open', null) }) }) }; const GB = function (e) { qB(e), $B(e) }; const XB = function (e) { return qn.isElement(e) && Io(ve.fromDom(e)) }; const YB = function (e) { const t = e.selection.getRng(); const n = vl.fromRangeStart(t); const r = vl.fromRangeEnd(t); if (vl.isElementPosition(n)) { var o = n.container(); XB(o) && fm.firstPositionIn(o).each(function (e) { return t.setStart(e.container(), e.offset()) }) } if (vl.isElementPosition(r)) { o = n.container(); XB(o) && fm.lastPositionIn(o).each(function (e) { return t.setEnd(e.container(), e.offset()) }) }e.selection.setRng(US.normalize(t)) }; const KB = function (e) { e.on('click', function (t) { t.detail >= 3 && YB(e) }) }; const JB = function (e) { let t, n, r, o; return o = e.getBoundingClientRect(), t = e.ownerDocument, n = t.documentElement, r = t.defaultView, { top: o.top + r.pageYOffset - n.clientTop, left: o.left + r.pageXOffset - n.clientLeft } }; const ZB = function (e) { return e.inline ? JB(e.getBody()) : { left: 0, top: 0 } }; const QB = function (e) { const t = e.getBody(); return e.inline ? { left: t.scrollLeft, top: t.scrollTop } : { left: 0, top: 0 } }; const eM = function (e) { const t = e.getBody(); const n = e.getDoc().documentElement; const r = { left: t.scrollLeft, top: t.scrollTop }; const o = { left: t.scrollLeft || n.scrollLeft, top: t.scrollTop || n.scrollTop }; return e.inline ? r : o }; const tM = function (e, t) { if (t.target.ownerDocument !== e.getDoc()) { const n = JB(e.getContentAreaContainer()); const r = eM(e); return { left: t.pageX - n.left + r.left, top: t.pageY - n.top + r.top } } return { left: t.pageX, top: t.pageY } }; const nM = function (e, t, n) { return { pageX: n.left - e.left + t.left, pageY: n.top - e.top + t.top } }; const rM = function (e, t) { return nM(ZB(e), QB(e), tM(e, t)) }; const oM = { calc: rM }; const iM = qn.isContentEditableFalse; const uM = qn.isContentEditableTrue; const aM = function (e, t) { return iM(t) && t !== e }; const cM = function (e, t, n) { return t !== n && !e.dom.isChildOf(t, n) && !iM(t) }; const sM = function (e) { const t = e.cloneNode(!0); return t.removeAttribute('data-mce-selected'), t }; const lM = function (e, t, n, r) { const o = t.cloneNode(!0); e.dom.setStyles(o, { width: n, height: r }), e.dom.setAttrib(o, 'data-mce-selected', null); const i = e.dom.create('div', { class: 'mce-drag-container', 'data-mce-bogus': 'all', unselectable: 'on', contenteditable: 'false' }); return e.dom.setStyles(i, { position: 'absolute', opacity: 0.5, overflow: 'hidden', border: 0, padding: 0, margin: 0, width: n, height: r }), e.dom.setStyles(o, { margin: 0, boxSizing: 'border-box' }), i.appendChild(o), i }; const fM = function (e, t) { e.parentNode !== t && t.appendChild(e) }; const dM = function (e, t, n, r, o, i) { let u = 0; let a = 0; e.style.left = t.pageX + 'px', e.style.top = t.pageY + 'px', t.pageX + n > o && (u = t.pageX + n - o), t.pageY + r > i && (a = t.pageY + r - i), e.style.width = n - u + 'px', e.style.height = r - a + 'px' }; const mM = function (e) { e && e.parentNode && e.parentNode.removeChild(e) }; const gM = function (e) { return e.button === 0 }; const hM = function (e) { return e.element }; const pM = function (e, t) { return { pageX: t.pageX - e.relX, pageY: t.pageY + 5 } }; const vM = function (e, t) { return function (n) { if (gM(n)) { const r = F(t.dom.getParents(n.target), Ks.or(iM, uM)).getOr(null); if (aM(t.getBody(), r)) { const o = t.dom.getPos(r); const i = t.getBody(); const u = t.getDoc().documentElement; e.element = r, e.screenX = n.screenX, e.screenY = n.screenY, e.maxX = (t.inline ? i.scrollWidth : u.offsetWidth) - 2, e.maxY = (t.inline ? i.scrollHeight : u.offsetHeight) - 2, e.relX = n.pageX - o.x, e.relY = n.pageY - o.y, e.width = r.offsetWidth, e.height = r.offsetHeight, e.ghost = lM(t, r, e.width, e.height) } } } }; const bM = function (e, t) { const n = Ir.throttle(function (e, n) { t._selectionOverrides.hideFakeCaret(), t.selection.placeCaretAt(e, n) }, 0); return function (r) { const o = Math.max(Math.abs(r.screenX - e.screenX), Math.abs(r.screenY - e.screenY)); if (hM(e) && !e.dragging && o > 10) { const i = t.fire('dragstart', { target: e.element }); if (i.isDefaultPrevented()) { return } e.dragging = !0, t.focus() } if (e.dragging) { const u = pM(e, oM.calc(t, r)); fM(e.ghost, t.getBody()), dM(e.ghost, u, e.width, e.height, e.maxX, e.maxY), n(r.clientX, r.clientY) } } }; const yM = function (e) { const t = e.getSel().getRangeAt(0); const n = t.startContainer; return n.nodeType === 3 ? n.parentNode : n }; const wM = function (e, t) { return function (n) { if (e.dragging && cM(t, yM(t.selection), e.element)) { let r = sM(e.element); const o = t.fire('drop', { targetClone: r, clientX: n.clientX, clientY: n.clientY }); o.isDefaultPrevented() || (r = o.targetClone, t.undoManager.transact(function () { mM(e.element), t.insertContent(t.dom.getOuterHTML(r)), t._selectionOverrides.hideFakeCaret() })) }CM(e) } }; const xM = function (e, t) { return function () { e.dragging && t.fire('dragend'), CM(e) } }; var CM = function (e) { e.dragging = !1, e.element = null, mM(e.ghost) }; const SM = function (e) { let t; let r; let o; let i; let u; let a; const c = {}; t = Va.DOM, a = n.document, r = vM(c, e), o = bM(c, e), i = wM(c, e), u = xM(c, e), e.on('mousedown', r), e.on('mousemove', o), e.on('mouseup', i), t.bind(a, 'mousemove', o), t.bind(a, 'mouseup', u), e.on('remove', function () { t.unbind(a, 'mousemove', o), t.unbind(a, 'mouseup', u) }) }; const kM = function (e) { e.on('drop', function (t) { const n = typeof t.clientX !== 'undefined' ? e.getDoc().elementFromPoint(t.clientX, t.clientY) : null; (iM(n) || iM(e.dom.getContentEditableParent(n))) && t.preventDefault() }) }; const TM = function (e) { SM(e), kM(e) }; const EM = { init: TM }; const OM = function (e) { const t = fc(function () { if (!e.removed && e.getBody().contains(n.document.activeElement)) { const t = e.selection.getRng(); if (t.collapsed) { const r = lO(e, e.selection.getRng(), !1); e.selection.setRng(r) } } }, 0); e.on('focus', function () { t.throttle() }), e.on('blur', function () { t.cancel() }) }; const NM = { setup: OM }; const _M = qn.isContentEditableTrue; const DM = qn.isContentEditableFalse; const AM = function (e, t) { const n = e.getBody(); while (t && t !== n) { if (_M(t) || DM(t)) { return t } t = t.parentNode } return null }; const RM = function (e) { let t; const n = function (t) { return e.dom.isBlock(t) }; const r = e.getBody(); const o = fd(e, r, n, function () { return wp.hasFocus(e) }); const i = 'sel-' + e.dom.uniqueId(); const u = function (t) { return e.dom.hasClass(t, 'mce-offscreen-selection') }; const a = function () { const t = e.dom.get(i); return t ? t.getElementsByTagName('*')[0] : t }; const c = function (t) { t && e.selection.setRng(t) }; const s = function () { return e.selection.getRng() }; const l = function (t, n, r, i) { let u; return void 0 === i && (i = !0), u = e.fire('ShowCaret', { target: n, direction: t, before: r }), u.isDefaultPrevented() ? null : (i && e.selection.scrollIntoView(n, t === -1), o.show(r, n)) }; const f = function (t) { t.hasAttribute('data-mce-caret') && (hs(t), c(s()), e.selection.scrollIntoView(t)) }; const d = function () { e.on('mouseup', function (t) { const n = s(); n.collapsed && Lv.isXYInContentArea(e, t.clientX, t.clientY) && c(sO(e, n, !1)) }), e.on('click', function (t) { let n; n = AM(e, t.target), n && (DM(n) && (t.preventDefault(), e.focus()), _M(n) && e.dom.isChildOf(n, e.selection.getNode()) && v()) }), e.on('blur NewBlock', function () { v() }), e.on('ResizeWindow FullscreenStateChanged', function () { return o.reposition() }); const n = function (e) { e.on('tap', function (t) { const n = AM(e, t.target); DM(n) && (t.preventDefault(), p(cO(e, n))) }, !0) }; const i = function (e) { const t = Jd(e); if (!e.firstChild) { return !1 } const n = yl.before(e.firstChild); const r = t.next(n); return r && !CO(r) && !SO(r) }; const f = function (t, n) { const r = e.dom.getParent(t, e.dom.isBlock); const o = e.dom.getParent(n, e.dom.isBlock); return r === o }; const d = function (t, n) { const r = e.dom.getParent(t, e.dom.isBlock); const o = e.dom.getParent(n, e.dom.isBlock); return !(!r || !e.dom.isChildOf(r, o) || !1 !== DM(AM(e, r))) || r && !f(r, o) && i(r) }; n(e), e.on('mousedown', function (t) { let n; const o = t.target; if ((o === r || o.nodeName === 'HTML' || e.dom.isChildOf(o, r)) && !1 !== Lv.isXYInContentArea(e, t.clientX, t.clientY)) { if (n = AM(e, o), n) { DM(n) ? (t.preventDefault(), p(cO(e, n))) : (v(), _M(n) && t.shiftKey || sb.isXYWithinRange(t.clientX, t.clientY, e.selection.getRng()) || (y(), e.selection.placeCaretAt(t.clientX, t.clientY))) } else if (!1 === md(o)) { v(), y(); const i = rO(r, t.clientX, t.clientY); if (i && !d(t.target, i.node)) { t.preventDefault(); const u = l(1, i.node, i.before, !1); e.getBody().focus(), c(u) } } } }), e.on('keypress', function (t) { if (!lb.modifierPressed(t)) { switch (t.keyCode) { default:DM(e.selection.getNode()) && t.preventDefault(); break } } }), e.on('GetSelectionRange', function (e) { let n = e.range; if (t) { if (!t.parentNode) { return void (t = null) } n = n.cloneRange(), n.selectNode(t), e.range = n } }), e.on('SetSelectionRange', function (e) { e.range = h(e.range); const t = p(e.range, e.forward); t && (e.range = t) }); const m = function (e) { return e.id === 'mcepastebin' }; e.on('AfterSetSelectionRange', function (e) { const t = e.range; g(t) || m(t.startContainer.parentNode) || y(), u(t.startContainer.parentNode) || v() }), e.on('copy', function (e) { const t = e.clipboardData; if (!e.isDefaultPrevented() && e.clipboardData && !$r.ie) { const n = a(); n && (e.preventDefault(), t.clearData(), t.setData('text/html', n.outerHTML), t.setData('text/plain', n.outerText)) } }), EM.init(e), NM.setup(e) }; const m = function (e) { return is(e) || ds(e) || ms(e) }; var g = function (e) { return m(e.startContainer) || m(e.endContainer) }; var h = function (t) { const n = e.schema.getShortEndedElements(); const r = e.dom.createRng(); const o = t.startContainer; const i = t.startOffset; const u = t.endContainer; const a = t.endOffset; return ce(n, o.nodeName.toLowerCase()) ? i === 0 ? r.setStartBefore(o) : r.setStartAfter(o) : r.setStart(o, i), ce(n, u.nodeName.toLowerCase()) ? a === 0 ? r.setEndBefore(u) : r.setEndAfter(u) : r.setEnd(u, a), r }; var p = function (n, o) { let u; let a; let c; let s; let f; let d; let m; let h; let p; let v; const b = e.$; const w = e.dom; if (!n) { return null } if (n.collapsed) { if (!g(n)) { if (!1 === o) { if (h = Md(-1, r, n), md(h.getNode(!0))) { return l(-1, h.getNode(!0), !1, !1) } if (md(h.getNode())) { return l(-1, h.getNode(), !h.isAtEnd(), !1) } } else { if (h = Md(1, r, n), md(h.getNode())) { return l(1, h.getNode(), !h.isAtEnd(), !1) } if (md(h.getNode(!0))) { return l(1, h.getNode(!0), !1, !1) } } } return null } if (s = n.startContainer, f = n.startOffset, d = n.endOffset, s.nodeType === 3 && f === 0 && DM(s.parentNode) && (s = s.parentNode, f = w.nodeIndex(s), s = s.parentNode), s.nodeType !== 1) { return null } if (d === f + 1 && s === n.endContainer && (u = s.childNodes[f]), !DM(u)) { return null } if (p = v = u.cloneNode(!0), m = e.fire('ObjectSelected', { target: u, targetClone: p }), m.isDefaultPrevented()) { return null } a = Dc(ve.fromDom(e.getBody()), '#' + i).fold(function () { return b([]) }, function (e) { return b([e.dom()]) }), p = m.targetClone, a.length === 0 && (a = b('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr('id', i), a.appendTo(e.getBody())), n = e.dom.createRng(), p === v && $r.ie ? (a.empty().append('<p style="font-size: 0" data-mce-bogus="all"> </p>').append(p), n.setStartAfter(a[0].firstChild.firstChild), n.setEndAfter(p)) : (a.empty().append(Fi).append(p).append(Fi), n.setStart(a[0].firstChild, 1), n.setEnd(a[0].lastChild, 0)), a.css({ top: w.getPos(u, e.getBody()).y }), a[0].focus(), c = e.selection.getSel(), c.removeAllRanges(), c.addRange(n); const x = ve.fromDom(u); return M(Tc(ve.fromDom(e.getBody()), '*[data-mce-selected]'), function (e) { Dt(x, e) || Qn(e, 'data-mce-selected') }), e.dom.getAttrib(u, 'data-mce-selected') || u.setAttribute('data-mce-selected', '1'), t = u, y(), n }; var v = function () { t && (t.removeAttribute('data-mce-selected'), Dc(ve.fromDom(e.getBody()), '#' + i).each(rn), t = null), Dc(ve.fromDom(e.getBody()), '#' + i).each(rn), t = null }; const b = function () { o.destroy(), t = null }; var y = function () { o.hide() }; return $r.ceFalse && d(), { showCaret: l, showBlockCaretContainer: f, hideFakeCaret: y, destroy: b } }; const BM = function (e) { const t = vo.each; const r = lb.BACKSPACE; const o = lb.DELETE; const i = e.dom; const u = e.selection; const a = e.settings; const c = e.parser; const s = $r.gecko; const l = $r.ie; const f = $r.webkit; const d = 'data:text/mce-internal,'; const m = l ? 'Text' : 'URL'; const g = function (t, n) { try { e.getDoc().execCommand(t, !1, n) } catch (r) {} }; const h = function (e) { return e.isDefaultPrevented() }; const p = function (t) { let n, r; t.dataTransfer && (e.selection.isCollapsed() && t.target.tagName === 'IMG' && u.select(t.target), n = e.selection.getContent(), n.length > 0 && (r = d + escape(e.id) + ',' + escape(n), t.dataTransfer.setData(m, r))) }; const v = function (e) { let t; return e.dataTransfer && (t = e.dataTransfer.getData(m), t && t.includes(d)) ? (t = t.substr(d.length).split(','), { id: unescape(t[0]), html: unescape(t[1]) }) : null }; const b = function (t, n) { e.queryCommandSupported('mceInsertClipboardContent') ? e.execCommand('mceInsertClipboardContent', !1, { content: t, internal: n }) : e.execCommand('mceInsertContent', !1, t) }; const y = function () { const t = function (e) { const t = i.create('body'); const n = e.cloneContents(); return t.appendChild(n), u.serializer.serialize(t, { format: 'html' }) }; const n = function (n) { const r = t(n); const o = i.createRng(); o.selectNode(e.getBody()); const u = t(o); return r === u }; e.on('keydown', function (t) { let u; let a; const c = t.keyCode; if (!h(t) && (c === o || c === r)) { if (u = e.selection.isCollapsed(), a = e.getBody(), u && !i.isEmpty(a)) { return } if (!u && !n(e.selection.getRng())) { return } t.preventDefault(), e.setContent(''), a.firstChild && i.isBlock(a.firstChild) ? e.selection.setCursorLocation(a.firstChild, 0) : e.selection.setCursorLocation(a, 0), e.nodeChanged() } }) }; const w = function () { e.shortcuts.add('meta+a', null, 'SelectAll') }; const x = function () { e.inline || i.bind(e.getDoc(), 'mousedown mouseup', function (t) { let n; if (t.target === e.getDoc().documentElement) { if (n = u.getRng(), e.getBody().focus(), t.type === 'mousedown') { if (is(n.startContainer)) { return } u.placeCaretAt(t.clientX, t.clientY) } else { u.setRng(n) } } }) }; const C = function () { e.on('keydown', function (t) { if (!h(t) && t.keyCode === r) { if (!e.getBody().getElementsByTagName('hr').length) { return } if (u.isCollapsed() && u.getRng().startOffset === 0) { const n = u.getNode(); const o = n.previousSibling; if (n.nodeName === 'HR') { return i.remove(n), void t.preventDefault() } o && o.nodeName && o.nodeName.toLowerCase() === 'hr' && (i.remove(o), t.preventDefault()) } } }) }; const S = function () { n.Range.prototype.getClientRects || e.on('mousedown', function (t) { if (!h(t) && t.target.nodeName === 'HTML') { const n = e.getBody(); n.blur(), Ir.setEditorTimeout(e, function () { n.focus() }) } }) }; const k = function () { e.on('click', function (t) { const n = t.target; /^(IMG|HR)$/.test(n.nodeName) && i.getContentEditableParent(n) !== 'false' && (t.preventDefault(), e.selection.select(n), e.nodeChanged()), n.nodeName === 'A' && i.hasClass(n, 'mce-item-anchor') && (t.preventDefault(), u.select(n)) }) }; const T = function () { const n = function () { const n = i.getAttribs(u.getStart().cloneNode(!1)); return function () { const r = u.getStart(); r !== e.getBody() && (i.setAttrib(r, 'style', null), t(n, function (e) { r.setAttributeNode(e.cloneNode(!0)) })) } }; const r = function () { return !u.isCollapsed() && i.getParent(u.getStart(), i.isBlock) !== i.getParent(u.getEnd(), i.isBlock) }; e.on('keypress', function (t) { let o; if (!h(t) && (t.keyCode === 8 || t.keyCode === 46) && r()) { return o = n(), e.getDoc().execCommand('delete', !1, null), o(), t.preventDefault(), !1 } }), i.bind(e.getDoc(), 'cut', function (t) { let o; !h(t) && r() && (o = n(), Ir.setEditorTimeout(e, function () { o() })) }) }; const E = function () { e.on('keydown', function (e) { if (!h(e) && e.keyCode === r && u.isCollapsed() && u.getRng().startOffset === 0) { const t = u.getNode().previousSibling; if (t && t.nodeName && t.nodeName.toLowerCase() === 'table') { return e.preventDefault(), !1 } } }) }; const O = function () { e.on('keydown', function (t) { let n, r, o, a, c; if (!h(t) && t.keyCode === lb.BACKSPACE && (n = u.getRng(), r = n.startContainer, o = n.startOffset, a = i.getRoot(), c = r, n.collapsed && o === 0)) { while (c && c.parentNode && c.parentNode.firstChild === c && c.parentNode !== a) { c = c.parentNode }c.tagName === 'BLOCKQUOTE' && (e.formatter.toggle('blockquote', null, c), n = i.createRng(), n.setStart(r, 0), n.setEnd(r, 0), u.setRng(n)) } }) }; const N = function () { const t = function () { g('StyleWithCSS', !1), g('enableInlineTableEditing', !1), a.object_resizing || g('enableObjectResizing', !1) }; a.readonly || e.on('BeforeExecCommand mousedown', t) }; const _ = function () { const n = function () { t(i.select('a'), function (e) { let t = e.parentNode; const n = i.getRoot(); if (t.lastChild === e) { while (t && !i.isBlock(t)) { if (t.parentNode.lastChild !== t || t === n) { return } t = t.parentNode }i.add(t, 'br', { 'data-mce-bogus': 1 }) } }) }; e.on('SetContent ExecCommand', function (e) { e.type !== 'setcontent' && e.command !== 'mceInsertLink' || n() }) }; const D = function () { a.forced_root_block && e.on('init', function () { g('DefaultParagraphSeparator', id.getForcedRootBlock(e)) }) }; const A = function () { e.on('keyup focusin mouseup', function (e) { lb.modifierPressed(e) || u.normalize() }, !0) }; const R = function () { e.contentStyles.push('img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}') }; const B = function () { e.inline || e.on('keydown', function () { n.document.activeElement === n.document.body && e.getWin().focus() }) }; const M = function () { e.inline || (e.contentStyles.push('body {min-height: 150px}'), e.on('click', function (t) { let n; if (t.target.nodeName === 'HTML') { if ($r.ie > 11) { return void e.getBody().focus() } n = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(n), e.selection.normalize(), e.nodeChanged() } })) }; const P = function () { $r.mac && e.on('keydown', function (t) { if (lb.metaKeyPressed(t) && !t.shiftKey && (t.keyCode === 37 || t.keyCode === 39)) { t.preventDefault(); const n = e.selection.getSel(); n.modify('move', t.keyCode === 37 ? 'backward' : 'forward', 'lineboundary') } }) }; const z = function () { g('AutoUrlDetect', !1) }; const I = function () { e.on('click', function (e) { let t = e.target; do { if (t.tagName === 'A') { return void e.preventDefault() } } while (t = t.parentNode) }), e.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}') }; const L = function () { e.on('init', function () { e.dom.bind(e.getBody(), 'submit', function (e) { e.preventDefault() }) }) }; const H = function () { c.addNodeFilter('br', function (e) { let t = e.length; while (t--) { e[t].attr('class') === 'Apple-interchange-newline' && e[t].remove() } }) }; const F = function () { e.on('dragstart', function (e) { p(e) }), e.on('drop', function (t) { if (!h(t)) { const n = v(t); if (n && n.id !== e.id) { t.preventDefault(); const r = Zb.fromPoint(t.x, t.y, e.getDoc()); u.setRng(r), b(n.html, !0) } } }) }; const V = function () {}; const U = function () { let t; return !(!s || e.removed) && (t = e.selection.getSel(), !t || !t.rangeCount || t.rangeCount === 0) }; return O(), y(), $r.windowsPhone || A(), f && (x(), k(), D(), L(), E(), H(), $r.iOS ? (B(), M(), I()) : w()), $r.ie >= 11 && (M(), E()), $r.ie && (w(), z(), F()), s && (C(), S(), T(), N(), _(), R(), P(), E()), { refreshContentEditable: V, isHidden: U } }; const MM = Va.DOM; const PM = function (e, t) { const n = ve.fromDom(e.getDoc().head); const r = ve.fromTag('style'); Xn(r, 'type', 'text/css'), Zt(r, ve.fromText(t)), Zt(n, r) }; const zM = function (e) { const t = Qw(e.settings, e.schema); return t.addAttributeFilter('src,href,style,tabindex', function (t, n) { let r; let o; let i = t.length; const u = e.dom; const a = 'data-mce-' + n; while (i--) { if (r = t[i], o = r.attr(n), o && !r.attr(a)) { if (o.indexOf('data:') === 0 || o.indexOf('blob:') === 0) { continue } n === 'style' ? (o = u.serializeStyle(u.parseStyle(o), r.name), o.length || (o = null), r.attr(a, o), r.attr(n, o)) : n === 'tabindex' ? (r.attr(a, o), r.attr(n, null)) : r.attr(a, e.convertURL(o, n, r.name)) } } }), t.addNodeFilter('script', function (e) { let t; let n; let r = e.length; while (r--) { t = e[r], n = t.attr('type') || 'no/type', n.indexOf('mce-') !== 0 && t.attr('type', 'mce-' + n) } }), e.settings.preserve_cdata && t.addNodeFilter('#cdata', function (t) { let n; let r = t.length; while (r--) { n = t[r], n.type = 8, n.name = '#comment', n.value = '[CDATA[' + e.dom.encode(n.value) + ']]' } }), t.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (t) { let n; let r = t.length; const o = e.schema.getNonEmptyElements(); while (r--) { n = t[r], n.isEmpty(o) && n.getAll('br').length === 0 && (n.append(new Bg('br', 1)).shortEnded = !0) } }), t }; const IM = function (e) { e.settings.auto_focus && Ir.setEditorTimeout(e, function () { let t; t = !0 === e.settings.auto_focus ? e : e.editorManager.get(e.settings.auto_focus), t.destroyed || t.focus() }, 100) }; const LM = function (e) { const t = e.dom.getRoot(); e.inline || my(e) && e.selection.getStart(!0) !== t || fm.firstPositionIn(t).each(function (t) { const n = t.getNode(); const r = qn.isTable(n) ? fm.firstPositionIn(n).getOr(t) : t; $r.browser.isIE() ? Vh.storeNative(e, r.toRange()) : e.selection.setRng(r.toRange()) }) }; const HM = function (e) { e.bindPendingEventDelegates(), e.initialized = !0, Ip(e), e.focus(!0), LM(e), e.nodeChanged({ initial: !0 }), e.execCallback('init_instance_callback', e), IM(e) }; const FM = function (e) { return e.inline ? MM.styleSheetLoader : e.dom.styleSheetLoader }; const VM = function (e, t) { let r; let o; const i = e.settings; const u = e.getElement(); let a = e.getDoc(); i.inline || (e.getElement().style.visibility = e.orgVisibility), t || e.inline || (a.open(), a.write(e.iframeHTML), a.close()), e.inline && (e.on('remove', function () { const e = this.getBody(); MM.removeClass(e, 'mce-content-body'), MM.removeClass(e, 'mce-edit-focus'), MM.setAttrib(e, 'contentEditable', null) }), MM.addClass(u, 'mce-content-body'), e.contentDocument = a = n.document, e.contentWindow = n.window, e.bodyElement = u, e.contentAreaContainer = u, i.root_name = u.nodeName.toLowerCase()), r = e.getBody(), r.disabled = !0, e.readonly = !!i.readonly, e.readonly || (e.inline && MM.getStyle(r, 'position', !0) === 'static' && (r.style.position = 'relative'), r.contentEditable = e.getParam('content_editable_state', !0)), r.disabled = !1, e.editorUpload = Bx(e), e.schema = yi(i), e.dom = Va(a, { keep_values: !0, url_converter: e.convertURL, url_converter_scope: e, hex_colors: i.force_hex_style_colors, update_styles: !0, root_element: e.inline ? e.getBody() : null, collect () { return e.inline }, schema: e.schema, contentCssCors: id.shouldUseContentCssCors(e), referrerPolicy: id.getReferrerPolicy(e), onSetAttrib (t) { e.fire('SetAttrib', t) } }), e.parser = zM(e), e.serializer = gx(i, e), e.selection = Pw(e.dom, e.getWin(), e.serializer, e), e.annotator = Og(e), e.formatter = fk(e), e.undoManager = tT(e), e._nodeChangeDispatcher = new WB(e), e._selectionOverrides = RM(e), hT.setup(e), GB(e), KB(e), jB.setup(e), CT.setup(e), sT(e), Pp(e), i.browser_spellcheck || i.gecko_spellcheck || (a.body.spellcheck = !1, MM.setAttrib(r, 'spellcheck', 'false')), e.quirks = BM(e), zp(e); const c = id.getDirectionality(e); void 0 !== c && (r.dir = c), i.protect && e.on('BeforeSetContent', function (e) { vo.each(i.protect, function (t) { e.content = e.content.replace(t, function (e) { return '\x3C!--mce:protected ' + escape(e) + '--\x3E' }) }) }), e.on('SetContent', function () { e.addVisual(e.getBody()) }), e.load({ initial: !0, format: 'html' }), e.startContent = e.getContent({ format: 'raw' }), e.on('compositionstart compositionend', function (t) { e.composing = t.type === 'compositionstart' }), e.contentStyles.length > 0 && (o = '', vo.each(e.contentStyles, function (e) { o += e + '\r\n' }), e.dom.addStyle(o)), FM(e).loadAll(e.contentCSS, function (t) { HM(e) }, function (t) { HM(e) }), i.content_style && PM(e, i.content_style) }; const UM = { initContentBody: VM }; const jM = Va.DOM; const WM = function (e, t) { if (n.document.domain !== n.window.location.hostname && $r.browser.isIE()) { const r = Ax.uuid('mce'); e[r] = function () { UM.initContentBody(e) }; const o = 'javascript:(function(){document.open();document.domain="' + n.document.domain + '";var ed = window.parent.tinymce.get("' + e.id + '");document.write(ed.iframeHTML);document.close();ed.' + r + '(true);})()'; return jM.setAttrib(t, 'src', o), !0 } return !1 }; const qM = function (e, t, n, r) { const o = ve.fromTag('iframe'); return Yn(o, r), Yn(o, { id: e + '_ifr', frameBorder: '0', allowTransparency: 'true', title: t }), wc(o, 'tox-edit-area__iframe'), o }; const $M = function (e) { let t, n, r; return r = id.getDocType(e) + '<html><head>', id.getDocumentBaseUrl(e) !== e.documentBaseUrl && (r += '<base href="' + e.documentBaseURI.getURI() + '" />'), r += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />', t = id.getBodyId(e), n = id.getBodyClass(e), id.getContentSecurityPolicy(e) && (r += '<meta http-equiv="Content-Security-Policy" content="' + id.getContentSecurityPolicy(e) + '" />'), r += '</head><body id="' + t + '" class="mce-content-body ' + n + '" data-id="' + e.id + '"><br></body></html>', r }; const GM = function (e, t) { const n = e.editorManager.translate('Rich Text Area. Press ALT-0 for help.'); const r = qM(e.id, n, t.height, id.getIframeAttrs(e)).dom(); r.onload = function () { r.onload = null, e.fire('load') }; const o = WM(e, r); return e.contentAreaContainer = t.iframeContainer, e.iframeElement = r, e.iframeHTML = $M(e), jM.add(t.iframeContainer, r), o }; const XM = function (e, t) { const n = GM(e, t); t.editorContainer && (jM.get(t.editorContainer).style.display = e.orgDisplay, e.hidden = jM.isHidden(t.editorContainer)), e.getElement().style.display = 'none', jM.setAttrib(e.id, 'aria-hidden', 'true'), n || UM.initContentBody(e) }; const YM = { init: XM }; const KM = Va.DOM; var JM = function (e, t, n) { const r = Vv.get(n); const o = Vv.urls[n] || e.documentBaseUrl.replace(/\/$/, ''); if (n = vo.trim(n), r && vo.inArray(t, n) === -1) { if (vo.each(Vv.dependencies(n), function (n) { JM(e, t, n) }), e.plugins[n]) { return } try { const i = new r(e, o, e.$); e.plugins[n] = i, i.init && (i.init(e, o), t.push(n)) } catch (OL) { tb.pluginInitError(e, n, OL) } } }; const ZM = function (e) { return e.replace(/^\-/, '') }; const QM = function (e) { const t = []; vo.each(e.settings.plugins.split(/[ ,]/), function (n) { JM(e, t, ZM(n)) }) }; const eP = function (e) { const t = vo.trim(e.settings.icons); const n = e.ui.registry.getAll().icons; const r = nb(); const o = se(se({}, r), Tv.get(t).icons); ee(o, function (t, r) { ce(n, r) || e.ui.registry.addIcon(r, t) }) }; const tP = function (e) { const t = e.settings.theme; if (y(t)) { e.settings.theme = ZM(t); const n = Uv.get(t); e.theme = new n(e, Uv.urls[t]), e.theme.init && e.theme.init(e, Uv.urls[t] || e.documentBaseUrl.replace(/\/$/, ''), e.$) } else { e.theme = {} } }; const nP = function (e) { return e.theme.renderUI() }; const rP = function (e) { const t = e.getElement(); const n = e.settings.theme; const r = n(e, t); return r.editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || e.id + '_parent'), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || e.id + '_iframecontainer'), r.height = r.iframeHeight ? r.iframeHeight : t.offsetHeight, r }; const oP = function (e) { return { editorContainer: e, iframeContainer: e } }; const iP = function (e) { const t = KM.create('div'); return KM.insertAfter(t, e), oP(t) }; const uP = function (e) { const t = e.getElement(); return e.inline ? oP(null) : iP(t) }; const aP = function (e) { const t = e.getElement(); return e.orgDisplay = t.style.display, y(e.settings.theme) ? nP(e) : k(e.settings.theme) ? rP(e) : uP(e) }; const cP = function (e) { e.fire('ScriptsLoaded'), eP(e), tP(e), QM(e); const t = aP(e); return e.editorContainer = t.editorContainer ? t.editorContainer : null, ib(e), e.inline ? UM.initContentBody(e) : YM.init(e, t) }; const sP = { init: cP }; const lP = Va.DOM; const fP = function (e) { return e.charAt(0) === '-' }; const dP = function (e, t) { const n = id.getLanguageCode(t); const o = id.getLanguageUrl(t); if (!1 === cc.hasCode(n) && n !== 'en') { const i = o !== '' ? o : t.editorManager.baseURL + '/langs/' + n + '.js'; e.add(i, r, void 0, function () { tb.languageLoadError(t, i, n) }) } }; const mP = function (e, t, n, r) { const o = t.settings; const i = o.theme; if (y(i)) { if (!fP(i) && !Uv.urls.hasOwnProperty(i)) { const u = o.theme_url; u ? Uv.load(i, t.documentBaseURI.toAbsolute(u)) : Uv.load(i, 'themes/' + i + '/theme' + n + '.js') }e.loadQueue(function () { Uv.waitFor(i, r) }) } else { r() } }; const gP = function (e) { return p.from(id.getIconsUrl(e)).filter(function (e) { return e.length > 0 }).map(function (e) { return { url: e, name: p.none() } }) }; const hP = function (e) { return p.from(id.getIconPackName(e)).filter(function (e) { return e.length > 0 && !Tv.has(e) }).map(function (t) { return { url: e.editorManager.baseURL + '/icons/' + t + '/icons.js', name: p.some(t) } }) }; const pP = function (e, t) { gP(t).orThunk(function () { return hP(t) }).each(function (n) { e.add(n.url, r, void 0, function () { tb.iconsLoadError(t, n.url, n.name.getOrUndefined()) }) }) }; const vP = function (e, t, n) { x(t.plugins) && (t.plugins = t.plugins.join(' ')), vo.each(t.external_plugins, function (n, o) { Vv.load(o, n, r, void 0, function () { tb.pluginLoadError(e, n, o) }), t.plugins += ' ' + o }), vo.each(t.plugins.split(/[ ,]/), function (t) { if (t = vo.trim(t), t && !Vv.urls[t]) { if (fP(t)) { t = t.substr(1, t.length); const o = Vv.dependencies(t); vo.each(o, function (t) { const o = { prefix: 'plugins/', resource: t, suffix: '/plugin' + n + '.js' }; const i = Vv.createUrl(o, t); Vv.load(i.resource, i, r, void 0, function () { tb.pluginLoadError(e, i.prefix + i.resource + i.suffix, i.resource) }) }) } else { const i = { prefix: 'plugins/', resource: t, suffix: '/plugin' + n + '.js' }; Vv.load(t, i, r, void 0, function () { tb.pluginLoadError(e, i.prefix + i.resource + i.suffix, t) }) } } }) }; const bP = function (e, t) { const n = Ya.ScriptLoader; mP(n, e, t, function () { dP(n, e), pP(n, e), vP(e, e.settings, t), n.loadQueue(function () { e.removed || sP.init(e) }, e, function () { e.removed || sP.init(e) }) }) }; const yP = function (e) { const t = e.settings; const r = e.id; cc.setCode(id.getLanguageCode(e)); var o = function () { lP.unbind(n.window, 'ready', o), e.render() }; if (eu.Event.domLoaded) { if (e.getElement() && $r.contentEditable) { t.inline ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = 'hidden'); const i = e.getElement().form || lP.getParent(r, 'form'); i && (e.formElement = i, t.hidden_input && !qn.isTextareaOrInput(e.getElement()) && (lP.insertAfter(lP.create('input', { type: 'hidden', name: r }), r), e.hasHiddenInput = !0), e.formEventDelegate = function (t) { e.fire(t.type, t) }, lP.bind(i, 'submit reset', e.formEventDelegate), e.on('reset', function () { e.resetContent() }), !t.submit_patch || i.submit.nodeType || i.submit.length || i._mceOldSubmit || (i._mceOldSubmit = i.submit, i.submit = function () { return e.editorManager.triggerSave(), e.setDirty(!1), i._mceOldSubmit(i) })), e.windowManager = Wv(e), e.notificationManager = Fv(e), t.encoding === 'xml' && e.on('GetContent', function (e) { e.save && (e.content = lP.encode(e.content)) }), t.add_form_submit_trigger && e.on('submit', function () { e.initialized && e.save() }), t.add_unload_trigger && (e._beforeUnload = function () { !e.initialized || e.destroyed || e.isHidden() || e.save({ format: 'raw', no_events: !0, set_dirty: !1 }) }, e.editorManager.on('BeforeUnload', e._beforeUnload)), e.editorManager.add(e), bP(e, e.suffix) } } else { lP.bind(n.window, 'ready', o) } }; const wP = { render: yP }; const xP = function (e) { return e.firstChild && e.firstChild === e.lastChild }; const CP = function (e) { return e.name === 'br' || e.value === Fi }; const SP = function (e, t) { const n = e.getBlockElements(); return n[t.name] && xP(t) && CP(t.firstChild) }; const kP = function (e, t) { const n = e.getNonEmptyElements(); return t && (t.isEmpty(n) || SP(e, t)) }; const TP = function (e, t) { let n = t.firstChild; let r = t.lastChild; return n && n.name === 'meta' && (n = n.next), r && r.attr('id') === 'mce_marker' && (r = r.prev), kP(e, r) && (r = r.prev), !(!n || n !== r) && (n.name === 'ul' || n.name === 'ol') }; const EP = function (e) { const t = e.firstChild; const n = e.lastChild; return t && t.nodeName === 'META' && t.parentNode.removeChild(t), n && n.id === 'mce_marker' && n.parentNode.removeChild(n), e }; const OP = function (e, t, n) { const r = t.serialize(n); const o = e.createFragment(r); return EP(o) }; const NP = function (e) { return vo.grep(e.childNodes, function (e) { return e.nodeName === 'LI' }) }; const _P = function (e) { return e.data === Fi || qn.isBr(e) }; const DP = function (e) { return e && e.firstChild && e.firstChild === e.lastChild && _P(e.firstChild) }; const AP = function (e) { return !e.firstChild || DP(e) }; const RP = function (e) { return e.length > 0 && AP(e[e.length - 1]) ? e.slice(0, -1) : e }; const BP = function (e, t) { const n = e.getParent(t, e.isBlock); return n && n.nodeName === 'LI' ? n : null }; const MP = function (e, t) { return !!BP(e, t) }; const PP = function (e, t) { const n = t.cloneRange(); const r = t.cloneRange(); return n.setStartBefore(e), r.setEndAfter(e), [n.cloneContents(), r.cloneContents()] }; const zP = function (e, t) { const n = yl.before(e); const r = Jd(t); const o = r.next(n); return o ? o.toRange() : null }; const IP = function (e, t) { const n = yl.after(e); const r = Jd(t); const o = r.prev(n); return o ? o.toRange() : null }; const LP = function (e, t, n, r) { const o = PP(e, r); const i = e.parentNode; return i.insertBefore(o[0], e), vo.each(t, function (t) { i.insertBefore(t, e) }), i.insertBefore(o[1], e), i.removeChild(e), IP(t[t.length - 1], n) }; const HP = function (e, t, n) { const r = e.parentNode; return vo.each(t, function (t) { r.insertBefore(t, e) }), zP(e, n) }; const FP = function (e, t, n, r) { return r.insertAfter(t.reverse(), e), IP(t[0], n) }; const VP = function (e, t, n, r) { const o = OP(t, e, r); const i = BP(t, n.startContainer); const u = RP(NP(o.firstChild)); const a = 1; const c = 2; const s = t.getRoot(); const l = function (e) { const r = yl.fromRangeStart(n); const o = Jd(t.getRoot()); const u = e === a ? o.prev(r) : o.next(r); return !u || BP(t, u.getNode()) !== i }; return l(a) ? HP(i, u, s) : l(c) ? FP(i, u, s, t) : LP(i, u, s, n) }; const UP = { isListFragment: TP, insertAtCaret: VP, isParentBlockLi: MP, trimListItems: RP, listItems: NP }; const jP = function (e, t) { return qn.isText(e) && e.nodeValue[t - 1] === Fi }; const WP = function (e, t) { let n, r; n = e.startContainer, r = e.startOffset; const o = function (e) { return n[e] && n[e].nodeType === 3 }; return n.nodeType === 3 && (r > 0 ? t = t.replace(/^&nbsp;/, ' ') : o('previousSibling') || (t = t.replace(/^ /, '&nbsp;')), r < n.length ? t = t.replace(/&nbsp;(<br>|)$/, ' ') : o('nextSibling') || (t = t.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;'))), t }; const qP = function (e, t) { let n, r; return n = e.startContainer, r = e.startOffset, n.nodeType === 3 && e.collapsed && (n.data[r] === Fi ? (n.deleteData(r, 1), /[\u00A0| ]$/.test(t) || (t += ' ')) : n.data[r - 1] === Fi && (n.deleteData(r - 1, 1), /[\u00A0| ]$/.test(t) || (t = ' ' + t))), t }; const $P = qn.matchNodeNames(['td', 'th']); const GP = function (e, t) { const n = e.selection.getRng(); const r = n.startContainer; const o = n.startOffset; n.collapsed && jP(r, o) && qn.isText(r) && (r.insertData(o - 1, ' '), r.deleteData(o, 1), n.setStart(r, o), n.setEnd(r, o), e.selection.setRng(n)), e.selection.setContent(t) }; const XP = function (e, t, n) { if (n.getAttribute('data-mce-bogus') === 'all') { n.parentNode.insertBefore(e.dom.createFragment(t), n) } else { const r = n.firstChild; const o = n.lastChild; !r || r === o && r.nodeName === 'BR' ? e.dom.setHTML(n, t) : GP(e, t) } }; const YP = function (e, t) { p.from(e.getParent(t, 'td,th')).map(ve.fromDom).each(Fx.trimBlockTrailingBr) }; const KP = function (e, t) { const n = e.schema.getTextInlineElements(); const r = e.dom; if (t) { const o = e.getBody(); const i = new uS(r); vo.each(r.select('*[data-mce-fragment]'), function (e) { for (let t = e.parentNode; t && t !== o; t = t.parentNode) { n[e.nodeName.toLowerCase()] && i.compare(t, e) && r.remove(e, !0) } }) } }; const JP = function (e) { let t = e; while (t = t.walk()) { t.type === 1 && t.attr('data-mce-fragment', '1') } }; const ZP = function (e) { vo.each(e.getElementsByTagName('*'), function (e) { e.removeAttribute('data-mce-fragment') }) }; const QP = function (e) { return !!e.getAttribute('data-mce-fragment') }; const ez = function (e, t) { return t && !e.schema.getShortEndedElements()[t.nodeName] }; const tz = function (e, t) { let n; let r; let o; let i; let u; const a = e.dom; const c = e.selection; const s = function (t) { for (let n = e.getBody(); t && t !== n; t = t.parentNode) { if (e.dom.getContentEditable(t) === 'false') { return t } } return null }; if (t) { if (e.selection.scrollIntoView(t), n = s(t), n) { return a.remove(t), void c.select(n) } let l = a.createRng(); i = t.previousSibling, i && i.nodeType === 3 ? (l.setStart(i, i.nodeValue.length), $r.ie || (u = t.nextSibling, u && u.nodeType === 3 && (i.appendData(u.data), u.parentNode.removeChild(u)))) : (l.setStartBefore(t), l.setEndBefore(t)); const f = function (t) { let n = yl.fromRangeStart(t); const r = Jd(e.getBody()); if (n = r.next(n), n) { return n.toRange() } }; r = a.getParent(t, a.isBlock), a.remove(t), r && a.isEmpty(r) && (e.$(r).empty(), l.setStart(r, 0), l.setEnd(r, 0), $P(r) || QP(r) || !(o = f(l)) ? a.add(r, a.create('br', { 'data-mce-bogus': '1' })) : (l = o, a.remove(r))), c.setRng(l) } }; const nz = function (e, t, n) { let r; let o; let i; let u; let a; let c; let s; let l; let f; let d; let m; const g = e.selection; const h = e.dom; if (/^ | $/.test(t) && (t = WP(g.getRng(), t)), r = e.parser, m = n.merge, o = Qg({ validate: e.settings.validate }, e.schema), d = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>', c = { content: t, format: 'html', selection: !0, paste: n.paste }, c = e.fire('BeforeSetContent', c), c.isDefaultPrevented()) { e.fire('SetContent', { content: c.content, format: 'html', selection: !0, paste: n.paste }) } else { t = c.content, !t.includes('{$caret}') && (t += '{$caret}'), t = t.replace(/\{\$caret\}/, d), l = g.getRng(); const p = l.startContainer || (l.parentElement ? l.parentElement() : null); const v = e.getBody(); p === v && g.isCollapsed() && h.isBlock(v.firstChild) && ez(e, v.firstChild) && h.isEmpty(v.firstChild) && (l = h.createRng(), l.setStart(v.firstChild, 0), l.setEnd(v.firstChild, 0), g.setRng(l)), g.isCollapsed() || (e.selection.setRng(US.normalize(e.selection.getRng())), e.getDoc().execCommand('Delete', !1, null), t = qP(e.selection.getRng(), t)), i = g.getNode(); const b = { context: i.nodeName.toLowerCase(), data: n.data, insert: !0 }; if (a = r.parse(t, b), !0 === n.paste && UP.isListFragment(e.schema, a) && UP.isParentBlockLi(h, i)) { return l = UP.insertAtCaret(o, h, e.selection.getRng(), a), e.selection.setRng(l), void e.fire('SetContent', c) } if (JP(a), f = a.lastChild, f.attr('id') === 'mce_marker') { for (s = f, f = f.prev; f; f = f.walk(!0)) { if (f.type === 3 || !h.isBlock(f.name)) { e.schema.isValidChild(f.parent.name, 'span') && f.parent.insert(s, f, f.name === 'br'); break } } } if (e._selectionOverrides.showBlockCaretContainer(i), b.invalid) { GP(e, d), i = g.getNode(), u = e.getBody(), i.nodeType === 9 ? i = f = u : f = i; while (f !== u) { i = f, f = f.parentNode }t = i === u ? u.innerHTML : h.getOuterHTML(i), t = o.serialize(r.parse(t.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function () { return o.serialize(a) }))), i === u ? h.setHTML(u, t) : h.setOuterHTML(i, t) } else { t = o.serialize(a), XP(e, t, i) }KP(e, m), tz(e, h.get('mce_marker')), ZP(e.getBody()), YP(e.dom, e.selection.getStart()), e.fire('SetContent', c), e.addVisual() } }; const rz = function (e) { let t; return typeof e !== 'string' ? (t = vo.extend({ paste: e.paste, data: { paste: e.paste } }, e), { content: e.content, details: t }) : { content: e, details: {} } }; const oz = function (e, t) { const n = rz(t); nz(e, n.content, n.details) }; const iz = { insertAtCaret: oz }; const uz = function (e, t) { e.getDoc().execCommand(t, !1, null) }; const az = function (e) { RA.backspaceDelete(e, !1) || rD.backspaceDelete(e, !1) || cD.backspaceDelete(e, !1) || vD.backspaceDelete(e, !1) || C_.backspaceDelete(e, !1) || sA.backspaceDelete(e) || D_.backspaceDelete(e, !1) || SD.backspaceDelete(e, !1) || (uz(e, 'Delete'), ZN.paddEmptyBody(e)) }; const cz = function (e) { rD.backspaceDelete(e, !0) || cD.backspaceDelete(e, !0) || vD.backspaceDelete(e, !0) || C_.backspaceDelete(e, !0) || sA.backspaceDelete(e) || D_.backspaceDelete(e, !0) || SD.backspaceDelete(e, !0) || uz(e, 'ForwardDelete') }; const sz = { deleteCommand: az, forwardDeleteCommand: cz }; const lz = function (e, t, n) { let r = e.dom(); const o = k(n) ? n : i(!1); while (r.parentNode) { r = r.parentNode; const u = ve.fromDom(r); const a = t(u); if (a.isSome()) { return a } if (o(u)) { break } } return p.none() }; const fz = function (e, t, n) { const r = t(e); return r.orThunk(function () { return n(e) ? p.none() : lz(e, t, n) }) }; const dz = { 'font-size': 'size', 'font-family': 'face' }; const mz = function (e, t, n) { const r = function (t) { return nr(t, e).orThunk(function () { return un(t) === 'font' ? ae(dz, e).bind(function (e) { return Jn(t, e) }) : p.none() }) }; const o = function (e) { return Dt(ve.fromDom(t), e) }; return fz(ve.fromDom(n), function (e) { return r(e) }, o) }; const gz = function (e, t) { const n = Math.pow(10, t); return Math.round(e * n) / n }; const hz = function (e, t) { return /[0-9.]+px$/.test(e) ? gz(72 * parseInt(e, 10) / 96, t || 0) + 'pt' : e }; const pz = function (e) { return e.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',') }; const vz = function (e, t) { return p.from(Va.DOM.getStyle(t, e, !0)) }; const bz = function (e) { return function (t, n) { return p.from(n).map(ve.fromDom).filter(sn).bind(function (n) { return mz(e, t, n.dom()).or(vz(e, n.dom())) }).getOr('') } }; const yz = { getFontSize: bz('font-size'), getFontFamily: o(pz, bz('font-family')), toPt: hz }; const wz = function (e) { return fm.firstPositionIn(e.getBody()).map(function (e) { const t = e.container(); return qn.isText(t) ? t.parentNode : t }) }; const xz = function (e, t) { return e.startContainer === t && e.startOffset === 0 }; const Cz = function (e) { return p.from(e.selection.getRng()).bind(function (t) { const n = e.getBody(); return xz(t, n) ? p.none() : p.from(e.selection.getStart(!0)) }) }; const Sz = function (e, t) { if (/^[0-9\.]+$/.test(t)) { const n = parseInt(t, 10); if (n >= 1 && n <= 7) { const r = id.getFontStyleValues(e); const o = id.getFontSizeClasses(e); return o ? o[n - 1] || t : r[n - 1] || t } return t } return t }; const kz = function (e) { const t = e.split(/\s*,\s*/); return B(t, function (e) { return !e.includes(' ') || et(e, '"') || et(e, "'") ? e : "'" + e + "'" }).join(',') }; const Tz = function (e, t) { const n = Sz(e, t); e.formatter.toggle('fontname', { value: kz(n) }), e.nodeChanged() }; const Ez = function (e) { return Cz(e).fold(function () { return wz(e).map(function (t) { return yz.getFontFamily(e.getBody(), t) }).getOr('') }, function (t) { return yz.getFontFamily(e.getBody(), t) }) }; const Oz = function (e, t) { e.formatter.toggle('fontsize', { value: Sz(e, t) }), e.nodeChanged() }; const Nz = function (e) { return Cz(e).fold(function () { return wz(e).map(function (t) { return yz.getFontSize(e.getBody(), t) }).getOr('') }, function (t) { return yz.getFontSize(e.getBody(), t) }) }; const _z = vo.each; const Dz = vo.map; const Az = vo.inArray; const Rz = (function () { function e (e) { this.commands = { state: {}, exec: {}, value: {} }, this.editor = e, this.setupCommands(e) } return e.prototype.execCommand = function (e, t, n, r) { let o; let i; let u = !1; const a = this; if (!a.editor.removed) { if (/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(e) || r && r.skip_focus ? Vh.restore(a.editor) : a.editor.focus(), r = a.editor.fire('BeforeExecCommand', { command: e, ui: t, value: n }), r.isDefaultPrevented()) { return !1 } if (i = e.toLowerCase(), o = a.commands.exec[i]) { return o(i, t, n), a.editor.fire('ExecCommand', { command: e, ui: t, value: n }), !0 } if (_z(this.editor.plugins, function (r) { if (r.execCommand && r.execCommand(e, t, n)) { return a.editor.fire('ExecCommand', { command: e, ui: t, value: n }), u = !0, !1 } }), u) { return u } if (a.editor.theme && a.editor.theme.execCommand && a.editor.theme.execCommand(e, t, n)) { return a.editor.fire('ExecCommand', { command: e, ui: t, value: n }), !0 } try { u = a.editor.getDoc().execCommand(e, t, n) } catch (c) {} return !!u && (a.editor.fire('ExecCommand', { command: e, ui: t, value: n }), !0) } }, e.prototype.queryCommandState = function (e) { let t; if (!this.editor.quirks.isHidden() && !this.editor.removed) { if (e = e.toLowerCase(), t = this.commands.state[e]) { return t(e) } try { return this.editor.getDoc().queryCommandState(e) } catch (n) {} return !1 } }, e.prototype.queryCommandValue = function (e) { let t; if (!this.editor.quirks.isHidden() && !this.editor.removed) { if (e = e.toLowerCase(), t = this.commands.value[e]) { return t(e) } try { return this.editor.getDoc().queryCommandValue(e) } catch (n) {} } }, e.prototype.addCommands = function (e, t) { const n = this; t = t || 'exec', _z(e, function (e, r) { _z(r.toLowerCase().split(','), function (r) { n.commands[t][r] = e }) }) }, e.prototype.addCommand = function (e, t, n) { const r = this; e = e.toLowerCase(), this.commands.exec[e] = function (e, o, i, u) { return t.call(n || r.editor, o, i, u) } }, e.prototype.queryCommandSupported = function (e) { if (e = e.toLowerCase(), this.commands.exec[e]) { return !0 } try { return this.editor.getDoc().queryCommandSupported(e) } catch (t) {} return !1 }, e.prototype.addQueryStateHandler = function (e, t, n) { const r = this; e = e.toLowerCase(), this.commands.state[e] = function () { return t.call(n || r.editor) } }, e.prototype.addQueryValueHandler = function (e, t, n) { const r = this; e = e.toLowerCase(), this.commands.value[e] = function () { return t.call(n || r.editor) } }, e.prototype.hasCustomCommand = function (e) { return e = e.toLowerCase(), !!this.commands.exec[e] }, e.prototype.execNativeCommand = function (e, t, n) { return void 0 === t && (t = !1), void 0 === n && (n = null), this.editor.getDoc().execCommand(e, t, n) }, e.prototype.isFormatMatch = function (e) { return this.editor.formatter.match(e) }, e.prototype.toggleFormat = function (e, t) { this.editor.formatter.toggle(e, t ? { value: t } : void 0), this.editor.nodeChanged() }, e.prototype.storeSelection = function (e) { this.selectionBookmark = this.editor.selection.getBookmark(e) }, e.prototype.restoreSelection = function () { this.editor.selection.moveToBookmark(this.selectionBookmark) }, e.prototype.setupCommands = function (e) { const t = this; this.addCommands({ 'mceResetDesignMode,mceBeginUndoLevel' () {}, 'mceEndUndoLevel,mceAddUndoLevel' () { e.undoManager.add() }, 'Cut,Copy,Paste' (n) { let r; const o = e.getDoc(); try { t.execNativeCommand(n) } catch (u) { r = !0 } if (n !== 'paste' || o.queryCommandEnabled(n) || (r = !0), r || !o.queryCommandSupported(n)) { let i = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead."); $r.mac && (i = i.replace(/Ctrl\+/g, '⌘+')), e.notificationManager.open({ text: i, type: 'error' }) } }, unlink () { if (e.selection.isCollapsed()) { const t = e.dom.getParent(e.selection.getStart(), 'a'); t && e.dom.remove(t, !0) } else { e.formatter.remove('link') } }, 'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone' (n) { let r = n.substring(7); r === 'full' && (r = 'justify'), _z('left,center,right,justify'.split(','), function (t) { r !== t && e.formatter.remove('align' + t) }), r !== 'none' && t.toggleFormat('align' + r) }, 'InsertUnorderedList,InsertOrderedList' (n) { let r, o; t.execNativeCommand(n), r = e.dom.getParent(e.selection.getNode(), 'ol,ul'), r && (o = r.parentNode, /^(H[1-6]|P|ADDRESS|PRE)$/.test(o.nodeName) && (t.storeSelection(), e.dom.split(o, r), t.restoreSelection())) }, 'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' (e) { t.toggleFormat(e) }, 'ForeColor,HiliteColor' (e, n, r) { t.toggleFormat(e, r) }, FontName (t, n, r) { Tz(e, r) }, FontSize (t, n, r) { Oz(e, r) }, RemoveFormat (t) { e.formatter.remove(t) }, mceBlockQuote () { t.toggleFormat('blockquote') }, FormatBlock (e, n, r) { return t.toggleFormat(r || 'p') }, mceCleanup () { const t = e.selection.getBookmark(); e.setContent(e.getContent()), e.selection.moveToBookmark(t) }, mceRemoveNode (n, r, o) { const i = o || e.selection.getNode(); i !== e.getBody() && (t.storeSelection(), e.dom.remove(i, !0), t.restoreSelection()) }, mceSelectNodeDepth (t, n, r) { let o = 0; e.dom.getParent(e.selection.getNode(), function (t) { if (t.nodeType === 1 && o++ === r) { return e.selection.select(t), !1 } }, e.getBody()) }, mceSelectNode (t, n, r) { e.selection.select(r) }, mceInsertContent (t, n, r) { iz.insertAtCaret(e, r) }, mceInsertRawHTML (t, n, r) { e.selection.setContent('tiny_mce_marker'); const o = e.getContent(); e.setContent(o.replace(/tiny_mce_marker/g, function () { return r })) }, mceInsertNewLine (t, n, r) { XR.insert(e, r) }, mceToggleFormat (e, n, r) { t.toggleFormat(r) }, mceSetContent (t, n, r) { e.setContent(r) }, 'Indent,Outdent' (t) { CA(e, t) }, mceRepaint () {}, InsertHorizontalRule () { e.execCommand('mceInsertContent', !1, '<hr />') }, mceToggleVisualAid () { e.hasVisual = !e.hasVisual, e.addVisual() }, mceReplaceContent (t, n, r) { e.execCommand('mceInsertContent', !1, r.replace(/\{\$selection\}/g, e.selection.getContent({ format: 'text' }))) }, mceInsertLink (t, n, r) { let o; typeof r === 'string' && (r = { href: r }), o = e.dom.getParent(e.selection.getNode(), 'a'), r.href = r.href.replace(/ /g, '%20'), o && r.href || e.formatter.remove('link'), r.href && e.formatter.apply('link', r, o) }, selectAll () { const t = e.dom.getParent(e.selection.getStart(), qn.isContentEditableTrue); if (t) { const n = e.dom.createRng(); n.selectNodeContents(t), e.selection.setRng(n) } }, delete () { sz.deleteCommand(e) }, forwardDelete () { sz.forwardDeleteCommand(e) }, mceNewDocument () { e.setContent('') }, InsertLineBreak (t, n, r) { return NR.insert(e, r), !0 } }); const n = function (t) { return function () { const n = e.selection.isCollapsed() ? [e.dom.getParent(e.selection.getNode(), e.dom.isBlock)] : e.selection.getSelectedBlocks(); const r = Dz(n, function (n) { return !!e.formatter.matchNode(n, t) }); return Az(r, !0) !== -1 } }; t.addCommands({ JustifyLeft: n('alignleft'), JustifyCenter: n('aligncenter'), JustifyRight: n('alignright'), JustifyFull: n('alignjustify'), 'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' (e) { return t.isFormatMatch(e) }, mceBlockQuote () { return t.isFormatMatch('blockquote') }, Outdent () { return bA(e) }, 'InsertUnorderedList,InsertOrderedList' (t) { const n = e.dom.getParent(e.selection.getNode(), 'ul,ol'); return n && (t === 'insertunorderedlist' && n.tagName === 'UL' || t === 'insertorderedlist' && n.tagName === 'OL') } }, 'state'), t.addCommands({ Undo () { e.undoManager.undo() }, Redo () { e.undoManager.redo() } }), t.addQueryValueHandler('FontName', function () { return Ez(e) }, this), t.addQueryValueHandler('FontSize', function () { return Nz(e) }, this) }, e }()); const Bz = vo.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' '); const Mz = (function () { function e (e) { this.bindings = {}, this.settings = e || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || l } return e.isNative = function (e) { return !!Bz[e.toLowerCase()] }, e.prototype.fire = function (e, t) { let n, r, o, i; if (e = e.toLowerCase(), t = t || {}, t.type = e, t.target || (t.target = this.scope), t.preventDefault || (t.preventDefault = function () { t.isDefaultPrevented = f }, t.stopPropagation = function () { t.isPropagationStopped = f }, t.stopImmediatePropagation = function () { t.isImmediatePropagationStopped = f }, t.isDefaultPrevented = l, t.isPropagationStopped = l, t.isImmediatePropagationStopped = l), this.settings.beforeFire && this.settings.beforeFire(t), n = this.bindings[e], n) { for (r = 0, o = n.length; r < o; r++) { if (i = n[r], i.once && this.off(e, i.func), t.isImmediatePropagationStopped()) { return t.stopPropagation(), t } if (!1 === i.func.call(this.scope, t)) { return t.preventDefault(), t } } } return t }, e.prototype.on = function (e, t, n, r) { let o, i, u; if (!1 === t && (t = l), t) { const a = { func: t }; r && vo.extend(a, r), i = e.toLowerCase().split(' '), u = i.length; while (u--) { e = i[u], o = this.bindings[e], o || (o = this.bindings[e] = [], this.toggleEvent(e, !0)), n ? o.unshift(a) : o.push(a) } } return this }, e.prototype.off = function (e, t) { let n, r, o, i, u; if (e) { i = e.toLowerCase().split(' '), n = i.length; while (n--) { if (e = i[n], r = this.bindings[e], !e) { for (o in this.bindings) { this.toggleEvent(o, !1), delete this.bindings[o] } return this } if (r) { if (t) { u = r.length; while (u--) { r[u].func === t && (r = r.slice(0, u).concat(r.slice(u + 1)), this.bindings[e] = r) } } else { r.length = 0 }r.length || (this.toggleEvent(e, !1), delete this.bindings[e]) } } } else { for (e in this.bindings) { this.toggleEvent(e, !1) } this.bindings = {} } return this }, e.prototype.once = function (e, t, n) { return this.on(e, t, n, { once: !0 }) }, e.prototype.has = function (e) { return e = e.toLowerCase(), !(!this.bindings[e] || this.bindings[e].length === 0) }, e }()); const Pz = function (e) { return e._eventDispatcher || (e._eventDispatcher = new Mz({ scope: e, toggleEvent (t, n) { Mz.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, n) } })), e._eventDispatcher }; const zz = { fire (e, t, n) { const r = this; if (r.removed && e !== 'remove' && e !== 'detach') { return t } const o = Pz(r).fire(e, t); if (!1 !== n && r.parent) { let i = r.parent(); while (i && !o.isPropagationStopped()) { i.fire(e, o, !1), i = i.parent() } } return o }, on (e, t, n) { return Pz(this).on(e, t, n) }, off (e, t) { return Pz(this).off(e, t) }, once (e, t) { return Pz(this).once(e, t) }, hasEventListeners (e) { return Pz(this).has(e) } }; const Iz = 'data-mce-contenteditable'; const Lz = function (e, t, n) { Sc(e, t) && !1 === n ? Cc(e, t) : n && wc(e, t) }; const Hz = function (e, t, n) { try { e.getDoc().execCommand(t, !1, n) } catch (r) {} }; const Fz = function (e, t) { e.dom().contentEditable = t ? 'true' : 'false' }; const Vz = function (e) { M(Tc(e, '*[contenteditable="true"]'), function (e) { Xn(e, Iz, 'true'), Fz(e, !1) }) }; const Uz = function (e) { M(Tc(e, '*[' + Iz + '="true"]'), function (e) { Qn(e, Iz), Fz(e, !0) }) }; const jz = function (e) { p.from(e.selection.getNode()).each(function (e) { e.removeAttribute('data-mce-selected') }) }; const Wz = function (e) { e.selection.setRng(e.selection.getRng()) }; const qz = function (e, t) { const n = ve.fromDom(e.getBody()); Lz(n, 'mce-content-readonly', t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), jz(e), e.readonly = !0, Fz(n, !1), Vz(n)) : (e.readonly = !1, Fz(n, !0), Uz(n), Hz(e, 'StyleWithCSS', !1), Hz(e, 'enableInlineTableEditing', !1), Hz(e, 'enableObjectResizing', !1), wp.hasEditorOrUiFocus(e) && e.focus(), Wz(e), e.nodeChanged()) }; const $z = function (e) { return e.readonly }; const Gz = function (e) { e.parser.addAttributeFilter('contenteditable', function (t) { $z(e) && M(t, function (e) { e.attr(Iz, e.attr('contenteditable')), e.attr('contenteditable', 'false') }) }), e.serializer.addAttributeFilter(Iz, function (t) { $z(e) && M(t, function (e) { e.attr('contenteditable', e.attr(Iz)) }) }), e.serializer.addTempAttr(Iz) }; const Xz = function (e) { e.serializer ? Gz(e) : e.on('PreInit', function () { Gz(e) }) }; const Yz = function (e) { return e.type === 'click' }; const Kz = function (e, t) { return e.dom.getParent(t, 'a') !== null }; const Jz = function (e, t) { const n = t.target; Yz(t) && !lb.metaKeyPressed(t) && Kz(e, n) && t.preventDefault() }; const Zz = function (e) { e.on('ShowCaret', function (t) { $z(e) && t.preventDefault() }), e.on('ObjectSelected', function (t) { $z(e) && t.preventDefault() }) }; const Qz = Va.DOM; const eI = function (e, t) { return t === 'selectionchange' ? e.getDoc() : !e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(t) ? e.getDoc().documentElement : e.settings.event_root ? (e.eventRoot || (e.eventRoot = Qz.select(e.settings.event_root)[0]), e.eventRoot) : e.getBody() }; const tI = function (e) { return !e.hidden && !$z(e) }; const nI = function (e, t, n) { tI(e) ? e.fire(t, n) : $z(e) && Jz(e, n) }; const rI = function (e, t) { let n, r; if (e.delegates || (e.delegates = {}), !e.delegates[t] && !e.removed) { if (n = eI(e, t), e.settings.event_root) { if (kO || (kO = {}, e.editorManager.on('removeEditor', function () { let t; if (!e.editorManager.activeEditor && kO) { for (t in kO) { e.dom.unbind(eI(e, t)) }kO = null } })), kO[t]) { return } r = function (n) { const r = n.target; const o = e.editorManager.get(); let i = o.length; while (i--) { const u = o[i].getBody(); (u === r || Qz.isChildOf(r, u)) && nI(o[i], t, n) } }, kO[t] = r, Qz.bind(n, t, r) } else { r = function (n) { nI(e, t, n) }, Qz.bind(n, t, r), e.delegates[t] = r } } }; const oI = se(se({}, zz), { bindPendingEventDelegates () { const e = this; vo.each(e._pendingNativeEvents, function (t) { rI(e, t) }) }, toggleNativeEvent (e, t) { const n = this; e !== 'focus' && e !== 'blur' && (t ? n.initialized ? rI(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [e] : n.initialized && (n.dom.unbind(eI(n, e), e, n.delegates[e]), delete n.delegates[e])) }, unbindAllNativeEvents () { let e; const t = this; const n = t.getBody(); const r = t.dom; if (t.delegates) { for (e in t.delegates) { t.dom.unbind(eI(t, e), e, t.delegates[e]) } delete t.delegates }!t.inline && n && r && (n.onload = null, r.unbind(t.getWin()), r.unbind(t.getDoc())), r && (r.unbind(n), r.unbind(t.getContainer())) } }); const iI = ['design', 'readonly']; const uI = function (e, t, r, o) { const i = r[t.get()]; const u = r[o]; try { u.activate() } catch (OL) { return void n.console.error('problem while activating editor mode ' + o + ':', OL) }i.deactivate(), i.editorReadOnly !== u.editorReadOnly && qz(e, u.editorReadOnly), t.set(o), Rp(e, o) }; const aI = function (e, t, n, r) { if (r !== n.get()) { if (!ce(t, r)) { throw new Error("Editor mode '" + r + "' is invalid") } e.initialized ? uI(e, n, t, r) : e.on('init', function () { return uI(e, n, t, r) }) } }; const cI = function (e, t, r) { let o; if (A(iI, t)) { throw new Error('Cannot override default mode ' + t) } return se(se({}, e), (o = {}, o[t] = se(se({}, r), { deactivate () { try { r.deactivate() } catch (OL) { n.console.error('problem while deactivating editor mode ' + t + ':', OL) } } }), o)) }; const sI = function (e) { const t = be('design'); const n = be({ design: { activate: r, deactivate: r, editorReadOnly: !1 }, readonly: { activate: r, deactivate: r, editorReadOnly: !0 } }); return Xz(e), Zz(e), { isReadOnly () { return $z(e) }, set (r) { return aI(e, n.get(), t, r) }, get () { return t.get() }, register (e, t) { n.set(cI(n.get(), e, t)) } } }; const lI = vo.each; const fI = vo.explode; const dI = { f1: 112, f2: 113, f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123 }; const mI = vo.makeMap('alt,ctrl,shift,meta,access'); const gI = (function () { function e (e) { this.shortcuts = {}, this.pendingPatterns = [], this.editor = e; const t = this; e.on('keyup keypress keydown', function (e) { !t.hasModifier(e) && !t.isFunctionKey(e) || e.isDefaultPrevented() || (lI(t.shortcuts, function (n) { if (t.matchShortcut(e, n)) { return t.pendingPatterns = n.subpatterns.slice(0), e.type === 'keydown' && t.executeShortcutAction(n), !0 } }), t.matchShortcut(e, t.pendingPatterns[0]) && (t.pendingPatterns.length === 1 && e.type === 'keydown' && t.executeShortcutAction(t.pendingPatterns[0]), t.pendingPatterns.shift())) }) } return e.prototype.add = function (e, t, n, r) { let o; const i = this; return o = n, typeof n === 'string' ? n = function () { i.editor.execCommand(o, !1, null) } : vo.isArray(o) && (n = function () { i.editor.execCommand(o[0], o[1], o[2]) }), lI(fI(vo.trim(e)), function (e) { const o = i.createShortcut(e, t, n, r); i.shortcuts[o.id] = o }), !0 }, e.prototype.remove = function (e) { const t = this.createShortcut(e); return !!this.shortcuts[t.id] && (delete this.shortcuts[t.id], !0) }, e.prototype.parseShortcut = function (e) { let t; let n; const r = {}; for (n in lI(fI(e.toLowerCase(), '+'), function (e) { e in mI ? r[e] = !0 : /^[0-9]{2,}$/.test(e) ? r.keyCode = parseInt(e, 10) : (r.charCode = e.charCodeAt(0), r.keyCode = dI[e] || e.toUpperCase().charCodeAt(0)) }), t = [r.keyCode], mI) { r[n] ? t.push(n) : r[n] = !1 } return r.id = t.join(','), r.access && (r.alt = !0, $r.mac ? r.ctrl = !0 : r.shift = !0), r.meta && ($r.mac ? r.meta = !0 : (r.ctrl = !0, r.meta = !1)), r }, e.prototype.createShortcut = function (e, t, n, r) { let o; return o = vo.map(fI(e, '>'), this.parseShortcut), o[o.length - 1] = vo.extend(o[o.length - 1], { func: n, scope: r || this.editor }), vo.extend(o[0], { desc: this.editor.translate(t), subpatterns: o.slice(1) }) }, e.prototype.hasModifier = function (e) { return e.altKey || e.ctrlKey || e.metaKey }, e.prototype.isFunctionKey = function (e) { return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123 }, e.prototype.matchShortcut = function (e, t) { return !!t && (t.ctrl === e.ctrlKey && t.meta === e.metaKey && (t.alt === e.altKey && t.shift === e.shiftKey && (!!(e.keyCode === t.keyCode || e.charCode && e.charCode === t.charCode) && (e.preventDefault(), !0)))) }, e.prototype.executeShortcutAction = function (e) { return e.func ? e.func.call(e.scope) : null }, e }()); const hI = function () { const e = {}; const t = {}; const n = {}; const r = {}; const o = {}; const i = {}; const u = {}; const a = function (e, t) { return function (n, r) { return e[n.toLowerCase()] = se(se({}, r), { type: t }) } }; const c = function (e, t) { return r[e.toLowerCase()] = t }; return { addButton: a(e, 'button'), addGroupToolbarButton: a(e, 'grouptoolbarbutton'), addToggleButton: a(e, 'togglebutton'), addMenuButton: a(e, 'menubutton'), addSplitButton: a(e, 'splitbutton'), addMenuItem: a(t, 'menuitem'), addNestedMenuItem: a(t, 'nestedmenuitem'), addToggleMenuItem: a(t, 'togglemenuitem'), addAutocompleter: a(n, 'autocompleter'), addContextMenu: a(o, 'contextmenu'), addContextToolbar: a(i, 'contexttoolbar'), addContextForm: a(i, 'contextform'), addSidebar: a(u, 'sidebar'), addIcon: c, getAll () { return { buttons: e, menuItems: t, icons: r, popups: n, contextMenus: o, contextToolbars: i, sidebars: u } } } }; const pI = function () { const e = hI(); return { addAutocompleter: e.addAutocompleter, addButton: e.addButton, addContextForm: e.addContextForm, addContextMenu: e.addContextMenu, addContextToolbar: e.addContextToolbar, addIcon: e.addIcon, addMenuButton: e.addMenuButton, addMenuItem: e.addMenuItem, addNestedMenuItem: e.addNestedMenuItem, addSidebar: e.addSidebar, addSplitButton: e.addSplitButton, addToggleButton: e.addToggleButton, addGroupToolbarButton: e.addGroupToolbarButton, addToggleMenuItem: e.addToggleMenuItem, getAll: e.getAll } }; const vI = vo.each; const bI = vo.trim; const yI = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' '); const wI = { ftp: 21, http: 80, https: 443, mailto: 25 }; const xI = (function () { function e (t, r) { t = bI(t), this.settings = r || {}; const o = this.settings.base_uri; const i = this; if (/^([\w\-]+):([^\/]{2})/i.test(t) || /^\s*#/.test(t)) { i.source = t } else { const u = t.indexOf('//') === 0; if (t.indexOf('/') !== 0 || u || (t = (o && o.protocol || 'http') + '://mce_host' + t), !/^[\w\-]*:?\/\//.test(t)) { const a = this.settings.base_uri ? this.settings.base_uri.path : new e(n.document.location.href).directory; if (this.settings.base_uri && this.settings.base_uri.protocol == '') { t = '//mce_host' + i.toAbsPath(a, t) } else { const c = /([^#?]*)([#?]?.*)/.exec(t); t = (o && o.protocol || 'http') + '://mce_host' + i.toAbsPath(a, c[1]) + c[2] } }t = t.replace(/@@/g, '(mce_at)'); const s = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(t); vI(yI, function (e, t) { let n = s[t]; n && (n = n.replace(/\(mce_at\)/g, '@@')), i[e] = n }), o && (i.protocol || (i.protocol = o.protocol), i.userInfo || (i.userInfo = o.userInfo), i.port || i.host !== 'mce_host' || (i.port = o.port), i.host && i.host !== 'mce_host' || (i.host = o.host), i.source = ''), u && (i.protocol = '') } } return e.parseDataUri = function (e) { let t; const n = decodeURIComponent(e).split(','); const r = /data:([^;]+)/.exec(n[0]); return r && (t = r[1]), { type: t, data: n[1] } }, e.getDocumentBaseUrl = function (e) { let t; return t = e.protocol.indexOf('http') !== 0 && e.protocol !== 'file:' ? e.href : e.protocol + '//' + e.host + e.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(t) && (t = t.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, ''), /[\/\\]$/.test(t) || (t += '/')), t }, e.prototype.setPath = function (e) { const t = /^(.*?)\/?(\w+)?$/.exec(e); this.path = t[0], this.directory = t[1], this.file = t[2], this.source = '', this.getURI() }, e.prototype.toRelative = function (t) { let n; if (t === './') { return t } const r = new e(t, { base_uri: this }); if (r.host !== 'mce_host' && this.host !== r.host && r.host || this.port !== r.port || this.protocol !== r.protocol && r.protocol !== '') { return r.getURI() } const o = this.getURI(); const i = r.getURI(); return o === i || o.charAt(o.length - 1) === '/' && o.substr(0, o.length - 1) === i ? o : (n = this.toRelPath(this.path, r.path), r.query && (n += '?' + r.query), r.anchor && (n += '#' + r.anchor), n) }, e.prototype.toAbsolute = function (t, n) { const r = new e(t, { base_uri: this }); return r.getURI(n && this.isSameOrigin(r)) }, e.prototype.isSameOrigin = function (e) { if (this.host == e.host && this.protocol == e.protocol) { if (this.port == e.port) { return !0 } const t = wI[this.protocol]; if (t && (this.port || t) == (e.port || t)) { return !0 } } return !1 }, e.prototype.toRelPath = function (e, t) { let n; let r; let o; let i = 0; let u = ''; const a = e.substring(0, e.lastIndexOf('/')).split('/'); if (n = t.split('/'), a.length >= n.length) { for (r = 0, o = a.length; r < o; r++) { if (r >= n.length || a[r] !== n[r]) { i = r + 1; break } } } if (a.length < n.length) { for (r = 0, o = n.length; r < o; r++) { if (r >= a.length || a[r] !== n[r]) { i = r + 1; break } } } if (i === 1) { return t } for (r = 0, o = a.length - (i - 1); r < o; r++) { u += '../' } for (r = i - 1, o = n.length; r < o; r++) { u += r !== i - 1 ? '/' + n[r] : n[r] } return u }, e.prototype.toAbsPath = function (e, t) { let n; let r; let o; let i = 0; let u = []; r = /\/$/.test(t) ? '/' : ''; let a = e.split('/'); const c = t.split('/'); for (vI(a, function (e) { e && u.push(e) }), a = u, n = c.length - 1, u = []; n >= 0; n--) { c[n].length !== 0 && c[n] !== '.' && (c[n] !== '..' ? i > 0 ? i-- : u.push(c[n]) : i++) } return n = a.length - i, o = n <= 0 ? q(u).join('/') : a.slice(0, n).join('/') + '/' + q(u).join('/'), o.indexOf('/') !== 0 && (o = '/' + o), r && o.lastIndexOf('/') !== o.length - 1 && (o += r), o }, e.prototype.getURI = function (e) { let t; return void 0 === e && (e = !1), this.source && !e || (t = '', e || (this.protocol ? t += this.protocol + '://' : t += '//', this.userInfo && (t += this.userInfo + '@'), this.host && (t += this.host), this.port && (t += ':' + this.port)), this.path && (t += this.path), this.query && (t += '?' + this.query), this.anchor && (t += '#' + this.anchor), this.source = t), this.source }, e }()); const CI = Va.DOM; const SI = vo.extend; const kI = vo.each; const TI = vo.resolve; const EI = $r.ie; const OI = (function () { function e (e, t, n) { const r = this; this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.editorManager = n, this.documentBaseUrl = n.documentBaseURL, SI(this, oI), this.settings = yv(this, e, this.documentBaseUrl, n.defaultSettings, t), this.settings.suffix && (n.suffix = this.settings.suffix), this.suffix = n.suffix, this.settings.base_url && n._setBaseUrl(this.settings.base_url), this.baseUri = n.baseURI, this.settings.referrer_policy && (Ya.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy), Va.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy)), lc.languageLoad = this.settings.language_load, lc.baseURL = n.baseURL, this.id = e, this.setDirty(!1), this.documentBaseURI = new xI(this.settings.document_base_url, { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = !!this.settings.inline, this.shortcuts = new gI(this), this.editorCommands = new Rz(this), this.settings.cache_suffix && ($r.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, '')), this.ui = { registry: pI() }; const o = this; const i = sI(o); this.mode = i, this.setMode = i.set, n.fire('SetupEditor', { editor: this }), this.execCallback('setup', this), this.$ = Da.overrideDefaults(function () { return { context: r.inline ? r.getBody() : r.getDoc(), element: r.getBody() } }) } return e.prototype.render = function () { wP.render(this) }, e.prototype.focus = function (e) { wp.focus(this, e) }, e.prototype.hasFocus = function () { return wp.hasFocus(this) }, e.prototype.execCallback = function (e) { for (let t = [], n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n] } let r; const o = this; let i = o.settings[e]; if (i) { return o.callbackLookup && (r = o.callbackLookup[e]) && (i = r.func, r = r.scope), typeof i === 'string' && (r = i.replace(/\.\w+$/, ''), r = r ? TI(r) : 0, i = TI(i), o.callbackLookup = o.callbackLookup || {}, o.callbackLookup[e] = { func: i, scope: r }), i.apply(r || o, Array.prototype.slice.call(arguments, 1)) } }, e.prototype.translate = function (e) { return cc.translate(e) }, e.prototype.getParam = function (e, t, n) { return Sv(this, e, t, n) }, e.prototype.nodeChanged = function (e) { this._nodeChangeDispatcher.nodeChanged(e) }, e.prototype.addCommand = function (e, t, n) { this.editorCommands.addCommand(e, t, n) }, e.prototype.addQueryStateHandler = function (e, t, n) { this.editorCommands.addQueryStateHandler(e, t, n) }, e.prototype.addQueryValueHandler = function (e, t, n) { this.editorCommands.addQueryValueHandler(e, t, n) }, e.prototype.addShortcut = function (e, t, n, r) { this.shortcuts.add(e, t, n, r) }, e.prototype.execCommand = function (e, t, n, r) { return this.editorCommands.execCommand(e, t, n, r) }, e.prototype.queryCommandState = function (e) { return this.editorCommands.queryCommandState(e) }, e.prototype.queryCommandValue = function (e) { return this.editorCommands.queryCommandValue(e) }, e.prototype.queryCommandSupported = function (e) { return this.editorCommands.queryCommandSupported(e) }, e.prototype.show = function () { const e = this; e.hidden && (e.hidden = !1, e.inline ? e.getBody().contentEditable = 'true' : (CI.show(e.getContainer()), CI.hide(e.id)), e.load(), e.fire('show')) }, e.prototype.hide = function () { const e = this; const t = e.getDoc(); e.hidden || (EI && t && !e.inline && t.execCommand('SelectAll'), e.save(), e.inline ? (e.getBody().contentEditable = 'false', e === e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) : (CI.hide(e.getContainer()), CI.setStyle(e.id, 'display', e.orgDisplay)), e.hidden = !0, e.fire('hide')) }, e.prototype.isHidden = function () { return !!this.hidden }, e.prototype.setProgressState = function (e, t) { this.fire('ProgressState', { state: e, time: t }) }, e.prototype.load = function (e) { let t; const n = this; let r = n.getElement(); if (n.removed) { return '' } if (r) { e = e || {}, e.load = !0; const o = qn.isTextareaOrInput(r) ? r.value : r.innerHTML; return t = n.setContent(o, e), e.element = r, e.no_events || n.fire('LoadContent', e), e.element = r = null, t } }, e.prototype.save = function (e) { let t; let n; const r = this; let o = r.getElement(); if (o && r.initialized && !r.removed) { return e = e || {}, e.save = !0, e.element = o, t = e.content = r.getContent(e), e.no_events || r.fire('SaveContent', e), e.format === 'raw' && r.fire('RawSaveContent', e), t = e.content, qn.isTextareaOrInput(o) ? o.value = t : (!e.is_removing && r.inline || (o.innerHTML = t), (n = CI.getParent(r.id, 'form')) && kI(n.elements, function (e) { if (e.name === r.id) { return e.value = t, !1 } })), e.element = o = null, !1 !== e.set_dirty && r.setDirty(!1), t } }, e.prototype.setContent = function (e, t) { return Op(this, e, t) }, e.prototype.getContent = function (e) { return Kg(this, e) }, e.prototype.insertContent = function (e, t) { t && (e = SI({ content: e }, t)), this.execCommand('mceInsertContent', !1, e) }, e.prototype.resetContent = function (e) { void 0 === e ? Op(this, this.startContent, { format: 'raw' }) : Op(this, e), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged() }, e.prototype.isDirty = function () { return !this.isNotDirty }, e.prototype.setDirty = function (e) { const t = !this.isNotDirty; this.isNotDirty = !e, e && e !== t && this.fire('dirty') }, e.prototype.getContainer = function () { const e = this; return e.container || (e.container = CI.get(e.editorContainer || e.id + '_parent')), e.container }, e.prototype.getContentAreaContainer = function () { return this.contentAreaContainer }, e.prototype.getElement = function () { return this.targetElm || (this.targetElm = CI.get(this.id)), this.targetElm }, e.prototype.getWin = function () { let e; const t = this; return t.contentWindow || (e = t.iframeElement, e && (t.contentWindow = e.contentWindow)), t.contentWindow }, e.prototype.getDoc = function () { let e; const t = this; return t.contentDocument || (e = t.getWin(), e && (t.contentDocument = e.document)), t.contentDocument }, e.prototype.getBody = function () { const e = this.getDoc(); return this.bodyElement || (e ? e.body : null) }, e.prototype.convertURL = function (e, t, n) { const r = this; const o = r.settings; return o.urlconverter_callback ? r.execCallback('urlconverter_callback', e, n, !0, t) : !o.convert_urls || n && n.nodeName === 'LINK' || e.indexOf('file:') === 0 || e.length === 0 ? e : o.relative_urls ? r.documentBaseURI.toRelative(e) : (e = r.documentBaseURI.toAbsolute(e, o.remove_script_host), e) }, e.prototype.addVisual = function (e) { let t; const n = this; const r = n.settings; const o = n.dom; e = e || n.getBody(), void 0 === n.hasVisual && (n.hasVisual = r.visual), kI(o.select('table,a', e), function (e) { let i; switch (e.nodeName) { case 'TABLE':return t = r.visual_table_class || 'mce-item-table', i = o.getAttrib(e, 'border'), void (i && i !== '0' || !n.hasVisual ? o.removeClass(e, t) : o.addClass(e, t)); case 'A':return void (o.getAttrib(e, 'href') || (i = o.getAttrib(e, 'name') || e.id, t = r.visual_anchor_class || 'mce-item-anchor', i && n.hasVisual ? o.addClass(e, t) : o.removeClass(e, t))) } }), n.fire('VisualAid', { element: e, hasVisual: n.hasVisual }) }, e.prototype.remove = function () { qp(this) }, e.prototype.destroy = function (e) { $p(this, e) }, e.prototype.uploadImages = function (e) { return this.editorUpload.uploadImages(e) }, e.prototype._scanForImages = function () { return this.editorUpload.scanForImages() }, e.prototype.addButton = function () { throw new Error('editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead') }, e.prototype.addSidebar = function () { throw new Error('editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead') }, e.prototype.addMenuItem = function () { throw new Error('editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead') }, e.prototype.addContextToolbar = function () { throw new Error('editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead') }, e }()); const NI = Va.DOM; const _I = vo.explode; const DI = vo.each; const AI = vo.extend; let RI = 0; let BI = !1; const MI = []; let PI = []; const zI = function (e) { return e !== 'length' }; const II = function (e) { const t = e.type; DI(UI.get(), function (n) { switch (t) { case 'scroll':n.fire('ScrollWindow', e); break; case 'resize':n.fire('ResizeWindow', e); break } }) }; const LI = function (e) { e !== BI && (e ? Da(window).on('resize scroll', II) : Da(window).off('resize scroll', II), BI = e) }; const HI = function (e) { const t = PI; delete MI[e.id]; for (let n = 0; n < MI.length; n++) { if (MI[n] === e) { MI.splice(n, 1); break } } return PI = I(PI, function (t) { return e !== t }), UI.activeEditor === e && (UI.activeEditor = PI.length > 0 ? PI[0] : null), UI.focusedEditor === e && (UI.focusedEditor = null), t.length !== PI.length }; const FI = function (e) { return e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (HI(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0, e = null), e }; const VI = n.document.compatMode !== 'CSS1Compat'; var UI = se(se({}, zz), { baseURI: null, baseURL: null, defaultSettings: {}, documentBaseURL: null, suffix: null, $: Da, majorVersion: '5', minorVersion: '2.2', releaseDate: '2020-04-23', editors: MI, i18n: cc, activeEditor: null, focusedEditor: null, settings: {}, setup () { let e; let t; const r = this; let o = ''; t = xI.getDocumentBaseUrl(n.document.location), /^[^:]+:\/\/\/?[^\/]+\//.test(t) && (t = t.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, ''), /[\/\\]$/.test(t) || (t += '/')); const i = window.tinymce || window.tinyMCEPreInit; if (i) { e = i.base || i.baseURL, o = i.suffix } else { for (let u = n.document.getElementsByTagName('script'), a = 0; a < u.length; a++) { var c = u[a].src || ''; if (c !== '') { const s = c.substring(c.lastIndexOf('/')); if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(c)) { s.includes('.min') && (o = '.min'), e = c.substring(0, c.lastIndexOf('/')); break } } } if (!e && n.document.currentScript) { c = n.document.currentScript.src; c.includes('.min') && (o = '.min'), e = c.substring(0, c.lastIndexOf('/')) } }r.baseURL = new xI(t).toAbsolute(e), r.documentBaseURL = t, r.baseURI = new xI(r.baseURL), r.suffix = o, ip.setup(r) }, overrideDefaults (e) { let t, n; t = e.base_url, t && this._setBaseUrl(t), n = e.suffix, e.suffix && (this.suffix = n), this.defaultSettings = e; const r = e.plugin_base_urls; for (const o in r) { lc.PluginManager.urls[o] = r[o] } }, init (e) { let t; let r; const o = this; r = vo.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' '); const i = function (e, t) { return e.inline && t.tagName.toLowerCase() in r }; const u = function (e) { let t = e.id; return t || (t = e.name, t = t && !NI.get(t) ? e.name : NI.uniqueId(), e.setAttribute('id', t)), t }; const a = function (t) { const n = e[t]; if (n) { return n.apply(o, Array.prototype.slice.call(arguments, 2)) } }; const c = function (e, t) { return t.constructor === RegExp ? t.test(e.className) : NI.hasClass(e, t) }; const s = function (e) { let t; let r = []; if ($r.browser.isIE() && $r.browser.version.major < 11) { return tb.initError('TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/'), [] } if (VI) { return tb.initError('Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.'), [] } if (e.types) { return DI(e.types, function (e) { r = r.concat(NI.select(e.selector)) }), r } if (e.selector) { return NI.select(e.selector) } if (e.target) { return [e.target] } switch (e.mode) { case 'exact':t = e.elements || '', t.length > 0 && DI(_I(t), function (e) { let t; (t = NI.get(e)) ? r.push(t) : DI(n.document.forms, function (t) { DI(t.elements, function (t) { t.name === e && (e = 'mce_editor_' + RI++, NI.setAttrib(t, 'id', e), r.push(t)) }) }) }); break; case 'textareas':case 'specific_textareas':DI(NI.select('textarea'), function (t) { e.editor_deselector && c(t, e.editor_deselector) || e.editor_selector && !c(t, e.editor_selector) || r.push(t) }); break } return r }; let l = function (e) { t = e }; var f = function () { let t; let n = 0; const r = []; const c = function (e, i, u) { const a = new OI(e, i, o); r.push(a), a.on('init', function () { ++n === t.length && l(r) }), a.targetElm = a.targetElm || u, a.render() }; NI.unbind(window, 'ready', f), a('onpageload'), t = Da.unique(s(e)), e.types ? DI(e.types, function (n) { vo.each(t, function (t) { return !NI.is(t, n.selector) || (c(u(t), AI({}, e, n), t), !1) }) }) : (vo.each(t, function (e) { FI(o.get(e.id)) }), t = vo.grep(t, function (e) { return !o.get(e.id) }), t.length === 0 ? l([]) : DI(t, function (t) { i(e, t) ? tb.initError('Could not initialize inline editor on invalid inline target element', t) : c(u(t), e, t) })) }; return o.settings = e, NI.bind(window, 'ready', f), new Dr(function (e) { t ? e(t) : l = function (t) { e(t) } }) }, get (e) { return arguments.length === 0 ? PI.slice(0) : y(e) ? F(PI, function (t) { return t.id === e }).getOr(null) : T(e) && PI[e] ? PI[e] : null }, add (e) { let t; const n = this; return t = MI[e.id], t === e ? e : (n.get(e.id) === null && (zI(e.id) && (MI[e.id] = e), MI.push(e), PI.push(e)), LI(!0), n.activeEditor = e, n.fire('AddEditor', { editor: e }), TO || (TO = function (e) { const t = n.fire('BeforeUnload'); if (t.returnValue) { return e.preventDefault(), e.returnValue = t.returnValue, t.returnValue } }, window.addEventListener('beforeunload', TO)), e) }, createEditor (e, t) { return this.add(new OI(e, t, this)) }, remove (e) { let t; let n; const r = this; if (e) { if (!y(e)) { return n = e, C(r.get(n.id)) ? null : (HI(n) && r.fire('RemoveEditor', { editor: n }), PI.length === 0 && window.removeEventListener('beforeunload', TO), n.remove(), LI(PI.length > 0), n) } DI(NI.select(e), function (e) { n = r.get(e.id), n && r.remove(n) }) } else { for (t = PI.length - 1; t >= 0; t--) { r.remove(PI[t]) } } }, execCommand (e, t, n) { const r = this; const o = r.get(n); switch (e) { case 'mceAddEditor':return r.get(n) || new OI(n, r.settings, r).render(), !0; case 'mceRemoveEditor':return o && o.remove(), !0; case 'mceToggleEditor':return o ? (o.isHidden() ? o.show() : o.hide(), !0) : (r.execCommand('mceAddEditor', 0, n), !0) } return !!r.activeEditor && r.activeEditor.execCommand(e, t, n) }, triggerSave () { DI(PI, function (e) { e.save() }) }, addI18n (e, t) { cc.add(e, t) }, translate (e) { return cc.translate(e) }, setActive (e) { const t = this.activeEditor; this.activeEditor !== e && (t && t.fire('deactivate', { relatedTarget: e }), e.fire('activate', { relatedTarget: t })), this.activeEditor = e }, _setBaseUrl (e) { this.baseURL = new xI(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, '')), this.baseURI = new xI(this.baseURL) } }); function jI (e) { const t = function (t, n) { return vg.walk(e, t, n) }; const n = Jx; const r = function (t) { return pw.normalize(e, t).fold(i(!1), function (e) { return t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), !0 }) }; return { walk: t, split: n, normalize: r } }UI.setup(), (function (e) { e.compareRanges = rw.isEq, e.getCaretRangeFromPoint = Zb.fromPoint, e.getSelectedNode = Fs, e.getNode = Vs }(jI || (jI = {}))); let WI; let qI; const $I = jI; const GI = function (e, t, r) { void 0 === r && (r = 1e3); let o = !1; let i = null; const u = function (e) { return function () { for (var t = [], r = 0; r < arguments.length; r++) { t[r] = arguments[r] }o || (o = !0, i !== null && (n.clearTimeout(i), i = null), e.apply(null, t)) } }; const a = u(e); const c = u(t); const s = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] }o || i !== null || (i = n.setTimeout(function () { return c.apply(null, e) }, r)) }; return { start: s, resolve: a, reject: c } }; const XI = function () { const e = {}; const t = {}; const n = function (n, r) { const o = 'Script at URL "' + r + '" failed to load'; const i = 'Script at URL "' + r + "\" did not call `tinymce.Resource.add('" + n + "', data)` within 1 second"; if (void 0 !== e[n]) { return e[n] } const u = new Dr(function (e, u) { const a = GI(e, u); t[n] = a.resolve, Ya.ScriptLoader.loadScript(r, function () { return a.start(i) }, function () { return a.reject(o) }) }); return e[n] = u, u }; const r = function (n, r) { void 0 !== t[n] && (t[n](r), delete t[n]), e[n] = Dr.resolve(r) }; return { load: n, add: r } }; const YI = XI(); const KI = Math.min; const JI = Math.max; const ZI = Math.round; const QI = function (e, t, n) { let r, o, i, u, a, c; return r = t.x, o = t.y, i = e.w, u = e.h, a = t.w, c = t.h, n = (n || '').split(''), n[0] === 'b' && (o += c), n[1] === 'r' && (r += a), n[0] === 'c' && (o += ZI(c / 2)), n[1] === 'c' && (r += ZI(a / 2)), n[3] === 'b' && (o -= u), n[4] === 'r' && (r -= i), n[3] === 'c' && (o -= ZI(u / 2)), n[4] === 'c' && (r -= ZI(i / 2)), oL(r, o, i, u) }; const eL = function (e, t, n, r) { let o, i; for (i = 0; i < r.length; i++) { if (o = QI(e, t, r[i]), o.x >= n.x && o.x + o.w <= n.w + n.x && o.y >= n.y && o.y + o.h <= n.h + n.y) { return r[i] } } return null }; const tL = function (e, t, n) { return oL(e.x - t, e.y - n, e.w + 2 * t, e.h + 2 * n) }; const nL = function (e, t) { let n, r, o, i; return n = JI(e.x, t.x), r = JI(e.y, t.y), o = KI(e.x + e.w, t.x + t.w), i = KI(e.y + e.h, t.y + t.h), o - n < 0 || i - r < 0 ? null : oL(n, r, o - n, i - r) }; const rL = function (e, t, n) { let r, o, i, u, a, c, s, l, f, d; return a = e.x, c = e.y, s = e.x + e.w, l = e.y + e.h, f = t.x + t.w, d = t.y + t.h, r = JI(0, t.x - a), o = JI(0, t.y - c), i = JI(0, s - f), u = JI(0, l - d), a += r, c += o, n && (s += r, l += o, a -= i, c -= u), s -= i, l -= u, oL(a, c, s - a, l - c) }; var oL = function (e, t, n, r) { return { x: e, y: t, w: n, h: r } }; const iL = function (e) { return oL(e.left, e.top, e.width, e.height) }; const uL = { inflate: tL, relativePosition: QI, findBestRelativePosition: eL, intersect: nL, clamp: rL, create: oL, fromClientRect: iL }; const aL = vo.each; const cL = vo.extend; const sL = function () {}; sL.extend = WI = function (e) { let t; let n; let r; const o = this; const i = o.prototype; const u = function () { let e; let t; let n; const r = this; if (!qI && (r.init && r.init.apply(r, arguments), t = r.Mixins, t)) { e = t.length; while (e--) { n = t[e], n.init && n.init.apply(r, arguments) } } }; const a = function () { return this }; const c = function (e, t) { return function () { let n; const r = this; const o = r._super; return r._super = i[e], n = t.apply(r, arguments), r._super = o, n } }; for (n in qI = !0, t = new o(), qI = !1, e.Mixins && (aL(e.Mixins, function (t) { for (const n in t) { n !== 'init' && (e[n] = t[n]) } }), i.Mixins && (e.Mixins = i.Mixins.concat(e.Mixins))), e.Methods && aL(e.Methods.split(','), function (t) { e[t] = a }), e.Properties && aL(e.Properties.split(','), function (t) { const n = '_' + t; e[t] = function (e) { const t = this; return void 0 !== e ? (t[n] = e, t) : t[n] } }), e.Statics && aL(e.Statics, function (e, t) { u[t] = e }), e.Defaults && i.Defaults && (e.Defaults = cL({}, i.Defaults, e.Defaults)), e) { r = e[n], typeof r === 'function' && i[n] ? t[n] = c(n, r) : t[n] = r } return u.prototype = t, u.constructor = u, u.extend = WI, u }; let lL; const fL = Math.min; const dL = Math.max; const mL = Math.round; const gL = function (e) { const t = {}; let n = 0; let r = 0; let o = 0; const i = function (e, t, n) { let r, o, i, u, a, c; return r = 0, o = 0, i = 0, e /= 255, t /= 255, n /= 255, a = fL(e, fL(t, n)), c = dL(e, dL(t, n)), a === c ? (i = a, { h: 0, s: 0, v: 100 * i }) : (u = e === a ? t - n : n === a ? e - t : n - e, r = e === a ? 3 : n === a ? 1 : 5, r = 60 * (r - u / (c - a)), o = (c - a) / c, i = c, { h: mL(r), s: mL(100 * o), v: mL(100 * i) }) }; const u = function (e, t, i) { let u, a, c, s; if (e = (parseInt(e, 10) || 0) % 360, t = parseInt(t, 10) / 100, i = parseInt(i, 10) / 100, t = dL(0, fL(t, 1)), i = dL(0, fL(i, 1)), t !== 0) { switch (u = e / 60, a = i * t, c = a * (1 - Math.abs(u % 2 - 1)), s = i - a, Math.floor(u)) { case 0:n = a, r = c, o = 0; break; case 1:n = c, r = a, o = 0; break; case 2:n = 0, r = a, o = c; break; case 3:n = 0, r = c, o = a; break; case 4:n = c, r = 0, o = a; break; case 5:n = a, r = 0, o = c; break; default:n = r = o = 0 }n = mL(255 * (n + s)), r = mL(255 * (r + s)), o = mL(255 * (o + s)) } else { n = r = o = mL(255 * i) } }; const a = function () { const e = function (e) { return e = parseInt(e, 10).toString(16), e.length > 1 ? e : '0' + e }; return '#' + e(n) + e(r) + e(o) }; const c = function () { return { r: n, g: r, b: o } }; const s = function () { return i(n, r, o) }; const l = function (e) { let i; return typeof e === 'object' ? 'r' in e ? (n = e.r, r = e.g, o = e.b) : 'v' in e && u(e.h, e.s, e.v) : (i = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(e)) ? (n = parseInt(i[1], 10), r = parseInt(i[2], 10), o = parseInt(i[3], 10)) : (i = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(e)) ? (n = parseInt(i[1], 16), r = parseInt(i[2], 16), o = parseInt(i[3], 16)) : (i = /#([0-F])([0-F])([0-F])/gi.exec(e)) && (n = parseInt(i[1] + i[1], 16), r = parseInt(i[2] + i[2], 16), o = parseInt(i[3] + i[3], 16)), n = n < 0 ? 0 : n > 255 ? 255 : n, r = r < 0 ? 0 : r > 255 ? 255 : r, o = o < 0 ? 0 : o > 255 ? 255 : o, t }; return e && l(e), t.toRgb = c, t.toHsv = s, t.toHex = a, t.parse = l, t }; const hL = function (e) { const t = JSON.stringify(e); return y(t) ? t.replace(/[\u0080-\uFFFF]/g, function (e) { const t = e.charCodeAt(0).toString(16); return '\\u' + '0000'.substring(t.length) + t }) : t }; const pL = { serialize: hL, parse (e) { try { return JSON.parse(e) } catch (t) {} } }; const vL = { callbacks: {}, count: 0, send (e) { const t = this; const n = Va.DOM; const r = void 0 !== e.count ? e.count : t.count; const o = 'tinymce_jsonp_' + r; t.callbacks[r] = function (i) { n.remove(o), delete t.callbacks[r], e.callback(i) }, n.add(n.doc.body, 'script', { id: o, src: e.url, type: 'text/javascript' }), t.count++ } }; var bL = se(se({}, zz), { send (e) { let t; let r = 0; var o = function () { !e.async || t.readyState === 4 || r++ > 1e4 ? (e.success && r < 1e4 && t.status === 200 ? e.success.call(e.success_scope, '' + t.responseText, t, e) : e.error && e.error.call(e.error_scope, r > 1e4 ? 'TIMED_OUT' : 'GENERAL', t, e), t = null) : Ir.setTimeout(o, 10) }; if (e.scope = e.scope || this, e.success_scope = e.success_scope || e.scope, e.error_scope = e.error_scope || e.scope, e.async = !1 !== e.async, e.data = e.data || '', bL.fire('beforeInitialize', { settings: e }), t = new n.XMLHttpRequest(), t) { if (t.overrideMimeType && t.overrideMimeType(e.content_type), t.open(e.type || (e.data ? 'POST' : 'GET'), e.url, e.async), e.crossDomain && (t.withCredentials = !0), e.content_type && t.setRequestHeader('Content-Type', e.content_type), e.requestheaders && vo.each(e.requestheaders, function (e) { t.setRequestHeader(e.key, e.value) }), t.setRequestHeader('X-Requested-With', 'XMLHttpRequest'), t = bL.fire('beforeSend', { xhr: t, settings: e }).xhr, t.send(e.data), !e.async) { return o() } Ir.setTimeout(o, 10) } } }); const yL = vo.extend; const wL = (function () { function e (e) { this.settings = yL({}, e), this.count = 0 } return e.sendRPC = function (t) { return (new e()).send(t) }, e.prototype.send = function (e) { const t = e.error; const n = e.success; const r = yL(this.settings, e); r.success = function (e, o) { e = pL.parse(e), typeof e === 'undefined' && (e = { error: 'JSON Parse error.' }), e.error ? t.call(r.error_scope || r.scope, e.error, o) : n.call(r.success_scope || r.scope, e.result) }, r.error = function (e, n) { t && t.call(r.error_scope || r.scope, e, n) }, r.data = pL.serialize({ id: e.id || 'c' + this.count++, method: e.method, params: e.params }), r.content_type = 'application/json', bL.send(r) }, e }()); const xL = function () { return (function () { let e = {}; let t = []; const n = { getItem (t) { const n = e[t]; return n || null }, setItem (n, r) { t.push(n), e[n] = String(r) }, key (e) { return t[e] }, removeItem (n) { t = t.filter(function (e) { return e === n }), delete e[n] }, clear () { t = [], e = {} }, length: 0 }; return Object.defineProperty(n, 'length', { get () { return t.length }, configurable: !1, enumerable: !1 }), n }()) }; try { lL = n.window.localStorage } catch (OL) { lL = xL() } const CL = lL; const SL = { geom: { Rect: uL }, util: { Promise: Dr, Delay: Ir, Tools: vo, VK: lb, URI: xI, Class: sL, EventDispatcher: Mz, Observable: zz, I18n: cc, XHR: bL, JSON: pL, JSONRequest: wL, JSONP: vL, LocalStorage: CL, Color: gL }, dom: { EventUtils: eu, Sizzle: Lu, DomQuery: Da, TreeWalker: Aa, TextSeeker: tf, DOMUtils: Va, ScriptLoader: Ya, RangeUtils: $I, Serializer: gx, ControlSelection: gb, BookmarkManager: ab, Selection: Pw, Event: eu.Event }, html: { Styles: Ui, Entities: ci, Node: Bg, Schema: yi, SaxParser: Ug, DomParser: Qw, Writer: Zg, Serializer: Qg }, Env: $r, AddOnManager: lc, Annotator: Og, Formatter: fk, UndoManager: tT, EditorCommands: Rz, WindowManager: Wv, NotificationManager: Fv, EditorObservable: oI, Shortcuts: gI, Editor: OI, FocusManager: jh, EditorManager: UI, DOM: Va.DOM, ScriptLoader: Ya.ScriptLoader, PluginManager: lc.PluginManager, ThemeManager: lc.ThemeManager, IconManager: Tv, Resource: YI, trim: vo.trim, isArray: vo.isArray, is: vo.is, toArray: vo.toArray, makeMap: vo.makeMap, each: vo.each, map: vo.map, grep: vo.grep, inArray: vo.inArray, extend: vo.extend, create: vo.create, walk: vo.walk, createNS: vo.createNS, resolve: vo.resolve, explode: vo.explode, _addCacheSuffix: vo._addCacheSuffix, isOpera: $r.opera, isWebKit: $r.webkit, isIE: $r.ie, isGecko: $r.gecko, isMac: $r.mac }; const kL = vo.extend(UI, SL); const TL = function (t) { try { e.exports = t } catch (n) {} }; const EL = function (e) { window.tinymce = e, window.tinyMCE = e }; EL(kL), TL(kL) })(window) }).call(this, n('c8ba')) }, eefc (e, t, n) { 'use strict'; const r = n('876f'); const o = n.n(r); o.a }, ef1f (e, t) { (function () { 'use strict'; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = function (e, t) { e.focus(), e.undoManager.transact(function () { e.setContent(t) }), e.selection.setCursorLocation(), e.nodeChanged() }; const n = function (e) { return e.getContent({ source_view: !0 }) }; const r = { setContent: t, getContent: n }; const o = function (e) { const t = r.getContent(e); e.windowManager.open({ title: 'Source Code', size: 'large', body: { type: 'panel', items: [{ type: 'textarea', name: 'code' }] }, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: { code: t }, onSubmit (t) { r.setContent(e, t.getData().code), t.close() } }) }; const i = { open: o }; const u = function (e) { e.addCommand('mceCodeEditor', function () { i.open(e) }) }; const a = { register: u }; const c = function (e) { e.ui.registry.addButton('code', { icon: 'sourcecode', tooltip: 'Source code', onAction () { return i.open(e) } }), e.ui.registry.addMenuItem('code', { icon: 'sourcecode', text: 'Source code', onAction () { return i.open(e) } }) }; const s = { register: c }; function l () { e.add('code', function (e) { return a.register(e), s.register(e), {} }) }l() })() }, f034 (e, t) { (function (e) { 'use strict'; var t = function (e) { let n = e; const r = function () { return n }; const o = function (e) { n = e }; const i = function () { return t(r()) }; return { get: r, set: o, clone: i } }; const n = tinymce.util.Tools.resolve('tinymce.PluginManager'); const r = function (e) { return { isFullscreen () { return e.get() !== null } } }; const o = { get: r }; const i = function () {}; const u = function (e, t) { return function () { for (var n = [], r = 0; r < arguments.length; r++) { n[r] = arguments[r] } return e(t.apply(null, n)) } }; const a = function (e) { return function () { return e } }; const c = a(!1); const s = a(!0); const l = function () { return f }; var f = (function () { const e = function (e) { return e.isNone() }; const t = function (e) { return e() }; const n = function (e) { return e }; const r = { fold (e, t) { return e() }, is: c, isSome: c, isNone: s, getOr: n, getOrThunk: t, getOrDie (e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull: a(null), getOrUndefined: a(void 0), or: n, orThunk: t, map: l, each: i, bind: l, exists: c, forall: s, filter: l, equals: e, equals_: e, toArray () { return [] }, toString: a('none()') }; return Object.freeze && Object.freeze(r), r }()); var d = function (e) { const t = a(e); const n = function () { return o }; const r = function (t) { return t(e) }; var o = { fold (t, n) { return n(e) }, is (t) { return e === t }, isSome: s, isNone: c, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map (t) { return d(t(e)) }, each (t) { t(e) }, bind: r, exists: r, forall: r, filter (t) { return t(e) ? o : f }, toArray () { return [e] }, toString () { return 'some(' + e + ')' }, equals (t) { return t.is(e) }, equals_ (t, n) { return t.fold(c, function (t) { return n(e, t) }) } }; return o }; const m = function (e) { return e === null || void 0 === e ? f : d(e) }; const g = { some: d, none: l, from: m }; const h = function (e) { const n = t(g.none()); const r = function () { n.get().each(e) }; const o = function () { r(), n.set(g.none()) }; const i = function (e) { r(), n.set(g.some(e)) }; const u = function () { return n.get().isSome() }; return { clear: o, isSet: u, set: i } }; const p = function () { return h(function (e) { e.unbind() }) }; const v = function () { const e = t(g.none()); const n = function () { e.set(g.none()) }; const r = function (t) { e.set(g.some(t)) }; const o = function (t) { e.get().each(t) }; const i = function () { return e.get().isSome() }; return { clear: n, set: r, isSet: i, on: o } }; const b = function (e) { if (e === null) { return 'null' } const t = typeof e; return t === 'object' && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'Array') ? 'array' : t === 'object' && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === 'String') ? 'string' : t }; const y = function (e) { return function (t) { return b(t) === e } }; const w = y('string'); const x = y('array'); const C = y('boolean'); const S = y('function'); const k = y('number'); const T = Array.prototype.slice; const E = Array.prototype.push; const O = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o) } return r }; const N = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; t(o, n) } }; const _ = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r) && n.push(i) } return n }; const D = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n)) { return g.some(o) } } return g.none() }; const A = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!x(e[n])) { throw new Error('Arr.flatten item ' + n + ' was not an array, input: ' + e) } E.apply(t, e[n]) } return t }; const R = function (e, t) { return A(O(e, t)) }; const B = (S(Array.from) && Array.from, Object.keys); const M = function (e, t) { for (let n = B(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; const u = e[i]; t(u, i) } }; const P = function (e, t) { return e.includes(t) }; const z = function (e) { return void 0 !== e.style && S(e.style.getPropertyValue) }; const I = function (t, n) { const r = n || e.document; const o = r.createElement('div'); if (o.innerHTML = t, !o.hasChildNodes() || o.childNodes.length > 1) { throw e.console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node') } return F(o.childNodes[0]) }; const L = function (t, n) { const r = n || e.document; const o = r.createElement(t); return F(o) }; const H = function (t, n) { const r = n || e.document; const o = r.createTextNode(t); return F(o) }; var F = function (e) { if (e === null || void 0 === e) { throw new Error('Node cannot be null or undefined') } return { dom: a(e) } }; const V = function (e, t, n) { const r = e.dom(); return g.from(r.elementFromPoint(t, n)).map(F) }; const U = { fromHtml: I, fromTag: L, fromText: H, fromDom: F, fromPoint: V }; const j = (e.Node.ATTRIBUTE_NODE, e.Node.CDATA_SECTION_NODE, e.Node.COMMENT_NODE, e.Node.DOCUMENT_NODE); const W = (e.Node.DOCUMENT_TYPE_NODE, e.Node.DOCUMENT_FRAGMENT_NODE, e.Node.ELEMENT_NODE); const q = e.Node.TEXT_NODE; const $ = (e.Node.PROCESSING_INSTRUCTION_NODE, e.Node.ENTITY_REFERENCE_NODE, e.Node.ENTITY_NODE, e.Node.NOTATION_NODE, typeof e.window !== 'undefined' ? e.window : Function('return this;')(), function (e) { return e.dom().nodeType }); const G = function (e) { return function (t) { return $(t) === e } }; const X = G(q); const Y = function (e) { const t = X(e) ? e.dom().parentNode : e.dom(); return void 0 !== t && t !== null && t.ownerDocument.body.contains(t) }; const K = function (t, n, r) { if (!(w(r) || C(r) || k(r))) { throw e.console.error('Invalid call to Attr.set. Key ', n, ':: Value ', r, ':: Element ', t), new Error('Attribute value was not simple') } t.setAttribute(n, r + '') }; const J = function (e, t, n) { K(e.dom(), t, n) }; const Z = function (e, t) { const n = e.dom().getAttribute(t); return n === null ? void 0 : n }; const Q = function (e, t) { e.dom().removeAttribute(t) }; const ee = function (t, n, r) { if (!w(r)) { throw e.console.error('Invalid call to CSS.set. Property ', n, ':: Value ', r, ':: Element ', t), new Error('CSS value must be a string: ' + r) } z(t) && t.style.setProperty(n, r) }; const te = function (e, t) { const n = e.dom(); M(t, function (e, t) { ee(n, t, e) }) }; const ne = function (t, n) { const r = t.dom(); const o = e.window.getComputedStyle(r); const i = o.getPropertyValue(n); const u = i !== '' || Y(t) ? i : re(r, n); return u === null ? void 0 : u }; var re = function (e, t) { return z(e) ? e.style.getPropertyValue(t) : '' }; const oe = function (e, t, n, r, o, i, u) { return { target: a(e), x: a(t), y: a(n), stop: r, prevent: o, kill: i, raw: a(u) } }; const ie = function (e) { const t = U.fromDom(e.target); const n = function () { e.stopPropagation() }; const r = function () { e.preventDefault() }; const o = u(r, n); return oe(t, e.clientX, e.clientY, n, r, o, e) }; const ue = function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) { return r } } }; const ae = function (e, t) { const n = ue(e, t); if (!n) { return { major: 0, minor: 0 } } const r = function (e) { return Number(t.replace(n, '$' + e)) }; return le(r(1), r(2)) }; const ce = function (e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? se() : ae(e, n) }; var se = function () { return le(0, 0) }; var le = function (e, t) { return { major: e, minor: t } }; const fe = { nu: le, detect: ce, unknown: se }; const de = 'Edge'; const me = 'Chrome'; const ge = 'IE'; const he = 'Opera'; const pe = 'Firefox'; const ve = 'Safari'; const be = function (e, t) { return function () { return t === e } }; const ye = function () { return we({ current: void 0, version: fe.unknown() }) }; var we = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isEdge: be(de, t), isChrome: be(me, t), isIE: be(ge, t), isOpera: be(he, t), isFirefox: be(pe, t), isSafari: be(ve, t) } }; const xe = { unknown: ye, nu: we, edge: a(de), chrome: a(me), ie: a(ge), opera: a(he), firefox: a(pe), safari: a(ve) }; const Ce = 'Windows'; const Se = 'iOS'; const ke = 'Android'; const Te = 'Linux'; const Ee = 'OSX'; const Oe = 'Solaris'; const Ne = 'FreeBSD'; const _e = 'ChromeOS'; const De = function (e, t) { return function () { return t === e } }; const Ae = function () { return Re({ current: void 0, version: fe.unknown() }) }; var Re = function (e) { const t = e.current; const n = e.version; return { current: t, version: n, isWindows: De(Ce, t), isiOS: De(Se, t), isAndroid: De(ke, t), isOSX: De(Ee, t), isLinux: De(Te, t), isSolaris: De(Oe, t), isFreeBSD: De(Ne, t), isChromeOS: De(_e, t) } }; const Be = { unknown: Ae, nu: Re, windows: a(Ce), ios: a(Se), android: a(ke), linux: a(Te), osx: a(Ee), solaris: a(Oe), freebsd: a(Ne), chromeos: a(_e) }; const Me = function (e, t, n, r) { const o = e.isiOS() && !0 === /ipad/i.test(n); const i = e.isiOS() && !o; const u = e.isiOS() || e.isAndroid(); const c = u || r('(pointer:coarse)'); const s = o || !i && u && r('(min-device-width:768px)'); const l = i || u && !s; const f = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n); const d = !l && !s && !f; return { isiPad: a(o), isiPhone: a(i), isTablet: a(s), isPhone: a(l), isTouch: a(c), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: a(f), isDesktop: a(d) } }; const Pe = function (e, t) { const n = String(t).toLowerCase(); return D(e, function (e) { return e.search(n) }) }; const ze = function (e, t) { return Pe(e, t).map(function (e) { const n = fe.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Ie = function (e, t) { return Pe(e, t).map(function (e) { const n = fe.detect(e.versionRegexes, t); return { current: e.name, version: n } }) }; const Le = { detectBrowser: ze, detectOs: Ie }; const He = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const Fe = function (e) { return function (t) { return P(t, e) } }; const Ve = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search (e) { return P(e, 'edge/') && P(e, 'chrome') && P(e, 'safari') && P(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, He], search (e) { return P(e, 'chrome') && !P(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search (e) { return P(e, 'msie') || P(e, 'trident') } }, { name: 'Opera', versionRegexes: [He, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Fe('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Fe('firefox') }, { name: 'Safari', versionRegexes: [He, /.*?cpu os ([0-9]+)_([0-9]+).*/], search (e) { return (P(e, 'safari') || P(e, 'mobile/')) && P(e, 'applewebkit') } }]; const Ue = [{ name: 'Windows', search: Fe('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search (e) { return P(e, 'iphone') || P(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: Fe('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: Fe('mac os x'), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: Fe('linux'), versionRegexes: [] }, { name: 'Solaris', search: Fe('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: Fe('freebsd'), versionRegexes: [] }, { name: 'ChromeOS', search: Fe('cros'), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]; const je = { browsers: a(Ve), oses: a(Ue) }; const We = function (e, t) { const n = je.browsers(); const r = je.oses(); const o = Le.detectBrowser(n, e).fold(xe.unknown, xe.nu); const i = Le.detectOs(r, e).fold(Be.unknown, Be.nu); const u = Me(i, o, e, t); return { browser: o, os: i, deviceType: u } }; const qe = { detect: We }; const $e = function (t) { return e.window.matchMedia(t).matches }; const Ge = t(qe.detect(e.navigator.userAgent, $e)); const Xe = function () { return Ge.get() }; const Ye = function () { for (var e = [], t = 0; t < arguments.length; t++) { e[t] = arguments[t] } return function () { for (var t = [], n = 0; n < arguments.length; n++) { t[n] = arguments[n] } if (e.length !== t.length) { throw new Error('Wrong number of arguments to struct. Expected "[' + e.length + ']", got ' + t.length + ' arguments') } const r = {}; return N(e, function (e, n) { r[e] = a(t[n]) }), r } }; const Ke = function (e, t, n) { return (e.compareDocumentPosition(t) & n) !== 0 }; const Je = function (t, n) { return Ke(t, n, e.Node.DOCUMENT_POSITION_PRECEDING) }; const Ze = function (t, n) { return Ke(t, n, e.Node.DOCUMENT_POSITION_CONTAINED_BY) }; const Qe = { documentPositionPreceding: Je, documentPositionContainedBy: Ze }; const et = W; const tt = j; const nt = function (e, t) { const n = e.dom(); if (n.nodeType !== et) { return !1 } const r = n; if (void 0 !== r.matches) { return r.matches(t) } if (void 0 !== r.msMatchesSelector) { return r.msMatchesSelector(t) } if (void 0 !== r.webkitMatchesSelector) { return r.webkitMatchesSelector(t) } if (void 0 !== r.mozMatchesSelector) { return r.mozMatchesSelector(t) } throw new Error('Browser lacks native selectors') }; const rt = function (e) { return e.nodeType !== et && e.nodeType !== tt || e.childElementCount === 0 }; const ot = function (t, n) { const r = void 0 === n ? e.document : n.dom(); return rt(r) ? [] : O(r.querySelectorAll(t), U.fromDom) }; const it = function (e, t) { return e.dom() === t.dom() }; const ut = function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const at = function (e, t) { return Qe.documentPositionContainedBy(e.dom(), t.dom()) }; const ct = Xe().browser; const st = (ct.isIE(), function (e) { return g.from(e.dom().parentNode).map(U.fromDom) }); const lt = function (e, t) { const n = S(t) ? t : c; let r = e.dom(); const o = []; while (r.parentNode !== null && void 0 !== r.parentNode) { const i = r.parentNode; const u = U.fromDom(i); if (o.push(u), !0 === n(u)) { break } r = i } return o }; const ft = function (e) { const t = function (t) { return _(t, function (t) { return !it(e, t) }) }; return st(e).map(dt).map(t).getOr([]) }; var dt = function (e) { return O(e.dom().childNodes, U.fromDom) }; var mt = (Ye('element', 'offset'), function (e, t) { const n = function (n, r) { return mt(e + n, t + r) }; return { left: a(e), top: a(t), translate: n } }); const gt = mt; const ht = (Xe().browser.isSafari(), function (t) { const n = void 0 !== t ? t.dom() : e.document; const r = n.body.scrollLeft || n.documentElement.scrollLeft; const o = n.body.scrollTop || n.documentElement.scrollTop; return gt(r, o) }); const pt = function (t) { const n = void 0 === t ? e.window : t; return g.from(n.visualViewport) }; const vt = function (e, t, n, r) { return { x: a(e), y: a(t), width: a(n), height: a(r), right: a(e + n), bottom: a(t + r) } }; const bt = function (t) { const n = void 0 === t ? e.window : t; const r = n.document; const o = ht(U.fromDom(r)); return pt(n).fold(function () { const e = n.document.documentElement; const t = e.clientWidth; const r = e.clientHeight; return vt(o.left(), o.top(), t, r) }, function (e) { return vt(Math.max(e.pageLeft, o.left()), Math.max(e.pageTop, o.top()), e.width, e.height) }) }; const yt = function (e, t, n) { return pt(n).map(function (t) { const n = function (e) { return ie(e) }; return t.addEventListener(e, n), { unbind () { return t.removeEventListener(e, n) } } }).getOrThunk(function () { return { unbind: i } }) }; const wt = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const xt = tinymce.util.Tools.resolve('tinymce.Env'); const Ct = tinymce.util.Tools.resolve('tinymce.util.Delay'); const St = function (e, t) { e.fire('FullscreenStateChanged', { state: t }) }; const kt = { fireFullscreenStateChanged: St }; const Tt = function (e, t, n) { return _(lt(e, n), t) }; const Et = function (e, t) { return _(ft(e), t) }; const Ot = function (e) { return ot(e) }; const Nt = function (e, t, n) { return Tt(e, function (e) { return nt(e, t) }, n) }; const _t = function (e, t) { return Et(e, function (e) { return nt(e, t) }) }; const Dt = 'data-ephox-mobile-fullscreen-style'; const At = 'display:none!important;'; const Rt = 'position:absolute!important;'; const Bt = 'top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;'; const Mt = 'background-color:rgb(255,255,255)!important;'; const Pt = xt.os.isAndroid(); const zt = function (e) { const t = ne(e, 'background-color'); return void 0 !== t && t !== '' ? 'background-color:' + t + '!important' : Mt }; const It = function (e, t, n) { const r = function (e) { return _t(e, '*:not(.tox-silver-sink)') }; const o = function (t) { return function (n) { const r = Z(n, 'style'); const o = void 0 === r ? 'no-styles' : r.trim(); o !== t && (J(n, Dt, o), te(n, e.parseStyle(t))) } }; const i = Nt(t, '*'); const u = R(i, r); const a = zt(n); N(u, o(At)), N(i, o(Rt + Bt + a)); const c = !0 === Pt ? '' : Rt; o(c + Bt + a)(t) }; const Lt = function (e) { const t = Ot('[' + Dt + ']'); N(t, function (t) { const n = Z(t, Dt); n !== 'no-styles' ? te(t, e.parseStyle(n)) : Q(t, 'style'), Q(t, Dt) }) }; const Ht = { clobberStyles: It, restoreStyles: Lt }; const Ft = wt.DOM; const Vt = function () { const t = bt(e.window); return { x: t.x(), y: t.y() } }; const Ut = function (t) { e.window.scrollTo(t.x, t.y) }; const jt = pt().fold(function () { return { bind: i, unbind: i } }, function (t) { const n = v(); const r = p(); const o = p(); const i = function () { e.document.body.scrollTop = 0, e.document.documentElement.scrollTop = 0 }; const u = function () { e.window.requestAnimationFrame(function () { n.on(function (e) { return te(e, { top: t.offsetTop + 'px', left: t.offsetLeft + 'px', height: t.height + 'px', width: t.width + 'px' }) }) }) }; const a = Ct.throttle(function () { i(), u() }, 50); const c = function (e) { n.set(e), a(), r.set(yt('resize')), o.set(yt('scroll')) }; const s = function () { n.on(function () { r.clear(), o.clear() }), n.clear() }; return { bind: c, unbind: s } }); const Wt = function (t, n) { let r; let o; let i; let u; const a = e.document.body; const c = e.document.documentElement; o = t.getContainer(); const s = U.fromDom(o); const l = n.get(); const f = U.fromDom(t.getBody()); const d = xt.deviceType.isTouch(); if (r = o.style, i = t.getContentAreaContainer().firstChild, u = i.style, l) { u.width = l.iframeWidth, u.height = l.iframeHeight, r.width = l.containerWidth, r.height = l.containerHeight, r.top = l.containerTop, r.left = l.containerLeft, d && Ht.restoreStyles(t.dom), Ft.removeClass(a, 'tox-fullscreen'), Ft.removeClass(c, 'tox-fullscreen'), Ft.removeClass(o, 'tox-fullscreen'), Ut(l.scrollPos), n.set(null), kt.fireFullscreenStateChanged(t, !1), jt.unbind(), t.off('remove', jt.unbind) } else { const m = { scrollPos: Vt(), containerWidth: r.width, containerHeight: r.height, containerTop: r.top, containerLeft: r.left, iframeWidth: u.width, iframeHeight: u.height }; d && Ht.clobberStyles(t.dom, s, f), u.width = u.height = '100%', r.width = r.height = '', Ft.addClass(a, 'tox-fullscreen'), Ft.addClass(c, 'tox-fullscreen'), Ft.addClass(o, 'tox-fullscreen'), jt.bind(s), t.on('remove', jt.unbind), n.set(m), kt.fireFullscreenStateChanged(t, !0) } }; const qt = { toggleFullscreen: Wt }; const $t = function (e, t) { e.addCommand('mceFullScreen', function () { qt.toggleFullscreen(e, t) }) }; const Gt = { register: $t }; const Xt = function (e, t) { return function (n) { n.setActive(t.get() !== null); const r = function (e) { return n.setActive(e.state) }; return e.on('FullscreenStateChanged', r), function () { return e.off('FullscreenStateChanged', r) } } }; const Yt = function (e, t) { e.ui.registry.addToggleMenuItem('fullscreen', { text: 'Fullscreen', shortcut: 'Meta+Shift+F', onAction () { return e.execCommand('mceFullScreen') }, onSetup: Xt(e, t) }), e.ui.registry.addToggleButton('fullscreen', { tooltip: 'Fullscreen', icon: 'fullscreen', onAction () { return e.execCommand('mceFullScreen') }, onSetup: Xt(e, t) }) }; const Kt = { register: Yt }; function Jt () { n.add('fullscreen', function (e) { const n = t(null); return e.settings.inline ? o.get(n) : (Gt.register(e, n), Kt.register(e, n), e.addShortcut('Meta+Shift+F', '', 'mceFullScreen'), o.get(n)) }) }Jt() })(window) } }])
// # sourceMappingURL=chunk-7d14240d.8eacdad7.js.map
